public void setCodec ( String codec ) { this . codec = codec ; }
public void setBitRate ( Integer bitRate ) { this . bitRate = bitRate ; }
public void setSamplingRate ( Integer samplingRate ) { this . samplingRate = samplingRate ; }
public void setChannels ( Integer channels ) { this . channels = channels ; }
public void setVolume ( Integer volume ) { this . volume = volume ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (codec= " + codec + " , bitRate= " + bitRate + " , samplingRate= " + samplingRate + " , channels= "
void setDecoder ( String format ) { this . decoder = format ; }
void setSamplingRate ( int samplingRate ) { this . samplingRate = samplingRate ; }
void setChannels ( int channels ) { this . channels = channels ; }
void setBitRate ( int bitRate ) { this . bitRate = bitRate ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (decoder= " + decoder + " , samplingRate= " + samplingRate + " , channels= " + channels + " , bitRate= "
protected String getFFMPEGExecutablePath ( ) { return path ; }
private void copyFile ( String path , File dest ) throws RuntimeException { InputStream input = null ; OutputStream output = null ; try { input = getClass ( ) . getResourceAsStream ( " native/ " + path ) ;
public String [ ] getAudioDecoders ( ) throws EncoderException { ArrayList < String > res = new ArrayList < String > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = ENCODER_DECODER_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String decoderFlag = matcher . group ( 1 ) ; String audioVideoFlag = matcher . group ( 3 ) ; if ( " D " . equals ( decoderFlag ) & & " A " . equals ( audioVideoFlag ) ) { String name = matcher . group ( 4 ) ; res . add ( name ) ; } } else { break ; } } else if ( line . trim ( ) . equals ( " Codecs: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public String [ ] getAudioEncoders ( ) throws EncoderException { ArrayList < String > res = new ArrayList < String > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = ENCODER_DECODER_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String encoderFlag = matcher . group ( 2 ) ; String audioVideoFlag = matcher . group ( 3 ) ; if ( " E " . equals ( encoderFlag ) & & " A " . equals ( audioVideoFlag ) ) { String name = matcher . group ( 4 ) ; res . add ( name ) ; } } else { break ; } } else if ( line . trim ( ) . equals ( " Codecs: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public String [ ] getVideoDecoders ( ) throws EncoderException { ArrayList < String > res = new ArrayList < String > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = ENCODER_DECODER_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String decoderFlag = matcher . group ( 1 ) ; String audioVideoFlag = matcher . group ( 3 ) ; if ( " D " . equals ( decoderFlag ) & & " V " . equals ( audioVideoFlag ) ) { String name = matcher . group ( 4 ) ; res . add ( name ) ; } } else { break ; } } else if ( line . trim ( ) . equals ( " Codecs: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public String [ ] getVideoEncoders ( ) throws EncoderException { ArrayList < String > res = new ArrayList < String > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = ENCODER_DECODER_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String encoderFlag = matcher . group ( 2 ) ; String audioVideoFlag = matcher . group ( 3 ) ; if ( " E " . equals ( encoderFlag ) & & " V " . equals ( audioVideoFlag ) ) { String name = matcher . group ( 4 ) ; res . add ( name ) ; } } else { break ; } } else if ( line . trim ( ) . equals ( " Codecs: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public String [ ] getSupportedEncodingFormats ( ) throws EncoderException { ArrayList < String > res = new ArrayList < String > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = FORMAT_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String encoderFlag = matcher . group ( 2 ) ; if ( " E " . equals ( encoderFlag ) ) { String aux = matcher . group ( 3 ) ; StringTokenizer st = new StringTokenizer ( aux , " , " ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) . trim ( ) ; if ( ! res . contains ( token ) ) { res . add ( token ) ; } } } } else { break ; } } else if ( line . trim ( ) . equals ( " File formats: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public String [ ] getSupportedDecodingFormats ( ) throws EncoderException { ArrayList < String > res = new ArrayList < String > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = FORMAT_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String decoderFlag = matcher . group ( 1 ) ; if ( " D " . equals ( decoderFlag ) ) { String aux = matcher . group ( 3 ) ; StringTokenizer st = new StringTokenizer ( aux , " , " ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) . trim ( ) ; if ( ! res . contains ( token ) ) { res . add ( token ) ; } } } } else { break ; } } else if ( line . trim ( ) . equals ( " File formats: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public MultimediaInfo getInfo ( File source ) throws InputFormatException , EncoderException { FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( source . getAbsolutePath ( ) ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try { RBufferedReader reader = null ;
private HashMap < String , String > parseProgressInfoLine ( String line ) { HashMap < String , String > table = null ; Matcher m = PROGRESS_INFO_PATTERN . matcher ( line ) ; while ( m . find ( ) ) { if ( table = = null ) { table = new HashMap < String , String > ( ) ; } String key = m . group ( 1 ) ; String value = m . group ( 2 ) ; table . put ( key , value ) ; } return table ; }
public void encode ( File source , File target , EncodingAttributes attributes ) throws IllegalArgumentException , InputFormatException , EncoderException { encode ( source , target , attributes , null ) ; }
public void sourceInfo ( MultimediaInfo info ) ; /** * This method is called to notify a progress in the encoding process. * * @param permil * A permil value representing the encoding process progress. */ public void progress ( int permil ) ; /** * This method is called every time the encoder need to send a message * (usually, a warning). * * @param message * The message sent by the encoder. */ public void message ( String message ) ; }
public void progress ( int permil ) ; /** * This method is called every time the encoder need to send a message * (usually, a warning). * * @param message * The message sent by the encoder. */ public void message ( String message ) ; }
public void setFormat ( String format ) { this . format = format ; }
public void setOffset ( Float offset ) { this . offset = offset ; }
public void setDuration ( Float duration ) { this . duration = duration ; }
AudioAttributes getAudioAttributes ( ) { return audioAttributes ; }
public void setAudioAttributes ( AudioAttributes audioAttributes ) { this . audioAttributes = audioAttributes ; }
VideoAttributes getVideoAttributes ( ) { return videoAttributes ; }
public void setVideoAttributes ( VideoAttributes videoAttributes ) { this . videoAttributes = videoAttributes ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (format= " + format + " , offset= " + offset + " , duration= " + duration + " , audioAttributes= "
public void execute ( ) throws IOException { int argsSize = args . size ( ) ; String [ ] cmd = new String [ argsSize + 1 ] ; cmd [ 0 ] = ffmpegExecutablePath ; for ( int i = 0 ; i < argsSize ; i + + ) { cmd [ i + 1 ] = args . get ( i ) ; } if ( _log . isDebugEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( String c : cmd ) { sb . append ( c ) ; sb . append ( ' ' ) ; } _log . debug ( " About to execute " + sb . toString ( ) ) ; } Runtime runtime = Runtime . getRuntime ( ) ; ffmpeg = runtime . exec ( cmd ) ; ffmpegKiller = new ProcessKiller ( ffmpeg ) ; runtime . addShutdownHook ( ffmpegKiller ) ; inputStream = ffmpeg . getInputStream ( ) ; outputStream = ffmpeg . getOutputStream ( ) ; errorStream = ffmpeg . getErrorStream ( ) ; }
public InputStream getInputStream ( ) { return inputStream ; }
public OutputStream getOutputStream ( ) { return outputStream ; }
public InputStream getErrorStream ( ) { return errorStream ; }
public void destroy ( ) { if ( inputStream ! = null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { _log . warn ( " Error closing input stream " , t ) ; } inputStream = null ; } if ( outputStream ! = null ) { try { outputStream . close ( ) ; } catch ( Throwable t ) { _log . warn ( " Error closing output stream " , t ) ; } outputStream = null ; } if ( errorStream ! = null ) { try { errorStream . close ( ) ; } catch ( Throwable t ) { _log . warn ( " Error closing error stream " , t ) ; } errorStream = null ; } if ( ffmpeg ! = null ) { ffmpeg . destroy ( ) ; ffmpeg = null ; } if ( ffmpegKiller ! = null ) { Runtime runtime = Runtime . getRuntime ( ) ;
protected abstract String getFFMPEGExecutablePath ( ) ; /** * It returns a brand new {@link FFMPEGExecutor}, ready to be used in a * ffmpeg call. * * @return A newly instanced {@link FFMPEGExecutor}, using this locator to * call the ffmpeg executable. */ FFMPEGExecutor createExecutor ( ) { return new FFMPEGExecutor ( getFFMPEGExecutablePath ( ) ) ; } }
FFMPEGExecutor createExecutor ( ) { return new FFMPEGExecutor ( getFFMPEGExecutablePath ( ) ) ; }
void setFormat ( String format ) { this . format = format ; }
void setDuration ( long duration ) { this . duration = duration ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (format= " + format + " , duration= " + duration + " , video= " + video + " , audio= " + audio + " ) " ;
public String readLine ( ) throws IOException { if ( lines . size ( ) > 0 ) {
public void reinsertLine ( String line ) { lines . add ( 0 , line ) ; }
public X264_PROFILE getX264Profile ( ) { return x264Profile ; }
public void setX264Profile ( X264_PROFILE x264Profile ) { this . x264Profile = x264Profile ; }
public String getModeName ( ) { return modeName ; }
public void setCodec ( String codec ) { this . codec = codec ; }
public void setTag ( String tag ) { this . tag = tag ; }
public void setBitRate ( Integer bitRate ) { this . bitRate = bitRate ; }
Integer getFrameRate ( ) { return frameRate ; }
public void setFrameRate ( Integer frameRate ) { this . frameRate = frameRate ; }
public void setSize ( VideoSize size ) { this . size = size ; }
public boolean isFaststart ( ) { return faststart ; }
public void setFaststart ( boolean faststart ) { this . faststart = faststart ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (codec= " + codec + " , bitRate= " + bitRate + " , frameRate= " + frameRate + " , size= " + size + " , faststart= " + faststart + " ) " ;
void setDecoder ( String codec ) { this . decoder = codec ; }
void setFrameRate ( float frameRate ) { this . frameRate = frameRate ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (decoder= " + decoder + " , size= " + size + " , bitRate= " + bitRate + " , frameRate= " + frameRate + " ) " ;
public String toString ( ) { return getClass ( ) . getName ( ) + " (width= " + width + " , height= " + height + " ) " ;
public void render ( File inputFile , int width , int height , String compression , File outputDir ) throws InputFormatException , EncoderException { FFMPEGExecutor ffmpeg = this . locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( inputFile . getAbsolutePath ( ) ) ; ffmpeg . addArgument ( " -f " ) ; ffmpeg . addArgument ( " image2 " ) ; ffmpeg . addArgument ( " -vf " ) ; ffmpeg . addArgument ( String . valueOf ( " fps=fps=1/5 " ) ) ; ffmpeg . addArgument ( " -s " ) ; ffmpeg . addArgument ( String . format ( " %sx%s " , String . valueOf ( width ) , String . valueOf ( height ) ) ) ; ffmpeg . addArgument ( outputDir . getAbsolutePath ( ) + " \\ test-%04d.png " ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try { RBufferedReader reader = new RBufferedReader (
public void render ( File inputFile , int width , int height , int seconds , File outputDir , String fileNamePrefix , String extension , int quality ) throws InputFormatException , EncoderException { FFMPEGExecutor ffmpeg = this . locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( inputFile . getAbsolutePath ( ) ) ; ffmpeg . addArgument ( " -f " ) ; ffmpeg . addArgument ( " image2 " ) ; ffmpeg . addArgument ( " -vf " ) ; ffmpeg . addArgument ( String . format ( " fps=fps=1/%s " , String . valueOf ( seconds ) ) ) ; ffmpeg . addArgument ( " -s " ) ; ffmpeg . addArgument ( String . format ( " %sx%s " , String . valueOf ( width ) , String . valueOf ( height ) ) ) ; ffmpeg . addArgument ( " -qscale " ) ; ffmpeg . addArgument ( String . valueOf ( quality ) ) ; ffmpeg . addArgument ( String . format ( " %s%s%s-%%04d.%s " , outputDir . getAbsolutePath ( ) , File . separator , fileNamePrefix , extension ) ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try { RBufferedReader reader = new RBufferedReader (
public int getNumberOfScreens ( ) { return numberOfScreens ; }
public void render ( File inputFile , int width , int height , int seconds , File outputDir , String fileNamePrefix , String extension , int quality ) throws InputFormatException , EncoderException { try { if ( ! outputDir . exists ( ) ) { if ( ! outputDir . mkdirs ( ) ) { _log . debug ( " Failed to create destination folder " ) ; throw new SecurityException ( ) ; } } if ( ! inputFile . canRead ( ) ) { _log . debug ( " Failed to open input file " ) ; throw new SecurityException ( ) ; } } catch ( SecurityException e ) { _log . debug ( " Access denied checking destination folder " + e ) ; } Encoder encoder = new Encoder ( ) ; MultimediaInfo multimediaInfo = encoder . getInfo ( inputFile ) ; numberOfScreens = ( int ) Math . ceil ( ( multimediaInfo . getDuration ( ) * .001 ) / seconds + 1 ) ; FFMPEGExecutor ffmpeg = this . locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( inputFile . getAbsolutePath ( ) ) ; ffmpeg . addArgument ( " -f " ) ; ffmpeg . addArgument ( " image2 " ) ; ffmpeg . addArgument ( " -vf " ) ; ffmpeg . addArgument ( String . format ( " fps=fps=1/%s " , String . valueOf ( seconds ) ) ) ; ffmpeg . addArgument ( " -s " ) ; ffmpeg . addArgument ( String . format ( " %sx%s " , String . valueOf ( width ) , String . valueOf ( height ) ) ) ; ffmpeg . addArgument ( " -qscale " ) ; ffmpeg . addArgument ( String . valueOf ( quality ) ) ; ffmpeg . addArgument ( String . format ( " %s%s%s-%%04d.%s " , outputDir . getAbsolutePath ( ) , File . separator , fileNamePrefix , extension ) ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try { RBufferedReader reader = new RBufferedReader (
public void encode ( MultimediaObject multimediaObject , File target , EncodingAttributes attributes ) throws IllegalArgumentException , InputFormatException , EncoderException { encode ( multimediaObject , target , attributes , null ) ; }
public File getFile ( ) { return this . inputFile ; }
public void setFile ( File file ) { this . inputFile = file ; }
public MultimediaInfo getInfo ( ) throws InputFormatException , EncoderException { FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( inputFile . getAbsolutePath ( ) ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try { RBufferedReader reader = null ;
public void render ( MultimediaObject multimediaObject , int width , int height , int seconds , File outputDir , String fileNamePrefix , String extension , int quality ) throws InputFormatException , EncoderException { FFMPEGExecutor ffmpeg = this . locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( multimediaObject . getFile ( ) . getAbsolutePath ( ) ) ; ffmpeg . addArgument ( " -f " ) ; ffmpeg . addArgument ( " image2 " ) ; ffmpeg . addArgument ( " -vf " ) ; ffmpeg . addArgument ( String . format ( " fps=fps=1/%s " , String . valueOf ( seconds ) ) ) ; ffmpeg . addArgument ( " -s " ) ; ffmpeg . addArgument ( String . format ( " %sx%s " , String . valueOf ( width ) , String . valueOf ( height ) ) ) ; ffmpeg . addArgument ( " -qscale " ) ; ffmpeg . addArgument ( String . valueOf ( quality ) ) ; ffmpeg . addArgument ( String . format ( " %s%s%s-%%04d.%s " , outputDir . getAbsolutePath ( ) , File . separator , fileNamePrefix , extension ) ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try { RBufferedReader reader = new RBufferedReader (
public void addFilter ( VideoFilter videoFilter ) { this . videoFilters . add ( videoFilter ) ; }
public ArrayList < VideoFilter > getVideoFilters ( ) { return this . videoFilters ; }
public String getExpression ( ) { return this . expression ; }
public void setExpression ( String expression ) { this . expression = expression ; }
public String toString ( ) { return this . expression ; }
public void render ( MultimediaObject multimediaObject , int width , int height , int seconds , File outputDir , String fileNamePrefix , String extension , int quality ) throws InputFormatException , EncoderException { File inputFile = multimediaObject . getFile ( ) ; try { if ( ! outputDir . exists ( ) ) { if ( ! outputDir . mkdirs ( ) ) { _log . debug ( " Failed to create destination folder " ) ; throw new SecurityException ( ) ; } } if ( ! inputFile . canRead ( ) ) { _log . debug ( " Failed to open input file " ) ; throw new SecurityException ( ) ; } } catch ( SecurityException e ) { _log . debug ( " Access denied checking destination folder " + e ) ; } MultimediaInfo multimediaInfo = multimediaObject . getInfo ( ) ; numberOfScreens = ( int ) Math . ceil ( ( multimediaInfo . getDuration ( ) * .001 ) / seconds + 1 ) ; FFMPEGExecutor ffmpeg = this . locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( inputFile . getAbsolutePath ( ) ) ; ffmpeg . addArgument ( " -f " ) ; ffmpeg . addArgument ( " image2 " ) ; ffmpeg . addArgument ( " -vf " ) ; ffmpeg . addArgument ( String . format ( " fps=fps=1/%s " , String . valueOf ( seconds ) ) ) ; ffmpeg . addArgument ( " -s " ) ; ffmpeg . addArgument ( String . format ( " %sx%s " , String . valueOf ( width ) , String . valueOf ( height ) ) ) ; ffmpeg . addArgument ( " -qscale " ) ; ffmpeg . addArgument ( String . valueOf ( quality ) ) ; ffmpeg . addArgument ( String . format ( " %s%s%s-%%04d.%s " , outputDir . getAbsolutePath ( ) , File . separator , fileNamePrefix , extension ) ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try { RBufferedReader reader = new RBufferedReader (
public void render ( MultimediaObject multimediaObject , int width , int height , int seconds , File target , int quality ) throws EncoderException { File inputFile = multimediaObject . getFile ( ) ; target = target . getAbsoluteFile ( ) ; target . getParentFile ( ) . mkdirs ( ) ; try { if ( ! inputFile . canRead ( ) ) { _log . debug ( " Failed to open input file " ) ; throw new SecurityException ( ) ; } } catch ( SecurityException e ) { _log . debug ( " Access denied checking destination folder " + e ) ; } MultimediaInfo multimediaInfo = multimediaObject . getInfo ( ) ; int duration = ( int ) ( multimediaInfo . getDuration ( ) * .001 ) ; numberOfScreens = seconds < = duration ? 1 : 0 ; FFMPEGExecutor ffmpeg = this . locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( inputFile . getAbsolutePath ( ) ) ; ffmpeg . addArgument ( " -f " ) ; ffmpeg . addArgument ( " image2 " ) ; ffmpeg . addArgument ( " -vframes " ) ; ffmpeg . addArgument ( " 1 " ) ; ffmpeg . addArgument ( " -ss " ) ; ffmpeg . addArgument ( String . valueOf ( seconds ) ) ; ffmpeg . addArgument ( " -s " ) ; ffmpeg . addArgument ( String . format ( " %sx%s " , String . valueOf ( width ) , String . valueOf ( height ) ) ) ; ffmpeg . addArgument ( " -qscale " ) ; ffmpeg . addArgument ( String . valueOf ( quality ) ) ; ffmpeg . addArgument ( target . getAbsolutePath ( ) ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try { RBufferedReader reader = new RBufferedReader (
public String [ ] getAudioDecoders ( ) throws EncoderException { ArrayList < String > res = new ArrayList < > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = ENCODER_DECODER_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String decoderFlag = matcher . group ( 1 ) ; String audioVideoFlag = matcher . group ( 3 ) ; if ( " D " . equals ( decoderFlag ) & & " A " . equals ( audioVideoFlag ) ) { String name = matcher . group ( 4 ) ; res . add ( name ) ; } } else { break ; } } else if ( line . trim ( ) . equals ( " Codecs: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public String [ ] getAudioEncoders ( ) throws EncoderException { ArrayList < String > res = new ArrayList < > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = ENCODER_DECODER_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String encoderFlag = matcher . group ( 2 ) ; String audioVideoFlag = matcher . group ( 3 ) ; if ( " E " . equals ( encoderFlag ) & & " A " . equals ( audioVideoFlag ) ) { String name = matcher . group ( 4 ) ; res . add ( name ) ; } } else { break ; } } else if ( line . trim ( ) . equals ( " Codecs: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public String [ ] getVideoDecoders ( ) throws EncoderException { ArrayList < String > res = new ArrayList < > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = ENCODER_DECODER_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String decoderFlag = matcher . group ( 1 ) ; String audioVideoFlag = matcher . group ( 3 ) ; if ( " D " . equals ( decoderFlag ) & & " V " . equals ( audioVideoFlag ) ) { String name = matcher . group ( 4 ) ; res . add ( name ) ; } } else { break ; } } else if ( line . trim ( ) . equals ( " Codecs: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public String [ ] getVideoEncoders ( ) throws EncoderException { ArrayList < String > res = new ArrayList < > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = ENCODER_DECODER_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String encoderFlag = matcher . group ( 2 ) ; String audioVideoFlag = matcher . group ( 3 ) ; if ( " E " . equals ( encoderFlag ) & & " V " . equals ( audioVideoFlag ) ) { String name = matcher . group ( 4 ) ; res . add ( name ) ; } } else { break ; } } else if ( line . trim ( ) . equals ( " Codecs: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public String [ ] getSupportedEncodingFormats ( ) throws EncoderException { ArrayList < String > res = new ArrayList < > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = FORMAT_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String encoderFlag = matcher . group ( 2 ) ; if ( " E " . equals ( encoderFlag ) ) { String aux = matcher . group ( 3 ) ; StringTokenizer st = new StringTokenizer ( aux , " , " ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) . trim ( ) ; if ( ! res . contains ( token ) ) { res . add ( token ) ; } } } } else { break ; } } else if ( line . trim ( ) . equals ( " File formats: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public String [ ] getSupportedDecodingFormats ( ) throws EncoderException { ArrayList < String > res = new ArrayList < > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; boolean evaluate = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( evaluate ) { Matcher matcher = FORMAT_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String decoderFlag = matcher . group ( 1 ) ; if ( " D " . equals ( decoderFlag ) ) { String aux = matcher . group ( 3 ) ; StringTokenizer st = new StringTokenizer ( aux , " , " ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) . trim ( ) ; if ( ! res . contains ( token ) ) { res . add ( token ) ; } } } } else { break ; } } else if ( line . trim ( ) . equals ( " File formats: " ) ) { evaluate = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
private HashMap < String , String > parseProgressInfoLine ( String line ) { HashMap < String , String > table = null ; Matcher m = PROGRESS_INFO_PATTERN . matcher ( line ) ; while ( m . find ( ) ) { if ( table = = null ) { table = new HashMap < > ( ) ; } String key = m . group ( 1 ) ; String value = m . group ( 2 ) ; table . put ( key , value ) ; } return table ; }
public void testGetFFMPEGExecutablePath ( ) { // TODO review the generated test code and remove the default call to fail. DefaultFFMPEGLocator locator= new DefaultFFMPEGLocator(); String exePath= locator.getFFMPEGExecutablePath(); fail("The test case is a prototype."); }
public void testSomeMethod ( ) { DefaultFFMPEGLocator locator = new DefaultFFMPEGLocator ( ) ; String exePath = locator . getFFMPEGExecutablePath ( ) ; assertNotNull ( " Native component not found " , exePath ) ; }
public void testSomeMethod ( ) { // TODO review the generated test code and remove the default call to fail. fail("The test case is a prototype."); }
public static void main ( String [ ] args ) { // TODO review the generated test code and remove the default call to fail. DefaultFFMPEGLocator locator= new DefaultFFMPEGLocator(); //String exePath= locator.getFFMPEGExecutablePath(); System.out.println("Done"); }
public void testGetAudioDecoders ( ) throws Exception { System . out . println ( " getAudioDecoders " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getAudioDecoders ( ) ; assertTrue ( " No audio decoders found " , result ! = null & & result . length > 0 ) ; }
public void testGetAudioEncoders ( ) throws Exception { System . out . println ( " getAudioEncoders " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getAudioEncoders ( ) ; assertTrue ( " No audio encoders found " , result ! = null & & result . length > 0 ) ; }
public void testGetVideoDecoders ( ) throws Exception { System . out . println ( " getVideoDecoders " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getVideoDecoders ( ) ; assertTrue ( " No video decoders found " , result ! = null & & result . length > 0 ) ; }
public void testGetVideoEncoders ( ) throws Exception { System . out . println ( " getVideoEncoders " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getVideoEncoders ( ) ; assertTrue ( " No video enecoders found " , result ! = null & & result . length > 0 ) ; }
public void testGetSupportedEncodingFormats ( ) throws Exception { System . out . println ( " getSupportedEncodingFormats " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getSupportedEncodingFormats ( ) ; assertTrue ( " No supported encoding formats found " , result ! = null & & result . length > 0 ) ; }
public void testGetSupportedDecodingFormats ( ) throws Exception { System . out . println ( " getSupportedDecodingFormats " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getSupportedDecodingFormats ( ) ; assertTrue ( " No supported decoding formats found " , result ! = null & & result . length > 0 ) ; }
public void testEncode3args ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/dance1.avi " ) ; File target = new File ( " target/testoutput/target3.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( " Output file missing " , target . exists ( ) ) ; }
public void testEncode4args ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/dance1.avi " ) ; File target = new File ( " target/testoutput/target4.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( " Output file missing " , target . exists ( ) ) ; }
public void testEncode4argsLarge ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/target4Large.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Unknown encoder 'libfaac' " ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { message = ex . getMessage ( ) ; } assertEquals ( " Encoding problem not found " , compareTo , message ) ; }
public void testEncode4argsLarge2 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/target4Large2.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " adpcm_ms " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " codec not currently supported in container " ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { message = ex . getMessage ( ) ; } assertTrue ( " Encoding problem not found " , message . contains ( compareTo ) ) ; }
public void sourceInfo ( MultimediaInfo info ) { _info = info ; }
public void progress ( int permil ) { _progress . add ( permil ) ; }
public void message ( String message ) { _messages . add ( message ) ; }
public MultimediaInfo getInfo ( ) { return _info ; }
public List < String > getMessages ( ) { return _messages ; }
public List < Integer > getProgress ( ) { return _progress ; }
public void testGetFile ( ) { System . out . println ( " getFile " ) ; File file = new File ( " src/test/resources/dance1.avi " ) ; MultimediaObject instance = new MultimediaObject ( file ) ; File expResult = file ; File result = instance . getFile ( ) ; assertEquals ( expResult , result ) ; }
public void testGetInfo ( ) throws Exception { System . out . println ( " getInfo " ) ; File file = new File ( " src/test/resources/dance1.avi " ) ; MultimediaObject instance = new MultimediaObject ( file ) ; MultimediaInfo result = instance . getInfo ( ) ; assertEquals ( " avi " , result . getFormat ( ) ) ; assertEquals ( 1530 , result . getDuration ( ) ) ; assertNull ( result . getAudio ( ) ) ; assertEquals ( " rawvideo " , result . getVideo ( ) . getDecoder ( ) ) ; assertEquals ( 320 , result . getVideo ( ) . getSize ( ) . getWidth ( ) ) ; assertEquals ( 240 , result . getVideo ( ) . getSize ( ) . getHeight ( ) ) ; assertEquals ( 4817 , result . getVideo ( ) . getBitRate ( ) ) ; assertEquals ( 15.0f , result . getVideo ( ) . getFrameRate ( ) , 0 ) ; }
public String [ ] getAudioDecoders ( ) throws EncoderException { return getCoders ( false , true ) ; }
public String [ ] getAudioEncoders ( ) throws EncoderException { return getCoders ( true , true ) ; }
protected String [ ] getCoders ( boolean encoder , boolean audio ) throws EncoderException { ArrayList < String > res = new ArrayList < > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( encoder ? " -encoders " : " -decoders " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; String format = audio ? " A " : " V " ; boolean headerFound = false ; boolean evaluateLine = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( headerFound ) { if ( evaluateLine ) { Matcher matcher = ENCODER_DECODER_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { //String encoderFlag = matcher.group(2); String audioVideoFlag = matcher.group(1); if (format.equals(audioVideoFlag)) { String name = matcher.group(2); res.add(name); } } else { break; } } else { evaluateLine = line.trim().equals("------"); } } else if (line.trim().equals(encoder ? "Encoders:" : "Decoders:")) { headerFound = true; } } } catch (IOException e) { throw new EncoderException(e); } finally { ffmpeg.destroy(); } int size = res.size(); String[] ret = new String[size]; for (int i = 0; i < size; i++) { ret[i] = res.get(i); } return ret; }
public String [ ] getVideoDecoders ( ) throws EncoderException { return getCoders ( false , false ) ; }
public String [ ] getVideoEncoders ( ) throws EncoderException { return getCoders ( true , false ) ; }
public String [ ] getSupportedEncodingFormats ( ) throws EncoderException { return getSupportedCodingFormats ( true ) ; }
protected String [ ] getSupportedCodingFormats ( boolean encoding ) throws EncoderException { ArrayList < String > res = new ArrayList < > ( ) ; FFMPEGExecutor ffmpeg = locator . createExecutor ( ) ; ffmpeg . addArgument ( " -formats " ) ; try { ffmpeg . execute ( ) ; RBufferedReader reader = null ; reader = new RBufferedReader ( new InputStreamReader ( ffmpeg . getInputStream ( ) ) ) ; String line ; String ed = encoding ? " E " : " D " ; boolean headerFound = false ; boolean evaluateLine = false ; while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . trim ( ) . length ( ) = = 0 ) { continue ; } if ( headerFound ) { if ( evaluateLine ) { Matcher matcher = FORMAT_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String encoderFlag = matcher . group ( encoding ? 2 : 1 ) ; if ( ed . equals ( encoderFlag ) ) { String aux = matcher . group ( 3 ) ; StringTokenizer st = new StringTokenizer ( aux , " , " ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) . trim ( ) ; if ( ! res . contains ( token ) ) { res . add ( token ) ; } } } } else { break ; } } else { evaluateLine = line . trim ( ) . equals ( " -- " ) ; } } else if ( line . trim ( ) . equals ( " File formats: " ) ) { headerFound = true ; } } } catch ( IOException e ) { throw new EncoderException ( e ) ; } finally { ffmpeg . destroy ( ) ; } int size = res . size ( ) ; String [ ] ret = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) { ret [ i ] = res . get ( i ) ; } return ret ; }
public String [ ] getSupportedDecodingFormats ( ) throws EncoderException { return getSupportedCodingFormats ( false ) ; }
private HashMap < String , String > parseProgressInfoLine ( String line ) { HashMap < String , String > table = null ; Matcher m = PROGRESS_INFO_PATTERN . matcher ( line ) ; while ( m . find ( ) ) { if ( table = = null ) { table = new HashMap < > ( ) ; } String key = m . group ( 1 ) ; String value = m . group ( 2 ) ; table . put ( key , value ) ; } return table ; }
public void execute ( ) throws IOException { int argsSize = args . size ( ) ; String [ ] cmd = new String [ argsSize + 2 ] ; cmd [ 0 ] = ffmpegExecutablePath ; for ( int i = 0 ; i < argsSize ; i + + ) { cmd [ i + 1 ] = args . get ( i ) ; } cmd [ argsSize + 1 ] = " -hide_banner " ; if ( LOG . isDebugEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( String c : cmd ) { sb . append ( c ) ; sb . append ( ' ' ) ; } LOG . debug ( " About to execute " + sb . toString ( ) ) ; } Runtime runtime = Runtime . getRuntime ( ) ; ffmpeg = runtime . exec ( cmd ) ; ffmpegKiller = new ProcessKiller ( ffmpeg ) ; runtime . addShutdownHook ( ffmpegKiller ) ; inputStream = ffmpeg . getInputStream ( ) ; outputStream = ffmpeg . getOutputStream ( ) ; errorStream = ffmpeg . getErrorStream ( ) ; }
public void destroy ( ) { if ( inputStream ! = null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { LOG . warn ( " Error closing input stream " , t ) ; } inputStream = null ; } if ( outputStream ! = null ) { try { outputStream . close ( ) ; } catch ( Throwable t ) { LOG . warn ( " Error closing output stream " , t ) ; } outputStream = null ; } if ( errorStream ! = null ) { try { errorStream . close ( ) ; } catch ( Throwable t ) { LOG . warn ( " Error closing error stream " , t ) ; } errorStream = null ; } if ( ffmpeg ! = null ) { ffmpeg . destroy ( ) ; ffmpeg = null ; } if ( ffmpegKiller ! = null ) { Runtime runtime = Runtime . getRuntime ( ) ;
public MultimediaInfo getInfo ( ) throws InputFormatException , EncoderException { if ( inputFile . canRead ( ) ) {
public void render ( MultimediaObject multimediaObject , int width , int height , int seconds , File outputDir , String fileNamePrefix , String extension , int quality ) throws InputFormatException , EncoderException { File inputFile = multimediaObject . getFile ( ) ; try { if ( ! outputDir . exists ( ) ) { if ( ! outputDir . mkdirs ( ) ) { LOG . debug ( " Failed to create destination folder " ) ; throw new SecurityException ( ) ; } } if ( ! inputFile . canRead ( ) ) { LOG . debug ( " Failed to open input file " ) ; throw new SecurityException ( ) ; } } catch ( SecurityException e ) { LOG . debug ( " Access denied checking destination folder " + e ) ; } MultimediaInfo multimediaInfo = multimediaObject . getInfo ( ) ; numberOfScreens = ( int ) Math . ceil ( ( multimediaInfo . getDuration ( ) * .001 ) / seconds + 1 ) ; FFMPEGExecutor ffmpeg = this . locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( inputFile . getAbsolutePath ( ) ) ; ffmpeg . addArgument ( " -f " ) ; ffmpeg . addArgument ( " image2 " ) ; ffmpeg . addArgument ( " -vf " ) ; ffmpeg . addArgument ( String . format ( " fps=fps=1/%s " , String . valueOf ( seconds ) ) ) ; ffmpeg . addArgument ( " -s " ) ; ffmpeg . addArgument ( String . format ( " %sx%s " , String . valueOf ( width ) , String . valueOf ( height ) ) ) ; ffmpeg . addArgument ( " -qscale " ) ; ffmpeg . addArgument ( String . valueOf ( quality ) ) ; ffmpeg . addArgument ( String . format ( " %s%s%s-%%04d.%s " , outputDir . getAbsolutePath ( ) , File . separator , fileNamePrefix , extension ) ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try { RBufferedReader reader = new RBufferedReader (
public void render ( MultimediaObject multimediaObject , int width , int height , int seconds , File target , int quality ) throws EncoderException { File inputFile = multimediaObject . getFile ( ) ; target = target . getAbsoluteFile ( ) ; target . getParentFile ( ) . mkdirs ( ) ; try { if ( ! inputFile . canRead ( ) ) { LOG . debug ( " Failed to open input file " ) ; throw new SecurityException ( ) ; } } catch ( SecurityException e ) { LOG . debug ( " Access denied checking destination folder " + e ) ; } MultimediaInfo multimediaInfo = multimediaObject . getInfo ( ) ; int duration = ( int ) ( multimediaInfo . getDuration ( ) * .001 ) ; numberOfScreens = seconds < = duration ? 1 : 0 ; FFMPEGExecutor ffmpeg = this . locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( inputFile . getAbsolutePath ( ) ) ; ffmpeg . addArgument ( " -f " ) ; ffmpeg . addArgument ( " image2 " ) ; ffmpeg . addArgument ( " -vframes " ) ; ffmpeg . addArgument ( " 1 " ) ; ffmpeg . addArgument ( " -ss " ) ; ffmpeg . addArgument ( String . valueOf ( seconds ) ) ; ffmpeg . addArgument ( " -s " ) ; ffmpeg . addArgument ( String . format ( " %sx%s " , String . valueOf ( width ) , String . valueOf ( height ) ) ) ; ffmpeg . addArgument ( " -qscale " ) ; ffmpeg . addArgument ( String . valueOf ( quality ) ) ; ffmpeg . addArgument ( target . getAbsolutePath ( ) ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try { RBufferedReader reader = new RBufferedReader (
public void testEncode4argsLarge3 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/target4Large3.flv " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 64000 ) ; audio . setChannels ( 1 ) ; audio . setSamplingRate ( 22050 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " flv " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 400 , 300 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " flv " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( " Output file missing " , target . exists ( ) ) ; }
Integer getSamplingRate ( ) { return samplingRate ; }
public void setSamplingRate ( Integer samplingRate ) { this . samplingRate = samplingRate ; }
public void setChannels ( Integer channels ) { this . channels = channels ; }
public void setVolume ( Integer volume ) { this . volume = volume ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (codec= " + codec + " , bitRate= " + bitRate + " , samplingRate= " + samplingRate + " , channels= "
public String getDecoder ( ) { return decoder ; }
void setDecoder ( String format ) { this . decoder = format ; }
public int getSamplingRate ( ) { return samplingRate ; }
void setSamplingRate ( int samplingRate ) { this . samplingRate = samplingRate ; }
public int getChannels ( ) { return channels ; }
void setChannels ( int channels ) { this . channels = channels ; }
public int getBitRate ( ) { return bitRate ; }
void setBitRate ( int bitRate ) { this . bitRate = bitRate ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (decoder= " + decoder + " , samplingRate= " + samplingRate + " , channels= " + channels + " , bitRate= "
protected String getFFMPEGExecutablePath ( ) { return path ; }
private void copyFile ( String path , File dest ) throws RuntimeException { copy ( getClass ( ) . getResourceAsStream ( " native/ " + path ) , dest . getAbsolutePath ( ) ) ; }
private boolean copy ( InputStream source , String destination ) { boolean success = true ; try { Files . copy ( source , Paths . get ( destination ) , StandardCopyOption . REPLACE_EXISTING ) ; } catch ( IOException ex ) { LOG . warn ( " Cannot write file " + destination , ex ) ; success = false ; } return success ; }
public void sourceInfo ( MultimediaInfo info ) ; /** * This method is called to notify a progress in the encoding process. * * @param permil A permil value representing the encoding process progress. */ public void progress ( int permil ) ; /** * This method is called every time the encoder need to send a message * (usually, a warning). * * @param message The message sent by the encoder. */ public void message ( String message ) ; }
public void progress ( int permil ) ; /** * This method is called every time the encoder need to send a message * (usually, a warning). * * @param message The message sent by the encoder. */ public void message ( String message ) ; }
public void setFormat ( String format ) { this . format = format ; }
public void setOffset ( Float offset ) { this . offset = offset ; }
public void setDuration ( Float duration ) { this . duration = duration ; }
AudioAttributes getAudioAttributes ( ) { return audioAttributes ; }
public void setAudioAttributes ( AudioAttributes audioAttributes ) { this . audioAttributes = audioAttributes ; }
VideoAttributes getVideoAttributes ( ) { return videoAttributes ; }
public void setVideoAttributes ( VideoAttributes videoAttributes ) { this . videoAttributes = videoAttributes ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (format= " + format + " , offset= " + offset + " , duration= " + duration + " , audioAttributes= "
public void addArgument ( String arg ) { args . add ( arg ) ; }
public void execute ( ) throws IOException { int argsSize = args . size ( ) ; String [ ] cmd = new String [ argsSize + 2 ] ; cmd [ 0 ] = ffmpegExecutablePath ; for ( int i = 0 ; i < argsSize ; i + + ) { cmd [ i + 1 ] = args . get ( i ) ; } cmd [ argsSize + 1 ] = " -hide_banner " ; if ( LOG . isDebugEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( String c : cmd ) { sb . append ( c ) ; sb . append ( ' ' ) ; } LOG . debug ( " About to execute " + sb . toString ( ) ) ; } Runtime runtime = Runtime . getRuntime ( ) ; ffmpeg = runtime . exec ( cmd ) ; ffmpegKiller = new ProcessKiller ( ffmpeg ) ; runtime . addShutdownHook ( ffmpegKiller ) ; inputStream = ffmpeg . getInputStream ( ) ; outputStream = ffmpeg . getOutputStream ( ) ; errorStream = ffmpeg . getErrorStream ( ) ; }
public InputStream getInputStream ( ) { return inputStream ; }
public OutputStream getOutputStream ( ) { return outputStream ; }
public InputStream getErrorStream ( ) { return errorStream ; }
public void destroy ( ) { if ( inputStream ! = null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { LOG . warn ( " Error closing input stream " , t ) ; } inputStream = null ; } if ( outputStream ! = null ) { try { outputStream . close ( ) ; } catch ( Throwable t ) { LOG . warn ( " Error closing output stream " , t ) ; } outputStream = null ; } if ( errorStream ! = null ) { try { errorStream . close ( ) ; } catch ( Throwable t ) { LOG . warn ( " Error closing error stream " , t ) ; } errorStream = null ; } if ( ffmpeg ! = null ) { ffmpeg . destroy ( ) ; ffmpeg = null ; } if ( ffmpegKiller ! = null ) {
protected abstract String getFFMPEGExecutablePath ( ) ; /** * It returns a brand new {@link FFMPEGExecutor}, ready to be used in a * ffmpeg call. * * @return A newly instanced {@link FFMPEGExecutor}, using this locator to * call the ffmpeg executable. */ FFMPEGExecutor createExecutor ( ) { return new FFMPEGExecutor ( getFFMPEGExecutablePath ( ) ) ; } }
FFMPEGExecutor createExecutor ( ) { return new FFMPEGExecutor ( getFFMPEGExecutablePath ( ) ) ; }
public String getFormat ( ) { return format ; }
void setFormat ( String format ) { this . format = format ; }
public long getDuration ( ) { return duration ; }
void setDuration ( long duration ) { this . duration = duration ; }
public AudioInfo getAudio ( ) { return audio ; }
void setAudio ( AudioInfo audio ) { this . audio = audio ; }
public VideoInfo getVideo ( ) { return video ; }
void setVideo ( VideoInfo video ) { this . video = video ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (format= " + format + " , duration= " + duration + " , video= " + video + " , audio= " + audio + " ) " ;
public File getFile ( ) { return this . inputFile ; }
public String readLine ( ) throws IOException { if ( lines . size ( ) > 0 ) {
public void reinsertLine ( String line ) { lines . add ( 0 , line ) ; }
public int getNumberOfScreens ( ) { return numberOfScreens ; }
public void render ( MultimediaObject multimediaObject , int width , int height , int seconds , File outputDir , String fileNamePrefix , String extension , int quality ) throws InputFormatException , EncoderException { File inputFile = multimediaObject . getFile ( ) ; try { if ( ! outputDir . exists ( ) ) { if ( ! outputDir . mkdirs ( ) ) { LOG . debug ( " Failed to create destination folder " ) ; throw new SecurityException ( ) ; } } if ( ! inputFile . canRead ( ) ) { LOG . debug ( " Failed to open input file " ) ; throw new SecurityException ( ) ; } } catch ( SecurityException e ) { LOG . debug ( " Access denied checking destination folder " + e ) ; } MultimediaInfo multimediaInfo = multimediaObject . getInfo ( ) ; numberOfScreens = ( int ) Math . ceil ( ( multimediaInfo . getDuration ( ) * .001 ) / seconds + 1 ) ; FFMPEGExecutor ffmpeg = this . locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( inputFile . getAbsolutePath ( ) ) ; ffmpeg . addArgument ( " -f " ) ; ffmpeg . addArgument ( " image2 " ) ; ffmpeg . addArgument ( " -vf " ) ; ffmpeg . addArgument ( String . format ( " fps=fps=1/%s " , String . valueOf ( seconds ) ) ) ; ffmpeg . addArgument ( " -s " ) ; ffmpeg . addArgument ( String . format ( " %sx%s " , String . valueOf ( width ) , String . valueOf ( height ) ) ) ; ffmpeg . addArgument ( " -qscale " ) ; ffmpeg . addArgument ( String . valueOf ( quality ) ) ; ffmpeg . addArgument ( String . format ( " %s%s%s-%%04d.%s " , outputDir . getAbsolutePath ( ) , File . separator , fileNamePrefix , extension ) ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try {
public void render ( MultimediaObject multimediaObject , int width , int height , int seconds , File target , int quality ) throws EncoderException { File inputFile = multimediaObject . getFile ( ) ; target = target . getAbsoluteFile ( ) ; target . getParentFile ( ) . mkdirs ( ) ; try { if ( ! inputFile . canRead ( ) ) { LOG . debug ( " Failed to open input file " ) ; throw new SecurityException ( ) ; } } catch ( SecurityException e ) { LOG . debug ( " Access denied checking destination folder " + e ) ; } MultimediaInfo multimediaInfo = multimediaObject . getInfo ( ) ; int duration = ( int ) ( multimediaInfo . getDuration ( ) * .001 ) ; numberOfScreens = seconds < = duration ? 1 : 0 ; FFMPEGExecutor ffmpeg = this . locator . createExecutor ( ) ; ffmpeg . addArgument ( " -i " ) ; ffmpeg . addArgument ( inputFile . getAbsolutePath ( ) ) ; ffmpeg . addArgument ( " -f " ) ; ffmpeg . addArgument ( " image2 " ) ; ffmpeg . addArgument ( " -vframes " ) ; ffmpeg . addArgument ( " 1 " ) ; ffmpeg . addArgument ( " -ss " ) ; ffmpeg . addArgument ( String . valueOf ( seconds ) ) ; ffmpeg . addArgument ( " -s " ) ; ffmpeg . addArgument ( String . format ( " %sx%s " , String . valueOf ( width ) , String . valueOf ( height ) ) ) ; ffmpeg . addArgument ( " -qscale " ) ; ffmpeg . addArgument ( String . valueOf ( quality ) ) ; ffmpeg . addArgument ( target . getAbsolutePath ( ) ) ; try { ffmpeg . execute ( ) ; } catch ( IOException e ) { throw new EncoderException ( e ) ; } try {
public void setX264Profile ( X264_PROFILE x264Profile ) { this . x264Profile = x264Profile ; }
public void addFilter ( VideoFilter videoFilter ) { this . videoFilters . add ( videoFilter ) ; }
public ArrayList < VideoFilter > getVideoFilters ( ) { return this . videoFilters ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (codec= " + codec + " , bitRate= " + bitRate + " , frameRate= " + frameRate + " , size= " + size + " , faststart= " + faststart + " ) " ;
public String getExpression ( ) { return this . expression ; }
public String toString ( ) { return this . expression ; }
void setDecoder ( String codec ) { this . decoder = codec ; }
public VideoSize getSize ( ) { return size ; }
void setSize ( VideoSize size ) { this . size = size ; }
public float getFrameRate ( ) { return frameRate ; }
void setFrameRate ( float frameRate ) { this . frameRate = frameRate ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " (decoder= " + decoder + " , size= " + size + " , bitRate= " + bitRate + " , frameRate= " + frameRate + " ) " ;
public String toString ( ) { return getClass ( ) . getName ( ) + " (width= " + width + " , height= " + height + " ) " ;
public void testEncodeAudio1 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/Alesis-Fusion-Clean-Guitar-C3.wav " ) ; File target = new File ( " target/testoutput/Alesis-Fusion-Clean-Guitar-C3.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( new Integer ( 128000 ) ) ; audio . setChannels ( new Integer ( 2 ) ) ; audio . setSamplingRate ( new Integer ( 44100 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( " Output file missing " , target . exists ( ) ) ; }
public void testEncodeVideo1 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/dance1.avi " ) ; File target = new File ( " target/testoutput/target3.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( " Output file missing " , target . exists ( ) ) ; }
public void testEncodeVideo2 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/dance1.avi " ) ; File target = new File ( " target/testoutput/target4.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( " Output file missing " , target . exists ( ) ) ; }
public void testEncodeVideo3 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/target4Large.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Unknown encoder 'libfaac' " ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { message = ex . getMessage ( ) ; } assertEquals ( " Encoding problem not found " , compareTo , message ) ; }
public void testEncodeVideo4 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/target4Large2.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " adpcm_ms " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " codec not currently supported in container " ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { message = ex . getMessage ( ) ; } assertTrue ( " Encoding problem not found " , message . contains ( compareTo ) ) ; }
public void testEncodeVideo5 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/target4Large3.flv " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 64000 ) ; audio . setChannels ( 1 ) ; audio . setSamplingRate ( 22050 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " flv " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 400 , 300 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " flv " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( " Output file missing " , target . exists ( ) ) ; }
public void testEncodeAudio2 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/Alesis-Fusion-Clean-Guitar-C3.wav " ) ; File target = new File ( " target/testoutput/Alesis-Fusion-Clean-Guitar-C3.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( new Integer ( 128000 ) ) ; audio . setChannels ( new Integer ( 2 ) ) ; audio . setSamplingRate ( new Integer ( 42100 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Specified sample rate " ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { message = ex . getMessage ( ) ; } assertTrue ( " Encoding problem not found " , message . contains ( compareTo ) ) ; }
public void testFindExecutable ( ) { DefaultFFMPEGLocator locator = new DefaultFFMPEGLocator ( ) ; String exePath = locator . getFFMPEGExecutablePath ( ) ; assertNotNull ( " Native component not found " , exePath ) ; }
private void copyFile ( String path , File dest ) { copy ( getClass ( ) . getResourceAsStream ( " native/ " + path ) , dest . getAbsolutePath ( ) ) ; }
public void testGetAudioDecoders ( ) throws Exception { System . out . println ( " getAudioDecoders " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getAudioDecoders ( ) ; assertTrue ( result ! = null & & result . length > 0 , " No audio decoders found " ) ; }
public void testGetAudioEncoders ( ) throws Exception { System . out . println ( " getAudioEncoders " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getAudioEncoders ( ) ; assertTrue ( result ! = null & & result . length > 0 , " No audio encoders found " ) ; }
public void testGetVideoDecoders ( ) throws Exception { System . out . println ( " getVideoDecoders " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getVideoDecoders ( ) ; assertTrue ( result ! = null & & result . length > 0 , " No video decoders found " ) ; }
public void testGetVideoEncoders ( ) throws Exception { System . out . println ( " getVideoEncoders " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getVideoEncoders ( ) ; assertTrue ( result ! = null & & result . length > 0 , " No video enecoders found " ) ; }
public void testGetSupportedEncodingFormats ( ) throws Exception { System . out . println ( " getSupportedEncodingFormats " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getSupportedEncodingFormats ( ) ; assertTrue ( result ! = null & & result . length > 0 , " No supported encoding formats found " ) ; }
public void testGetSupportedDecodingFormats ( ) throws Exception { System . out . println ( " getSupportedDecodingFormats " ) ; Encoder instance = new Encoder ( ) ; String [ ] result = instance . getSupportedDecodingFormats ( ) ; assertTrue ( result ! = null & & result . length > 0 , " No supported decoding formats found " ) ; }
public void testEncodeVideo1 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/dance1.avi " ) ; File target = new File ( " target/testoutput/target3.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeVideo2 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/dance1.avi " ) ; File target = new File ( " target/testoutput/target4.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeVideo4 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/target4Large2.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " adpcm_ms " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " codec not currently supported in container " ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { message = ex . getMessage ( ) ; } assertTrue ( message . contains ( compareTo ) , " Encoding problem not found " ) ; }
public void testEncodeVideo5 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/target4Large3.flv " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 64000 ) ; audio . setChannels ( 1 ) ; audio . setSamplingRate ( 22050 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " flv " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 400 , 300 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " flv " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeAudio1 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/Alesis-Fusion-Clean-Guitar-C3.wav " ) ; File target = new File ( " target/testoutput/Alesis-Fusion-Clean-Guitar-C3.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( new Integer ( 128000 ) ) ; audio . setChannels ( new Integer ( 2 ) ) ; audio . setSamplingRate ( new Integer ( 44100 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeAudio2 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/Alesis-Fusion-Clean-Guitar-C3.wav " ) ; File target = new File ( " target/testoutput/Alesis-Fusion-Clean-Guitar-C3.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( new Integer ( 128000 ) ) ; audio . setChannels ( new Integer ( 2 ) ) ; audio . setSamplingRate ( new Integer ( 42100 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Specified sample rate " ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { message = ex . getMessage ( ) ; } assertTrue ( message . contains ( compareTo ) , " Encoding problem not found " ) ; }
public void testEncodeVideo3 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/target4Large.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Unknown encoder 'libfaac' " ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { message = ex . getMessage ( ) ; } assertEquals ( compareTo , message , " Encoding problem not found " ) ; }
public void testEncodeAudio3 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/testfile3.wmv " ) ; File target = new File ( " target/testoutput/testfile3.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Specified sample rate " ; AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( new Integer ( 128000 ) ) ; audio . setChannels ( new Integer ( 2 ) ) ; audio . setSamplingRate ( new Integer ( 44100 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testGetInfo ( ) throws Exception { System . out . println ( " getInfo " ) ; File file = new File ( " src/test/resources/dance1.avi " ) ; MultimediaObject instance = new MultimediaObject ( file ) ; MultimediaInfo result = instance . getInfo ( ) ; assertEquals ( " avi " , result . getFormat ( ) ) ; assertEquals ( 1530 , result . getDuration ( ) ) ; assertNull ( result . getAudio ( ) ) ; assertEquals ( " rawvideo " , result . getVideo ( ) . getDecoder ( ) ) ; assertEquals ( 320 , result . getVideo ( ) . getSize ( ) . getWidth ( ) ) ; assertEquals ( 240 , result . getVideo ( ) . getSize ( ) . getHeight ( ) ) ; assertEquals ( 4817 , result . getVideo ( ) . getBitRate ( ) ) ; assertEquals ( 15.0f , result . getVideo ( ) . getFrameRate ( ) ) ; }
public void testAnalyzeNewLine1 ( ) { System . out . println ( " analyzeNewLine 1 " ) ; File file = new File ( " src/test/resources/testoutput1.log " ) ; ConversionOutputAnalyzer oa1 = new ConversionOutputAnalyzer ( 0 , null ) ; try {
public void testEncodeVideo3 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/target4Large.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " In step: 1 Error in line 10 : <Unknown encoder 'libfaac'> " ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { message = ex . getMessage ( ) ; } assertEquals ( compareTo , message , " Encoding problem not found " ) ; }
public void analyzeNewLine ( String line ) throws EncoderException { lineNR + + ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Input Line ( " + lineNR + " ): < " + line + " > " ) ; } if ( line . startsWith ( " WARNING: " ) ) { if ( listener ! = null ) { listener . message ( line ) ; } } if ( line . startsWith ( " Press [q] " ) ) {
public String getLastWarning ( ) { return lastWarning ; }
public void testAnalyzeNewLine1 ( ) { System . out . println ( " analyzeNewLine 1 " ) ; File file = new File ( " src/test/resources/testoutput1.txt " ) ; ConversionOutputAnalyzer oa1 = new ConversionOutputAnalyzer ( 0 , null ) ; try {
public void testEncodeVideo1 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/dance1.avi " ) ; File target = new File ( " target/testoutput/testEncodeVideo1.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeVideo2 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/dance1.avi " ) ; File target = new File ( " target/testoutput/testEncodeVideo2.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeVideo3 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/testEncodeVideo3.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String errorMessage = " Exit code of ffmpeg encoding run is 1 " ; boolean exceptionThrown = false ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { assertEquals ( ex . getMessage ( ) , errorMessage , " Not expected error message " ) ; exceptionThrown = true ; } assertTrue ( exceptionThrown , " No exception occured " ) ; }
public void testEncodeVideo4 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/testEncodeVideo4.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " adpcm_ms " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; boolean exceptionThrown = false ; String errorMessage = " Exit code of ffmpeg encoding run is 1 " ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { assertEquals ( ex . getMessage ( ) , errorMessage , " Not expected error message " ) ; exceptionThrown = true ; } assertTrue ( exceptionThrown , " No exception occured " ) ; }
public void testEncodeVideo5 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/testEncodeVideo5.flv " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 64000 ) ; audio . setChannels ( 1 ) ; audio . setSamplingRate ( 22050 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " flv " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 400 , 300 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " flv " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeAudio1 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/Alesis-Fusion-Clean-Guitar-C3.wav " ) ; File target = new File ( " target/testoutput/testEncodeAudio1.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 128000 ) ; audio . setChannels ( 2 ) ; audio . setSamplingRate ( 44100 ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeAudio2 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/Alesis-Fusion-Clean-Guitar-C3.wav " ) ; File target = new File ( " target/testoutput/testEncodeAudio2.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 128000 ) ; audio . setChannels ( 2 ) ; audio . setSamplingRate ( 42100 ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String errorMessage = " Exit code of ffmpeg encoding run is 1 " ; boolean exceptionThrown = false ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { assertEquals ( ex . getMessage ( ) , errorMessage , " Not expected error message " ) ; exceptionThrown = true ; } assertTrue ( exceptionThrown , " No exception occured " ) ; }
public void testEncodeAudio3 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/testfile3.wmv " ) ; File target = new File ( " target/testoutput/testEncodeAudio3.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Specified sample rate " ; AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 128000 ) ; audio . setChannels ( 2 ) ; audio . setSamplingRate ( 44100 ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeAudio4 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/buggy.ogg " ) ; File target = new File ( " target/testoutput/testEncodeAudio4.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Specified sample rate " ; AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testAbortEncoder ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/testfile3.wmv " ) ; File target = new File ( " target/testoutput/testAbortEncoder.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Specified sample rate " ; AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 128000 ) ; audio . setChannels ( 2 ) ; audio . setSamplingRate ( 44100 ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; Runnable task = ( ) - > { try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; } catch ( EncoderException ex ) { throw new AssertionError ( " Unexpected exception in encoder " , ex ) ; } } ; Thread thread = new Thread ( task ) ; thread . start ( ) ; TimeUnit . MILLISECONDS . sleep ( 100 ) ; encoder . abortEncoding ( ) ; }
public List < String > getUnhandledMessages ( ) { return unhandledMessages ; }
public void abortEncoding ( ) { if ( ffmpeg ! = null ) {
public void execute ( ) throws IOException { int argsSize = args . size ( ) ; String [ ] cmd = new String [ argsSize + 2 ] ; cmd [ 0 ] = ffmpegExecutablePath ; for ( int i = 0 ; i < argsSize ; i + + ) { cmd [ i + 1 ] = args . get ( i ) ; } cmd [ argsSize + 1 ] = " -hide_banner " ; // Don't show banner if (LOG.isDebugEnabled()) { StringBuilder sb = new StringBuilder(); for (String c : cmd) { sb.append(c); sb.append(' '); } LOG.debug("About to execute " + sb.toString()); } Runtime runtime = Runtime.getRuntime(); ffmpeg = runtime.exec(cmd); ffmpegKiller = new ProcessKiller(ffmpeg); runtime.addShutdownHook(ffmpegKiller); inputStream = ffmpeg.getInputStream(); outputStream = ffmpeg.getOutputStream(); errorStream = ffmpeg.getErrorStream(); }
public int getProcessExitCode ( ) { return ffmpeg . exitValue ( ) ; }
public void testEncodeVideo6 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/private/test10.mpg " ) ; if ( source . exists ( ) ) {
public void testEncodeAudio09 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/testfile09.mp3 " ) ; if ( source . exists ( ) ) {
public void testEncodeVideo10 ( ) throws Exception { System . out . println ( " encode " ) ; Logger . getLogger ( " it.sauronsoftware.jave.FFMPEGExecutor " ) . setLevel ( Level . FINEST ) ; File source = new File ( " src/test/resources/private/test10.mpg " ) ; if ( source . exists ( ) ) {
public void testEncodeVideo1 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/dance1.avi " ) ; File target = new File ( " target/testoutput/testEncodeVideo1.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeVideo2 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/dance1.avi " ) ; File target = new File ( " target/testoutput/testEncodeVideo2.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeVideo3 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/testEncodeVideo3.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String errorMessage = " Exit code of ffmpeg encoding run is 1 " ; boolean exceptionThrown = false ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { assertEquals ( ex . getMessage ( ) , errorMessage , " Not expected error message " ) ; exceptionThrown = true ; } assertTrue ( exceptionThrown , " No exception occured " ) ; }
public void testEncodeVideo4 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/testEncodeVideo4.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " adpcm_ms " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; boolean exceptionThrown = false ; String errorMessage = " Exit code of ffmpeg encoding run is 1 " ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { assertEquals ( ex . getMessage ( ) , errorMessage , " Not expected error message " ) ; exceptionThrown = true ; } assertTrue ( exceptionThrown , " No exception occured " ) ; }
public void testEncodeVideo5 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/AV36_1.AVI " ) ; File target = new File ( " target/testoutput/testEncodeVideo5.flv " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 64000 ) ; audio . setChannels ( 1 ) ; audio . setSamplingRate ( 22050 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " flv " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 400 , 300 ) ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " flv " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeAudio09 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/testfile09.mp3 " ) ; if ( source . exists ( ) ) {
public void testEncodeVideo10 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/private/test10.mpg " ) ; if ( source . exists ( ) ) {
public void testEncodeAudio1 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/Alesis-Fusion-Clean-Guitar-C3.wav " ) ; File target = new File ( " target/testoutput/testEncodeAudio1.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 128000 ) ; audio . setChannels ( 2 ) ; audio . setSamplingRate ( 44100 ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertNotNull ( listener . getInfo ( ) ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeAudio2 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/Alesis-Fusion-Clean-Guitar-C3.wav " ) ; File target = new File ( " target/testoutput/testEncodeAudio2.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 128000 ) ; audio . setChannels ( 2 ) ; audio . setSamplingRate ( 42100 ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String errorMessage = " Exit code of ffmpeg encoding run is 1 " ; boolean exceptionThrown = false ; try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; } catch ( EncoderException ex ) { assertEquals ( ex . getMessage ( ) , errorMessage , " Not expected error message " ) ; exceptionThrown = true ; } assertTrue ( exceptionThrown , " No exception occured " ) ; }
public void testEncodeAudio3 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/testfile3.wmv " ) ; File target = new File ( " target/testoutput/testEncodeAudio3.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Specified sample rate " ; AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 128000 ) ; audio . setChannels ( 2 ) ; audio . setSamplingRate ( 44100 ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testEncodeAudio4 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/buggy.ogg " ) ; File target = new File ( " target/testoutput/testEncodeAudio4.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Specified sample rate " ; AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public void testAbortEncoder ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/testfile3.wmv " ) ; File target = new File ( " target/testoutput/testAbortEncoder.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Specified sample rate " ; AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; audio . setBitRate ( 128000 ) ; audio . setChannels ( 2 ) ; audio . setSamplingRate ( 44100 ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; Runnable task = ( ) - > { try { encoder . encode ( new MultimediaObject ( source ) , target , attrs , listener ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; } catch ( EncoderException ex ) { throw new AssertionError ( " Unexpected exception in encoder " , ex ) ; } } ; Thread thread = new Thread ( task ) ; thread . start ( ) ; TimeUnit . MILLISECONDS . sleep ( 100 ) ; encoder . abortEncoding ( ) ; }
public void testEncodeAudio5 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/cj2009-10-05d01t07.ku100_at37.flac " ) ; File target = new File ( " target/testoutput/testEncodeAudio5.mp3 " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } Encoder encoder = new Encoder ( ) ; PListener listener = new PListener ( ) ; String message = null ; String compareTo = " Specified sample rate " ; AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libmp3lame " ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " mp3 " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setMapMetaData ( true ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
private void copyFile ( String path , File dest ) { String resourceName = " native/ " + path ; try {
public Float getOffset ( ) { return offset ; }
public Float getDuration ( ) { return duration ; }
public AudioAttributes getAudioAttributes ( ) { return audioAttributes ; }
public VideoAttributes getVideoAttributes ( ) { return videoAttributes ; }
public boolean isMapMetaData ( ) { return mapMetaData ; }
public void setMapMetaData ( boolean mapMetaData ) { this . mapMetaData = mapMetaData ; }
public int getProcessExitCode ( ) { // Make sure it's terminated try { ffmpeg.waitFor(); } catch (InterruptedException ex) { LOG.warn("Interrupted during waiting on process, forced shutdown?", ex); } return ffmpeg.exitValue(); }
public void testEncodeVideo11 ( ) throws Exception { System . out . println ( " encode " ) ; File source = new File ( " src/test/resources/dance1.avi " ) ; File target = new File ( " target/testoutput/testEncodeVideo11.3gp " ) ; if ( target . exists ( ) ) { target . delete ( ) ; } AudioAttributes audio = new AudioAttributes ( ) ; audio . setCodec ( " libfaac " ) ; audio . setBitRate ( 128000 ) ; audio . setSamplingRate ( 44100 ) ; audio . setChannels ( 2 ) ; audio . setQuality ( 31 ) ; VideoAttributes video = new VideoAttributes ( ) ; video . setCodec ( " mpeg4 " ) ; video . setBitRate ( 160000 ) ; video . setFrameRate ( 15 ) ; video . setSize ( new VideoSize ( 176 , 144 ) ) ; video . setQuality ( 31 ) ; EncodingAttributes attrs = new EncodingAttributes ( ) ; attrs . setFormat ( " 3gp " ) ; attrs . setAudioAttributes ( audio ) ; attrs . setVideoAttributes ( video ) ; Encoder encoder = new Encoder ( ) ; encoder . encode ( new MultimediaObject ( source ) , target , attrs ) ; assertTrue ( target . exists ( ) , " Output file missing " ) ; }
public Integer getQuality ( ) { return quality ; }
public void setQuality ( Integer quality ) { this . quality = quality ; }
private static final String parse ( String query , Map paramMap ) { // I was originally using regular expressions, but they didn't work well for ignoring // parameter-like strings inside quotes. int length=query.length(); StringBuffer parsedQuery=new StringBuffer(length); boolean inSingleQuote=false; boolean inDoubleQuote=false; int index=1; for(int i=0;i<length;i++) { char c=query.charAt(i); if(inSingleQuote) { if(c=='\'') { inSingleQuote=false; } } else if(inDoubleQuote) { if(c=='"') { inDoubleQuote=false; } } else { if(c=='\'') { inSingleQuote=true; } else if(c=='"') { inDoubleQuote=true; } else if(c==':' && i+1<length && Character.isJavaIdentifierStart(query.charAt(i+1))) { int j=i+2; while(j<length && Character.isJavaIdentifierPart(query.charAt(j))) { j++; } String name=query.substring(i+1,j); c='?'; // replace the parameter with a question mark i+=name.length(); // skip past the end if the parameter List indexList=(List)paramMap.get(name); if(indexList==null) { indexList=new LinkedList(); paramMap.put(name, indexList); } indexList.add(new Integer(index)); index++; } } parsedQuery.append(c); } // replace the lists of Integer objects with arrays of ints for(Iterator itr=paramMap.entrySet().iterator(); itr.hasNext();) { Map.Entry entry=(Map.Entry)itr.next(); List list=(List)entry.getValue(); int[] indexes=new int[list.size()]; int i=0; for(Iterator itr2=list.iterator(); itr2.hasNext();) { Integer x=(Integer)itr2.next(); indexes[i++]=x.intValue(); } entry.setValue(indexes); } return parsedQuery.toString(); }
private int [ ] getIndexes ( String name ) { int [ ] indexes = ( int [ ] ) indexMap . get ( name ) ; if ( indexes = = null ) { throw new IllegalArgumentException ( " Parameter not found: " + name ) ; } return indexes ; }
public void setObject ( String name , Object value ) throws SQLException { int [ ] indexes = getIndexes ( name ) ; for ( int i = 0 ; i < indexes . length ; i + + ) { statement . setObject ( indexes [ i ] , value ) ;
public void setString ( String name , String value ) throws SQLException { int [ ] indexes = getIndexes ( name ) ; for ( int i = 0 ; i < indexes . length ; i + + ) { statement . setString ( indexes [ i ] , value ) ;
public void setInt ( String name , int value ) throws SQLException { int [ ] indexes = getIndexes ( name ) ; for ( int i = 0 ; i < indexes . length ; i + + ) { statement . setInt ( indexes [ i ] , value ) ;
public void setLong ( String name , long value ) throws SQLException { int [ ] indexes = getIndexes ( name ) ; for ( int i = 0 ; i < indexes . length ; i + + ) { statement . setLong ( indexes [ i ] , value ) ;
public void setTimestamp ( String name , Timestamp value ) throws SQLException { int [ ] indexes = getIndexes ( name ) ; for ( int i = 0 ; i < indexes . length ; i + + ) { statement . setTimestamp ( indexes [ i ] , value ) ;
public PreparedStatement getStatement ( ) { return statement ; }
public boolean execute ( ) throws SQLException { return statement . execute ( ) ; }
public ResultSet executeQuery ( ) throws SQLException { return statement . executeQuery ( ) ; }
public int executeUpdate ( ) throws SQLException { return statement . executeUpdate ( ) ; }
public void close ( ) throws SQLException { statement . close ( ) ; }
public void addBatch ( ) throws SQLException { statement . addBatch ( ) ; }
public int [ ] executeBatch ( ) throws SQLException { return statement . executeBatch ( ) ; }
public Query addParameter ( String name , Object value ) { try { statement . setObject ( name , value ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } return this ; }
public Query addParameter ( String name , int value ) { try { statement . setInt ( name , value ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } return this ; }
public Query addParameter ( String name , long value ) { try { statement . setLong ( name , value ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } return this ; }
public Query addParameter ( String name , String value ) { try { statement . setString ( name , value ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } return this ; }
public Query addParameter ( String name , Timestamp value ) { try { statement . setTimestamp ( name , value ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } return this ; }
public List fetch ( ) { List list = new ArrayList ( ) ; try { ResultSet rs = statement . executeQuery ( ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; while ( rs . next ( ) ) { Object obj = this . destinationClass . newInstance ( ) ; for ( int colIdx = 1 ; colIdx < = meta . getColumnCount ( ) ; colIdx + + ) { String colName = meta . getColumnName ( colIdx ) ; int colType = meta . getColumnType ( colIdx ) ; Object value = rs . getObject ( colName ) ; try { Field field = destinationClass . getField ( colName ) ; field . set ( obj , value ) ; } catch ( NoSuchFieldException nsfe ) { String methodName = " set " + colName . substring ( 0 , 1 ) . toUpperCase ( ) + colName . substring ( 1 ) ; Method method = destinationClass . getMethod ( methodName , value . getClass ( ) ) ; method . invoke ( obj , value ) ; } } list . add ( obj ) ; } } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } finally { if ( statement ! = null ) { try { statement . close ( ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } } } return list ; }
public Query createQuery ( String query , Class c ) { Query q = new Query ( this , c , query ) ; return q ; }
public static void registerDriver ( String driverName ) { try { Driver driver = ( Driver ) Class . forName ( driverName ) . newInstance ( ) ;
public static Connection createConnection ( Sql2o sql2o ) { Properties conProps = new Properties ( ) ; conProps . put ( " user " , sql2o . getUser ( ) ) ; conProps . put ( " password " , sql2o . getPass ( ) ) ; Connection con ; try { con = DriverManager . getConnection ( " jdbc: " + sql2o . getUrl ( ) , conProps ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } return con ; }
public void setEmail ( String email ) { this . email = email ; }
public void test ( ) { String driver = " com.mysql.jdbc.Driver " ; String url = " mysql://127.0.0.1/playblog " ; String user = " root " ; String pass = " test123 " ; Sql2o . registerDriver ( driver ) ; Sql2o sql2o = new Sql2o ( url , user , pass ) ; List < User > userO = sql2o . createQuery ( " select id, name, email from User where id = :id " , User . class ) . addParameter ( " id " , 2L ) . fetch ( ) ; List < User > user1 = sql2o . createQuery ( " select id, name, email from User where id = :id " , User . class ) . addParameter ( " id " , 3L ) . fetch ( ) ; List < User > user2 = sql2o . createQuery ( " select id, name, email from User " , User . class ) . fetch ( ) ; assertNotNull ( userO ) ; }
public void testSelect ( ) { String driver = " com.mysql.jdbc.Driver " ; String url = " mysql://127.0.0.1/playblog " ; String user = " root " ; String pass = " test123 " ; Sql2o . registerDriver ( driver ) ; Sql2o sql2o = new Sql2o ( url , user , pass ) ; List < User > userO = sql2o . createQuery ( " select id, name, email from User where id = :id " , User . class ) . addParameter ( " id " , 2L ) . fetch ( ) ; List < User > user1 = sql2o . createQuery ( " select id, name, email from User where id = :id " , User . class ) . addParameter ( " id " , 3L ) . fetch ( ) ; List < User > user2 = sql2o . createQuery ( " select id, name, email from User " , User . class ) . fetch ( ) ; assertNotNull ( userO ) ; }
public < T > List < T > fetch ( ) { List list = new ArrayList ( ) ; try { ResultSet rs = statement . executeQuery ( ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; while ( rs . next ( ) ) { Object obj = this . destinationClass . newInstance ( ) ; for ( int colIdx = 1 ; colIdx < = meta . getColumnCount ( ) ; colIdx + + ) { String colName = meta . getColumnName ( colIdx ) ; int colType = meta . getColumnType ( colIdx ) ; Object value = rs . getObject ( colName ) ; try { Field field = destinationClass . getField ( colName ) ; field . set ( obj , value ) ; } catch ( NoSuchFieldException nsfe ) { String methodName = " set " + colName . substring ( 0 , 1 ) . toUpperCase ( ) + colName . substring ( 1 ) ; Method method = destinationClass . getMethod ( methodName , value . getClass ( ) ) ; method . invoke ( obj , value ) ; } } list . add ( obj ) ; } rs . close ( ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } finally { if ( statement ! = null ) { try { statement . getStatement ( ) . getConnection ( ) . close ( ) ; statement . close ( ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } } } return list ; }
public < T > T fetchFirst ( ) { List l = this . fetch ( ) ; if ( l . size ( ) = = 0 ) { return null ;
public void setUrl ( String url ) { this . url = url ; }
public static Connection createConnection ( Sql2o sql2o ) { Properties conProps = new Properties ( ) ; conProps . put ( " user " , sql2o . getUser ( ) ) ; conProps . put ( " password " , sql2o . getPass ( ) ) ; Connection con ; try { if ( ! sql2o . getUrl ( ) . startsWith ( " jdbc " ) ) { sql2o . setUrl ( " jdbc: " + sql2o . getUrl ( ) ) ; } con = DriverManager . getConnection ( sql2o . getUrl ( ) , conProps ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } return con ; }
private String getSetterName ( String fieldName ) { return " set " + fieldName . substring ( 0 , 1 ) . toUpperCase ( ) + fieldName . substring ( 1 ) ; }
private String getGetterName ( String fieldName ) { return " get " + fieldName . substring ( 0 , 1 ) . toUpperCase ( ) + fieldName . substring ( 1 ) ; }
private void setField ( Object obj , String fieldName , Object value ) throws IllegalAccessException , NoSuchMethodException , InvocationTargetException { Class objClass = obj . getClass ( ) ; try { Field field = objClass . getField ( fieldName ) ;
private Object instantiateIfNecessary ( Object obj , String fieldName ) throws IllegalAccessException , InstantiationException , NoSuchMethodException , InvocationTargetException { Object instantiation ; Class objClass = obj . getClass ( ) ; try { Field field = objClass . getField ( fieldName ) ; instantiation = field . get ( obj ) ; if ( instantiation = = null ) { instantiation = field . getType ( ) . newInstance ( ) ; field . set ( obj , instantiation ) ; } } catch ( NoSuchFieldException nsfe ) { Method getter = objClass . getMethod ( getGetterName ( fieldName ) ) ; instantiation = getter . invoke ( obj ) ; if ( instantiation = = null ) { Method setter = objClass . getMethod ( getSetterName ( fieldName ) , getter . getReturnType ( ) ) ; instantiation = getter . getReturnType ( ) . newInstance ( ) ; setter . invoke ( obj , instantiation ) ; } } return instantiation ; }
public < T > List < T > fetch ( ) { List list = new ArrayList ( ) ; try { ResultSet rs = statement . executeQuery ( ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; while ( rs . next ( ) ) { Object obj = this . destinationClass . newInstance ( ) ; for ( int colIdx = 1 ; colIdx < = meta . getColumnCount ( ) ; colIdx + + ) { String colName = meta . getColumnName ( colIdx ) ; //int colType = meta.getColumnType(colIdx); String[] fieldPath = colName.split("\\."); if (fieldPath.length == 0){ fieldPath = new String[]{colName}; } Object value = rs.getObject(colName); Object pathObject = obj; for (int pathIdx = 0; pathIdx < fieldPath.length; pathIdx++){ if (pathIdx == fieldPath.length - 1){ setField(pathObject, fieldPath[pathIdx], value); break; } pathObject = instantiateIfNecessary(pathObject, fieldPath[pathIdx]); } } list.add(obj); } rs.close(); } catch(Exception ex){ throw new RuntimeException(ex); } finally { if (statement != null){ try{ statement.getStatement().getConnection().close(); statement.close(); } catch (Exception ex){ throw new RuntimeException(ex); } } } return list; }
public void setName ( String name ) { this . name = name ; }
public void testSelect ( ) { String driver = " com.mysql.jdbc.Driver " ; String url = " mysql://127.0.0.1/playblog " ; String user = " root " ; String pass = " test123 " ; Sql2o . registerDriver ( driver ) ; Sql2o sql2o = new Sql2o ( url , user , pass ) ; String query = " select id, name, email, \ n " + " \ t'test' as \" customer1.name \" , \ n " + " \ t1 as \" customer1.id \" , \ n " + " \ t'test2' as \" customer2.name \" , \ n " + " \ t2 as \" customer2.id \" \ n " + " from User where id = :id " ; User user3 = sql2o . createQuery ( query , User . class ) . addParameter ( " id " , 2 ) . fetchFirst ( ) ; List < User > userO = sql2o . createQuery ( " select id, name, email from User where id = :id " , User . class ) . addParameter ( " id " , 2L ) . fetch ( ) ; List < User > user1 = sql2o . createQuery ( " select id, name, email from User where id = :id " , User . class ) . addParameter ( " id " , 3L ) . fetch ( ) ; List < User > user2 = sql2o . createQuery ( " select id, name, email from User " , User . class ) . fetch ( ) ; assertNotNull ( userO ) ; }
public Customer getCustomer2 ( ) { return customer2 ; }
public void setCustomer2 ( Customer customer2 ) { this . customer2 = customer2 ; }
public void setTimestamp ( String name , Timestamp value ) throws SQLException { int [ ] indexes = getIndexes ( name ) ; for ( int i = 0 ; i < indexes . length ; i + + ) { statement . setTimestamp ( indexes [ i ] , value ) ;
public void setDate ( String name , Date value ) throws SQLException { int [ ] indexes = getIndexes ( name ) ; for ( int index : indexes ) { statement . setDate ( index , value ) ;
public Query addParameter ( String name , Date value ) { try { statement . setDate ( name , value ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } return this ; }
private void setField ( Object obj , String fieldName , Object value ) throws IllegalAccessException , NoSuchMethodException , InvocationTargetException { Class objClass = obj . getClass ( ) ; fieldName = columnMappings . containsKey ( fieldName ) ? columnMappings . get ( fieldName ) : fieldName ; try { Field field = objClass . getField ( fieldName ) ;
public < T > List < T > executeAndFetch ( Class returnType ) { List list = new ArrayList ( ) ; try { java . util . Date st = new java . util . Date ( ) ; ResultSet rs = statement . executeQuery ( ) ; System . out . println ( String . format ( " execute query time: %s " , new java . util . Date ( ) . getTime ( ) - st . getTime ( ) ) ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; while ( rs . next ( ) ) { Object obj = returnType . newInstance ( ) ; for ( int colIdx = 1 ; colIdx < = meta . getColumnCount ( ) ; colIdx + + ) { String colName = meta . getColumnName ( colIdx ) ; //int colType = meta.getColumnType(colIdx); String[] fieldPath = colName.split("\\."); if (fieldPath.length == 0){ fieldPath = new String[]{colName}; } Object value = rs.getObject(colName); Object pathObject = obj; for (int pathIdx = 0; pathIdx < fieldPath.length; pathIdx++){ if (pathIdx == fieldPath.length - 1){ setField(pathObject, fieldPath[pathIdx], value); break; } pathObject = instantiateIfNecessary(pathObject, fieldPath[pathIdx]); } } list.add(obj); } rs.close(); } catch(Exception ex){ throw new RuntimeException(ex); } finally { if (statement != null){ try{ statement.getStatement().getConnection().close(); statement.close(); } catch (Exception ex){ throw new RuntimeException(ex); } } } return list; }
public < T > T fetchFirst ( Class returnType ) { List l = this . executeAndFetch ( returnType ) ; if ( l . size ( ) = = 0 ) { return null ;
public Query executeUpdate ( ) { int result ; try { result = statement . executeUpdate ( ) ; } catch ( Exception ex ) { rollback ( ) ; throw new RuntimeException ( ex ) ; } finally { if ( ! autoCommit & & statement ! = null ) { try { statement . getStatement ( ) . getConnection ( ) . close ( ) ; statement . close ( ) ; } catch ( SQLException ex ) { throw new RuntimeException ( ex ) ; } } } return this ; }
public Map < String , String > getColumnMappings ( ) { return columnMappings ; }
public Query addColumnMapping ( String columnName , String fieldName ) { this . columnMappings . put ( columnName , fieldName ) ; return this ; }
public Query beginTransaction ( int isolationLevel ) { try { this . statement . getStatement ( ) . getConnection ( ) . setAutoCommit ( false ) ; this . statement . getStatement ( ) . getConnection ( ) . setTransactionIsolation ( isolationLevel ) ; this . autoCommit = true ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } return this ; }
public Query beginTransaction ( ) { this . beginTransaction ( Connection . TRANSACTION_READ_COMMITTED ) ; return this ; }
public void commit ( ) { try { this . statement . getStatement ( ) . getConnection ( ) . commit ( ) ;
public void rollback ( ) { try { this . statement . getStatement ( ) . getConnection ( ) . rollback ( ) ;
public Map < String , String > getDefaultColumnMappings ( ) { return defaultColumnMappings ; }
public void setDefaultColumnMappings ( Map < String , String > defaultColumnMappings ) { this . defaultColumnMappings = defaultColumnMappings ; }
public Query createQuery ( String query ) { Query q = new Query ( this , query , defaultColumnMappings ) ; return q ; }
public static void registerDriver ( Driver driver ) { try { DriverManager . registerDriver ( driver ) ;
public < T > T executeAndFetchFirst ( Class returnType ) { List l = this . executeAndFetch ( returnType ) ; if ( l . size ( ) = = 0 ) { return null ;
public < T > List < T > executeAndFetch ( Class returnType ) { List list = new ArrayList ( ) ; try { java . util . Date st = new java . util . Date ( ) ; ResultSet rs = statement . executeQuery ( ) ; System . out . println ( String . format ( " execute query time: %s " , new java . util . Date ( ) . getTime ( ) - st . getTime ( ) ) ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; while ( rs . next ( ) ) { Object obj = returnType . newInstance ( ) ; for ( int colIdx = 1 ; colIdx < = meta . getColumnCount ( ) ; colIdx + + ) { String colName = meta . getColumnName ( colIdx ) ; //int colType = meta.getColumnType(colIdx); String[] fieldPath = colName.split("\\."); if (fieldPath.length == 0){ fieldPath = new String[]{colName}; } Object value = rs.getObject(colName); Object pathObject = obj; for (int pathIdx = 0; pathIdx < fieldPath.length; pathIdx++){ if (pathIdx == fieldPath.length - 1){ setField(pathObject, fieldPath[pathIdx], value); break; } pathObject = instantiateIfNecessary(pathObject, fieldPath[pathIdx]); } } list.add(obj); } rs.close(); } catch(Exception ex){ throw new RuntimeException(ex); } finally { try{ if (this.sql2O.getConnection().getAutoCommit() && statement != null){ sql2O.getConnection().close(); statement.close(); } } catch (Exception ex){ throw new RuntimeException(ex); } } return list; }
public Sql2o executeUpdate ( ) { int result ; try { result = statement . executeUpdate ( ) ; } catch ( Exception ex ) { this . sql2O . rollback ( ) ; throw new RuntimeException ( ex ) ; } finally { try { if ( this . sql2O . getConnection ( ) . getAutoCommit ( ) & & statement ! = null ) { try { this . sql2O . getConnection ( ) . close ( ) ; statement . close ( ) ; } catch ( SQLException ex ) { throw new RuntimeException ( ex ) ; } } } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } return this . sql2O ; }
public Connection getConnection ( ) { return connection ; }
public Query createQuery ( String query ) { try { if ( this . getConnection ( ) . isClosed ( ) ) { this . createConnection ( ) ; } } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } Query q = new Query ( this , query ) ; return q ; }
private void createConnection ( ) { Properties conProps = new Properties ( ) ; conProps . put ( " user " , this . getUser ( ) ) ; conProps . put ( " password " , this . getPass ( ) ) ; try { if ( ! this . getUrl ( ) . startsWith ( " jdbc " ) ) {
public Sql2o beginTransaction ( int isolationLevel ) { try { if ( this . connection . isClosed ( ) ) { this . createConnection ( ) ; } this . getConnection ( ) . setAutoCommit ( false ) ; this . getConnection ( ) . setTransactionIsolation ( isolationLevel ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } return this ; }
public Sql2o beginTransaction ( ) { return this . beginTransaction ( Connection . TRANSACTION_READ_COMMITTED ) ; }
public Sql2o commit ( ) { try { this . getConnection ( ) . commit ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } finally { try { this . getConnection ( ) . close ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } return this ; }
public Sql2o rollback ( ) { try { this . getConnection ( ) . rollback ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } finally { try { this . getConnection ( ) . close ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } return this ; }
public void setUp ( ) throws Exception { this . sql2o = new Sql2o ( this . url , this . user , this . pass ) ; HashMap < String , String > defaultColumnMap = new HashMap < String , String > ( ) ; defaultColumnMap . put ( " ID " , " id " ) ; defaultColumnMap . put ( " NAME " , " name " ) ; defaultColumnMap . put ( " EMAIL " , " email " ) ; defaultColumnMap . put ( " TEXT " , " text " ) ; sql2o . setDefaultColumnMappings ( defaultColumnMap ) ; }
public void tearDown ( ) throws Exception { } public void testExecuteUpdate ( ) { } public void testExecuteAndFetch ( ) { createAndFillUserTable ( ) ; Date before = new Date ( ) ; List < User > allUsers = sql2o . createQuery ( " select * from User " ) . executeAndFetch ( User . class ) ; Date after = new Date ( ) ; long span = after . getTime ( ) - before . getTime ( ) ; System . out . println ( String . format ( " Fetched %s user: %s ms " , insertIntoUsers , span ) ) ; assertTrue ( allUsers . size ( ) = = insertIntoUsers ) ; } /************** Helper stuff ******************/ private void createAndFillUserTable ( ) { sql2o . createQuery ( " create table User( \ n " + " id int identity primary key, \ n " + " name varchar(20), \ n " + " email varchar(255), \ n " + " text varchar(100)) " ) . executeUpdate ( ) ; Query insQuery = sql2o . beginTransaction ( ) . createQuery ( " insert into User(name, email, text) values (:name, :email, :text) " ) ; Date before = new Date ( ) ; for ( int idx = 0 ; idx < 10000 ; idx + + ) { insQuery . addParameter ( " name " , " a name " + idx ) . addParameter ( " email " , String . format ( " test%s@email.com " , idx ) ) . addParameter ( " text " , " some text " ) . executeUpdate ( ) ; } sql2o . commit ( ) ; Date after = new Date ( ) ; Long span = after . getTime ( ) - before . getTime ( ) ; System . out . println ( String . format ( " inserted 10000 rows into User table. Time used: %s ms " , span ) ) ; insertIntoUsers + = 10000 ; } private void createTestEntityTable ( String tableName ) { } }
public void testExecuteUpdate ( ) { } public void testExecuteAndFetch ( ) { createAndFillUserTable ( ) ; Date before = new Date ( ) ; List < User > allUsers = sql2o . createQuery ( " select * from User " ) . executeAndFetch ( User . class ) ; Date after = new Date ( ) ; long span = after . getTime ( ) - before . getTime ( ) ; System . out . println ( String . format ( " Fetched %s user: %s ms " , insertIntoUsers , span ) ) ; assertTrue ( allUsers . size ( ) = = insertIntoUsers ) ; } /************** Helper stuff ******************/ private void createAndFillUserTable ( ) { sql2o . createQuery ( " create table User( \ n " + " id int identity primary key, \ n " + " name varchar(20), \ n " + " email varchar(255), \ n " + " text varchar(100)) " ) . executeUpdate ( ) ; Query insQuery = sql2o . beginTransaction ( ) . createQuery ( " insert into User(name, email, text) values (:name, :email, :text) " ) ; Date before = new Date ( ) ; for ( int idx = 0 ; idx < 10000 ; idx + + ) { insQuery . addParameter ( " name " , " a name " + idx ) . addParameter ( " email " , String . format ( " test%s@email.com " , idx ) ) . addParameter ( " text " , " some text " ) . executeUpdate ( ) ; } sql2o . commit ( ) ; Date after = new Date ( ) ; Long span = after . getTime ( ) - before . getTime ( ) ; System . out . println ( String . format ( " inserted 10000 rows into User table. Time used: %s ms " , span ) ) ; insertIntoUsers + = 10000 ; } private void createTestEntityTable ( String tableName ) { } }
public void testExecuteAndFetch ( ) { createAndFillUserTable ( ) ; Date before = new Date ( ) ; List < User > allUsers = sql2o . createQuery ( " select * from User " ) . executeAndFetch ( User . class ) ; Date after = new Date ( ) ; long span = after . getTime ( ) - before . getTime ( ) ; System . out . println ( String . format ( " Fetched %s user: %s ms " , insertIntoUsers , span ) ) ; assertTrue ( allUsers . size ( ) = = insertIntoUsers ) ; }
private void createAndFillUserTable ( ) { sql2o . createQuery ( " create table User( \ n " + " id int identity primary key, \ n " + " name varchar(20), \ n " + " email varchar(255), \ n " + " text varchar(100)) " ) . executeUpdate ( ) ; Query insQuery = sql2o . beginTransaction ( ) . createQuery ( " insert into User(name, email, text) values (:name, :email, :text) " ) ; Date before = new Date ( ) ; for ( int idx = 0 ; idx < 10000 ; idx + + ) { insQuery . addParameter ( " name " , " a name " + idx ) . addParameter ( " email " , String . format ( " test%s@email.com " , idx ) ) . addParameter ( " text " , " some text " ) . executeUpdate ( ) ; } sql2o . commit ( ) ; Date after = new Date ( ) ; Long span = after . getTime ( ) - before . getTime ( ) ; System . out . println ( String . format ( " inserted 10000 rows into User table. Time used: %s ms " , span ) ) ; insertIntoUsers + = 10000 ; }
private void createTestEntityTable ( String tableName ) { } }
public void setTime ( Date time ) { this . time = time ; }
public void setTs ( Timestamp ts ) { this . ts = ts ; }
public Integer getaNumber ( ) { return aNumber ; }
public void setaNumber ( Integer aNumber ) { this . aNumber = aNumber ; }
public Query addParameter ( String name , java . util . Date value ) { Date sqlDate = new Date ( value . getTime ( ) ) ; return addParameter ( name , sqlDate ) ; }
public Sql2o executeUpdate ( ) { int result ; try { result = statement . executeUpdate ( ) ; if ( this . sql2O . getConnection ( ) . getAutoCommit ( ) ) { this . sql2O . getConnection ( ) . close ( ) ; statement . close ( ) ; } } catch ( Exception ex ) { this . sql2O . rollback ( ) ; throw new RuntimeException ( ex ) ; } return this . sql2O ; }
public void setUp ( ) throws Exception { this . sql2o = new Sql2o ( this . url , this . user , this . pass ) ; HashMap < String , String > defaultColumnMap = new HashMap < String , String > ( ) ; defaultColumnMap . put ( " ID " , " id " ) ; defaultColumnMap . put ( " NAME " , " name " ) ; defaultColumnMap . put ( " EMAIL " , " email " ) ; defaultColumnMap . put ( " TEXT " , " text " ) ; defaultColumnMap . put ( " ANUMBER " , " aNumber " ) ; defaultColumnMap . put ( " ALONGNUMBER " , " aLongNumber " ) ; sql2o . setDefaultColumnMappings ( defaultColumnMap ) ; }
public void testExecuteAndFetchWithNulls ( ) { String sql = " create table testExecWithNullsTbl ( " + " id int identity primary key, " + " text varchar(255), " + " aNumber int, " + " aLongNumber bigint) " ; sql2o . createQuery ( sql ) . executeUpdate ( ) ; Query insQuery = sql2o . beginTransaction ( ) . createQuery ( " insert into testExecWithNullsTbl (text, aNumber, aLongNumber) values(:text, :number, :lnum) " ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , 2 ) . addParameter ( " lnum " , 10L ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , ( Integer ) null ) . addParameter ( " lnum " , 10L ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , ( String ) null ) . addParameter ( " number " , 21 ) . addParameter ( " lnum " , ( Long ) null ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , 1221 ) . addParameter ( " lnum " , 10 ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , 2311 ) . addParameter ( " lnum " , 12 ) . executeUpdate ( ) ; sql2o . commit ( ) ; List < TestEntity > fetched = sql2o . createQuery ( " select * from testExecWithNullsTbl " ) . executeAndFetch ( TestEntity . class ) ; assertTrue ( fetched . size ( ) = = 5 ) ; assertNull ( fetched . get ( 2 ) . text ) ; assertNotNull ( fetched . get ( 3 ) . text ) ; assertNull ( fetched . get ( 1 ) . aNumber ) ; assertNotNull ( fetched . get ( 2 ) . aNumber ) ; assertNull ( fetched . get ( 2 ) . aLongNumber ) ; assertNotNull ( fetched . get ( 3 ) . aLongNumber ) ; }
public Query addParameter ( String name , Time value ) { try { statement . setTime ( name , value ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } return this ; }
public void setTime ( String name , Time value ) throws SQLException { int [ ] indexes = getIndexes ( name ) ; for ( int index : indexes ) { statement . setTime ( index , value ) ;
public Query addToBatch ( ) { try { statement . addBatch ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; //To change body of catch statement use File | Settings | File Templates. } return this; }
public Sql2o executeBatch ( ) { try { statement . executeBatch ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } return this . sql2O ; }
public void testBatch ( ) { sql2o . createQuery ( " create table User( \ n " + " id int identity primary key, \ n " + " name varchar(20), \ n " + " email varchar(255), \ n " + " text varchar(100)) " ) . executeUpdate ( ) ; String insQuery = " insert into User(name, email, text) values (:name, :email, :text) " ; sql2o . beginTransaction ( ) . createQuery ( insQuery ) . addParameter ( " name " , " test " ) . addParameter ( " email " , " test@test.com " ) . addParameter ( " text " , " something exciting " ) . addToBatch ( ) . addParameter ( " name " , " test2 " ) . addParameter ( " email " , " test2@test.com " ) . addParameter ( " text " , " something exciting too " ) . addToBatch ( )
public void testBatchNoTransaction ( ) { sql2o . createQuery ( " create table User( \ n " + " id int identity primary key, \ n " + " name varchar(20), \ n " + " email varchar(255), \ n " + " text varchar(100)) " ) . executeUpdate ( ) ; String insQuery = " insert into User(name, email, text) values (:name, :email, :text) " ; sql2o . createQuery ( insQuery ) . addParameter ( " name " , " test " ) . addParameter ( " email " , " test@test.com " ) . addParameter ( " text " , " something exciting " ) . addToBatch ( ) . addParameter ( " name " , " test2 " ) . addParameter ( " email " , " test2@test.com " ) . addParameter ( " text " , " something exciting too " ) . addToBatch ( )
public Object executeScalar ( ) { try { ResultSet rs = this . statement . executeQuery ( ) ;
public Query addToBatch ( ) { try { statement . addBatch ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } return this ; }
public void testExecuteAndFetch ( ) { createAndFillUserTable ( ) ; Date before = new Date ( ) ; List < User > allUsers = sql2o . createQuery ( " select * from User " ) . executeAndFetch ( User . class ) ; Date after = new Date ( ) ; long span = after . getTime ( ) - before . getTime ( ) ; System . out . println ( String . format ( " Fetched %s user: %s ms " , insertIntoUsers , span ) ) ; assertTrue ( allUsers . size ( ) = = insertIntoUsers ) ; deleteUserTable ( ) ; }
public void testBatch ( ) { sql2o . createQuery ( " create table User( \ n " + " id int identity primary key, \ n " + " name varchar(20), \ n " + " email varchar(255), \ n " + " text varchar(100)) " ) . executeUpdate ( ) ; String insQuery = " insert into User(name, email, text) values (:name, :email, :text) " ; sql2o . beginTransaction ( ) . createQuery ( insQuery ) . addParameter ( " name " , " test " ) . addParameter ( " email " , " test@test.com " ) . addParameter ( " text " , " something exciting " ) . addToBatch ( ) . addParameter ( " name " , " test2 " ) . addParameter ( " email " , " test2@test.com " ) . addParameter ( " text " , " something exciting too " ) . addToBatch ( ) . addParameter ( " name " , " test3 " ) . addParameter ( " email " , " test3@test.com " ) . addParameter ( " text " , " blablabla " ) . addToBatch ( ) . executeBatch ( ) . commit ( ) ; deleteUserTable ( ) ; }
public void testExecuteScalar ( ) { createAndFillUserTable ( ) ; Object o = sql2o . createQuery ( " select text from User where id = 2 " ) . executeScalar ( ) ; assertTrue ( o . getClass ( ) . equals ( String . class ) ) ; Object o2 = sql2o . createQuery ( " select 10 " ) . executeScalar ( ) ; assertEquals ( o2 , 10 ) ; deleteUserTable ( ) ; }
public void testBatchNoTransaction ( ) { sql2o . createQuery ( " create table User( \ n " + " id int identity primary key, \ n " + " name varchar(20), \ n " + " email varchar(255), \ n " + " text varchar(100)) " ) . executeUpdate ( ) ; String insQuery = " insert into User(name, email, text) values (:name, :email, :text) " ; sql2o . createQuery ( insQuery ) . addParameter ( " name " , " test " ) . addParameter ( " email " , " test@test.com " ) . addParameter ( " text " , " something exciting " ) . addToBatch ( ) . addParameter ( " name " , " test2 " ) . addParameter ( " email " , " test2@test.com " ) . addParameter ( " text " , " something exciting too " ) . addToBatch ( ) . addParameter ( " name " , " test3 " ) . addParameter ( " email " , " test3@test.com " ) . addParameter ( " text " , " blablabla " ) . addToBatch ( ) . executeBatch ( ) ; deleteUserTable ( ) ; }
private void createAndFillUserTable ( ) { int rowCount = 10000 ; sql2o . createQuery ( " create table User( \ n " + " id int identity primary key, \ n " + " name varchar(20), \ n " + " email varchar(255), \ n " + " text varchar(100)) " ) . executeUpdate ( ) ; Query insQuery = sql2o . createQuery ( " insert into User(name, email, text) values (:name, :email, :text) " ) ; Date before = new Date ( ) ; for ( int idx = 0 ; idx < rowCount ; idx + + ) { insQuery . addParameter ( " name " , " a name " + idx ) . addParameter ( " email " , String . format ( " test%s@email.com " , idx ) ) . addParameter ( " text " , " some text " ) . addToBatch ( ) ; } insQuery . executeBatch ( ) . commit ( ) ; Date after = new Date ( ) ; Long span = after . getTime ( ) - before . getTime ( ) ; System . out . println ( String . format ( " inserted %d rows into User table. Time used: %s ms " , rowCount , span ) ) ; insertIntoUsers + = rowCount ; }
private void deleteUserTable ( ) { sql2o . createQuery ( " drop table User " ) . executeUpdate ( ) ; }
public boolean isCaseSensitive ( ) { return caseSensitive ; }
public Query setCaseSensitive ( boolean caseSensitive ) { this . caseSensitive = caseSensitive ; return this ; }
private void prepareColumnMappings ( Class objClass ) { if ( ! this . isCaseSensitive ( ) ) {
private void setField ( Object obj , String fieldName , Object value ) throws IllegalAccessException , NoSuchMethodException , InvocationTargetException { Class objClass = obj . getClass ( ) ; if ( ! this . isCaseSensitive ( ) ) { fieldName = fieldName . toLowerCase ( ) ; } fieldName = columnMappings . containsKey ( fieldName ) ? columnMappings . get ( fieldName ) : fieldName ; try { Field field = objClass . getField ( fieldName ) ;
public < T > List < T > executeAndFetch ( Class returnType ) { List list = new ArrayList ( ) ; try { prepareColumnMappings ( returnType ) ; java . util . Date st = new java . util . Date ( ) ; ResultSet rs = statement . executeQuery ( ) ; System . out . println ( String . format ( " execute query time: %s " , new java . util . Date ( ) . getTime ( ) - st . getTime ( ) ) ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; while ( rs . next ( ) ) { Object obj = returnType . newInstance ( ) ; for ( int colIdx = 1 ; colIdx < = meta . getColumnCount ( ) ; colIdx + + ) { String colName = meta . getColumnName ( colIdx ) ; //int colType = meta.getColumnType(colIdx); String[] fieldPath = colName.split("\\."); if (fieldPath.length == 0){ fieldPath = new String[]{colName}; } Object value = rs.getObject(colName); Object pathObject = obj; for (int pathIdx = 0; pathIdx < fieldPath.length; pathIdx++){ if (pathIdx == fieldPath.length - 1){ setField(pathObject, fieldPath[pathIdx], value); break; } pathObject = instantiateIfNecessary(pathObject, fieldPath[pathIdx]); } } list.add(obj); } rs.close(); } catch(Exception ex){ throw new RuntimeException(ex); } finally { try{ if (this.sql2O.getConnection().getAutoCommit() && statement != null){ sql2O.getConnection().close(); statement.close(); } } catch (Exception ex){ throw new RuntimeException(ex); } } return list; }
public boolean isDefaultCaseSensitive ( ) { return defaultCaseSensitive ; }
public void setDefaultCaseSensitive ( boolean defaultCaseSensitive ) { this . defaultCaseSensitive = defaultCaseSensitive ; }
public void testCaseInsensitive ( ) { sql2o . createQuery ( " create table testCI(id2 int primary key, value2 varchar(20), sometext varchar(20)) " ) . executeUpdate ( ) ; Query query = sql2o . createQuery ( " insert into testCI(id2, value2, sometext) values(:id, :value, :someText) " ) ; for ( int i = 0 ; i < 20 ; i + + ) { query . addParameter ( " id " , i ) . addParameter ( " value " , " some text " + i ) . addParameter ( " someText " , " whatever " + i ) . addToBatch ( ) ; } query . executeBatch ( ) ; List < TestCIEntity > ciEntities = sql2o . createQuery ( " select * from testCI " ) . setCaseSensitive ( false ) . executeAndFetch ( TestCIEntity . class ) ; assertTrue ( ciEntities . size ( ) = = 20 ) ; // test defaultCaseSensitive; sql2o.setDefaultCaseSensitive(false); List<TestCIEntity> ciEntities2 = sql2o.createQuery("select * from testCI").executeAndFetch(TestCIEntity.class); assertTrue(ciEntities2.size() == 20); }
private void deleteUserTable ( ) { sql2o . createQuery ( " drop table User " ) . executeUpdate ( ) ; insertIntoUsers = 0 ; }
private String getSetterName ( String fieldName ) { String setterName = " set " + fieldName . substring ( 0 , 1 ) . toUpperCase ( ) + fieldName . substring ( 1 ) ; if ( ! this . isCaseSensitive ( ) & & this . csMethods . containsKey ( setterName . toLowerCase ( ) ) ) { setterName = csMethods . get ( setterName . toLowerCase ( ) ) ; } return setterName ; }
private String getGetterName ( String fieldName ) { String getterName = " get " + fieldName . substring ( 0 , 1 ) . toUpperCase ( ) + fieldName . substring ( 1 ) ; if ( ! this . isCaseSensitive ( ) & & this . csMethods . containsKey ( getterName . toLowerCase ( ) ) ) { getterName = this . csMethods . get ( getterName . toLowerCase ( ) ) ; } return getterName ; }
public < T > List < T > executeAndFetch ( Class returnType ) { List list = new ArrayList ( ) ; try { prepareColumnMappings ( returnType ) ; java . util . Date st = new java . util . Date ( ) ; ResultSet rs = statement . executeQuery ( ) ; System . out . println ( String . format ( " execute query time: %s " , new java . util . Date ( ) . getTime ( ) - st . getTime ( ) ) ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; while ( rs . next ( ) ) { Object obj = returnType . newInstance ( ) ; for ( int colIdx = 1 ; colIdx < = meta . getColumnCount ( ) ; colIdx + + ) { String colName = meta . getColumnName ( colIdx ) ; //int colType = meta.getColumnType(colIdx); String[] fieldPath = colName.split("\\."); if (fieldPath.length == 0){ fieldPath = new String[]{colName}; } Object value = rs.getObject(colName); Object pathObject = obj; for (int pathIdx = 0; pathIdx < fieldPath.length; pathIdx++){ if (pathIdx == fieldPath.length - 1){ setField(pathObject, fieldPath[pathIdx], value); break; } pathObject = instantiateIfNecessary(pathObject, fieldPath[pathIdx]); } } list.add(obj); } rs.close(); } catch(Exception ex){ throw new RuntimeException(ex); } finally { closeConnectionIfNecessary(); } return list; }
public Sql2o executeUpdate ( ) { int result ; try { result = statement . executeUpdate ( ) ; } catch ( Exception ex ) { this . sql2O . rollback ( ) ; throw new RuntimeException ( ex ) ; } finally { closeConnectionIfNecessary ( ) ; } return this . sql2O ; }
public < T > List < T > executeScalarList ( ) { List < T > list = new ArrayList < T > ( ) ; try { ResultSet rs = this . statement . executeQuery ( ) ;
public Sql2o executeBatch ( ) { try { statement . executeBatch ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } finally { closeConnectionIfNecessary ( ) ; } return this . sql2O ; }
private void closeConnectionIfNecessary ( ) { try { if ( this . sql2O . getConnection ( ) . getAutoCommit ( ) & & statement ! = null ) {
public void testCaseInsensitive ( ) { sql2o . createQuery ( " create table testCI(id2 int primary key, value2 varchar(20), sometext varchar(20), valwithgetter varchar(20)) " ) . executeUpdate ( ) ; Query query = sql2o . createQuery ( " insert into testCI(id2, value2, sometext, valwithgetter) values(:id, :value, :someText, :valwithgetter) " ) ; for ( int i = 0 ; i < 20 ; i + + ) { query . addParameter ( " id " , i ) . addParameter ( " value " , " some text " + i ) . addParameter ( " someText " , " whatever " + i ) . addParameter ( " valwithgetter " , " spaz " + i ) . addToBatch ( ) ; } query . executeBatch ( ) ; List < TestCIEntity > ciEntities = sql2o . createQuery ( " select * from testCI " ) . setCaseSensitive ( false ) . executeAndFetch ( TestCIEntity . class ) ; assertTrue ( ciEntities . size ( ) = = 20 ) ; // test defaultCaseSensitive; sql2o.setDefaultCaseSensitive(false); List<TestCIEntity> ciEntities2 = sql2o.createQuery("select * from testCI").executeAndFetch(TestCIEntity.class); assertTrue(ciEntities2.size() == 20); }
public void testExecuteAndFetchResultSet ( ) throws SQLException { List < Integer > list = sql2o . createQuery ( " select 1 val union select 2 union select 3 " ) . executeScalarList ( ) ; assertEquals ( ( int ) list . get ( 0 ) , 1 ) ; assertEquals ( ( int ) list . get ( 1 ) , 2 ) ; assertEquals ( ( int ) list . get ( 2 ) , 3 ) ;
private void createAndFillUserTable ( ) { int rowCount = 10000 ; sql2o . createQuery ( " create table User( \ n " + " id int identity primary key, \ n " + " name varchar(20), \ n " + " email varchar(255), \ n " + " text varchar(100)) " ) . executeUpdate ( ) ; Query insQuery = sql2o . createQuery ( " insert into User(name, email, text) values (:name, :email, :text) " ) ; Date before = new Date ( ) ; for ( int idx = 0 ; idx < rowCount ; idx + + ) { insQuery . addParameter ( " name " , " a name " + idx ) . addParameter ( " email " , String . format ( " test%s@email.com " , idx ) ) . addParameter ( " text " , " some text " ) . addToBatch ( ) ; } insQuery . executeBatch ( ) ; Date after = new Date ( ) ; Long span = after . getTime ( ) - before . getTime ( ) ; System . out . println ( String . format ( " inserted %d rows into User table. Time used: %s ms " , rowCount , span ) ) ; insertIntoUsers + = rowCount ; }
public String getValWithGetter ( ) { return valWithGetter ; }
public void setValWithGetter ( String valWithGetter ) { this . valWithGetter = valWithGetter ; }
public Query addParameter ( String name , DateTime value ) { return addParameter ( name , value . toDate ( ) ) ; }
private void setField ( Object obj , String fieldName , Object value ) throws IllegalAccessException , InvocationTargetException , NoSuchMethodException { Class objClass = obj . getClass ( ) ; if ( ! this . isCaseSensitive ( ) ) { fieldName = fieldName . toLowerCase ( ) ; } fieldName = columnMappings . containsKey ( fieldName ) ? columnMappings . get ( fieldName ) : fieldName ; try { Field field = objClass . getField ( fieldName ) ;
private Object setterConverter ( Class type , Object value ) { Object returnVal = value ; // handle jodatime if (type.equals(DateTime.class)){ returnVal = new DateTime(value); } return returnVal; }
public DateTime getJoda2 ( ) { return joda2 ; }
public void setJoda2 ( DateTime joda2 ) { this . joda2 = joda2 ; }
public void testJodaTime ( ) { sql2o . createQuery ( " create table testjoda(id int primary key, joda1 datetime, joda2 datetime) " ) . executeUpdate ( ) ; sql2o . createQuery ( " insert into testjoda(id, joda1, joda2) values(:id, :joda1, :joda2) " ) . addParameter ( " id " , 1 ) . addParameter ( " joda1 " , new DateTime ( ) ) . addParameter ( " joda2 " , new DateTime ( ) . plusDays ( - 1 ) ) . addToBatch ( ) . addParameter ( " id " , 2 ) . addParameter ( " joda1 " , new DateTime ( ) . plusYears ( 1 ) ) . addParameter ( " joda2 " , new DateTime ( ) . plusDays ( - 2 ) ) . addToBatch ( ) . addParameter ( " id " , 3 ) . addParameter ( " joda1 " , new DateTime ( ) . plusYears ( 2 ) ) . addParameter ( " joda2 " , new DateTime ( ) . plusDays ( - 3 ) ) . addToBatch ( ) . executeBatch ( ) ; List < JodaEntity > list = sql2o . createQuery ( " select * from testjoda " ) . executeAndFetch ( JodaEntity . class ) ; assertTrue ( list . size ( ) = = 3 ) ; assertTrue ( list . get ( 0 ) . getJoda2 ( ) . isBeforeNow ( ) ) ;
private Class getValueClass ( Object value ) { Class valClass = value . getClass ( ) ; if ( java . util . Date . class . isAssignableFrom ( valClass ) ) { return java . util . Date . class ;
public void testUtilDate ( ) { sql2o . createQuery ( " create table testutildate(id int primary key, d1 datetime, d2 timestamp) " ) . executeUpdate ( ) ; sql2o . createQuery ( " insert into testutildate(id, d1, d2) values(:id, :d1, :d2) " ) . addParameter ( " id " , 1 ) . addParameter ( " d1 " , new Date ( ) ) . addParameter ( " d2 " , new Date ( ) ) . addToBatch ( ) . addParameter ( " id " , 2 ) . addParameter ( " d1 " , new Date ( ) ) . addParameter ( " d2 " , new Date ( ) ) . addToBatch ( ) . addParameter ( " id " , 3 ) . addParameter ( " d1 " , new Date ( ) ) . addParameter ( " d2 " , new Date ( ) ) . addToBatch ( ) . executeBatch ( ) ; List < UtilDateEntity > list = sql2o . createQuery ( " select * from testutildate " ) . executeAndFetch ( UtilDateEntity . class ) ; assertTrue ( list . size ( ) = = 3 ) ;
public void setD2 ( Date d2 ) { this . d2 = d2 ; }
private void prepareColumnMappingsIfNecessary ( Class objClass ) { if ( this . isCaseSensitive ( ) ) { return ; } if ( mappedTypes = = null ) { mappedTypes = new HashMap < String , Class > ( ) ; } if ( ! mappedTypes . containsKey ( objClass . getName ( ) ) ) { mappedTypes . put ( objClass . getName ( ) , objClass ) ;
public < T > List < T > executeAndFetch ( Class returnType ) { List list = new ArrayList ( ) ; try { prepareColumnMappings ( returnType ) ; java . util . Date st = new java . util . Date ( ) ; ResultSet rs = statement . executeQuery ( ) ; System . out . println ( String . format ( " execute query time: %s " , new java . util . Date ( ) . getTime ( ) - st . getTime ( ) ) ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; while ( rs . next ( ) ) { Object obj = returnType . newInstance ( ) ; for ( int colIdx = 1 ; colIdx < = meta . getColumnCount ( ) ; colIdx + + ) { String colName = meta . getColumnName ( colIdx ) ; //int colType = meta.getColumnType(colIdx); String[] fieldPath = colName.split("\\."); if (fieldPath.length == 0){ fieldPath = new String[]{colName}; } Object value = rs.getObject(colName); Object pathObject = obj; for (int pathIdx = 0; pathIdx < fieldPath.length; pathIdx++){ if (pathIdx == fieldPath.length - 1){ setField(pathObject, fieldPath[pathIdx], value); break; } pathObject = instantiateIfNecessary(pathObject, fieldPath[pathIdx]); prepareColumnMappingsIfNecessary(pathObject.getClass()); } } list.add(obj); } rs.close(); } catch(Exception ex){ throw new RuntimeException(ex); } finally { closeConnectionIfNecessary(); } return list; }
public void testComplexTypes ( ) { List < ComplexEntity > list = sql2o . createQuery ( " select 1 id, 'test' val, 'test2' \" obj.val1 \" , 2 \" obj.valint \" union select 2 id, 'test2' val, 'tessdf' \" obj.val1 \" , 100 \" obj.valint \" " ) . executeAndFetch ( ComplexEntity . class ) ; assertTrue ( list . size ( ) = = 2 ) ; //assertEquals(2, list.get(0).obj.valInt);
private String getSetterName ( String fieldName ) { String setterName = " set " + fieldName . substring ( 0 , 1 ) . toUpperCase ( ) + fieldName . substring ( 1 ) ; return this . isCaseSensitive ( ) ? setterName : setterName . toLowerCase ( ) ; }
private String getGetterName ( String fieldName ) { String getterName = " get " + fieldName . substring ( 0 , 1 ) . toUpperCase ( ) + fieldName . substring ( 1 ) ; return this . isCaseSensitive ( ) ? getterName : getterName . toLowerCase ( ) ; }
private void prepareColumnMappings ( Class objClass ) { if ( ! this . isCaseSensitive ( ) ) { for ( Field f : objClass . getFields ( ) ) { this . columnMappings . put ( f . getName ( ) . toLowerCase ( ) , f . getName ( ) ) ; } } for ( Method m : objClass . getMethods ( ) ) { String methodName = this . isCaseSensitive ( ) ? m . getName ( ) : m . getName ( ) . toLowerCase ( ) ;
public static Object convert ( Class type , Object value ) { if ( value = = null ) { return null ; } // handle jodatime if (type.equals(DateTime.class)){ return new DateTime(value); } if (type.equals(value.getClass())) { return value; } if (Number.class.isAssignableFrom(type)){ Number numberVal = (Number)value; if (type.equals(Integer.class)){ return numberVal.intValue(); } else if(type.equals(Long.class)){ return numberVal.longValue(); } else if(type.equals(Short.class)){ return numberVal.shortValue(); } else if(type.equals(Double.class)){ return numberVal.doubleValue(); } else if(type.equals(Float.class)){ return numberVal.floatValue(); } else if(type.equals(Byte.class)){ return numberVal.byteValue(); } else{ throw new RuntimeException("Cannot convert from type " + value.getClass().getName() + " to " + type.getName()); } } return value; }
public void testConversion ( ) { String sql = " select cast(1 as smallint) as val1, 2 as val2 union select cast(3 as smallint) as val1, 4 as val2 " ; List < TypeConvertEntity > entities = sql2o . createQuery ( sql ) . executeAndFetch ( TypeConvertEntity . class ) ; assertTrue ( entities . size ( ) = = 2 ) ; }
public void setVal2 ( long val2 ) { this . val2 = val2 ; }
public java . sql . Connection getJdbcConnection ( ) { return jdbcConnection ; }
public Query createQuery ( String queryText ) { try { if ( this . getJdbcConnection ( ) . isClosed ( ) ) { createConnection ( ) ; } } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } Query q = new Query ( this , queryText ) ; return q ; }
public Sql2o rollback ( ) { try { this . getJdbcConnection ( ) . rollback ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } finally { try { this . getJdbcConnection ( ) . close ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } return this . getSql2o ( ) ; }
public Sql2o commit ( ) { try { this . getJdbcConnection ( ) . commit ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } finally { try { this . getJdbcConnection ( ) . close ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } return this . getSql2o ( ) ; }
private void createConnection ( ) { Properties conProps = new Properties ( ) ; conProps . put ( " user " , sql2o . getUser ( ) ) ; conProps . put ( " password " , sql2o . getPass ( ) ) ; String url = this . sql2o . getUrl ( ) ; try {
public Connection executeUpdate ( ) { int result ; try { result = statement . executeUpdate ( ) ; } catch ( Exception ex ) { this . connection . rollback ( ) ; throw new RuntimeException ( ex ) ; } finally { closeConnectionIfNecessary ( ) ; } return this . connection ; }
public Connection executeBatch ( ) { try { statement . executeBatch ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } finally { closeConnectionIfNecessary ( ) ; } return this . connection ; }
private void closeConnectionIfNecessary ( ) { try { if ( this . connection . getJdbcConnection ( ) . getAutoCommit ( ) & & statement ! = null ) {
public Query createQuery ( String query ) { Connection connection = new Connection ( this ) ; return connection . createQuery ( query ) ; }
public Connection beginTransaction ( int isolationLevel ) { Connection connection = new Connection ( this ) ; try { connection . getJdbcConnection ( ) . setAutoCommit ( false ) ; connection . getJdbcConnection ( ) . setTransactionIsolation ( isolationLevel ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } return connection ; }
public Connection beginTransaction ( ) { return this . beginTransaction ( java . sql . Connection . TRANSACTION_READ_COMMITTED ) ; }
public void testExecuteAndFetchWithNulls ( ) { String sql = " create table testExecWithNullsTbl ( " + " id int identity primary key, " + " text varchar(255), " + " aNumber int, " + " aLongNumber bigint) " ; sql2o . createQuery ( sql ) . executeUpdate ( ) ; Connection connection = sql2o . beginTransaction ( ) ; Query insQuery = connection . createQuery ( " insert into testExecWithNullsTbl (text, aNumber, aLongNumber) values(:text, :number, :lnum) " ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , 2 ) . addParameter ( " lnum " , 10L ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , ( Integer ) null ) . addParameter ( " lnum " , 10L ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , ( String ) null ) . addParameter ( " number " , 21 ) . addParameter ( " lnum " , ( Long ) null ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , 1221 ) . addParameter ( " lnum " , 10 ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , 2311 ) . addParameter ( " lnum " , 12 ) . executeUpdate ( ) ; connection . commit ( ) ; List < TestEntity > fetched = sql2o . createQuery ( " select * from testExecWithNullsTbl " ) . executeAndFetch ( TestEntity . class ) ; assertTrue ( fetched . size ( ) = = 5 ) ; assertNull ( fetched . get ( 2 ) . text ) ; assertNotNull ( fetched . get ( 3 ) . text ) ; assertNull ( fetched . get ( 1 ) . aNumber ) ; assertNotNull ( fetched . get ( 2 ) . aNumber ) ; assertNull ( fetched . get ( 2 ) . aLongNumber ) ; assertNotNull ( fetched . get ( 3 ) . aLongNumber ) ; }
public void testUpdateNoTransaction ( ) throws SQLException { String ddlQuery = " create table testUpdateNoTransaction(id int primary key, value varchar(50)) " ; Connection connection = sql2o . createQuery ( ddlQuery ) . executeUpdate ( ) ; assertTrue ( connection . getJdbcConnection ( ) . isClosed ( ) ) ; String insQuery = " insert into testUpdateNoTransaction(id, value) values (:id, :value) " ; sql2o . createQuery ( insQuery ) . addParameter ( " id " , 1 ) . addParameter ( " value " , " test1 " ) . executeUpdate ( ) . createQuery ( insQuery ) . addParameter ( " id " , 2 ) . addParameter ( " value " , " val2 " ) . executeUpdate ( ) ; assertTrue ( connection . getJdbcConnection ( ) . isClosed ( ) ) ; }
private void closeConnectionIfNecessary ( ) { try { if ( ! this . connection . getJdbcConnection ( ) . isClosed ( ) & & this . connection . getJdbcConnection ( ) . getAutoCommit ( ) & & statement ! = null ) {
public void testExecuteAndFetchWithNulls ( ) { String sql = " create table testExecWithNullsTbl ( " + " id int identity primary key, " + " text varchar(255), " + " aNumber int, " + " aLongNumber bigint) " ; sql2o . createQuery ( sql ) . executeUpdate ( ) ; Connection connection = sql2o . beginTransaction ( ) ; Query insQuery = connection . createQuery ( " insert into testExecWithNullsTbl (text, aNumber, aLongNumber) values(:text, :number, :lnum) " ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , 2 ) . addParameter ( " lnum " , 10L ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , ( Integer ) null ) . addParameter ( " lnum " , 10L ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , ( String ) null ) . addParameter ( " number " , 21 ) . addParameter ( " lnum " , ( Long ) null ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , 1221 ) . addParameter ( " lnum " , 10 ) . executeUpdate ( ) ; insQuery . addParameter ( " text " , " some text " ) . addParameter ( " number " , 2311 ) . addParameter ( " lnum " , 12 ) . executeUpdate ( ) ; connection . commit ( ) ; List < Entity > fetched = sql2o . createQuery ( " select * from testExecWithNullsTbl " ) . executeAndFetch ( Entity . class ) ; assertTrue ( fetched . size ( ) = = 5 ) ; assertNull ( fetched . get ( 2 ) . text ) ; assertNotNull ( fetched . get ( 3 ) . text ) ; assertNull ( fetched . get ( 1 ) . aNumber ) ; assertNotNull ( fetched . get ( 2 ) . aNumber ) ; assertNull ( fetched . get ( 2 ) . aLongNumber ) ; assertNotNull ( fetched . get ( 3 ) . aLongNumber ) ; }
public void testCaseInsensitive ( ) { sql2o . createQuery ( " create table testCI(id2 int primary key, value2 varchar(20), sometext varchar(20), valwithgetter varchar(20)) " ) . executeUpdate ( ) ; Query query = sql2o . createQuery ( " insert into testCI(id2, value2, sometext, valwithgetter) values(:id, :value, :someText, :valwithgetter) " ) ; for ( int i = 0 ; i < 20 ; i + + ) { query . addParameter ( " id " , i ) . addParameter ( " value " , " some text " + i ) . addParameter ( " someText " , " whatever " + i ) . addParameter ( " valwithgetter " , " spaz " + i ) . addToBatch ( ) ; } query . executeBatch ( ) ; List < CIEntity > ciEntities = sql2o . createQuery ( " select * from testCI " ) . setCaseSensitive ( false ) . executeAndFetch ( CIEntity . class ) ; assertTrue ( ciEntities . size ( ) = = 20 ) ; // test defaultCaseSensitive; sql2o.setDefaultCaseSensitive(false); List<CIEntity> ciEntities2 = sql2o.createQuery("select * from testCI").executeAndFetch(CIEntity.class); assertTrue(ciEntities2.size() == 20); }
private void setField ( Object obj , String fieldName , Object value ) throws IllegalAccessException , InvocationTargetException , NoSuchFieldException { Class objClass = obj . getClass ( ) ; if ( ! this . isCaseSensitive ( ) ) { fieldName = fieldName . toLowerCase ( ) ; } fieldName = columnMappings . containsKey ( fieldName ) ? columnMappings . get ( fieldName ) : fieldName ; Method method = methodsMap . get ( getSetterName ( fieldName ) ) ; if ( method = = null ) { Field field = objClass . getField ( fieldName ) ;
private Object instantiateIfNecessary ( Object obj , String fieldName ) throws IllegalAccessException , InstantiationException , NoSuchFieldException , InvocationTargetException { Object instantiation ; Class objClass = obj . getClass ( ) ; try { Method getter = objClass . getMethod ( getGetterName ( fieldName ) ) ; instantiation = getter . invoke ( obj ) ; if ( instantiation = = null ) { Method setter = objClass . getMethod ( getSetterName ( fieldName ) , getter . getReturnType ( ) ) ; instantiation = getter . getReturnType ( ) . newInstance ( ) ; setter . invoke ( obj , instantiation ) ; } } catch ( NoSuchMethodException nsme ) { Field field = objClass . getField ( fieldName ) ; instantiation = field . get ( obj ) ; if ( instantiation = = null ) { instantiation = field . getType ( ) . newInstance ( ) ; field . set ( obj , instantiation ) ; } } return instantiation ; }
public void testSetterPriority ( ) { Sql2o sql2o = new Sql2o ( url , user , pass ) ; Issue1Pojo pojo = sql2o . createQuery ( " select 1 val " ) . executeAndFetchFirst ( Issue1Pojo . class ) ; assertEquals ( 2 , pojo . val ) ;
public void setVal ( int val ) { this . val = val + 1 ; }
private void setField ( Object obj , String fieldName , Object value ) throws IllegalAccessException , InvocationTargetException { Class objClass = obj . getClass ( ) ; if ( ! this . isCaseSensitive ( ) ) { fieldName = fieldName . toLowerCase ( ) ; } fieldName = columnMappings . containsKey ( fieldName ) ? columnMappings . get ( fieldName ) : fieldName ; Method method = methodsMap . get ( getSetterName ( fieldName ) ) ; if ( method = = null ) { Field field ;
private Object instantiateIfNecessary ( Object obj , String fieldName ) throws IllegalAccessException , InstantiationException , InvocationTargetException { Object instantiation ; Class objClass = obj . getClass ( ) ; try { Method getter = objClass . getMethod ( getGetterName ( fieldName ) ) ; instantiation = getter . invoke ( obj ) ; if ( instantiation = = null ) { Method setter = objClass . getMethod ( getSetterName ( fieldName ) , getter . getReturnType ( ) ) ; instantiation = getter . getReturnType ( ) . newInstance ( ) ; setter . invoke ( obj , instantiation ) ; } } catch ( NoSuchMethodException nsme ) { Field field = null ; try { field = objClass . getField ( fieldName ) ; } catch ( NoSuchFieldException e ) { throw new Sql2oException ( " Cannot find property ' " + fieldName + " ' of " + objClass . toString ( ) ) ; } instantiation = field . get ( obj ) ; if ( instantiation = = null ) { instantiation = field . getType ( ) . newInstance ( ) ; field . set ( obj , instantiation ) ; } } return instantiation ; }
public < T > List < T > executeAndFetch ( Class returnType ) { List list = new ArrayList ( ) ; try { prepareColumnMappings ( returnType ) ; java . util . Date st = new java . util . Date ( ) ; ResultSet rs = statement . executeQuery ( ) ; System . out . println ( String . format ( " execute query time: %s " , new java . util . Date ( ) . getTime ( ) - st . getTime ( ) ) ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; while ( rs . next ( ) ) { Object obj = returnType . newInstance ( ) ; for ( int colIdx = 1 ; colIdx < = meta . getColumnCount ( ) ; colIdx + + ) { String colName = meta . getColumnName ( colIdx ) ; //int colType = meta.getColumnType(colIdx); String[] fieldPath = colName.split("\\."); if (fieldPath.length == 0){ fieldPath = new String[]{colName}; } Object value = rs.getObject(colName); Object pathObject = obj; for (int pathIdx = 0; pathIdx < fieldPath.length; pathIdx++){ if (pathIdx == fieldPath.length - 1){ setField(pathObject, fieldPath[pathIdx], value); break; } pathObject = instantiateIfNecessary(pathObject, fieldPath[pathIdx]); prepareColumnMappingsIfNecessary(pathObject.getClass()); } } list.add(obj); } rs.close(); } catch (InvocationTargetException ex){ throw new RuntimeException(ex); } catch(SQLException ex){ throw new RuntimeException(ex); } catch (IllegalAccessException ex){ throw new RuntimeException(ex); } catch (InstantiationException ex){ throw new RuntimeException(ex); } finally { closeConnectionIfNecessary(); } return list; }
public void testForFieldDoesNotExistException ( ) { Sql2o sql2o = new Sql2o ( url , user , pass ) ; try { KeyValueEntity pojo = sql2o . createQuery ( " select 1 id, 'something' foo " ) . executeAndFetchFirst ( KeyValueEntity . class ) ;
public int getResult ( ) { if ( this . result = = null ) { throw new Sql2oException ( " It is required to call executeUpdate() method before calling getResult(). " ) ; } return this . result ; }
public void setResultInternal ( int result ) { this . result = result ; }
public Connection executeUpdate ( ) { try { this . connection . setResultInternal ( statement . executeUpdate ( ) ) ; } catch ( Exception ex ) { this . connection . rollback ( ) ; throw new RuntimeException ( ex ) ; } finally { closeConnectionIfNecessary ( ) ; } return this . connection ; }
public void testGetResult ( ) { sql2o . createQuery ( " create table get_result_test(id integer primary key, value varchar(20)) " ) . executeUpdate ( ) ; String insertSql = " insert into get_result_test(id, value) " + " select 1, 'hello' union " + " select 2, 'hello2' union " + " select 3, 'hello3' " ; int result = sql2o . createQuery ( insertSql ) . executeUpdate ( ) . getResult ( ) ; assertEquals ( 3 , result ) ; }
public Query addParameter ( String name , java . util . Date value ) { Date sqlDate = value = = null ? null : new Date ( value . getTime ( ) ) ; return addParameter ( name , sqlDate ) ; }
public void testNullDate ( ) { sql2o . createQuery ( " create table nullDateTest(id integer primary key, somedate datetime) " ) . executeUpdate ( ) ; sql2o . createQuery ( " insert into nullDateTest(id, somedate) values(:id, :date) " ) . addParameter ( " id " , 1 ) . addParameter ( " date " , ( Date ) null ) . executeUpdate ( ) ; Date d = ( Date ) sql2o . createQuery ( " select somedate from nullDateTest where id = 1 " ) . executeScalar ( ) ; assertNull ( d ) ; }
void setResult ( int result ) { this . result = result ; }
void setKeys ( ResultSet rs ) throws SQLException { this . keys = new ArrayList < Object > ( ) ; while ( rs . next ( ) ) { this . keys . add ( rs . getObject ( 1 ) ) ;
public Object getKey ( ) { if ( ! isCanGetKeys ( ) ) { throw new Sql2oException ( " Keys where not fetched from database. Please call executeUpdate(true) to fetch keys " ) ; } if ( this . keys ! = null & & this . keys . size ( ) > 0 ) { return keys . get ( 0 ) ; } return null ; }
public Object [ ] getKeys ( ) { if ( ! isCanGetKeys ( ) ) { throw new Sql2oException ( " Keys where not fetched from database. Please call executeUpdate(true) to fetch keys " ) ; } if ( this . keys ! = null ) { return this . keys . toArray ( ) ; } return null ; }
public boolean isCanGetKeys ( ) { return canGetKeys ; }
void setCanGetKeys ( boolean canGetKeys ) { this . canGetKeys = canGetKeys ; }
public Connection executeUpdate ( ) { return executeUpdate ( false ) ; }
public Connection executeUpdate ( boolean getKeys ) { try { this . connection . setResult ( statement . executeUpdate ( ) ) ; if ( getKeys ) { this . connection . setKeys ( statement . getStatement ( ) . getGeneratedKeys ( ) ) ; } connection . setCanGetKeys ( getKeys ) ; } catch ( SQLException ex ) { this . connection . rollback ( ) ; throw new RuntimeException ( ex ) ; } finally { closeConnectionIfNecessary ( ) ; } return this . connection ; }
public void testGetKeys ( ) { sql2o . createQuery ( " create table get_keys_test(id integer identity primary key, value varchar(20)) " ) . executeUpdate ( ) ; String insertSql = " insert into get_keys_test(value) values(:val) " ; try { Integer key = ( Integer ) sql2o . createQuery ( insertSql ) . addParameter ( " val " , " something " ) . executeUpdate ( ) . getKey ( ) ; throw new RuntimeException ( " Sql2oException expected in code line above " ) ; } catch ( Sql2oException ex ) { assertTrue ( ex . getMessage ( ) . contains ( " executeUpdate(true) " ) ) ; } Integer key = ( Integer ) sql2o . createQuery ( insertSql ) . addParameter ( " val " , " something " ) . executeUpdate ( true ) . getKey ( ) ; assertNotNull ( key ) ; assertTrue ( key > 0 ) ; String multiInsertSql = " insert into get_keys_test(value) select 'a val' col1 union select 'another val' col1 " ; Object [ ] keys = sql2o . createQuery ( multiInsertSql ) . executeUpdate ( true ) . getKeys ( ) ; assertNotNull ( keys ) ; assertTrue ( keys . length > 0 ) ;
public void testRollback ( ) { sql2o . createQuery ( " create table test_rollback_table(id integer identity primary key, value varchar(25)) " ) . executeUpdate ( ) ; sql2o //first insert something, and commit it. .beginTransaction() .createQuery("insert into test_rollback_table(value) values (:val)") .addParameter("val", "something") .executeUpdate() .commit() // insert something else, and roll it back. .beginTransaction() .createQuery("insert into test_rollback_table(value) values (:val)") .addParameter("val", "something to rollback") .executeUpdate() .rollback(); long rowCount = (Long)sql2o.createQuery("select count(*) from test_rollback_table").executeScalar(); assertEquals(1, rowCount); }
public static int getUncompressedLength ( byte [ ] compressed , int compressedOffset ) { return SnappyDecompressor . getUncompressedLength ( compressed , compressedOffset ) ; }
public static byte [ ] uncompress ( byte [ ] compressed , int compressedOffset , int compressedSize ) { return SnappyDecompressor . uncompress ( compressed , compressedOffset , compressedSize ) ; }
public static int uncompress ( byte [ ] compressed , int compressedOffset , int compressedSize , byte [ ] uncompressed , int uncompressedOffset ) { return SnappyDecompressor . uncompress ( compressed , compressedOffset , compressedSize , uncompressed , uncompressedOffset ) ; }
public static int maxCompressedLength ( int sourceLength ) { return SnappyCompressor . maxCompressedLength ( sourceLength ) ; }
public static int compress ( byte [ ] uncompressed , int uncompressedOffset , int uncompressedLength , byte [ ] compressed , int compressedOffset ) { return SnappyCompressor . compress ( uncompressed , uncompressedOffset ,
public static int maxCompressedLength ( int sourceLength ) { // Compressed data can be defined as: // compressed := item* literal* // item := literal* copy // // The trailing literal sequence has a space blowup of at most 62/60 // since a literal of length 60 needs one tag byte + one extra byte // for length information. // // Item blowup is trickier to measure. Suppose the "copy" op copies // 4 bytes of data. Because of a special check in the encoding code, // we produce a 4-byte copy only if the offset is < 65536. Therefore // the copy op takes 3 bytes to encode, and this type of item leads // to at most the 62/60 blowup for representing literals. // // Suppose the "copy" op copies 5 bytes of data. If the offset is big // enough, it will take 5 bytes to encode the copy op. Therefore the // worst case here is a one-byte literal followed by a five-byte copy. // I.e., 6 bytes of input turn into 7 bytes of "compressed" data. // // This last factor dominates the blowup, so the final estimate is: return 32 + sourceLength + sourceLength / 6; }
public static int compress ( final byte [ ] uncompressed , final int uncompressedOffset , final int uncompressedLength , final byte [ ] compressed , final int compressedOffset ) { // First write the uncompressed size to the output as a variable length int int compressedIndex = writeUncompressedLength(compressed, compressedOffset, uncompressedLength); int hashTableSize = getHashTableSize(uncompressedLength); short[] table = new short[hashTableSize]; for (int read = 0; read < uncompressedLength; read += kBlockSize) { // Get encoding table for compression Arrays.fill(table, (short) 0); compressedIndex = compressFragment( uncompressed, uncompressedOffset + read, Math.min(uncompressedLength - read, kBlockSize), compressed, compressedIndex, table); } return compressedIndex - compressedOffset; }
private static int [ ] findCandidate ( byte [ ] input , int ipIndex , int ipLimit , int inputOffset , int shift , short [ ] table , int skip ) { int candidateIndex = 0 ; for ( ipIndex + = 1 ; ipIndex + bytesBetweenHashLookups ( skip ) < = ipLimit ; ipIndex + = bytesBetweenHashLookups ( skip + + ) ) { // hash the 4 bytes starting at the input pointer int currentInt = SnappyInternalUtils.loadInt(input, ipIndex); int hash = hashBytes(currentInt, shift); // get the position of a 4 bytes sequence with the same hash candidateIndex = inputOffset + table[hash]; assert candidateIndex >= 0; assert candidateIndex < ipIndex; // update the hash to point to the current position table[hash] = (short) (ipIndex - inputOffset); // if the 4 byte sequence a the candidate index matches the sequence at the // current position, proceed to the next phase if (currentInt == SnappyInternalUtils.loadInt(input, candidateIndex)) { break; } } return new int[]{ipIndex, candidateIndex, skip}; }
private static int bytesBetweenHashLookups ( int skip ) { return ( skip > > > 5 ) ; }
private static int [ ] emitCopies ( byte [ ] input , final int inputOffset , final int inputSize , int ipIndex , byte [ ] output , int outputIndex , short [ ] table , int shift , int candidateIndex ) { // Step 3: Call EmitCopy, and then see if another EmitCopy could // be our next move. Repeat until we find no match for the // input immediately after what was consumed by the last EmitCopy call. // // If we exit this loop normally then we need to call EmitLiteral next, // though we don't yet know how big the literal will be. We handle that // by proceeding to the next iteration of the main loop. We also can exit // this loop via goto if we get close to exhausting the input. int inputBytes; do { // We have a 4-byte match at ip, and no need to emit any // "literal bytes" prior to ip. int matched = 4 + findMatchLength(input, candidateIndex + 4, input, ipIndex + 4, inputOffset + inputSize); int offset = ipIndex - candidateIndex; assert SnappyInternalUtils.equals(input, ipIndex, input, candidateIndex, matched); ipIndex += matched; // emit the copy operation for this chunk outputIndex = emitCopy(output, outputIndex, offset, matched); // are we done? if (ipIndex >= inputOffset + inputSize - kInputMarginBytes) { return new int[]{ipIndex, outputIndex}; } // We could immediately start working at ip now, but to improve // compression we first update table[Hash(ip - 1, ...)]. int prevInt; if (SnappyInternalUtils.HAS_UNSAFE) { long foo = SnappyInternalUtils.loadLong(input, ipIndex - 1); prevInt = (int) foo; inputBytes = (int) (foo >>> 8); } else { prevInt = SnappyInternalUtils.loadInt(input, ipIndex - 1); inputBytes = SnappyInternalUtils.loadInt(input, ipIndex); } // add hash starting with previous byte int prevHash = hashBytes(prevInt, shift); table[prevHash] = (short) (ipIndex - inputOffset - 1); // update hash of current byte int curHash = hashBytes(inputBytes, shift); candidateIndex = inputOffset + table[curHash]; table[curHash] = (short) (ipIndex - inputOffset); } while (inputBytes == SnappyInternalUtils.loadInt(input, candidateIndex)); return new int[]{ipIndex, outputIndex}; }
private static int emitLiteral ( byte [ ] output , int outputIndex , byte [ ] literal , final int literalIndex , final int length , final boolean allowFastPath ) { SnappyInternalUtils . checkPositionIndexes ( literalIndex , literalIndex + length , literal . length ) ; int n = length - 1 ; // Zero-length literals are disallowed if (n < 60) { // Size fits in tag byte output[outputIndex++] = (byte) (LITERAL | n << 2); // The vast majority of copies are below 16 bytes, for which a // call to memcpy is overkill. This fast path can sometimes // copy up to 15 bytes too much, but that is okay in the // main loop, since we have a bit to go on for both sides: // // - The input will always have kInputMarginBytes = 15 extra // available bytes, as long as we're in the main loop, and // if not, allowFastPath = false. // - The output will always have 32 spare bytes (see // MaxCompressedLength). if (SnappyInternalUtils.HAS_UNSAFE && allowFastPath && length <= 16) { SnappyInternalUtils.copyLong(literal, literalIndex, output, outputIndex); SnappyInternalUtils.copyLong(literal, literalIndex + 8, output, outputIndex + 8); outputIndex += length; return outputIndex; } } else if (n < (1 << 8)) { output[outputIndex++] = (byte) (LITERAL | 59 + 1 << 2); output[outputIndex++] = (byte) (n); } else if (n < (1 << 16)) { output[outputIndex++] = (byte) (LITERAL | 59 + 2 << 2); output[outputIndex++] = (byte) (n); output[outputIndex++] = (byte) (n >>> 8); } else if (n < (1 << 24)) { output[outputIndex++] = (byte) (LITERAL | 59 + 3 << 2); output[outputIndex++] = (byte) (n); output[outputIndex++] = (byte) (n >>> 8); output[outputIndex++] = (byte) (n >>> 16); } else { output[outputIndex++] = (byte) (LITERAL | 59 + 4 << 2); output[outputIndex++] = (byte) (n); output[outputIndex++] = (byte) (n >>> 8); output[outputIndex++] = (byte) (n >>> 16); output[outputIndex++] = (byte) (n >>> 24); } SnappyInternalUtils.checkPositionIndexes(literalIndex, literalIndex + length, literal.length); System.arraycopy(literal, literalIndex, output, outputIndex, length); outputIndex += length; return outputIndex; }
private static int emitCopyLessThan64 ( byte [ ] output , int outputIndex , int offset , int length ) { assert offset > = 0 ; assert length < = 64 ; assert length > = 4 ; assert offset < 65536 ; if ( ( length < 12 ) & & ( offset < 2048 ) ) { int lenMinus4 = length - 4 ; assert ( lenMinus4 < 8 ) ; // Must fit in 3 bits output[outputIndex++] = (byte) (COPY_1_BYTE_OFFSET | ((lenMinus4) << 2) | ((offset >>> 8) << 5)); output[outputIndex++] = (byte) (offset); } else { output[outputIndex++] = (byte) (COPY_2_BYTE_OFFSET | ((length - 1) << 2)); output[outputIndex++] = (byte) (offset); output[outputIndex++] = (byte) (offset >>> 8); } return outputIndex; }
private static int emitCopy ( byte [ ] output , int outputIndex , int offset , int length ) { // Emit 64 byte copies but make sure to keep at least four bytes reserved while (length >= 68) { outputIndex = emitCopyLessThan64(output, outputIndex, offset, 64); length -= 64; } // Emit an extra 60 byte copy if have too much data to fit in one copy if (length > 64) { outputIndex = emitCopyLessThan64(output, outputIndex, offset, 60); length -= 60; } // Emit remainder outputIndex = emitCopyLessThan64(output, outputIndex, offset, length); return outputIndex; }
private static int findMatchLength ( byte [ ] s1 , int s1Index , byte [ ] s2 , final int s2Index , int s2Limit ) { assert ( s2Limit > = s2Index ) ; if ( SnappyInternalUtils . HAS_UNSAFE ) { int matched = 0 ;
private static int getHashTableSize ( int inputSize ) { // Use smaller hash table when input.size() is smaller, since we // fill the table, incurring O(hash table size) overhead for // compression, and if the input is short, we won't need that // many hash table entries anyway. assert (kMaxHashTableSize >= 256); int hashTableSize = 256; while (hashTableSize < kMaxHashTableSize && hashTableSize < inputSize) { hashTableSize <<= 1; } assert 0 == (hashTableSize & (hashTableSize - 1)) : "hash must be power of two"; assert hashTableSize <= kMaxHashTableSize : "hash table too large"; return hashTableSize;
private static int hashBytes ( int bytes , int shift ) { int kMul = 0x1e35a7bd ; return ( bytes * kMul ) > > > shift ; }
private static int log2Floor ( int n ) { return n = = 0 ? - 1 : 31 ^ Integer . numberOfLeadingZeros ( n ) ; }
private static int writeUncompressedLength ( byte [ ] compressed , int compressedOffset , int uncompressedLength ) { int highBitMask = 0x80 ; if ( uncompressedLength < ( 1 < < 7 ) & & uncompressedLength > = 0 ) { compressed [ compressedOffset + + ] = ( byte ) ( uncompressedLength ) ; } else if ( uncompressedLength < ( 1 < < 14 ) & & uncompressedLength > 0 ) { compressed [ compressedOffset + + ] = ( byte ) ( uncompressedLength | highBitMask ) ; compressed [ compressedOffset + + ] = ( byte ) ( uncompressedLength > > > 7 ) ; } else if ( uncompressedLength < ( 1 < < 21 ) & & uncompressedLength > 0 ) { compressed [ compressedOffset + + ] = ( byte ) ( uncompressedLength | highBitMask ) ; compressed [ compressedOffset + + ] = ( byte ) ( ( uncompressedLength > > > 7 ) | highBitMask ) ; compressed [ compressedOffset + + ] = ( byte ) ( uncompressedLength > > > 14 ) ; } else if ( uncompressedLength < ( 1 < < 28 ) & & uncompressedLength > 0 ) { compressed [ compressedOffset + + ] = ( byte ) ( uncompressedLength | highBitMask ) ; compressed [ compressedOffset + + ] = ( byte ) ( ( uncompressedLength > > > 7 ) | highBitMask ) ; compressed [ compressedOffset + + ] = ( byte ) ( ( uncompressedLength > > > 14 ) | highBitMask ) ; compressed [ compressedOffset + + ] = ( byte ) ( uncompressedLength > > > 21 ) ; } else { compressed [ compressedOffset + + ] = ( byte ) ( uncompressedLength | highBitMask ) ; compressed [ compressedOffset + + ] = ( byte ) ( ( uncompressedLength > > > 7 ) | highBitMask ) ; compressed [ compressedOffset + + ] = ( byte ) ( ( uncompressedLength > > > 14 ) | highBitMask ) ; compressed [ compressedOffset + + ] = ( byte ) ( ( uncompressedLength > > > 21 ) | highBitMask ) ; compressed [ compressedOffset + + ] = ( byte ) ( uncompressedLength > > > 28 ) ; } return compressedOffset ; }
public static int getUncompressedLength ( byte [ ] compressed , int compressedOffset ) { return readUncompressedLength ( compressed , compressedOffset ) [ 0 ] ; }
public static byte [ ] uncompress ( byte [ ] compressed , int compressedOffset , int compressedSize ) { // Read the uncompressed length from the front of the compressed input int[] varInt = readUncompressedLength(compressed, compressedOffset); int expectedLength = varInt[0]; compressedOffset += varInt[1]; compressedSize -= varInt[1]; // allocate the uncompressed buffer byte[] uncompressed = new byte[expectedLength]; // Process the entire input int uncompressedSize = decompressAllTags( compressed, compressedOffset, compressedSize, uncompressed, 0); SnappyInternalUtils.checkArgument(expectedLength == uncompressedSize, "Corrupt Input: recorded length is %s bytes but actual length after decompression is %s bytes ", expectedLength, uncompressedSize); return uncompressed; }
public static int uncompress ( byte [ ] compressed , int compressedOffset , int compressedSize , byte [ ] uncompressed , int uncompressedOffset ) { // Read the uncompressed length from the front of the compressed input int[] varInt = readUncompressedLength(compressed, compressedOffset); int expectedLength = varInt[0]; compressedOffset += varInt[1]; compressedSize -= varInt[1]; SnappyInternalUtils.checkArgument(expectedLength <= uncompressed.length - uncompressedOffset, "Uncompressed length %s must be less than %s", expectedLength, uncompressed.length - uncompressedOffset); // Process the entire input int uncompressedSize = decompressAllTags( compressed, compressedOffset, compressedSize, uncompressed, uncompressedOffset); SnappyInternalUtils.checkArgument(expectedLength == uncompressedSize, "Corrupt Input: recorded length is %s bytes but actual length after decompression is %s bytes ", expectedLength, uncompressedSize); return expectedLength; }
private static int decompressAllTags ( byte [ ] input , final int inputOffset , final int inputSize , byte [ ] output , final int outputOffset ) { final int ipLimit = inputOffset + inputSize ; int opIndex = outputOffset ; for ( int ipIndex = inputOffset ; ipIndex < ipLimit ; ) { // read the opcode int opCode = input[ipIndex++] & 0xFF; // use the quick lookup table to determine the decode the opcode int entry = opLookupTable[opCode] & 0xFFFF; int trailerBytes = entry >>> 11; int trailer = readTrailer(input, ipIndex, trailerBytes); int length = entry & 0xff; // advance the ipIndex past the op code bytes ipIndex += trailerBytes; if ((opCode & 0x3) == Snappy.LITERAL) { // trailer of a literal contains more of the length int literalLength = length + trailer; copyLiteral(input, ipIndex, output, opIndex, literalLength); ipIndex += literalLength; opIndex += literalLength; } else { // copyOffset/256 is encoded in bits 8..10. By just fetching // those bits, we get copyOffset (since the bit-field starts at // bit 8). int copyOffset = entry & 0x700; // trailer of a literal contains more of the copy offset length copyOffset += trailer; copyFromSelf(output, outputOffset, copyOffset, opIndex, length); opIndex += length; } } return opIndex - outputOffset; }
private static int readTrailer ( byte [ ] data , int index , int bytes ) { if ( SnappyInternalUtils . HAS_UNSAFE & & data . length > index + 4 ) { return SnappyInternalUtils . loadInt ( data , index ) & wordmask [ bytes ] ; } int value = 0 ; switch ( bytes ) { case 4 : value = ( data [ index + 3 ] & 0xff ) < < 24 ; case 3 : value | = ( data [ index + 2 ] & 0xff ) < < 16 ; case 2 : value | = ( data [ index + 1 ] & 0xff ) < < 8 ; case 1 : value | = ( data [ index ] & 0xff ) ; } return value ; }
private static void copyLiteral ( byte [ ] input , int ipIndex , byte [ ] output , int opIndex , int literalLength ) { if ( SnappyInternalUtils . HAS_UNSAFE ) { if ( literalLength < 0 | | ipIndex + literalLength > input . length | | opIndex + literalLength > output . length ) {
private static void copyFromSelf ( byte [ ] output , int outputBase , int copyOffset , int opIndex , int length ) { int spaceLeft = output . length - opIndex ; int srcIndex = opIndex - copyOffset ; // opIndex = srcIndex + copyOffset if (length < 0 || srcIndex < outputBase || srcIndex >= opIndex || spaceLeft < length) { throw new IndexOutOfBoundsException(); } if (length <= 16 && copyOffset >= 8 && spaceLeft >= 16) { // Fast path, used for the majority (70-80%) of dynamic invocations.
private static void incrementalCopyFastPath ( byte [ ] output , int srcIndex , int copyOffset , int limit ) { int available = copyOffset ; for ( ; available < 8 ; available < < = 1 ) { SnappyInternalUtils . copyLong ( output , srcIndex , output , srcIndex + available ) ; } limit - = available ; for ( int i = srcIndex ; i < limit ; i + = 8 ) { SnappyInternalUtils . copyLong ( output , i , output , i + available ) ;
private static void incrementalCopy ( byte [ ] src , int srcIndex , byte [ ] op , int opIndex , int length ) { do { op [ opIndex + + ] = src [ srcIndex + + ] ;
private static int [ ] readUncompressedLength ( byte [ ] compressed , int compressedOffset ) { int result = 0 ; int bytesRead = 0 ; for ( int shift = 0 ; shift < = 28 ; shift + = 7 ) { int b = compressed [ compressedOffset + bytesRead + + ] & 0xFF ; // add the lower 7 bits to the result result |= ((b & 0x7f) << shift); // if high bit is not set, this is the last byte in the number if ((b & 0x80) == 0) { return new int[]{result, bytesRead}; } } throw new NumberFormatException("last byte of variable length int has high bit set"); }
static boolean equals ( byte [ ] left , int leftIndex , byte [ ] right , int rightIndex , int length ) { checkPositionIndexes ( leftIndex , leftIndex + length , left . length ) ; checkPositionIndexes ( rightIndex , rightIndex + length , right . length ) ; for ( int i = 0 ; i < length ; i + + ) { if ( left [ leftIndex + i ] ! = right [ rightIndex + i ] ) { return false ; } } return true ; }
static int loadInt ( byte [ ] data , int index ) { if ( HAS_UNSAFE ) { return unsafe . getInt ( data , BYTE_ARRAY_OFFSET + index ) ;
static void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) { if ( HAS_UNSAFE ) { long value = unsafe . getLong ( src , BYTE_ARRAY_OFFSET + srcIndex ) ;
static long loadLong ( byte [ ] data , int index ) { if ( HAS_UNSAFE ) { return unsafe . getLong ( data , BYTE_ARRAY_OFFSET + index ) ;
static void checkArgument ( boolean expression , String errorMessageTemplate , Object . . . errorMessageArgs ) { if ( ! expression ) { throw new IllegalArgumentException (
static void checkPositionIndexes ( int start , int end , int size ) { // Carefully optimized for execution by hotspot (explanatory comment above) if (start < 0 || end < start || end > size) { throw new IndexOutOfBoundsException(badPositionIndexes(start, end, size));
static String badPositionIndexes ( int start , int end , int size ) { if ( start < 0 | | start > size ) { return badPositionIndex ( start , size , " start index " ) ; } if ( end < 0 | | end > size ) { return badPositionIndex ( end , size , " end index " ) ; } // end < start return String.format("end index (%s) must not be less than start index (%s)", end, start); }
static String badPositionIndex ( int index , int size , String desc ) { if ( index < 0 ) { return String . format ( " %s (%s) must not be negative " , desc , index ) ;
public static void main ( String [ ] args ) { System . err . printf ( " Running micro-benchmarks. \ n " ) ; System . err . printf ( " %-18s %10s %10s %10s %10s \ n " , " Benchmark " , " Size " , " Time(ns) " , " Iterations " , " Throughput " ) ; System . err . printf ( " -------------------------------------------------------------- \ n " ) ; SnappyBench snappyBench = new SnappyBench ( ) ; // verify implementation with a round trip for every input snappyBench.verify(); // warm up the code paths so hotspot inlines the code snappyBench.warmUp(); // Easy to use individual tests //TestSuite testSuite = Uncompress; //for (int i = 0; i < 100; i++) { // System.err.println("GOOD"); // snappyBench.run(testSuite, "lsp", 0); // snappyBench.run(testSuite, "bin", 0); // snappyBench.run(testSuite, "man", 0); // snappyBench.run(testSuite, "c", 0); // snappyBench.run(testSuite, "cp", 0); // // // ok // System.err.println("OK"); // snappyBench.run(testSuite, "xls", 0); // // // bad // System.err.println("BAD"); // snappyBench.run(testSuite, "txt1", 0); // snappyBench.run(testSuite, "txt2", 0); // snappyBench.run(testSuite, "txt3", 0); // snappyBench.run(testSuite, "txt4", 0); // snappyBench.run(testSuite, "sum", 0); //} snappyBench.run(Compress); snappyBench.run(Uncompress);
public void verify ( ) { // Warm up the code { for (String testName : files.keySet()) {
public void warmUp ( ) { // Warm up the code { long end = System.nanoTime() + TimeUnit.SECONDS.toNanos(WARM_UP_SECONDS);
public void run ( TestSuite testSuite ) { int testNumber = 0 ; for ( String testName : files . keySet ( ) ) { for ( boolean useJni : ImmutableList . of ( false , true ) ) {
private void run ( TestSuite testSuite , String testName , int testNumber ) { run ( testSuite , testName , testNumber , false ) ; run ( testSuite , testName , testNumber , true ) ; }
private void run ( TestSuite testSuite , String testName , int testNumber , boolean useJni ) { // Run a few iterations first to find out approximately how fast // the benchmark is. resetBenchmarkTiming(); startBenchmarkTiming(); if (testSuite == Compress) { benchmarkCompress(CALIBRATE_ITERATIONS, testName, useJni); } else if (testSuite == Uncompress) { benchmarkUncompress(CALIBRATE_ITERATIONS, testName, useJni); } else { throw new AssertionError("Unexpected testSuite " + testSuite); } stopBenchmarkTiming(); // Let each test case run for about 200ms, but at least as many // as we used to calibrate. // Run five times and pick the median. long iterations = 0; if (benchmarkRealTimeUsec > 0) { iterations = 200000 * CALIBRATE_ITERATIONS / benchmarkRealTimeUsec; } iterations = Math.max(iterations, CALIBRATE_ITERATIONS); long[] benchmarkRuns = new long[NUMBER_OF_RUNS]; for (int run = 0; run < NUMBER_OF_RUNS; ++run) { resetBenchmarkTiming(); startBenchmarkTiming(); if (testSuite == Compress) { benchmarkCompress(iterations, testName, useJni); } else if (testSuite == Uncompress) { benchmarkUncompress(iterations, testName, useJni); } else { throw new AssertionError("Unexpected testSuite " + testSuite); } stopBenchmarkTiming(); benchmarkRuns[run] = benchmarkRealTimeUsec; } long realTimeUs = getMedianValue(benchmarkRuns); long bytesPerSecond = benchmarkBytesProcessed * 1000000 / realTimeUs; String heading; if (useJni) { heading = format("%s/%d/jni", testSuite, testNumber); } else { heading = format("%s/%d/java", testSuite, testNumber); } String humanReadableSpeed; if (bytesPerSecond < 1024) { humanReadableSpeed = format("%dB/s", bytesPerSecond); } else if (bytesPerSecond < 1024 * 1024) { humanReadableSpeed = format("%.1fkB/s", bytesPerSecond / 1024.0f); } else if (bytesPerSecond < 1024 * 1024 * 1024) { humanReadableSpeed = format("%.1fMB/s", bytesPerSecond / (1024.0f * 1024.0f)); } else { humanReadableSpeed = format("%.1fGB/s", bytesPerSecond / (1024.0f * 1024.0f * 1024.0f)); } int size = readTestDataFile(files.get(testName)).length; System.err.printf( "%-18s %10d %10d %10d %10s %s\n",
private long getMedianValue ( long [ ] benchmarkRuns ) { ArrayList < Long > list = new ArrayList < Long > ( Longs . asList ( benchmarkRuns ) ) ; Collections . sort ( list ) ; return list . get ( benchmarkRuns . length / 2 ) ; }
public void benchmarkCompress ( long iterations , String suite , boolean useJni ) { stopBenchmarkTiming ( ) ; // Read the file and create buffers out side of timing byte[] contents = readTestDataFile(files.get(suite)); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; setBenchmarkBytesProcessed(iterations * contents.length); // compress the data int compressedSize; if (useJni) { startBenchmarkTiming(); compressedSize = 0; while (iterations-- > 0) { try { compressedSize = org.xerial.snappy.Snappy.compress(contents, 0, contents.length, compressed, 0); } catch (IOException e) { throw Throwables.propagate(e); } } stopBenchmarkTiming(); } else { startBenchmarkTiming(); compressedSize = 0; while (iterations-- > 0) { compressedSize = Snappy.compress(contents, 0, contents.length, compressed, 0); } stopBenchmarkTiming(); } double compressionRatio = compressedSize / Math.max(1.0, contents.length); setBenchmarkLabel(format("%s (%.2f %%)", suite, 100.0 * compressionRatio)); }
public void benchmarkUncompress ( long iterations , String suite , boolean useJni ) { stopBenchmarkTiming ( ) ; // Read the file and create buffers out side of timing byte[] contents = readTestDataFile(files.get(suite)); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; int compressedSize = Snappy.compress(contents, 0, contents.length, compressed, 0); byte[] uncompressed = new byte[contents.length]; // based in uncompressed size setBenchmarkBytesProcessed(iterations * contents.length); setBenchmarkLabel(suite); if (useJni) { startBenchmarkTiming(); while (iterations-- > 0) { try { org.xerial.snappy.Snappy.uncompress(compressed, 0, compressedSize, uncompressed, 0); } catch (IOException e) { throw Throwables.propagate(e); } } stopBenchmarkTiming(); } else { startBenchmarkTiming(); while (iterations-- > 0) { Snappy.uncompress(compressed, 0, compressedSize, uncompressed, 0); } stopBenchmarkTiming(); } if (!Arrays.equals(uncompressed, contents)) { throw new AssertionError(String.format(
private void resetBenchmarkTiming ( ) { benchmarkRealTimeUsec = 0 ; }
private void startBenchmarkTiming ( ) { benchmarkRunning = true ; benchmarkStart = System . nanoTime ( ) ; }
private void stopBenchmarkTiming ( ) { if ( ! benchmarkRunning ) { return ; } long end = System . nanoTime ( ) ; benchmarkRealTimeUsec = TimeUnit . NANOSECONDS . toMicros ( end - benchmarkStart ) ; benchmarkRunning = false ; }
private void setBenchmarkLabel ( String benchmarkLabel ) { this . benchmarkLabel = benchmarkLabel ; }
private void setBenchmarkBytesProcessed ( long benchmarkBytesProcessed ) { this . benchmarkBytesProcessed = benchmarkBytesProcessed ; }
private byte [ ] readTestDataFile ( String fileName ) { try { return Files . toByteArray ( new File ( " testdata " , fileName ) ) ;
public void testByteForByteOutputSyntheticData ( ) throws Exception { for ( int i = 1 ; i < 65 * 1024 ; i + + ) { try {
public void testByteForByteTestData ( ) throws Exception { File [ ] testFiles = TEST_DATA_DIR . listFiles ( ) ; Assert . assertTrue ( testFiles ! = null & & testFiles . length > 0 , " No test files at " + TEST_DATA_DIR . getAbsolutePath ( ) ) ; for ( File testFile : testFiles ) { byte [ ] data = Files . toByteArray ( testFile ) ;
private void verifyCompression ( int size ) throws Exception { byte [ ] input = randomGenerator . data ; int position = randomGenerator . getNextPosition ( size ) ; verifyCompression ( input , position , size ) ; }
private void verifyCompression ( byte [ ] input , int position , int size ) throws Exception { byte [ ] nativeCompressed = new byte [ org . xerial . snappy . Snappy . maxCompressedLength ( size ) ] ; byte [ ] javaCompressed = new byte [ Snappy . maxCompressedLength ( size ) ] ; int nativeCompressedSize = org . xerial . snappy . Snappy . compress ( input , position , size , nativeCompressed , 0 ) ; int javaCompressedSize = Snappy . compress ( input , position , size , javaCompressed , 0 ) ; // verify outputs are exactly the same String failureMessage = "Invalid compressed output for input size " + size + " at offset " + position; if (!SnappyInternalUtils.equals(javaCompressed, 0, nativeCompressed, 0, nativeCompressedSize)) { if (nativeCompressedSize < 100) { Assert.assertEquals( Arrays.toString(Arrays.copyOf(javaCompressed, nativeCompressedSize)), Arrays.toString(Arrays.copyOf(nativeCompressed, nativeCompressedSize)), failureMessage ); } else { Assert.fail(failureMessage); } } Assert.assertEquals(javaCompressedSize, nativeCompressedSize); // verify the contents can be uncompressed byte[] uncompressed = new byte[size]; Snappy.uncompress(javaCompressed, 0, javaCompressedSize, uncompressed, 0); if (!SnappyInternalUtils.equals(uncompressed, 0, input, position, size)) { Assert.fail("Invalid uncompressed output for input size " + size + " at offset "+ position);
public int getNextPosition ( int length ) { if ( position + length > data . length ) { position = 0 ; assert ( length < data . length ) ; } int result = position ; position + = length ; return result ; }
private static byte [ ] compressibleData ( Random random , double compressionRatio , int length ) { int raw = ( int ) ( length * compressionRatio ) ; if ( raw < 1 ) { raw = 1 ; } byte [ ] rawData = generateRandomData ( random , raw ) ; // Duplicate the random data until we have filled "length" bytes byte[] dest = new byte[length]; for (int i = 0; i < length;) { int chunkLength = Math.min(rawData.length, length - i); System.arraycopy(rawData, 0, dest, i, chunkLength); i += chunkLength; } return dest; }
private static byte [ ] generateRandomData ( Random random , int length ) { byte [ ] rawData = new byte [ length ] ; for ( int i = 0 ; i < rawData . length ; i + + ) { rawData [ i ] = ( byte ) ( ' ' + random . nextInt ( 95 ) ) ; } return rawData ; }
boolean fastAccessSupported ( ) ; int loadInt ( byte [ ] data , int index ) ; void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) ; long loadLong ( byte [ ] data , int index ) ; }
int loadInt ( byte [ ] data , int index ) ; void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) ; long loadLong ( byte [ ] data , int index ) ; }
void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) ; long loadLong ( byte [ ] data , int index ) ; }
public boolean fastAccessSupported ( ) { return false ; }
public int loadInt ( byte [ ] data , int index ) { return ( data [ index ] & 0xff ) | ( data [ index + 1 ] & 0xff ) < < 8 |
public void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) { for ( int i = 0 ; i < 8 ; i + + ) { dest [ destIndex + i ] = src [ srcIndex + i ] ;
public long loadLong ( byte [ ] data , int index ) { return ( data [ index ] & 0xffL ) | ( data [ index + 1 ] & 0xffL ) < < 8 |
private static int emitLiteral ( byte [ ] output , int outputIndex , byte [ ] literal , final int literalIndex , final int length , final boolean allowFastPath ) { SnappyInternalUtils . checkPositionIndexes ( literalIndex , literalIndex + length , literal . length ) ; int n = length - 1 ; // Zero-length literals are disallowed if (n < 60) { // Size fits in tag byte output[outputIndex++] = (byte) (LITERAL | n << 2); // The vast majority of copies are below 16 bytes, for which a // call to memcpy is overkill. This fast path can sometimes // copy up to 15 bytes too much, but that is okay in the // main loop, since we have a bit to go on for both sides: // // - The input will always have kInputMarginBytes = 15 extra // available bytes, as long as we're in the main loop, and // if not, allowFastPath = false. // - The output will always have 32 spare bytes (see // MaxCompressedLength). if (allowFastPath && length <= 16) { SnappyInternalUtils.copyLong(literal, literalIndex, output, outputIndex); SnappyInternalUtils.copyLong(literal, literalIndex + 8, output, outputIndex + 8); outputIndex += length; return outputIndex; } } else if (n < (1 << 8)) { output[outputIndex++] = (byte) (LITERAL | 59 + 1 << 2); output[outputIndex++] = (byte) (n); } else if (n < (1 << 16)) { output[outputIndex++] = (byte) (LITERAL | 59 + 2 << 2); output[outputIndex++] = (byte) (n); output[outputIndex++] = (byte) (n >>> 8); } else if (n < (1 << 24)) { output[outputIndex++] = (byte) (LITERAL | 59 + 3 << 2); output[outputIndex++] = (byte) (n); output[outputIndex++] = (byte) (n >>> 8); output[outputIndex++] = (byte) (n >>> 16); } else { output[outputIndex++] = (byte) (LITERAL | 59 + 4 << 2); output[outputIndex++] = (byte) (n); output[outputIndex++] = (byte) (n >>> 8); output[outputIndex++] = (byte) (n >>> 16); output[outputIndex++] = (byte) (n >>> 24); } SnappyInternalUtils.checkPositionIndexes(literalIndex, literalIndex + length, literal.length); System.arraycopy(literal, literalIndex, output, outputIndex, length); outputIndex += length; return outputIndex; }
private static int readTrailer ( byte [ ] data , int index , int bytes ) { if ( data . length > index + 4 ) { return SnappyInternalUtils . loadInt ( data , index ) & wordmask [ bytes ] ; } int value = 0 ; switch ( bytes ) { case 4 : value = ( data [ index + 3 ] & 0xff ) < < 24 ; case 3 : value | = ( data [ index + 2 ] & 0xff ) < < 16 ; case 2 : value | = ( data [ index + 1 ] & 0xff ) < < 8 ; case 1 : value | = ( data [ index ] & 0xff ) ; } return value ; }
private static void copyLiteral ( byte [ ] input , int ipIndex , byte [ ] output , int opIndex , int literalLength ) { if ( literalLength < 0 | | ipIndex + literalLength > input . length | | opIndex + literalLength > output . length ) { throw new IndexOutOfBoundsException ( ) ; } int spaceLeft = output . length - opIndex ; int readableBytes = input . length - ipIndex ; // most literals are less than 16 bytes to handle them specially if (literalLength <= 16 && spaceLeft >= 16 && readableBytes >= 16) { SnappyInternalUtils.copyLong(input, ipIndex, output, opIndex);
static int loadInt ( byte [ ] data , int index ) { return memory . loadInt ( data , index ) ; }
static void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) { memory . copyLong ( src , srcIndex , dest , destIndex ) ; }
static long loadLong ( byte [ ] data , int index ) { return memory . loadLong ( data , index ) ; }
public boolean fastAccessSupported ( ) { return true ; }
public int loadInt ( byte [ ] data , int index ) { return unsafe . getInt ( data , ( long ) ( BYTE_ARRAY_OFFSET + index ) ) ; }
public void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) { long value = unsafe . getLong ( src , ( long ) ( BYTE_ARRAY_OFFSET + srcIndex ) ) ; unsafe . putLong ( dest , ( ( long ) BYTE_ARRAY_OFFSET + destIndex ) , value ) ; }
public long loadLong ( byte [ ] data , int index ) { return unsafe . getLong ( data , ( long ) ( BYTE_ARRAY_OFFSET + index ) ) ; }
boolean fastAccessSupported ( ) ; int loadInt ( byte [ ] data , int index ) ; void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) ; long loadLong ( byte [ ] data , int index ) ; void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) ; }
int loadInt ( byte [ ] data , int index ) ; void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) ; long loadLong ( byte [ ] data , int index ) ; void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) ; }
void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) ; long loadLong ( byte [ ] data , int index ) ; void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) ; }
long loadLong ( byte [ ] data , int index ) ; void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) ; }
void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) ; }
public void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) { System . arraycopy ( input , inputIndex , output , outputIndex , length ) ; }
private static int decompressAllTags ( final byte [ ] input , final int inputOffset , final int inputSize , final byte [ ] output , final int outputOffset ) { final int ipLimit = inputOffset + inputSize ; int opIndex = outputOffset ; for ( int ipIndex = inputOffset ; ipIndex < ipLimit ; ) { // read the opcode int opCode = input[ipIndex++] & 0xFF; // use the quick lookup table to determine the decode the opcode int entry = opLookupTable[opCode] & 0xFFFF; int trailerBytes = entry >>> 11; int trailer = readTrailer(input, ipIndex, trailerBytes); int length = entry & 0xff; // advance the ipIndex past the op code bytes ipIndex += trailerBytes; if ((opCode & 0x3) == Snappy.LITERAL) { // trailer of a literal contains more of the length int literalLength = length + trailer; copyLiteral(input, ipIndex, output, opIndex, literalLength); ipIndex += literalLength; opIndex += literalLength; } else { // copyOffset/256 is encoded in bits 8..10. By just fetching // those bits, we get copyOffset (since the bit-field starts at // bit 8), and the trailer of a literal contains additional bits // for the copy offset length copyFromSelf(output, outputOffset, (entry & 0x700) + trailer, opIndex, length); opIndex += length; } } return opIndex - outputOffset; }
static void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) { memory . copyMemory ( input , inputIndex , output , outputIndex , length ) ; }
public void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int literalLength ) { unsafe . copyMemory ( input , UnsafeMemory . BYTE_ARRAY_OFFSET + inputIndex , output , UnsafeMemory . BYTE_ARRAY_OFFSET + outputIndex , literalLength ) ; }
public int read ( ) throws IOException { if ( ! ensureBuffer ( ) ) { return - 1 ; } return buffer [ position + + ] ; }
public int read ( byte [ ] output , int offset , int length ) throws IOException { if ( length = = 0 ) { return 0 ; } if ( ! ensureBuffer ( ) ) { return - 1 ; } int size = min ( length , available ( ) ) ; System . arraycopy ( buffer , position , output , offset , size ) ; position + = size ; return size ; }
public int available ( ) throws IOException { return valid - position ; }
public void close ( ) throws IOException { in . close ( ) ; }
private boolean ensureBuffer ( ) throws IOException { if ( available ( ) > 0 ) { return true ; } if ( eof ) { return false ; } if ( ! readBlockHeaderBytes ( ) ) { eof = true ; return false ; } int header = convertBlockHeaderBytes ( ) ; // extract compressed flag and length from header boolean compressed = (header & 0x8000) != 0; int length = (header & 0x7FFF) + 1; readInput(length); handleInput(length, compressed); return true; }
private void handleInput ( int length , boolean compressed ) { if ( compressed ) { buffer = uncompressed ; valid = Snappy . uncompress ( input , 0 , length , uncompressed , 0 ) ; } else { buffer = input ; valid = length ; } position = 0 ; }
private void readInput ( int length ) throws IOException { int offset = 0 ; while ( offset < length ) { int size = in . read ( input , offset , length - offset ) ;
private boolean readBlockHeaderBytes ( ) throws IOException { int n = in . read ( headerBytes , 0 , 2 ) ; if ( n = = - 1 ) { return false ; } if ( n = = 1 ) { int b = in . read ( ) ; if ( b = = - 1 ) { throw new EOFException ( " encountered EOF while reading block header " ) ; } headerBytes [ 1 ] = ( byte ) b ; } return true ; }
private int convertBlockHeaderBytes ( ) { int a = headerBytes [ 0 ] & 0xFF ; int b = headerBytes [ 1 ] & 0xFF ; return ( a < < 8 ) | b ; }
public void write ( int b ) throws IOException { if ( position > = buffer . length ) { flushBuffer ( ) ; } buffer [ position + + ] = ( byte ) b ; }
public void write ( byte [ ] input , int offset , int length ) throws IOException { int free = buffer . length - position ; // easy case: enough free space in buffer for entire input if (free >= length) { copyToBuffer(input, offset, length); return; } // fill partial buffer as much as possible and flush if (position > 0) { copyToBuffer(input, offset, free); flushBuffer(); offset += free; length -= free; } // write remaining full blocks directly from input array while (length >= buffer.length) { writeCompressed(input, offset, buffer.length); offset += buffer.length; length -= buffer.length; } // copy remaining partial block into now-empty buffer copyToBuffer(input, offset, length); }
public void flush ( ) throws IOException { flushBuffer ( ) ; out . flush ( ) ; }
public void close ( ) throws IOException { flush ( ) ; out . close ( ) ; }
private void copyToBuffer ( byte [ ] input , int offset , int length ) { System . arraycopy ( input , offset , buffer , position , length ) ; position + = length ; }
private void flushBuffer ( ) throws IOException { if ( position > 0 ) { writeCompressed ( buffer , 0 , position ) ;
private void writeCompressed ( byte [ ] input , int offset , int length ) throws IOException { int compressed = Snappy . compress ( input , offset , length , outputBuffer , 0 ) ; // use uncompressed input if less than 12.5% compression if (compressed >= (length - (length / 8))) { writeUncompressedBlock(input, offset, length);
private void writeUncompressedBlock ( byte [ ] uncompressed , int offset , int length ) throws IOException { int n = length - 1 ; out . write ( n > > > 8 ) ; out . write ( n & 0xFF ) ; out . write ( uncompressed , offset , length ) ; }
private void writeCompressedBlock ( byte [ ] compressed , int offset , int length ) throws IOException { int n = length - 1 ; out . write ( ( n > > > 8 ) | 0x80 ) ; out . write ( n & 0xFF ) ; out . write ( compressed , offset , length ) ; }
public void testSimple ( ) throws Exception { byte [ ] original = " aaaaaaaaaaaabbbbbbbaaaaaa " . getBytes ( Charsets . UTF_8 ) ; byte [ ] compressed = compress ( original ) ; byte [ ] uncompressed = uncompress ( compressed ) ; assertEquals ( uncompressed , original ) ; assertTrue ( compressed . length < original . length ) ; }
public void testLargeWrites ( ) throws Exception { byte [ ] random = getRandom ( 0.5 , 500000 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; OutputStream snappyOut = new SnappyOutputStream ( out ) ; // partially fill buffer int small = 1000; snappyOut.write(random, 0, small); // write more than the buffer size snappyOut.write(random, small, random.length - small); // get compressed data snappyOut.close(); byte[] compressed = out.toByteArray(); assertTrue(compressed.length < random.length); // decompress byte[] uncompressed = uncompress(compressed); assertEquals(uncompressed, random); // decompress byte at a time SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(compressed)); int i = 0; int c; while ((c = in.read()) != -1) { uncompressed[i++] = (byte) c; } assertEquals(i, random.length); assertEquals(uncompressed, random); }
public void testSingleByteWrites ( ) throws Exception { byte [ ] random = getRandom ( 0.5 , 500000 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; OutputStream snappyOut = new SnappyOutputStream ( out ) ; for ( byte b : random ) { snappyOut . write ( b ) ; } snappyOut . close ( ) ; byte [ ] compressed = out . toByteArray ( ) ; assertTrue ( compressed . length < random . length ) ; byte [ ] uncompressed = uncompress ( compressed ) ; assertEquals ( uncompressed , random ) ; }
public void testExtraFlushes ( ) throws Exception { byte [ ] random = getRandom ( 0.5 , 500000 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; OutputStream snappyOut = new SnappyOutputStream ( out ) ; snappyOut . write ( random ) ; for ( int i = 0 ; i < 10 ; i + + ) { snappyOut . flush ( ) ; } snappyOut . close ( ) ; byte [ ] compressed = out . toByteArray ( ) ; assertTrue ( compressed . length < random . length ) ; byte [ ] uncompressed = uncompress ( compressed ) ; assertEquals ( uncompressed , random ) ; }
public void testUncompressable ( ) throws Exception { byte [ ] random = getRandom ( 1 , 5000 ) ; byte [ ] compressed = compress ( random ) ; byte [ ] uncompressed = uncompress ( compressed ) ; assertEquals ( uncompressed , random ) ; assertEquals ( compressed . length , random . length + 2 ) ; }
public void testUncompressableRange ( ) throws Exception { int max = 35000 ; byte [ ] random = getRandom ( 1 , max ) ; for ( int i = 1 ; i < = max ; i + + ) { byte [ ] original = Arrays . copyOfRange ( random , 0 , i ) ;
public void testByteForByteTestData ( ) throws Exception { for ( File testFile : SnappyTest . getTestFiles ( ) ) { byte [ ] original = Files . toByteArray ( testFile ) ;
private static byte [ ] getRandom ( double compressionRatio , int length ) { SnappyTest . RandomGenerator gen = new SnappyTest . RandomGenerator ( compressionRatio ) ; gen . getNextPosition ( length ) ; byte [ ] random = Arrays . copyOf ( gen . data , length ) ; assertEquals ( random . length , length ) ; return random ; }
private static byte [ ] compress ( byte [ ] original ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; OutputStream snappyOut = new SnappyOutputStream ( out ) ; snappyOut . write ( original ) ; snappyOut . close ( ) ; return out . toByteArray ( ) ; }
private static byte [ ] uncompress ( byte [ ] compressed ) throws IOException { return toByteArray ( new SnappyInputStream ( new ByteArrayInputStream ( compressed ) ) ) ; }
public void testByteForByteTestData ( ) throws Exception { for ( File testFile : getTestFiles ( ) ) { byte [ ] data = Files . toByteArray ( testFile ) ;
static File [ ] getTestFiles ( ) { File [ ] testFiles = TEST_DATA_DIR . listFiles ( ) ; Assert . assertTrue ( testFiles ! = null & & testFiles . length > 0 , " No test files at " + TEST_DATA_DIR . getAbsolutePath ( ) ) ; return testFiles ; }
public static void main ( String [ ] args ) throws Exception { if ( ( args . length = = 1 ) & & ( args [ 0 ] . equals ( " -c " ) ) ) { compress ( ) ;
private static void usage ( ) { System . err . println ( " Usage: java -jar snappy.jar OPTION " ) ; System . err . println ( " Compress or uncompress with Snappy. " ) ; System . err . println ( ) ; System . err . println ( " -c compress from stdin to stdout " ) ; System . err . println ( " -d uncompress from stdin to stdout " ) ; System . exit ( 100 ) ; }
private static void compress ( ) throws IOException { copy ( System . in , new SnappyOutputStream ( System . out ) ) ; }
private static void uncompress ( ) throws IOException { copy ( new SnappyInputStream ( System . in ) , System . out ) ; }
private static void copy ( InputStream in , OutputStream out ) throws IOException { byte [ ] buf = new byte [ 4096 ] ; while ( true ) { int r = in . read ( buf ) ;
public CompressionOutputStream createOutputStream ( OutputStream outputStream ) throws IOException { return new SnappyCompressionOutputStream ( outputStream ) ; }
public CompressionOutputStream createOutputStream ( OutputStream outputStream , Compressor compressor ) throws IOException { throw new UnsupportedOperationException ( " Snappy Compressor is not supported " ) ; }
public Class < ? extends Compressor > getCompressorType ( ) { throw new UnsupportedOperationException ( " Snappy Compressor is not supported " ) ; }
public Compressor createCompressor ( ) { throw new UnsupportedOperationException ( " Snappy Compressor is not supported " ) ; }
public CompressionInputStream createInputStream ( InputStream inputStream ) throws IOException { return new SnappyCompressionInputStream ( inputStream ) ; }
public CompressionInputStream createInputStream ( InputStream inputStream , Decompressor decompressor ) throws IOException { throw new UnsupportedOperationException ( " Snappy Decompressor is not supported " ) ; }
public Class < ? extends Decompressor > getDecompressorType ( ) { throw new UnsupportedOperationException ( " Snappy Decompressor is not supported " ) ; }
public Decompressor createDecompressor ( ) { throw new UnsupportedOperationException ( " Snappy Decompressor is not supported " ) ; }
public String getDefaultExtension ( ) { return " .snappy " ; }
public void write ( byte [ ] b , int off , int len ) throws IOException { out . write ( b , off , len ) ; }
public void finish ( ) throws IOException { out . flush ( ) ; }
public void resetState ( ) throws IOException { out . flush ( ) ; }
public void write ( int b ) throws IOException { out . write ( b ) ; }
public int read ( byte [ ] b , int off , int len ) throws IOException { return in . read ( b , off , len ) ; }
public void resetState ( ) throws IOException { throw new UnsupportedOperationException ( " resetState not supported for Snappy " ) ; }
public int read ( ) throws IOException { return in . read ( ) ; }
public void testGetCodec ( ) { Path path = new Path ( " test.json.snappy " ) ; Configuration conf = new Configuration ( ) ; conf . set ( " io.compression.codecs " , HadoopSnappyCodec . class . getName ( ) ) ; CompressionCodec codec = new CompressionCodecFactory ( conf ) . getCodec ( path ) ; assertNotNull ( codec ) ; assertTrue ( codec instanceof HadoopSnappyCodec ) ; }
private static byte [ ] compress ( byte [ ] original ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; HadoopSnappyCodec codec = new HadoopSnappyCodec ( ) ; OutputStream snappyOut = codec . createOutputStream ( out ) ; snappyOut . write ( original ) ; snappyOut . close ( ) ; return out . toByteArray ( ) ; }
private static byte [ ] uncompress ( byte [ ] compressed ) throws IOException { HadoopSnappyCodec codec = new HadoopSnappyCodec ( ) ; return toByteArray ( codec . createInputStream ( new ByteArrayInputStream ( compressed ) ) ) ; }
private boolean ensureBuffer ( ) throws IOException { if ( available ( ) > 0 ) { return true ; } if ( eof ) { return false ; } if ( ! readBlockHeader ( ) ) { eof = true ; return false ; } boolean compressed = getHeaderCompressedFlag ( ) ; int length = getHeaderLength ( ) ; readInput ( length ) ; handleInput ( length , compressed ) ; return true ; }
private boolean readBlockHeader ( ) throws IOException { int offset = 0 ; while ( offset < header . length ) { int size = in . read ( header , offset , header . length - offset ) ; if ( size = = - 1 ) { // EOF on first byte means the stream ended cleanly if (offset == 0) { return false; } throw new EOFException("encounted EOF while reading block header"); } offset += size; } return true; }
private boolean getHeaderCompressedFlag ( ) throws IOException { int x = header [ 0 ] & 0xFF ; switch ( x ) { case 0x00 :
private int getHeaderLength ( ) throws IOException { int a = header [ 1 ] & 0xFF ; int b = header [ 2 ] & 0xFF ; int length = ( a < < 8 ) | b ; if ( ( length < = 0 ) | | ( length > MAX_BLOCK_SIZE ) ) { throw new IOException ( " invalid block size in header: " + length ) ; } return length ; }
private void writeCompressed ( byte [ ] input , int offset , int length ) throws IOException { int compressed = Snappy . compress ( input , offset , length , outputBuffer , 0 ) ; // use uncompressed input if less than 12.5% compression if (compressed >= (length - (length / 8))) { writeBlock(input, offset, length, false);
private void writeBlock ( byte [ ] data , int offset , int length , boolean compressed ) throws IOException { out . write ( compressed ? 0x01 : 0x00 ) ; out . write ( length > > > 8 ) ; out . write ( length & 0xFF ) ; out . write ( data , offset , length ) ; }
public void testSimple ( ) throws Exception { byte [ ] original = " aaaaaaaaaaaabbbbbbbaaaaaa " . getBytes ( Charsets . UTF_8 ) ; byte [ ] compressed = compress ( original ) ; byte [ ] uncompressed = uncompress ( compressed ) ; assertEquals ( uncompressed , original ) ; assertTrue ( compressed . length < original . length ) ; assertEquals ( compressed . length , 22 ) ; // 3 byte header, 19 bytes compressed data assertEquals(toInt(compressed[0]), 0x01); // flag: compressed assertEquals(toInt(compressed[1]), 0x00); // length: 19 = 0x0013 assertEquals(toInt(compressed[2]), 0x13); }
public void testUncompressable ( ) throws Exception { byte [ ] random = getRandom ( 1 , 5000 ) ; byte [ ] compressed = compress ( random ) ; byte [ ] uncompressed = uncompress ( compressed ) ; assertEquals ( uncompressed , random ) ; assertEquals ( compressed . length , random . length + 3 ) ; assertEquals ( toInt ( compressed [ 0 ] ) , 0x00 ) ; // flag: uncompressed assertEquals(toInt(compressed[1]), 0x13); // length: 5000 = 0x1388 assertEquals(toInt(compressed[2]), 0x88); }
public void testEmpty ( ) throws Exception { byte [ ] empty = new byte [ 0 ] ; assertEquals ( compress ( empty ) , empty ) ; assertEquals ( uncompress ( empty ) , empty ) ; }
public void testShortBlockHeader ( ) throws Exception { uncompress ( new byte [ ] { 0 } ) ; }
public void testShortBlockData ( ) throws Exception { uncompress ( new byte [ ] { 0 , 0 , 4 , 'x' , 'x' } ) ; // flag = 0, size = 4, block data = [x, x] }
public void testInvalidBlockHeaderCompressedFlag ( ) throws Exception { uncompress ( new byte [ ] { 'A' , 0 , 1 } ) ; // flag = 'A', block size = 1 }
public void testInvalidBlockSizeZero ( ) throws Exception { uncompress ( new byte [ ] { 0 , 0 , 0 } ) ; // flag = 'A', block size = 0 }
public void testInvalidBlockSizeLarge ( ) throws Exception { uncompress ( new byte [ ] { 0 , ( byte ) 0xD9 , 0x03 } ) ; // flag = 'A', block size = 55555 }
public int loadInt ( byte [ ] data , int index ) { assert index > = 0 ; assert index + 4 < = data . length ; return unsafe . getInt ( data , ( long ) ( BYTE_ARRAY_OFFSET + index ) ) ; }
public void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) { assert srcIndex > = 0 ; assert srcIndex + 8 < = src . length ; assert destIndex > = 0 ; assert destIndex + 8 < = dest . length ; long value = unsafe . getLong ( src , ( long ) ( BYTE_ARRAY_OFFSET + srcIndex ) ) ; unsafe . putLong ( dest , ( ( long ) BYTE_ARRAY_OFFSET + destIndex ) , value ) ; }
public long loadLong ( byte [ ] data , int index ) { assert index > 0 ; assert index + 4 < data . length ; return unsafe . getLong ( data , ( long ) ( BYTE_ARRAY_OFFSET + index ) ) ; }
public void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) { assert inputIndex > = 0 ; assert inputIndex + length < = input . length ; assert outputIndex > = 0 ; assert outputIndex + length < = output . length ; unsafe . copyMemory ( input , UnsafeMemory . BYTE_ARRAY_OFFSET + inputIndex , output , UnsafeMemory . BYTE_ARRAY_OFFSET + outputIndex , length ) ; System . arraycopy ( input , inputIndex , output , outputIndex , length ) ; }
public void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) { assert inputIndex > = 0 ; assert inputIndex + length < = input . length ; assert outputIndex > = 0 ; assert outputIndex + length < = output . length ; unsafe . copyMemory ( input , UnsafeMemory . BYTE_ARRAY_OFFSET + inputIndex , output , UnsafeMemory . BYTE_ARRAY_OFFSET + outputIndex , length ) ; }
boolean fastAccessSupported ( ) ; int lookupShort ( short [ ] data , int index ) ; int loadByte ( byte [ ] data , int index ) ; int loadInt ( byte [ ] data , int index ) ; void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) ; long loadLong ( byte [ ] data , int index ) ; void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) ; }
int lookupShort ( short [ ] data , int index ) ; int loadByte ( byte [ ] data , int index ) ; int loadInt ( byte [ ] data , int index ) ; void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) ; long loadLong ( byte [ ] data , int index ) ; void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) ; }
int loadByte ( byte [ ] data , int index ) ; int loadInt ( byte [ ] data , int index ) ; void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) ; long loadLong ( byte [ ] data , int index ) ; void copyMemory ( byte [ ] input , int inputIndex , byte [ ] output , int outputIndex , int length ) ; }
public int lookupShort ( short [ ] data , int index ) { return data [ index ] & 0xFFFF ; }
public int loadByte ( byte [ ] data , int index ) { return data [ index ] & 0xFF ; }
private static int [ ] decompressTagSlow ( byte [ ] input , int ipIndex , byte [ ] output , int outputLimit , int outputOffset , int opIndex ) { // read the op code int opCode = loadByte(input, ipIndex++); int entry = lookupShort(opLookupTable, opCode); int trailerBytes = entry >>> 11; // // Key difference here // int trailer = 0; switch (trailerBytes) { case 4: trailer = (input[ipIndex + 3] & 0xff) << 24; case 3: trailer |= (input[ipIndex + 2] & 0xff) << 16; case 2: trailer |= (input[ipIndex + 1] & 0xff) << 8; case 1: trailer |= (input[ipIndex] & 0xff); } // advance the ipIndex past the op codes ipIndex += trailerBytes; int length = entry & 0xff; if ((opCode & 0x3) == Snappy.LITERAL) { int literalLength = length + trailer; copyLiteral(input, ipIndex, output, opIndex, literalLength); ipIndex += literalLength; opIndex += literalLength; } else { // copyOffset/256 is encoded in bits 8..10. By just fetching // those bits, we get copyOffset (since the bit-field starts at // bit 8). int copyOffset = entry & 0x700; copyOffset += trailer; // inline to force hot-spot to keep inline { int spaceLeft = outputLimit - opIndex; int srcIndex = opIndex - copyOffset; if (srcIndex < outputOffset) { throw new IndexOutOfBoundsException(); } if (length <= 16 && copyOffset >= 8 && spaceLeft >= 16) { // Fast path, used for the majority (70-80%) of dynamic invocations. copyLong(output, srcIndex, output, opIndex); copyLong(output, srcIndex + 8, output, opIndex + 8); } else if (spaceLeft >= length + MAX_INCREMENT_COPY_OVERFLOW) { incrementalCopyFastPath(output, srcIndex, opIndex, length); } else { incrementalCopy(output, srcIndex, output, opIndex, length); } } opIndex += length; } return new int[] {ipIndex, opIndex}; }
private static int readTrailer ( byte [ ] data , int index , int bytes ) { return SnappyInternalUtils . loadInt ( data , index ) & wordmask [ bytes ] ; }
private static void copyLiteral ( byte [ ] input , int ipIndex , byte [ ] output , int opIndex , int length ) { assert length > 0 ; assert ipIndex > = 0 ; assert opIndex > = 0 ; int spaceLeft = output . length - opIndex ; int readableBytes = input . length - ipIndex ; if ( readableBytes < length | | spaceLeft < length ) { throw new IndexOutOfBoundsException ( ) ; } if ( length < = 16 & & spaceLeft > = 16 & & readableBytes > = 16 ) { copyLong ( input , ipIndex , output , opIndex ) ;
private static void incrementalCopyFastPath ( byte [ ] output , int srcIndex , int opIndex , int length ) { int copiedLength = 0 ; while ( ( opIndex + copiedLength ) - srcIndex < 8 ) { copyLong ( output , srcIndex , output , opIndex + copiedLength ) ; copiedLength + = ( opIndex + copiedLength ) - srcIndex ; } for ( int i = 0 ; i < length - copiedLength ; i + = 8 ) { copyLong ( output , srcIndex + i , output , opIndex + copiedLength + i ) ;
private static int [ ] readUncompressedLength ( byte [ ] compressed , int compressedOffset ) { int result ; int bytesRead = 0 ; { int b = compressed [ compressedOffset + bytesRead + + ] & 0xFF ; result = b & 0x7f ; if ( ( b & 0x80 ) ! = 0 ) { b = compressed [ compressedOffset + bytesRead + + ] & 0xFF ; result | = ( b & 0x7f ) < < 7 ; if ( ( b & 0x80 ) ! = 0 ) { b = compressed [ compressedOffset + bytesRead + + ] & 0xFF ; result | = ( b & 0x7f ) < < 14 ; if ( ( b & 0x80 ) ! = 0 ) { b = compressed [ compressedOffset + bytesRead + + ] & 0xFF ; result | = ( b & 0x7f ) < < 21 ; if ( ( b & 0x80 ) ! = 0 ) { b = compressed [ compressedOffset + bytesRead + + ] & 0xFF ; result | = ( b & 0x7f ) < < 28 ; if ( ( b & 0x80 ) ! = 0 ) { throw new NumberFormatException ( " last byte of variable length int has high bit set " ) ; } } } } } } return new int [ ] { result , bytesRead } ; }
public static int lookupShort ( short [ ] data , int index ) { return memory . lookupShort ( data , index ) ; }
public static int loadByte ( byte [ ] data , int index ) { return memory . loadByte ( data , index ) ; }
public int lookupShort ( short [ ] data , int index ) { assert index > = 0 ; assert index < = data . length ; return unsafe . getShort ( data , SHORT_ARRAY_OFFSET + ( index * SHORT_ARRAY_STRIDE ) ) & 0xFFFF ; }
public int loadByte ( byte [ ] data , int index ) { assert index > = 0 ; assert index < = data . length ; return unsafe . getByte ( data , BYTE_ARRAY_OFFSET + index ) & 0xFF ; }
public int loadInt ( byte [ ] data , int index ) { assert index > = 0 ; assert index + 4 < = data . length ; return unsafe . getInt ( data , BYTE_ARRAY_OFFSET + index ) ; }
public void copyLong ( byte [ ] src , int srcIndex , byte [ ] dest , int destIndex ) { assert srcIndex > = 0 ; assert srcIndex + 8 < = src . length ; assert destIndex > = 0 ; assert destIndex + 8 < = dest . length ; long value = unsafe . getLong ( src , BYTE_ARRAY_OFFSET + srcIndex ) ; unsafe . putLong ( dest , ( BYTE_ARRAY_OFFSET + destIndex ) , value ) ; }
public long loadLong ( byte [ ] data , int index ) { assert index > 0 ; assert index + 4 < data . length ; return unsafe . getLong ( data , BYTE_ARRAY_OFFSET + index ) ; }
public static void main ( String [ ] args ) { System . err . printf ( " Running micro-benchmarks. \ n " ) ; System . err . printf ( " %-18s %10s %10s %10s %10s \ n " , " Benchmark " , " Size " , " Time(ns) " , " Iterations " , " Throughput " ) ; System . err . printf ( " -------------------------------------------------------------- \ n " ) ; SnappyBench snappyBench = new SnappyBench ( ) ; // verify implementation with a round trip for every input snappyBench.verify(); // warm up the code paths so hotspot inlines the code snappyBench.warmUp(); // Easy to use individual tests // TestSuite testSuite = Uncompress; // for (int i = 0; i < 100; i++) { // snappyBench.run(testSuite, "jpg", 0); // // snappyBench.run(testSuite, "lsp", 0); //// snappyBench.run(testSuite, "bin", 0); // snappyBench.run(testSuite, "man", 0); // snappyBench.run(testSuite, "c", 0); // snappyBench.run(testSuite, "cp", 0); // // // ok //// snappyBench.run(testSuite, "xls", 0); // // // bad //// snappyBench.run(testSuite, "txt1", 0); //// snappyBench.run(testSuite, "txt2", 0); //// snappyBench.run(testSuite, "txt3", 0); // snappyBench.run(testSuite, "txt4", 0); // snappyBench.run(testSuite, "sum", 0); // } // snappyBench.run(Compress); snappyBench.run(Uncompress);
public void verify ( ) { for ( String testName : files . keySet ( ) ) { byte [ ] contents = readTestDataFile ( files . get ( testName ) ) ;
private void run ( TestSuite testSuite , String testName , int testNumber ) { run ( testSuite , testName , testNumber , false ) ; run ( testSuite , testName , testNumber , true ) ; System . err . println ( ) ; }
private void run ( TestSuite testSuite , String testName , int testNumber , boolean useJni ) { // Run a few iterations first to find out approximately how fast // the benchmark is. resetBenchmarkTiming(); startBenchmarkTiming(); if (testSuite == Compress) { benchmarkCompress(CALIBRATE_ITERATIONS, testName, useJni); } else if (testSuite == Uncompress) { benchmarkUncompress(CALIBRATE_ITERATIONS, testName, useJni); } else { throw new AssertionError("Unexpected testSuite " + testSuite); } stopBenchmarkTiming(); // Let each test case run for about 200ms, but at least as many // as we used to calibrate. // Run five times and pick the median. long iterations = 0; if (benchmarkRealTimeUsec > 0) { iterations = 400000 * CALIBRATE_ITERATIONS / benchmarkRealTimeUsec; } iterations = Math.max(iterations, CALIBRATE_ITERATIONS); long[] benchmarkRuns = new long[NUMBER_OF_RUNS]; for (int run = 0; run < NUMBER_OF_RUNS; ++run) { resetBenchmarkTiming(); startBenchmarkTiming(); if (testSuite == Compress) { benchmarkCompress(iterations, testName, useJni); } else if (testSuite == Uncompress) { benchmarkUncompress(iterations, testName, useJni); } else { throw new AssertionError("Unexpected testSuite " + testSuite); } stopBenchmarkTiming(); benchmarkRuns[run] = benchmarkRealTimeUsec; } long realTimeUs = getMedianValue(benchmarkRuns); long bytesPerSecond = benchmarkBytesProcessed * 1000000 / realTimeUs; String heading; if (useJni) { heading = format("%s/%d/jni", testSuite, testNumber); } else { heading = format("%s/%d/java", testSuite, testNumber); } String humanReadableSpeed; if (bytesPerSecond < 1024) { humanReadableSpeed = format("%dB/s", bytesPerSecond); } else if (bytesPerSecond < 1024 * 1024) { humanReadableSpeed = format("%.1fkB/s", bytesPerSecond / 1024.0f); } else if (bytesPerSecond < 1024 * 1024 * 1024) { humanReadableSpeed = format("%.1fMB/s", bytesPerSecond / (1024.0f * 1024.0f)); } else { humanReadableSpeed = format("%.1fGB/s", bytesPerSecond / (1024.0f * 1024.0f * 1024.0f)); } int size = readTestDataFile(files.get(testName)).length; System.err.printf( "%-18s %10d %10d %10d %10s %s\n",
public static void main ( String [ ] args ) { System . err . printf ( " Running micro-benchmarks. \ n " ) ; SnappyBench snappyBench = new SnappyBench ( ) ; // verify implementation with a round trip for every input snappyBench.verify(); // warm up the code paths so hot spot optimizes the code snappyBench.warmUp(); // Easy to use individual tests // for (int i = 0; i < 100; i++) { // snappyBench.runUncompress(TestData.txt1); // snappyBench.runUncompress(TestData.txt2); // snappyBench.runUncompress(TestData.txt3); // snappyBench.runUncompress(TestData.txt4); // snappyBench.runUncompress(TestData.sum); // snappyBench.runUncompress(TestData.lsp); // snappyBench.runUncompress(TestData.man); // snappyBench.runUncompress(TestData.c); // snappyBench.runUncompress(TestData.cp); // } snappyBench.runCompress(); snappyBench.runUncompress(); }
public void verify ( ) { for ( TestData testData : TestData . values ( ) ) { byte [ ] contents = testData . getContents ( ) ;
public void runCompress ( ) { System . err . println ( ) ; System . err . printf ( " %-12s %10s %10s %10s %10s %8s \ n " , " Benchmark " , " Size " , " Compress " , " JNI " , " Java " , " Change " ) ; System . err . printf ( " ----------------------------------------------------------------- \ n " ) ; for ( TestData testData : TestData . values ( ) ) { runCompress ( testData ) ;
private void runCompress ( TestData testData ) { long iterations = calibrateIterations ( testData , true ) ; // JNI long[] jniBenchmarkRuns = new long[NUMBER_OF_RUNS]; for (int run = 0; run < NUMBER_OF_RUNS; ++run) { jniBenchmarkRuns[run] = benchmarkCompressJava(testData, iterations); } long jniMedianTimeInNanos = getMedianValue(jniBenchmarkRuns); long jniBytesPerSecond = (long) (1.0 * benchmarkBytesProcessed / nanosToSeconds(jniMedianTimeInNanos)); // Java long[] javaBenchmarkRuns = new long[NUMBER_OF_RUNS]; for (int run = 0; run < NUMBER_OF_RUNS; ++run) { javaBenchmarkRuns[run] = benchmarkCompressJni(testData, iterations); } long javaMedianTimeInNanos = getMedianValue(javaBenchmarkRuns); long javaBytesPerSecond = (long) (1.0 * benchmarkBytesProcessed / nanosToSeconds(javaMedianTimeInNanos)); // results String heading = format("Compress/%d", testData.ordinal()); String javaHumanReadableSpeed = toHumanReadableSpeed(javaBytesPerSecond); String jniHumanReadableSpeed = toHumanReadableSpeed(jniBytesPerSecond); double improvement = 100.0d * (jniBytesPerSecond - javaBytesPerSecond) / jniBytesPerSecond; System.err.printf( "%-12s %10d %+9.1f%% %10s %10s %+7.1f%% %s\n",
public long benchmarkCompressJni ( TestData testData , long iterations ) { // Read the file and create buffers out side of timing byte[] contents = testData.getContents(); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; // based on compressed size setBenchmarkBytesProcessed(iterations * contents.length); long start = System.nanoTime(); while (iterations-- > 0) { try { org.xerial.snappy.Snappy.compress(contents, 0, contents.length, compressed, 0); } catch (IOException e) { throw Throwables.propagate(e); } } long timeInNanos = System.nanoTime() - start; return timeInNanos; }
public long benchmarkCompressJava ( TestData testData , long iterations ) { // Read the file and create buffers out side of timing byte[] contents = testData.getContents(); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; // based on compressed size setBenchmarkBytesProcessed(iterations * contents.length); long start = System.nanoTime(); while (iterations-- > 0) { Snappy.compress(contents, 0, contents.length, compressed, 0); } long timeInNanos = System.nanoTime() - start; return timeInNanos; }
public void runUncompress ( ) { System . err . println ( ) ; System . err . printf ( " %-12s %10s %10s %10s %10s %8s \ n " , " Benchmark " , " Size " , " Compress " , " JNI " , " Java " , " Change " ) ; System . err . printf ( " ----------------------------------------------------------------- \ n " ) ; for ( TestData testData : TestData . values ( ) ) { runUncompress ( testData ) ;
private void runUncompress ( TestData testData ) { long iterations = calibrateIterations ( testData , false ) ; // JNI long[] jniBenchmarkRuns = new long[NUMBER_OF_RUNS]; for (int run = 0; run < NUMBER_OF_RUNS; ++run) { jniBenchmarkRuns[run] = benchmarkUncompressJava(testData, iterations); } long jniMedianTimeInNanos = getMedianValue(jniBenchmarkRuns); long jniBytesPerSecond = (long) (1.0 * benchmarkBytesProcessed / nanosToSeconds(jniMedianTimeInNanos)); // Java long[] javaBenchmarkRuns = new long[NUMBER_OF_RUNS]; for (int run = 0; run < NUMBER_OF_RUNS; ++run) { javaBenchmarkRuns[run] = benchmarkUncompressJni(testData, iterations); } long javaMedianTimeInNanos = getMedianValue(javaBenchmarkRuns); long javaBytesPerSecond = (long) (1.0 * benchmarkBytesProcessed / nanosToSeconds(javaMedianTimeInNanos)); // results String heading = format("Compress/%d", testData.ordinal()); String javaHumanReadableSpeed = toHumanReadableSpeed(javaBytesPerSecond); String jniHumanReadableSpeed = toHumanReadableSpeed(jniBytesPerSecond); double improvement = 100.0d * (jniBytesPerSecond - javaBytesPerSecond) / jniBytesPerSecond; System.err.printf( "%-12s %10d %+9.1f%% %10s %10s %+7.1f%% %s\n",
public long benchmarkUncompressJni ( TestData testData , long iterations ) { // Read the file and create buffers out side of timing byte[] contents = testData.getContents(); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; int compressedSize = Snappy.compress(contents, 0, contents.length, compressed, 0); byte[] uncompressed = new byte[contents.length]; // based on uncompressed size setBenchmarkBytesProcessed(iterations * contents.length); long start = System.nanoTime(); while (iterations-- > 0) { try { org.xerial.snappy.Snappy.uncompress(compressed, 0, compressedSize, uncompressed, 0); } catch (IOException e) { throw Throwables.propagate(e); } } long timeInNanos = System.nanoTime() - start; // verify results if (!Arrays.equals(uncompressed, testData.getContents())) { throw new AssertionError(String.format( "Actual : %s\n" + "Expected : %s", Arrays.toString(uncompressed), Arrays.toString(testData.getContents()))); } return timeInNanos; }
public long benchmarkUncompressJava ( TestData testData , long iterations ) { // Read the file and create buffers out side of timing byte[] contents = testData.getContents(); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; int compressedSize = Snappy.compress(contents, 0, contents.length, compressed, 0); byte[] uncompressed = new byte[contents.length]; // based on uncompressed size setBenchmarkBytesProcessed(iterations * contents.length); long start = System.nanoTime(); while (iterations-- > 0) { Snappy.uncompress(compressed, 0, compressedSize, uncompressed, 0); } long timeInNanos = System.nanoTime() - start; // verify results if (!Arrays.equals(uncompressed, testData.getContents())) { throw new AssertionError(String.format( "Actual : %s\n" + "Expected : %s", Arrays.toString(uncompressed), Arrays.toString(testData.getContents()))); } return timeInNanos; }
private long calibrateIterations ( TestData testData , boolean compression ) { // Run a few iterations first to find out approximately how fast // the benchmark is. long start = System.nanoTime(); if (compression) { benchmarkCompressJni(testData, CALIBRATE_ITERATIONS); } else { benchmarkUncompressJni(testData, CALIBRATE_ITERATIONS); } long timeInNanos = System.nanoTime() - start; // Let each test case run for about 200ms, but at least as many // as we used to calibrate. // Run five times and pick the median. long iterations = 0; if (timeInNanos > 0) { double iterationsPerSecond = CALIBRATE_ITERATIONS / nanosToSeconds(timeInNanos); iterations = (long) (SECONDS_PER_RUN * iterationsPerSecond); } iterations = Math.max(iterations, CALIBRATE_ITERATIONS); return iterations; }
private double nanosToSeconds ( long nanos ) { return 1.0 * nanos / TimeUnit . SECONDS . toNanos ( 1 ) ; }
private String toHumanReadableSpeed ( long bytesPerSecond ) { String humanReadableSpeed ; if ( bytesPerSecond < 1024 ) { humanReadableSpeed = format ( " %dB/s " , bytesPerSecond ) ; } else if ( bytesPerSecond < 1024 * 1024 ) { humanReadableSpeed = format ( " %.1fkB/s " , bytesPerSecond / 1024.0f ) ; } else if ( bytesPerSecond < 1024 * 1024 * 1024 ) { humanReadableSpeed = format ( " %.1fMB/s " , bytesPerSecond / ( 1024.0f * 1024.0f ) ) ; } else { humanReadableSpeed = format ( " %.1fGB/s " , bytesPerSecond / ( 1024.0f * 1024.0f * 1024.0f ) ) ; } return humanReadableSpeed ; }
public String getFileName ( ) { return fileName ; }
public byte [ ] getContents ( ) { return Arrays . copyOf ( contents , contents . length ) ; }
public int size ( ) { return contents . length ; }
public byte [ ] getCompressed ( ) { return Arrays . copyOf ( compressed , compressed . length ) ; }
public int compressedSize ( ) { return compressed . length ; }
public double getCompressionRatio ( ) { return compressionRatio ; }
private void runCompress ( TestData testData ) { long iterations = calibrateIterations ( testData , true ) ; // JNI long[] jniBenchmarkRuns = new long[NUMBER_OF_RUNS]; for (int run = 0; run < NUMBER_OF_RUNS; ++run) { jniBenchmarkRuns[run] = benchmarkCompressJni(testData, iterations); } long jniMedianTimeInNanos = getMedianValue(jniBenchmarkRuns); long jniBytesPerSecond = (long) (1.0 * benchmarkBytesProcessed / nanosToSeconds(jniMedianTimeInNanos)); // Java long[] javaBenchmarkRuns = new long[NUMBER_OF_RUNS]; for (int run = 0; run < NUMBER_OF_RUNS; ++run) { javaBenchmarkRuns[run] = benchmarkCompressJava(testData, iterations); } long javaMedianTimeInNanos = getMedianValue(javaBenchmarkRuns); long javaBytesPerSecond = (long) (1.0 * benchmarkBytesProcessed / nanosToSeconds(javaMedianTimeInNanos)); // results String heading = format("Compress/%d", testData.ordinal()); String javaHumanReadableSpeed = toHumanReadableSpeed(javaBytesPerSecond); String jniHumanReadableSpeed = toHumanReadableSpeed(jniBytesPerSecond); double improvement = 100.0d * (javaBytesPerSecond - jniBytesPerSecond) / jniBytesPerSecond; System.err.printf( "%-12s %10d %+9.1f%% %10s %10s %+7.1f%% %s\n",
private void runUncompress ( TestData testData ) { long iterations = calibrateIterations ( testData , false ) ; // JNI long[] jniBenchmarkRuns = new long[NUMBER_OF_RUNS]; for (int run = 0; run < NUMBER_OF_RUNS; ++run) { jniBenchmarkRuns[run] = benchmarkUncompressJni(testData, iterations); } long jniMedianTimeInNanos = getMedianValue(jniBenchmarkRuns); long jniBytesPerSecond = (long) (1.0 * benchmarkBytesProcessed / nanosToSeconds(jniMedianTimeInNanos)); // Java long[] javaBenchmarkRuns = new long[NUMBER_OF_RUNS]; for (int run = 0; run < NUMBER_OF_RUNS; ++run) { javaBenchmarkRuns[run] = benchmarkUncompressJava(testData, iterations); } long javaMedianTimeInNanos = getMedianValue(javaBenchmarkRuns); long javaBytesPerSecond = (long) (1.0 * benchmarkBytesProcessed / nanosToSeconds(javaMedianTimeInNanos)); // results String heading = format("Compress/%d", testData.ordinal()); String javaHumanReadableSpeed = toHumanReadableSpeed(javaBytesPerSecond); String jniHumanReadableSpeed = toHumanReadableSpeed(jniBytesPerSecond); double improvement = 100.0d * (javaBytesPerSecond - jniBytesPerSecond) / jniBytesPerSecond; System.err.printf( "%-12s %10d %+9.1f%% %10s %10s %+7.1f%% %s\n",
public static int compress ( final byte [ ] uncompressed , final int uncompressedOffset , final int uncompressedLength , final byte [ ] compressed , final int compressedOffset ) { // First write the uncompressed size to the output as a variable length int int compressedIndex = writeUncompressedLength(compressed, compressedOffset, uncompressedLength); int hashTableSize = getHashTableSize(uncompressedLength); short[] table = new short[hashTableSize]; for (int read = 0; read < uncompressedLength; read += BLOCK_SIZE) { // Get encoding table for compression Arrays.fill(table, (short) 0); compressedIndex = compressFragment( uncompressed, uncompressedOffset + read, Math.min(uncompressedLength - read, BLOCK_SIZE), compressed, compressedIndex, table); } return compressedIndex - compressedOffset; }
private static int [ ] emitCopies ( byte [ ] input , final int inputOffset , final int inputSize , int ipIndex , byte [ ] output , int outputIndex , short [ ] table , int shift , int candidateIndex ) { // Step 3: Call EmitCopy, and then see if another EmitCopy could // be our next move. Repeat until we find no match for the // input immediately after what was consumed by the last EmitCopy call. // // If we exit this loop normally then we need to call EmitLiteral next, // though we don't yet know how big the literal will be. We handle that // by proceeding to the next iteration of the main loop. We also can exit // this loop via goto if we get close to exhausting the input. int inputBytes; do { // We have a 4-byte match at ip, and no need to emit any // "literal bytes" prior to ip. int matched = 4 + findMatchLength(input, candidateIndex + 4, input, ipIndex + 4, inputOffset + inputSize); int offset = ipIndex - candidateIndex; assert SnappyInternalUtils.equals(input, ipIndex, input, candidateIndex, matched); ipIndex += matched; // emit the copy operation for this chunk outputIndex = emitCopy(output, outputIndex, offset, matched); // are we done? if (ipIndex >= inputOffset + inputSize - INPUT_MARGIN_BYTES) { return new int[]{ipIndex, outputIndex}; } // We could immediately start working at ip now, but to improve // compression we first update table[Hash(ip - 1, ...)]. int prevInt; if (SnappyInternalUtils.HAS_UNSAFE) { long foo = SnappyInternalUtils.loadLong(input, ipIndex - 1); prevInt = (int) foo; inputBytes = (int) (foo >>> 8); } else { prevInt = SnappyInternalUtils.loadInt(input, ipIndex - 1); inputBytes = SnappyInternalUtils.loadInt(input, ipIndex); } // add hash starting with previous byte int prevHash = hashBytes(prevInt, shift); table[prevHash] = (short) (ipIndex - inputOffset - 1); // update hash of current byte int curHash = hashBytes(inputBytes, shift); candidateIndex = inputOffset + table[curHash]; table[curHash] = (short) (ipIndex - inputOffset); } while (inputBytes == SnappyInternalUtils.loadInt(input, candidateIndex)); return new int[]{ipIndex, outputIndex}; }
private static int getHashTableSize ( int inputSize ) { // Use smaller hash table when input.size() is smaller, since we // fill the table, incurring O(hash table size) overhead for // compression, and if the input is short, we won't need that // many hash table entries anyway. assert (MAX_HASH_TABLE_SIZE >= 256); int hashTableSize = 256; while (hashTableSize < MAX_HASH_TABLE_SIZE && hashTableSize < inputSize) { hashTableSize <<= 1; } assert 0 == (hashTableSize & (hashTableSize - 1)) : "hash must be power of two"; assert hashTableSize <= MAX_HASH_TABLE_SIZE : "hash table too large"; return hashTableSize;
public long compress ( TestData testData , long iterations ) { // Read the file and create buffers out side of timing byte[] contents = testData.getContents(); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; long start = System.nanoTime(); while (iterations-- > 0) { Snappy.compress(contents, 0, contents.length, compressed, 0); } long timeInNanos = System.nanoTime() - start; return timeInNanos; }
public long uncompress ( TestData testData , long iterations ) { // Read the file and create buffers out side of timing byte[] contents = testData.getContents(); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; int compressedSize = Snappy.compress(contents, 0, contents.length, compressed, 0); byte[] uncompressed = new byte[contents.length]; long start = System.nanoTime(); while (iterations-- > 0) { Snappy.uncompress(compressed, 0, compressedSize, uncompressed, 0); } long timeInNanos = System.nanoTime() - start; // verify results if (!Arrays.equals(uncompressed, testData.getContents())) { throw new AssertionError(String.format( "Actual : %s\n" + "Expected : %s", Arrays.toString(uncompressed), Arrays.toString(testData.getContents()))); } return timeInNanos; }
public double getCompressionRatio ( TestData testData ) { byte [ ] contents = testData . getContents ( ) ; byte [ ] compressed = new byte [ Snappy . maxCompressedLength ( contents . length ) ] ; int compressedSize = Snappy . compress ( contents , 0 , contents . length , compressed , 0 ) ; return 1.0 * ( contents . length - compressedSize ) / contents . length ; }
public long compress ( TestData testData , long iterations ) { // Read the file and create buffers out side of timing byte[] contents = testData.getContents(); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; long start = System.nanoTime(); while (iterations-- > 0) { try { org.xerial.snappy.Snappy.compress(contents, 0, contents.length, compressed, 0); } catch (IOException e) { throw Throwables.propagate(e); } } long timeInNanos = System.nanoTime() - start; return timeInNanos; }
public long uncompress ( TestData testData , long iterations ) { // Read the file and create buffers out side of timing byte[] contents = testData.getContents(); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; int compressedSize = Snappy.compress(contents, 0, contents.length, compressed, 0); byte[] uncompressed = new byte[contents.length]; long start = System.nanoTime(); while (iterations-- > 0) { try { org.xerial.snappy.Snappy.uncompress(compressed, 0, compressedSize, uncompressed, 0); } catch (IOException e) { throw Throwables.propagate(e); } } long timeInNanos = System.nanoTime() - start; // verify results if (!Arrays.equals(uncompressed, testData.getContents())) { throw new AssertionError(String.format( "Actual : %s\n" + "Expected : %s", Arrays.toString(uncompressed), Arrays.toString(testData.getContents()))); } return timeInNanos; }
public double getCompressionRatio ( TestData testData ) { byte [ ] contents = testData . getContents ( ) ; byte [ ] compressed = new byte [ Snappy . maxCompressedLength ( contents . length ) ] ; int compressedSize ; try { compressedSize = org . xerial . snappy . Snappy . compress ( contents , 0 , contents . length , compressed , 0 ) ; } catch ( IOException e ) { throw Throwables . propagate ( e ) ; } return 1.0 * ( contents . length - compressedSize ) / contents . length ; }
public long compress ( TestData testData , long iterations ) { try {
public long uncompress ( TestData testData , long iterations ) { try {
public double getCompressionRatio ( TestData testData ) { byte [ ] contents = testData . getContents ( ) ; int compressedSize ; try { ByteArrayOutputStream rawOut = new ByteArrayOutputStream ( ) ; SnappyOutputStream out = new SnappyOutputStream ( rawOut ) ; out . write ( contents ) ; out . close ( ) ; compressedSize = rawOut . size ( ) ; } catch ( IOException e ) { throw Throwables . propagate ( e ) ; } return 1.0 * ( contents . length - compressedSize ) / contents . length ; }
public double getCompressionRatio ( TestData testData ) { byte [ ] contents = testData . getContents ( ) ; int compressedSize ; try { ByteArrayOutputStream rawOut = new ByteArrayOutputStream ( ) ; org . xerial . snappy . SnappyOutputStream out = new org . xerial . snappy . SnappyOutputStream ( rawOut ) ; out . write ( contents ) ; out . close ( ) ; compressedSize = rawOut . size ( ) ; } catch ( IOException e ) { throw Throwables . propagate ( e ) ; } return 1.0 * ( contents . length - compressedSize ) / contents . length ; }
public abstract long compress ( TestData testData , long iterations ) ; public abstract long uncompress ( TestData testData , long iterations ) ; public abstract double getCompressionRatio ( TestData testData ) ; }
public abstract long uncompress ( TestData testData , long iterations ) ; public abstract double getCompressionRatio ( TestData testData ) ; }
public abstract double getCompressionRatio ( TestData testData ) ; }
public static void main ( String [ ] args ) { System . err . printf ( " Running micro-benchmarks. \ n " ) ; SnappyBench snappyBench = new SnappyBench ( ) ; // verify implementation with a round trip for every input snappyBench.verify(); // warm up the code paths so hot spot optimizes the code snappyBench.warmUp(); // Easy to use individual tests // for (int i = 0; i < 100; i++) { // snappyBench.runUncompress(TestData.txt1); // snappyBench.runUncompress(TestData.txt2); // snappyBench.runUncompress(TestData.txt3); // snappyBench.runUncompress(TestData.txt4); // snappyBench.runUncompress(TestData.sum); // snappyBench.runUncompress(TestData.lsp); // snappyBench.runUncompress(TestData.man); // snappyBench.runUncompress(TestData.c); // snappyBench.runUncompress(TestData.cp); // } snappyBench.runCompress("Block Compress", BenchmarkDriver.JNI_BLOCK, BenchmarkDriver.JAVA_BLOCK); snappyBench.runUncompress("Block Uncompress", BenchmarkDriver.JNI_BLOCK, BenchmarkDriver.JAVA_BLOCK); snappyBench.runCompress("Stream Compress", BenchmarkDriver.JNI_STREAM, BenchmarkDriver.JAVA_STREAM); snappyBench.runUncompress("Stream Uncompress", BenchmarkDriver.JNI_STREAM, BenchmarkDriver.JAVA_STREAM); }
public void verify ( ) { for ( TestData testData : TestData . values ( ) ) { byte [ ] contents = testData . getContents ( ) ; byte [ ] compressed = new byte [ Snappy . maxCompressedLength ( contents . length ) ] ; int compressedSize = Snappy . compress ( contents , 0 , contents . length , compressed , 0 ) ; byte [ ] uncompressed = new byte [ contents . length ] ; Snappy . uncompress ( compressed , 0 , compressedSize , uncompressed , 0 ) ; if ( ! Arrays . equals ( uncompressed , testData . getContents ( ) ) ) { throw new AssertionError ( " Failed for " + testData ) ; } Arrays . fill ( uncompressed , ( byte ) 0 ) ; compressed = Arrays . copyOf ( compressed , compressedSize ) ; Snappy . uncompress ( compressed , 0 , compressedSize , uncompressed , 0 ) ; if ( ! Arrays . equals ( uncompressed , testData . getContents ( ) ) ) { throw new AssertionError ( " Failed for " + testData ) ; } } for ( TestData testData : TestData . values ( ) ) { try {
private static void printHeader ( String benchmarkTitle ) { System . err . println ( ) ; System . err . println ( ) ; System . err . println ( benchmarkTitle ) ; System . err . println ( ) ; System . err . printf ( " %-8s %8s %9s %9s %11s %11s %7s \ n " , " " , " " , " JNI " , " Java " , " JNI " , " Java " , " " ) ; System . err . printf ( " %-8s %8s %9s %9s %11s %11s %7s \ n " , " Input " , " Size " , " Compress " , " Compress " , " Throughput " , " Throughput " , " Change " ) ; System . err . printf ( " --------------------------------------------------------------------- \ n " ) ; }
public void runCompress ( String benchmarkTitle , BenchmarkDriver oldDriver , BenchmarkDriver newDriver ) { printHeader ( benchmarkTitle ) ; for ( TestData testData : TestData . values ( ) ) { runCompress ( testData , oldDriver , newDriver ) ;
private void runCompress ( TestData testData , BenchmarkDriver oldDriver , BenchmarkDriver newDriver ) { long iterations = calibrateIterations ( testData , oldDriver , true ) ; long oldBytesPerSecond = benchmarkCompress ( testData , oldDriver , iterations ) ; long newBytesPerSecond = benchmarkCompress ( testData , newDriver , iterations ) ; // results String oldHumanReadableSpeed = toHumanReadableSpeed(oldBytesPerSecond); String newHumanReadableSpeed = toHumanReadableSpeed(newBytesPerSecond); double improvement = 100.0d * (newBytesPerSecond - oldBytesPerSecond) / oldBytesPerSecond; System.err.printf( "%-8s %8d %8.1f%% %8.1f%% %11s %11s %+6.1f%% %s\n",
private long benchmarkCompress ( TestData testData , BenchmarkDriver driver , long iterations ) { long [ ] firstBenchmarkRuns = new long [ NUMBER_OF_RUNS ] ; for ( int run = 0 ; run < NUMBER_OF_RUNS ; + + run ) { firstBenchmarkRuns [ run ] = driver . compress ( testData , iterations ) ; } long firstMedianTimeInNanos = getMedianValue ( firstBenchmarkRuns ) ; return ( long ) ( 1.0 * iterations * testData . size ( ) / nanosToSeconds ( firstMedianTimeInNanos ) ) ; }
public void runUncompress ( String benchmarkTitle , BenchmarkDriver oldDriver , BenchmarkDriver newDriver ) { printHeader ( benchmarkTitle ) ; for ( TestData testData : TestData . values ( ) ) { runUncompress ( testData , oldDriver , newDriver ) ;
private void runUncompress ( TestData testData , BenchmarkDriver oldDriver , BenchmarkDriver newDriver ) { long iterations = calibrateIterations ( testData , oldDriver , false ) ; long oldBytesPerSecond = benchmarkUncompress ( testData , oldDriver , iterations ) ; long newBytesPerSecond = benchmarkUncompress ( testData , newDriver , iterations ) ; // results String newHumanReadableSpeed = toHumanReadableSpeed(newBytesPerSecond); String oldHumanReadableSpeed = toHumanReadableSpeed(oldBytesPerSecond); double improvement = 100.0d * (newBytesPerSecond - oldBytesPerSecond) / oldBytesPerSecond; System.err.printf( "%-8s %8d %8.1f%% %8.1f%% %11s %11s %+6.1f%% %s\n",
private long benchmarkUncompress ( TestData testData , BenchmarkDriver driver , long iterations ) { long [ ] jniBenchmarkRuns = new long [ NUMBER_OF_RUNS ] ; for ( int run = 0 ; run < NUMBER_OF_RUNS ; + + run ) { jniBenchmarkRuns [ run ] = driver . uncompress ( testData , iterations ) ; } long jniMedianTimeInNanos = getMedianValue ( jniBenchmarkRuns ) ; return ( long ) ( 1.0 * iterations * testData . size ( ) / nanosToSeconds ( jniMedianTimeInNanos ) ) ; }
private long calibrateIterations ( TestData testData , BenchmarkDriver driver , boolean compression ) { // Run a few iterations first to find out approximately how fast // the benchmark is. long start = System.nanoTime(); if (compression) { driver.compress(testData, CALIBRATE_ITERATIONS); } else { driver.uncompress(testData, CALIBRATE_ITERATIONS); } long timeInNanos = System.nanoTime() - start; // Let each test case run for about 200ms, but at least as many // as we used to calibrate. // Run five times and pick the median. long iterations = 0; if (timeInNanos > 0) { double iterationsPerSecond = CALIBRATE_ITERATIONS / nanosToSeconds(timeInNanos); iterations = (long) (SECONDS_PER_RUN * iterationsPerSecond); } iterations = Math.max(iterations, CALIBRATE_ITERATIONS); return iterations; }
public boolean isCompressibleData ( ) { return compressibleData ; }
public String getInfo ( ) { if ( compressibleData ) { return name ( ) ;
public long roundTrip ( TestData testData , long iterations ) { // Read the file and create buffers out side of timing byte[] contents = testData.getContents(); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; byte[] uncompressed = new byte[contents.length]; long start = System.nanoTime(); while (iterations-- > 0) { int compressedSize = Snappy.compress(contents, 0, contents.length, compressed, 0); Snappy.uncompress(compressed, 0, compressedSize, uncompressed, 0); } long timeInNanos = System.nanoTime() - start; // verify results if (!Arrays.equals(uncompressed, testData.getContents())) { throw new AssertionError(String.format( "Actual : %s\n" + "Expected : %s", Arrays.toString(uncompressed), Arrays.toString(testData.getContents()))); } return timeInNanos; }
public long uncompress ( TestData testData , long iterations ) { // Read the file and create buffers out side of timing byte[] contents = testData.getContents(); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; int compressedSize = Snappy.compress(contents, 0, contents.length, compressed, 0); byte[] uncompressed = new byte[contents.length]; long timeInNanos; try { long start = System.nanoTime(); while (iterations-- > 0) { org.xerial.snappy.Snappy.uncompress(compressed, 0, compressedSize, uncompressed, 0); } timeInNanos = System.nanoTime() - start; } catch (IOException e) { throw Throwables.propagate(e); } // verify results if (!Arrays.equals(uncompressed, testData.getContents())) { throw new AssertionError(String.format( "Actual : %s\n" + "Expected : %s", Arrays.toString(uncompressed), Arrays.toString(testData.getContents()))); } return timeInNanos; }
public long roundTrip ( TestData testData , long iterations ) { // Read the file and create buffers out side of timing byte[] contents = testData.getContents(); byte[] compressed = new byte[Snappy.maxCompressedLength(contents.length)]; byte[] uncompressed = new byte[contents.length]; long timeInNanos; try { long start = System.nanoTime(); while (iterations-- > 0) { int compressedSize = Snappy.compress(contents, 0, contents.length, compressed, 0); org.xerial.snappy.Snappy.uncompress(compressed, 0, compressedSize, uncompressed, 0); } timeInNanos = System.nanoTime() - start; } catch (IOException e) { throw Throwables.propagate(e); } // verify results if (!Arrays.equals(uncompressed, testData.getContents())) { throw new AssertionError(String.format( "Actual : %s\n" + "Expected : %s", Arrays.toString(uncompressed), Arrays.toString(testData.getContents()))); } return timeInNanos; }
public long compress ( TestData testData , long iterations ) { try { // Read the file and create buffers out side of timing
public long roundTrip ( TestData testData , long iterations ) { try { // Read the file and create buffers out side of timing
public long roundTrip ( TestData testData , long iterations ) { try {
public abstract long compress ( TestData testData , long iterations ) ; public abstract long uncompress ( TestData testData , long iterations ) ; public abstract long roundTrip ( TestData testData , long iterations ) ; public abstract double getCompressionRatio ( TestData testData ) ; }
public abstract long uncompress ( TestData testData , long iterations ) ; public abstract long roundTrip ( TestData testData , long iterations ) ; public abstract double getCompressionRatio ( TestData testData ) ; }
public abstract long roundTrip ( TestData testData , long iterations ) ; public abstract double getCompressionRatio ( TestData testData ) ; }
public static void main ( String [ ] args ) { System . err . printf ( " Running micro-benchmarks. \ n " ) ; SnappyBench snappyBench = new SnappyBench ( ) ; // verify implementation with a round trip for every input snappyBench.verify(); // warm up the code paths so hot spot optimizes the code snappyBench.warmUp(); // Easy to use individual tests // for (int i = 0; i < 100; i++) { // snappyBench.runUncompress(TestData.txt1); // snappyBench.runUncompress(TestData.txt2); // snappyBench.runUncompress(TestData.txt3); // snappyBench.runUncompress(TestData.txt4); // snappyBench.runUncompress(TestData.sum); // snappyBench.runUncompress(TestData.lsp); // snappyBench.runUncompress(TestData.man); // snappyBench.runUncompress(TestData.c); // snappyBench.runUncompress(TestData.cp); // } snappyBench.runCompress("Block Compress", BenchmarkDriver.JNI_BLOCK, BenchmarkDriver.JAVA_BLOCK); snappyBench.runUncompress("Block Uncompress", BenchmarkDriver.JNI_BLOCK, BenchmarkDriver.JAVA_BLOCK); snappyBench.runRoundTrip("Block Round Trip", BenchmarkDriver.JNI_BLOCK, BenchmarkDriver.JAVA_BLOCK); snappyBench.runCompress("Stream Compress", BenchmarkDriver.JNI_STREAM, BenchmarkDriver.JAVA_STREAM); snappyBench.runUncompress("Stream Uncompress", BenchmarkDriver.JNI_STREAM, BenchmarkDriver.JAVA_STREAM); snappyBench.runRoundTrip("Stream RoundTrip", BenchmarkDriver.JNI_STREAM, BenchmarkDriver.JAVA_STREAM); }
public void runRoundTrip ( String benchmarkTitle , BenchmarkDriver oldDriver , BenchmarkDriver newDriver ) { printHeader ( benchmarkTitle ) ; for ( TestData testData : TestData . values ( ) ) { runRoundTrip ( testData , oldDriver , newDriver ) ;
private void runRoundTrip ( TestData testData , BenchmarkDriver oldDriver , BenchmarkDriver newDriver ) { long iterations = calibrateIterations ( testData , oldDriver , true ) ; long oldBytesPerSecond = benchmarkRoundTrip ( testData , oldDriver , iterations ) ; long newBytesPerSecond = benchmarkRoundTrip ( testData , newDriver , iterations ) ; // results String newHumanReadableSpeed = toHumanReadableSpeed(newBytesPerSecond); String oldHumanReadableSpeed = toHumanReadableSpeed(oldBytesPerSecond); double improvement = 100.0d * (newBytesPerSecond - oldBytesPerSecond) / oldBytesPerSecond; System.err.printf( "%-8s %8d %8.1f%% %8.1f%% %11s %11s %+6.1f%% %s\n",
private long benchmarkRoundTrip ( TestData testData , BenchmarkDriver driver , long iterations ) { long [ ] jniBenchmarkRuns = new long [ NUMBER_OF_RUNS ] ; for ( int run = 0 ; run < NUMBER_OF_RUNS ; + + run ) { jniBenchmarkRuns [ run ] = driver . roundTrip ( testData , iterations ) ; } long jniMedianTimeInNanos = getMedianValue ( jniBenchmarkRuns ) ; return ( long ) ( 1.0 * iterations * testData . size ( ) / nanosToSeconds ( jniMedianTimeInNanos ) ) ; }
public static BufferRecycler instance ( ) { SoftReference < BufferRecycler > ref = recyclerRef . get ( ) ; BufferRecycler bufferRecycler ; if ( ref = = null ) { bufferRecycler = null ; } else { bufferRecycler = ref . get ( ) ; } if ( bufferRecycler = = null ) { bufferRecycler = new BufferRecycler ( ) ; recyclerRef . set ( new SoftReference < BufferRecycler > ( bufferRecycler ) ) ; } return bufferRecycler ; }
public byte [ ] allocEncodingBuffer ( int minSize ) { byte [ ] buf = encodingBuffer ; if ( buf = = null | | buf . length < minSize ) { buf = new byte [ Math . max ( minSize , MIN_ENCODING_BUFFER ) ] ; } else { encodingBuffer = null ; } return buf ; }
public void releaseEncodeBuffer ( byte [ ] buffer ) { if ( encodingBuffer = = null | | buffer . length > encodingBuffer . length ) { encodingBuffer = buffer ;
public byte [ ] allocOutputBuffer ( int minSize ) { byte [ ] buf = outputBuffer ; if ( buf = = null | | buf . length < minSize ) { buf = new byte [ Math . max ( minSize , MIN_OUTPUT_BUFFER ) ] ; } else { outputBuffer = null ; } return buf ; }
public void releaseOutputBuffer ( byte [ ] buffer ) { if ( outputBuffer = = null | | ( buffer ! = null & & buffer . length > outputBuffer . length ) ) { outputBuffer = buffer ;
public int [ ] allocEncodingHash ( int suggestedSize ) { int [ ] buf = encodingHash ; if ( buf = = null | | buf . length < suggestedSize ) { buf = new int [ suggestedSize ] ; } else { encodingHash = null ; } return buf ; }
public void releaseEncodingHash ( int [ ] buffer ) { if ( encodingHash = = null | | ( buffer ! = null & & buffer . length > encodingHash . length ) ) { encodingHash = buffer ;
public byte [ ] allocInputBuffer ( int minSize ) { byte [ ] buf = inputBuffer ; if ( buf = = null | | buf . length < minSize ) { buf = new byte [ Math . max ( minSize , MIN_OUTPUT_BUFFER ) ] ; } else { inputBuffer = null ; } return buf ; }
public void releaseInputBuffer ( byte [ ] buffer ) { if ( inputBuffer = = null | | ( buffer ! = null & & buffer . length > inputBuffer . length ) ) { inputBuffer = buffer ;
public byte [ ] allocDecodeBuffer ( int size ) { byte [ ] buf = decodingBuffer ; if ( buf = = null | | buf . length < size ) { buf = new byte [ size ] ; } else { decodingBuffer = null ; } return buf ; }
public void releaseDecodeBuffer ( byte [ ] buffer ) { if ( decodingBuffer = = null | | ( buffer ! = null & & buffer . length > decodingBuffer . length ) ) { decodingBuffer = buffer ;
public void close ( ) throws IOException { try { in . close ( ) ;
public void write ( int b ) throws IOException { if ( position > = MAX_BLOCK_SIZE ) { flushBuffer ( ) ; } buffer [ position + + ] = ( byte ) b ; }
public void write ( byte [ ] input , int offset , int length ) throws IOException { int free = MAX_BLOCK_SIZE - position ; // easy case: enough free space in buffer for entire input if (free >= length) { copyToBuffer(input, offset, length); return; } // fill partial buffer as much as possible and flush if (position > 0) { copyToBuffer(input, offset, free); flushBuffer(); offset += free; length -= free; } // write remaining full blocks directly from input array while (length >= MAX_BLOCK_SIZE) { writeCompressed(input, offset, MAX_BLOCK_SIZE); offset += MAX_BLOCK_SIZE; length -= MAX_BLOCK_SIZE; } // copy remaining partial block into now-empty buffer copyToBuffer(input, offset, length); }
public void close ( ) throws IOException { try { flush ( ) ;
public double getCompressionRatio ( TestData testData ) { byte [ ] contents = testData . getContents ( ) ; int compressedSize ; try { ByteArrayOutputStream rawOut = new ByteArrayOutputStream ( Snappy . maxCompressedLength ( contents . length ) ) ; SnappyOutputStream out = new SnappyOutputStream ( rawOut ) ; out . write ( contents ) ; out . close ( ) ; compressedSize = rawOut . size ( ) ; } catch ( IOException e ) { throw Throwables . propagate ( e ) ; } return 1.0 * ( contents . length - compressedSize ) / contents . length ; }
public double getCompressionRatio ( TestData testData ) { byte [ ] contents = testData . getContents ( ) ; int compressedSize ; try { ByteArrayOutputStream rawOut = new ByteArrayOutputStream ( org . xerial . snappy . Snappy . maxCompressedLength ( contents . length ) ) ; org . xerial . snappy . SnappyOutputStream out = new org . xerial . snappy . SnappyOutputStream ( rawOut ) ; out . write ( contents ) ; out . close ( ) ; compressedSize = rawOut . size ( ) ; } catch ( IOException e ) { throw Throwables . propagate ( e ) ; } return 1.0 * ( contents . length - compressedSize ) / contents . length ; }
public void write ( int b ) { Preconditions . checkPositionIndex ( size + 1 , buffer . length ) ; buffer [ size + + ] = ( byte ) b ; }
public void write ( byte b [ ] , int off , int len ) { Preconditions . checkPositionIndex ( size + len , buffer . length ) ; System . arraycopy ( b , off , buffer , size , len ) ; size + = len ; }
public byte [ ] getBuffer ( ) { return buffer ; }
public byte [ ] toByteArray ( ) { return Arrays . copyOf ( buffer , size ) ; }
public int read ( ) throws IOException { if ( closed ) { return - 1 ; } if ( ! ensureBuffer ( ) ) { return - 1 ; } return buffer [ position + + ] ; }
public int read ( byte [ ] output , int offset , int length ) throws IOException { checkNotNull ( output , " output is null " ) ; checkPositionIndexes ( offset , offset + length , output . length ) ; if ( closed ) { throw new IOException ( " Stream is closed " ) ; } if ( length = = 0 ) { return 0 ; } if ( ! ensureBuffer ( ) ) { return - 1 ; } int size = min ( length , available ( ) ) ; System . arraycopy ( buffer , position , output , offset , size ) ; position + = size ; return size ; }
public int available ( ) throws IOException { if ( closed ) { return 0 ; } return valid - position ; }
private boolean readBlockHeader ( ) throws IOException { int offset = 0 ; while ( offset < header . length ) { int size = in . read ( header , offset , header . length - offset ) ; if ( size = = - 1 ) { // EOF on first byte means the stream ended cleanly if (offset == 0) { return false; } throw new EOFException("encountered EOF while reading block header"); } offset += size; } return true; }
static < T > T checkNotNull ( T reference , String errorMessageTemplate , Object . . . errorMessageArgs ) { if ( reference = = null ) { // If either of these parameters is null, the right thing happens anyway throw new NullPointerException(String.format(errorMessageTemplate, errorMessageArgs)); } return reference; }
static void checkArgument ( boolean expression , String errorMessageTemplate , Object . . . errorMessageArgs ) { if ( ! expression ) { throw new IllegalArgumentException ( String . format ( errorMessageTemplate , errorMessageArgs ) ) ;
public void write ( int b ) throws IOException { if ( closed ) { throw new IOException ( " Stream is closed " ) ; } if ( position > = MAX_BLOCK_SIZE ) { flushBuffer ( ) ; } buffer [ position + + ] = ( byte ) b ; }
public void write ( byte [ ] input , int offset , int length ) throws IOException { checkNotNull ( input , " input is null " ) ; checkPositionIndexes ( offset , offset + length , input . length ) ; if ( closed ) { throw new IOException ( " Stream is closed " ) ; } int free = MAX_BLOCK_SIZE - position ; // easy case: enough free space in buffer for entire input if (free >= length) { copyToBuffer(input, offset, length); return; } // fill partial buffer as much as possible and flush if (position > 0) { copyToBuffer(input, offset, free); flushBuffer(); offset += free; length -= free; } // write remaining full blocks directly from input array while (length >= MAX_BLOCK_SIZE) { writeCompressed(input, offset, MAX_BLOCK_SIZE); offset += MAX_BLOCK_SIZE; length -= MAX_BLOCK_SIZE; } // copy remaining partial block into now-empty buffer copyToBuffer(input, offset, length); }
public void flush ( ) throws IOException { if ( closed ) { throw new IOException ( " Stream is closed " ) ; } flushBuffer ( ) ; out . flush ( ) ; }
public static int getUncompressedLength ( byte [ ] compressed , int compressedOffset ) throws CorruptionException { return SnappyDecompressor . getUncompressedLength ( compressed , compressedOffset ) ; }
public static byte [ ] uncompress ( byte [ ] compressed , int compressedOffset , int compressedSize ) throws CorruptionException { return SnappyDecompressor . uncompress ( compressed , compressedOffset , compressedSize ) ; }
public static int uncompress ( byte [ ] compressed , int compressedOffset , int compressedSize , byte [ ] uncompressed , int uncompressedOffset ) throws CorruptionException { return SnappyDecompressor . uncompress ( compressed , compressedOffset , compressedSize , uncompressed , uncompressedOffset ) ; }
public static int getUncompressedLength ( byte [ ] compressed , int compressedOffset ) throws CorruptionException { return readUncompressedLength ( compressed , compressedOffset ) [ 0 ] ; }
public static byte [ ] uncompress ( byte [ ] compressed , int compressedOffset , int compressedSize ) throws CorruptionException { // Read the uncompressed length from the front of the compressed input int[] varInt = readUncompressedLength(compressed, compressedOffset); int expectedLength = varInt[0]; compressedOffset += varInt[1]; compressedSize -= varInt[1]; // allocate the uncompressed buffer byte[] uncompressed = new byte[expectedLength]; // Process the entire input int uncompressedSize = decompressAllTags( compressed, compressedOffset, compressedSize, uncompressed, 0); if (!(expectedLength == uncompressedSize)) { throw new CorruptionException(String.format("Recorded length is %s bytes but actual length after decompression is %s bytes ", expectedLength, uncompressedSize)); } return uncompressed; }
public static int uncompress ( byte [ ] compressed , int compressedOffset , int compressedSize , byte [ ] uncompressed , int uncompressedOffset ) throws CorruptionException { // Read the uncompressed length from the front of the compressed input int[] varInt = readUncompressedLength(compressed, compressedOffset); int expectedLength = varInt[0]; compressedOffset += varInt[1]; compressedSize -= varInt[1]; SnappyInternalUtils.checkArgument(expectedLength <= uncompressed.length - uncompressedOffset, "Uncompressed length %s must be less than %s", expectedLength, uncompressed.length - uncompressedOffset); // Process the entire input int uncompressedSize = decompressAllTags( compressed, compressedOffset, compressedSize, uncompressed, uncompressedOffset); if (!(expectedLength == uncompressedSize)) { throw new CorruptionException(String.format("Recorded length is %s bytes but actual length after decompression is %s bytes ", expectedLength, uncompressedSize)); } return expectedLength; }
private static int [ ] decompressTagSlow ( byte [ ] input , int ipIndex , byte [ ] output , int outputLimit , int outputOffset , int opIndex ) throws CorruptionException { // read the op code int opCode = loadByte(input, ipIndex++); int entry = lookupShort(opLookupTable, opCode); int trailerBytes = entry >>> 11; // // Key difference here // int trailer = 0; switch (trailerBytes) { case 4: trailer = (input[ipIndex + 3] & 0xff) << 24; case 3: trailer |= (input[ipIndex + 2] & 0xff) << 16; case 2: trailer |= (input[ipIndex + 1] & 0xff) << 8; case 1: trailer |= (input[ipIndex] & 0xff); } // advance the ipIndex past the op codes ipIndex += trailerBytes; int length = entry & 0xff; if ((opCode & 0x3) == Snappy.LITERAL) { int literalLength = length + trailer; copyLiteral(input, ipIndex, output, opIndex, literalLength); ipIndex += literalLength; opIndex += literalLength; } else { // copyOffset/256 is encoded in bits 8..10. By just fetching // those bits, we get copyOffset (since the bit-field starts at // bit 8). int copyOffset = entry & 0x700; copyOffset += trailer; // inline to force hot-spot to keep inline { int spaceLeft = outputLimit - opIndex; int srcIndex = opIndex - copyOffset; if (srcIndex < outputOffset) { throw new CorruptionException("Invalid copy offset for opcode starting at " + (ipIndex - trailerBytes - 1)); } if (length <= 16 && copyOffset >= 8 && spaceLeft >= 16) { // Fast path, used for the majority (70-80%) of dynamic invocations. copyLong(output, srcIndex, output, opIndex); copyLong(output, srcIndex + 8, output, opIndex + 8); } else if (spaceLeft >= length + MAX_INCREMENT_COPY_OVERFLOW) { incrementalCopyFastPath(output, srcIndex, opIndex, length); } else { incrementalCopy(output, srcIndex, output, opIndex, length); } } opIndex += length; } return new int[] {ipIndex, opIndex}; }
private static void copyLiteral ( byte [ ] input , int ipIndex , byte [ ] output , int opIndex , int length ) throws CorruptionException { assert length > 0 ; assert ipIndex > = 0 ; assert opIndex > = 0 ; int spaceLeft = output . length - opIndex ; int readableBytes = input . length - ipIndex ; if ( readableBytes < length | | spaceLeft < length ) { throw new CorruptionException ( " Corrupt literal length " ) ; } if ( length < = 16 & & spaceLeft > = 16 & & readableBytes > = 16 ) { copyLong ( input , ipIndex , output , opIndex ) ;
private static int [ ] readUncompressedLength ( byte [ ] compressed , int compressedOffset ) throws CorruptionException { int result ; int bytesRead = 0 ; { int b = compressed [ compressedOffset + bytesRead + + ] & 0xFF ; result = b & 0x7f ; if ( ( b & 0x80 ) ! = 0 ) { b = compressed [ compressedOffset + bytesRead + + ] & 0xFF ; result | = ( b & 0x7f ) < < 7 ; if ( ( b & 0x80 ) ! = 0 ) { b = compressed [ compressedOffset + bytesRead + + ] & 0xFF ; result | = ( b & 0x7f ) < < 14 ; if ( ( b & 0x80 ) ! = 0 ) { b = compressed [ compressedOffset + bytesRead + + ] & 0xFF ; result | = ( b & 0x7f ) < < 21 ; if ( ( b & 0x80 ) ! = 0 ) { b = compressed [ compressedOffset + bytesRead + + ] & 0xFF ; result | = ( b & 0x7f ) < < 28 ; if ( ( b & 0x80 ) ! = 0 ) { throw new CorruptionException ( " last byte of compressed length int has high bit set " ) ; } } } } } } return new int [ ] { result , bytesRead } ; }
private void handleInput ( int length , boolean compressed ) throws IOException { if ( compressed ) { buffer = uncompressed ; try { valid = Snappy . uncompress ( input , 0 , length , uncompressed , 0 ) ; } catch ( CorruptionException e ) { throw new IOException ( " Corrupt input " , e ) ; } } else { buffer = input ; valid = length ; } position = 0 ; }
public static int maskedCrc32c ( byte [ ] data ) { return maskedCrc32c ( data , 0 , data . length ) ; }
public static int maskedCrc32c ( byte [ ] data , int offset , int length ) { Crc32C crc32c = new Crc32C ( ) ; crc32c . update ( data , offset , length ) ; return crc32c . getMaskedValue ( ) ; }
public static int mask ( int crc ) { // Rotate right by 15 bits and add a constant. return ((crc >>> 15) | (crc << 17)) + MASK_DELTA; }
public static int unmask ( int maskedCrc ) { int rot = maskedCrc - MASK_DELTA ; return ( ( rot > > > 17 ) | ( rot < < 15 ) ) ; }
public int getMaskedValue ( ) { return mask ( getIntValue ( ) ) ; }
public int getIntValue ( ) { return ~ crc ; }
public long getValue ( ) { long ret = crc ; return ( ~ ret ) & 0xffffffffL ; }
public void reset ( ) { crc = 0xffffffff ; }
public void update ( byte [ ] b , int off , int len ) { int localCrc = crc ; while ( len > 7 ) { int c0 = b [ off + + ] ^ localCrc ; int c1 = b [ off + + ] ^ ( localCrc > > > = 8 ) ; int c2 = b [ off + + ] ^ ( localCrc > > > = 8 ) ; int c3 = b [ off + + ] ^ ( localCrc > > > = 8 ) ; localCrc = ( T8_7 [ c0 & 0xff ] ^ T8_6 [ c1 & 0xff ] ) ^ ( T8_5 [ c2 & 0xff ] ^ T8_4 [ c3 & 0xff ] ) ; localCrc ^ = ( T8_3 [ b [ off + + ] & 0xff ] ^ T8_2 [ b [ off + + ] & 0xff ] ) ^ ( T8_1 [ b [ off + + ] & 0xff ] ^ T8_0 [ b [ off + + ] & 0xff ] ) ; len - = 8 ; } while ( len > 0 ) { localCrc = ( localCrc > > > 8 ) ^ T8_0 [ ( localCrc ^ b [ off + + ] ) & 0xff ] ; len - - ; } // Publish crc out to object crc = localCrc; }
public void update ( int b ) { crc = ( crc > > > 8 ) ^ T8_0 [ ( crc ^ b ) & 0xff ] ; }
private void handleInput ( int length , boolean compressed ) throws IOException { if ( compressed ) { buffer = uncompressed ; try { valid = Snappy . uncompress ( input , 0 , length , uncompressed , 0 ) ; } catch ( CorruptionException e ) { throw new IOException ( " Corrupt input " , e ) ; } } else { buffer = input ; valid = length ; } if ( verifyChecksums ) { int expectedCrc32c = getCrc32c ( ) ; int actualCrc32c = Crc32C . maskedCrc32c ( buffer , 0 , valid ) ; if ( expectedCrc32c ! = actualCrc32c ) { throw new IOException ( " Corrupt input: invalid checksum " ) ; } } position = 0 ; }
private int getCrc32c ( ) throws IOException { return ( ( header [ 3 ] & 0xFF ) < < 24 ) | ( ( header [ 4 ] & 0xFF ) < < 16 ) |
private void writeCompressed ( byte [ ] input , int offset , int length ) throws IOException { // crc is based on the user supplied input data int crc32c = maskedCrc32c(input, offset, length); int compressed = Snappy.compress(input, offset, length, outputBuffer, 0); // use uncompressed input if less than 12.5% compression if (compressed >= (length - (length / 8))) { writeBlock(input, offset, length, false, crc32c);
private void writeBlock ( byte [ ] data , int offset , int length , boolean compressed , int crc32c ) throws IOException { // write compressed flag out.write(compressed ? 0x01 : 0x00); // write length out.write(length >>> 8); out.write(length); // write crc32c of user input data out.write(crc32c >>> 24); out.write(crc32c >>> 16); out.write(crc32c >>> 8); out.write(crc32c); // write data out.write(data, offset, length); }
public void testSimple ( ) throws Exception { byte [ ] original = " aaaaaaaaaaaabbbbbbbaaaaaa " . getBytes ( Charsets . UTF_8 ) ; byte [ ] compressed = compress ( original ) ; byte [ ] uncompressed = uncompress ( compressed ) ; assertEquals ( uncompressed , original ) ; assertEquals ( compressed . length , 26 ) ; // 7 byte header, 19 bytes compressed data assertEquals(toInt(compressed[0]), 0x01); // flag: compressed assertEquals(toInt(compressed[1]), 0x00); // length: 19 = 0x0013 assertEquals(toInt(compressed[2]), 0x13); assertEquals(toInt(compressed[3]), 0x92); // crc32c: 0x9274cda8 assertEquals(toInt(compressed[4]), 0x74); assertEquals(toInt(compressed[5]), 0xCD); assertEquals(toInt(compressed[6]), 0xA8); }
public void testUncompressable ( ) throws Exception { byte [ ] random = getRandom ( 1 , 5000 ) ; int crc32c = Crc32C . maskedCrc32c ( random ) ; byte [ ] compressed = compress ( random ) ; byte [ ] uncompressed = uncompress ( compressed ) ; assertEquals ( uncompressed , random ) ; assertEquals ( compressed . length , random . length + 7 ) ; assertEquals ( toInt ( compressed [ 0 ] ) , 0x00 ) ; // flag: uncompressed assertEquals(toInt(compressed[1]), 0x13); // length: 5000 = 0x1388 assertEquals(toInt(compressed[2]), 0x88); assertEquals(ByteBuffer.wrap(compressed, 3, 4).getInt(), crc32c); // crc: see above }
public void testShortBlockHeader ( ) throws Exception { uncompress ( new byte [ ] { 0 } ) ; }
public void testShortBlockData ( ) throws Exception { uncompress ( new byte [ ] { 0 , 0 , 4 , 0 , 0 , 0 , 0 , 'x' , 'x' } ) ; // flag = 0, size = 4, crc32c = 0, block data = [x, x] }
public void testInvalidBlockHeaderCompressedFlag ( ) throws Exception { uncompress ( new byte [ ] { 'A' , 0 , 1 , 0 , 0 , 0 , 0 , 0 } ) ; // flag = 'A', block size = 1, crc32c = 0 }
public void testInvalidBlockSizeZero ( ) throws Exception { uncompress ( new byte [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 0 } ) ; // flag = '0', block size = 0, crc32c = 0 }
public void testInvalidBlockSizeLarge ( ) throws Exception { uncompress ( new byte [ ] { 0 , ( byte ) 0xD9 , 0x03 , 0 , 0 , 0 , 0 } ) ; // flag = 'A', block size = 55555, crc32c = 0 }
public void testInvalidChecksum ( ) throws Exception { uncompress ( new byte [ ] { 0 , 0 , 1 , 0 , 0 , 0 , 0 , 'a' } ) ; // flag = 0, size = 4, crc32c = 0, block data = [a] }
public void testInvalidChecksumIgnoredWhenVerificationDisabled ( ) throws Exception { ByteArrayInputStream inputData = new ByteArrayInputStream ( new byte [ ] { 0 , 0 , 1 , 0 , 0 , 0 , 0 , 'a' } ) ; // flag = 0, size = 4, crc32c = 0, block data = [a] assertEquals(toByteArray(new SnappyInputStream(inputData, false)), new byte[] {'a'}); }
public static void main ( String [ ] args ) { System . err . printf ( " Running micro-benchmarks. \ n " ) ; SnappyBench snappyBench = new SnappyBench ( ) ; // verify implementation with a round trip for every input snappyBench.verify(); // warm up the code paths so hot spot optimizes the code snappyBench.warmUp(); // Easy to use individual tests // for (int i = 0; i < 100; i++) { // snappyBench.runUncompress(TestData.txt1); // snappyBench.runUncompress(TestData.txt2); // snappyBench.runUncompress(TestData.txt3); // snappyBench.runUncompress(TestData.txt4); // snappyBench.runUncompress(TestData.sum); // snappyBench.runUncompress(TestData.lsp); // snappyBench.runUncompress(TestData.man); // snappyBench.runUncompress(TestData.c); // snappyBench.runUncompress(TestData.cp); // } snappyBench.runCompress("Block Compress", JNI_BLOCK, JAVA_BLOCK); snappyBench.runUncompress("Block Uncompress", JNI_BLOCK, JAVA_BLOCK); snappyBench.runRoundTrip("Block Round Trip", JNI_BLOCK, JAVA_BLOCK); snappyBench.runCompress("Stream Compress", JNI_STREAM, JAVA_STREAM); snappyBench.runUncompress("Stream Uncompress", JNI_STREAM, JAVA_STREAM); snappyBench.runRoundTrip("Stream RoundTrip", JNI_STREAM, JAVA_STREAM); }
public short [ ] allocEncodingHash ( int suggestedSize ) { short [ ] buf = encodingHash ; if ( buf = = null | | buf . length < suggestedSize ) { buf = new short [ suggestedSize ] ; } else { encodingHash = null ; } return buf ; }
public void releaseEncodingHash ( short [ ] buffer ) { if ( encodingHash = = null | | ( buffer ! = null & & buffer . length > encodingHash . length ) ) { encodingHash = buffer ;
public static int compress ( final byte [ ] uncompressed , final int uncompressedOffset , final int uncompressedLength , final byte [ ] compressed , final int compressedOffset ) { // First write the uncompressed size to the output as a variable length int int compressedIndex = writeUncompressedLength(compressed, compressedOffset, uncompressedLength); int hashTableSize = getHashTableSize(uncompressedLength); BufferRecycler recycler = BufferRecycler.instance(); short[] table = recycler.allocEncodingHash(hashTableSize); for (int read = 0; read < uncompressedLength; read += BLOCK_SIZE) { // Get encoding table for compression Arrays.fill(table, (short) 0); compressedIndex = compressFragment( uncompressed, uncompressedOffset + read, Math.min(uncompressedLength - read, BLOCK_SIZE), compressed, compressedIndex, table); } recycler.releaseEncodingHash(table); return compressedIndex - compressedOffset; }
private static void printHeader ( String benchmarkTitle ) { System . err . println ( ) ; System . err . println ( ) ; System . err . println ( " ### " + benchmarkTitle ) ; System . err . println ( " <pre><code> " ) ; System . err . printf ( " %-8s %8s %9s %9s %11s %11s %7s \ n " , " " , " " , " JNI " , " Java " , " JNI " , " Java " , " " ) ; System . err . printf ( " %-8s %8s %9s %9s %11s %11s %7s \ n " , " Input " , " Size " , " Compress " , " Compress " , " Throughput " , " Throughput " , " Change " ) ; System . err . printf ( " --------------------------------------------------------------------- \ n " ) ; }
private static void printFooter ( ) { System . err . println ( " </code></pre> " ) ; }
public void runCompress ( String benchmarkTitle , BenchmarkDriver oldDriver , BenchmarkDriver newDriver ) { printHeader ( benchmarkTitle ) ; for ( TestData testData : TestData . values ( ) ) { runCompress ( testData , oldDriver , newDriver ) ; } printFooter ( ) ; }
public void runUncompress ( String benchmarkTitle , BenchmarkDriver oldDriver , BenchmarkDriver newDriver ) { printHeader ( benchmarkTitle ) ; for ( TestData testData : TestData . values ( ) ) { runUncompress ( testData , oldDriver , newDriver ) ; } printFooter ( ) ; }
public void runRoundTrip ( String benchmarkTitle , BenchmarkDriver oldDriver , BenchmarkDriver newDriver ) { printHeader ( benchmarkTitle ) ; for ( TestData testData : TestData . values ( ) ) { runRoundTrip ( testData , oldDriver , newDriver ) ; } printFooter ( ) ; }
private boolean readBlockHeader ( ) throws IOException { do { int offset = 0 ; while ( offset < header . length ) { int size = in . read ( header , offset , header . length - offset ) ; if ( size = = - 1 ) { // EOF on first byte means the stream ended cleanly if (offset == 0) { return false; } throw new EOFException("encountered EOF while reading block header"); } offset += size; } } while (Arrays.equals(header, FILE_HEADER)); return true; }
public void testSimple ( ) throws Exception { byte [ ] original = " aaaaaaaaaaaabbbbbbbaaaaaa " . getBytes ( Charsets . UTF_8 ) ; byte [ ] compressed = compress ( original ) ; byte [ ] uncompressed = uncompress ( compressed ) ; assertEquals ( uncompressed , original ) ; assertEquals ( compressed . length , 33 ) ; // 7 byte file header, 7 byte block header, 19 bytes compressed data assertEquals(Arrays.copyOf(compressed, 7), FILE_HEADER); // file header assertEquals(toInt(compressed[7]), 0x01); // flag: compressed assertEquals(toInt(compressed[8]), 0x00); // length: 19 = 0x0013 assertEquals(toInt(compressed[9]), 0x13); assertEquals(toInt(compressed[10]), 0x92); // crc32c: 0x9274cda8 assertEquals(toInt(compressed[11]), 0x74); assertEquals(toInt(compressed[12]), 0xCD); assertEquals(toInt(compressed[13]), 0xA8); }
public void testUncompressable ( ) throws Exception { byte [ ] random = getRandom ( 1 , 5000 ) ; int crc32c = Crc32C . maskedCrc32c ( random ) ; byte [ ] compressed = compress ( random ) ; byte [ ] uncompressed = uncompress ( compressed ) ; assertEquals ( uncompressed , random ) ; assertEquals ( compressed . length , random . length + 7 + 7 ) ; assertEquals ( toInt ( compressed [ 7 ] ) , 0x00 ) ; // flag: uncompressed assertEquals(toInt(compressed[8]), 0x13); // length: 5000 = 0x1388 assertEquals(toInt(compressed[9]), 0x88); assertEquals(ByteBuffer.wrap(compressed, 10, 4).getInt(), crc32c); // crc: see above }
public void testEmpty ( ) throws Exception { byte [ ] empty = new byte [ 0 ] ; assertEquals ( compress ( empty ) , FILE_HEADER ) ; assertEquals ( uncompress ( FILE_HEADER ) , empty ) ; }
public static SnappyOutputStream newChecksumFreeBenchmarkOutputStream ( OutputStream out ) throws IOException { return new SnappyOutputStream ( out , false ) ; }
private void writeCompressed ( byte [ ] input , int offset , int length ) throws IOException { // crc is based on the user supplied input data int crc32c = writeChecksums ? maskedCrc32c(input, offset, length) : 0; int compressed = Snappy.compress(input, offset, length, outputBuffer, 0); // use uncompressed input if less than 12.5% compression if (compressed >= (length - (length / 8))) { writeBlock(input, offset, length, false, crc32c);
public double getCompressionRatio ( TestData testData ) { byte [ ] contents = testData . getContents ( ) ; int compressedSize ; try { ByteArrayOutputStream rawOut = new ByteArrayOutputStream ( Snappy . maxCompressedLength ( contents . length ) ) ; SnappyOutputStream out = SnappyOutputStream . newChecksumFreeBenchmarkOutputStream ( rawOut ) ; out . write ( contents ) ; out . close ( ) ; compressedSize = rawOut . size ( ) ; } catch ( IOException e ) { throw Throwables . propagate ( e ) ; } return 1.0 * ( contents . length - compressedSize ) / contents . length ; }
public static void main ( String [ ] args ) { System . err . printf ( " Running micro-benchmarks. \ n " ) ; SnappyBench snappyBench = new SnappyBench ( ) ; // verify implementation with a round trip for every input snappyBench.verify(); // warm up the code paths so hot spot optimizes the code snappyBench.warmUp(); // Easy to use individual tests // for (int i = 0; i < 100; i++) { // snappyBench.runUncompress(TestData.txt1); // snappyBench.runUncompress(TestData.txt2); // snappyBench.runUncompress(TestData.txt3); // snappyBench.runUncompress(TestData.txt4); // snappyBench.runUncompress(TestData.sum); // snappyBench.runUncompress(TestData.lsp); // snappyBench.runUncompress(TestData.man); // snappyBench.runUncompress(TestData.c); // snappyBench.runUncompress(TestData.cp); // } snappyBench.runCompress("Block Compress", JNI_BLOCK, JAVA_BLOCK); snappyBench.runUncompress("Block Uncompress", JNI_BLOCK, JAVA_BLOCK); snappyBench.runRoundTrip("Block Round Trip", JNI_BLOCK, JAVA_BLOCK); snappyBench.runCompress("Stream Compress (no checksum)", JNI_STREAM, JAVA_STREAM); snappyBench.runUncompress("Stream Uncompress (no checksum)", JNI_STREAM, JAVA_STREAM); snappyBench.runRoundTrip("Stream RoundTrip (no checksum)", JNI_STREAM, JAVA_STREAM); }
private boolean readBlockHeader ( ) throws IOException { do { int offset = 0 ; while ( offset < header . length ) { int size = in . read ( header , offset , header . length - offset ) ; if ( size = = - 1 ) { // EOF on first byte means the stream ended cleanly if (offset == 0) { return false; } throw new EOFException("encountered EOF while reading block header"); } offset += size; } } while (Arrays.equals(header, STREAM_HEADER)); return true; }
public void testSimple ( ) throws Exception { byte [ ] original = " aaaaaaaaaaaabbbbbbbaaaaaa " . getBytes ( Charsets . UTF_8 ) ; byte [ ] compressed = compress ( original ) ; byte [ ] uncompressed = uncompressBlock ( compressed ) ; assertEquals ( uncompressed , original ) ; assertEquals ( compressed . length , 33 ) ; // 7 byte stream header, 7 byte block header, 19 bytes compressed data assertEquals(Arrays.copyOf(compressed, 7), STREAM_HEADER); // stream header assertEquals(toInt(compressed[7]), 0x01); // flag: compressed assertEquals(toInt(compressed[8]), 0x00); // length: 19 = 0x0013 assertEquals(toInt(compressed[9]), 0x13); assertEquals(toInt(compressed[10]), 0x92); // crc32c: 0x9274cda8 assertEquals(toInt(compressed[11]), 0x74); assertEquals(toInt(compressed[12]), 0xCD); assertEquals(toInt(compressed[13]), 0xA8); }
public void testLargeWrites ( ) throws Exception { byte [ ] random = getRandom ( 0.5 , 500000 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; OutputStream snappyOut = new SnappyOutputStream ( out ) ; // partially fill buffer int small = 1000; snappyOut.write(random, 0, small); // write more than the buffer size snappyOut.write(random, small, random.length - small); // get compressed data snappyOut.close(); byte[] compressed = out.toByteArray(); assertTrue(compressed.length < random.length); // decompress byte[] uncompressed = uncompressBlock(compressed); assertEquals(uncompressed, random); // decompress byte at a time SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(compressed)); int i = 0; int c; while ((c = in.read()) != -1) { uncompressed[i++] = (byte) c; } assertEquals(i, random.length); assertEquals(uncompressed, random); }
public void testSingleByteWrites ( ) throws Exception { byte [ ] random = getRandom ( 0.5 , 500000 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; OutputStream snappyOut = new SnappyOutputStream ( out ) ; for ( byte b : random ) { snappyOut . write ( b ) ; } snappyOut . close ( ) ; byte [ ] compressed = out . toByteArray ( ) ; assertTrue ( compressed . length < random . length ) ; byte [ ] uncompressed = uncompressBlock ( compressed ) ; assertEquals ( uncompressed , random ) ; }
public void testExtraFlushes ( ) throws Exception { byte [ ] random = getRandom ( 0.5 , 500000 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; OutputStream snappyOut = new SnappyOutputStream ( out ) ; snappyOut . write ( random ) ; for ( int i = 0 ; i < 10 ; i + + ) { snappyOut . flush ( ) ; } snappyOut . close ( ) ; byte [ ] compressed = out . toByteArray ( ) ; assertTrue ( compressed . length < random . length ) ; byte [ ] uncompressed = uncompressBlock ( compressed ) ; assertEquals ( uncompressed , random ) ; }
public void testUncompressable ( ) throws Exception { byte [ ] random = getRandom ( 1 , 5000 ) ; int crc32c = Crc32C . maskedCrc32c ( random ) ; byte [ ] compressed = compress ( random ) ; byte [ ] uncompressed = uncompressBlock ( compressed ) ; assertEquals ( uncompressed , random ) ; assertEquals ( compressed . length , random . length + 7 + 7 ) ; assertEquals ( toInt ( compressed [ 7 ] ) , 0x00 ) ; // flag: uncompressed assertEquals(toInt(compressed[8]), 0x13); // length: 5000 = 0x1388 assertEquals(toInt(compressed[9]), 0x88); assertEquals(ByteBuffer.wrap(compressed, 10, 4).getInt(), crc32c); // crc: see above }
public void testEmptyCompression ( ) throws Exception { byte [ ] empty = new byte [ 0 ] ; assertEquals ( compress ( empty ) , STREAM_HEADER ) ; assertEquals ( uncompressBlock ( STREAM_HEADER ) , empty ) ; }
public void testEmptyStream ( ) throws Exception { uncompressStream ( new byte [ 0 ] ) ; }
public void testInvalidStreamHeader ( ) throws Exception { uncompressStream ( new byte [ ] { 'b' , 0 , 0 , 'g' , 'u' , 's' , 0 } ) ; }
public void testShortBlockHeader ( ) throws Exception { uncompressBlock ( new byte [ ] { 0 } ) ; }
public void testShortBlockData ( ) throws Exception { uncompressBlock ( new byte [ ] { 0 , 0 , 4 , 0 , 0 , 0 , 0 , 'x' , 'x' } ) ; // flag = 0, size = 4, crc32c = 0, block data = [x, x] }
public void testInvalidBlockHeaderCompressedFlag ( ) throws Exception { uncompressBlock ( new byte [ ] { 'A' , 0 , 1 , 0 , 0 , 0 , 0 , 0 } ) ; // flag = 'A', block size = 1, crc32c = 0 }
public void testInvalidBlockSizeZero ( ) throws Exception { uncompressBlock ( new byte [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 0 } ) ; // flag = '0', block size = 0, crc32c = 0 }
public void testInvalidBlockSizeLarge ( ) throws Exception { uncompressBlock ( new byte [ ] { 0 , ( byte ) 0xD9 , 0x03 , 0 , 0 , 0 , 0 } ) ; // flag = 'A', block size = 55555, crc32c = 0 }
public void testInvalidChecksum ( ) throws Exception { uncompressBlock ( new byte [ ] { 0 , 0 , 1 , 0 , 0 , 0 , 0 , 'a' } ) ; // flag = 0, size = 4, crc32c = 0, block data = [a] }
public void testInvalidChecksumIgnoredWhenVerificationDisabled ( ) throws Exception { byte [ ] block = { 0 , 0 , 1 , 0 , 0 , 0 , 0 , 'a' } ; // flag = 0, size = 4, crc32c = 0, block data = [a] ByteArrayInputStream inputData = new ByteArrayInputStream(blockToStream(block)); assertEquals(toByteArray(new SnappyInputStream(inputData, false)), new byte[] {'a'}); }
private static byte [ ] uncompressBlock ( byte [ ] block ) throws IOException { byte [ ] stream = blockToStream ( block ) ; return uncompressStream ( stream ) ; }
private static byte [ ] blockToStream ( byte [ ] block ) { byte [ ] stream = new byte [ STREAM_HEADER . length + block . length ] ; System . arraycopy ( STREAM_HEADER , 0 , stream , 0 , STREAM_HEADER . length ) ; System . arraycopy ( block , 0 , stream , STREAM_HEADER . length , block . length ) ; return stream ; }
private static byte [ ] uncompressStream ( byte [ ] compressed ) throws IOException { return toByteArray ( new SnappyInputStream ( new ByteArrayInputStream ( compressed ) ) ) ; }
public int position ( ) { return position ; }
public void setPosition ( int position ) { checkPositionIndex ( position , slice . length ( ) ) ; this . position = position ; }
public boolean isReadable ( ) { return position < slice . length ( ) ; }
public int available ( ) { return slice . length ( ) - position ; }
public boolean readBoolean ( ) throws IOException { return readByte ( ) ! = 0 ; }
public int read ( ) { if ( position > = slice . length ( ) ) { return - 1 ; } int result = slice . getByte ( position ) & 0xFF ; position + + ; return result ; }
public byte readByte ( ) { int value = read ( ) ; if ( value = = - 1 ) { throw new IndexOutOfBoundsException ( ) ; } return ( byte ) value ; }
public int readUnsignedByte ( ) { return readByte ( ) & 0xFF ; }
public short readShort ( ) { short v = slice . getShort ( position ) ; position + = SIZE_OF_SHORT ; return v ; }
public int readUnsignedShort ( ) throws IOException { return readShort ( ) & 0xFFFF ; }
public int readInt ( ) { int v = slice . getInt ( position ) ; position + = SIZE_OF_INT ; return v ; }
public long readLong ( ) { long v = slice . getLong ( position ) ; position + = SIZE_OF_LONG ; return v ; }
public Slice readSlice ( int length ) { if ( length = = 0 ) { return Slices . EMPTY_SLICE ; } Slice newSlice = slice . slice ( position , length ) ; position + = length ; return newSlice ; }
public void readBytes ( byte [ ] destination , int destinationIndex , int length ) { slice . getBytes ( position , destination , destinationIndex , length ) ; position + = length ; }
public void readBytes ( Slice destination , int destinationIndex , int length ) { slice . getBytes ( position , destination , destinationIndex , length ) ; position + = length ; }
public void readBytes ( OutputStream out , int length ) throws IOException { slice . getBytes ( position , out , length ) ; position + = length ; }
public int skipBytes ( int length ) { length = Math . min ( length , available ( ) ) ; position + = length ; return length ; }
public Slice slice ( ) { return slice . slice ( position , slice . length ( ) - position ) ; }
public String toString ( Charset charset ) { return slice . toString ( position , available ( ) , charset ) ; }
public String toString ( ) { return Objects . toStringHelper ( this ) . add ( " position " , position )
public boolean isWritable ( ) { return writableBytes ( ) > 0 ; }
public int writableBytes ( ) { return slice . length ( ) - size ; }
public void writeByte ( int value ) { slice . setByte ( size , value ) ; size + = SIZE_OF_BYTE ; }
public void writeShort ( int value ) { slice . setShort ( size , value ) ; size + = SIZE_OF_SHORT ; }
public void writeInt ( int value ) { slice . setInt ( size , value ) ; size + = SIZE_OF_INT ; }
public void writeLong ( long value ) { slice . setLong ( size , value ) ; size + = SIZE_OF_LONG ; }
public void writeDouble ( double value ) { slice . setDouble ( size , value ) ; size + = SIZE_OF_DOUBLE ; }
public void writeBytes ( byte [ ] source , int sourceIndex , int length ) { slice . setBytes ( size , source , sourceIndex , length ) ; size + = length ; }
public void writeBytes ( byte [ ] source ) { writeBytes ( source , 0 , source . length ) ; }
public void writeBytes ( Slice source ) { writeBytes ( source , 0 , source . length ( ) ) ; }
public void writeBytes ( Slice source , int sourceIndex , int length ) { slice . setBytes ( size , source , sourceIndex , length ) ; size + = length ; }
public int writeBytes ( InputStream in , int length ) throws IOException { int writtenBytes = slice . setBytes ( size , in , length ) ; if ( writtenBytes > 0 ) { size + = writtenBytes ; } return writtenBytes ; }
public BasicSliceOutput appendLong ( long value ) { writeLong ( value ) ; return this ; }
public SliceOutput appendDouble ( double value ) { writeDouble ( value ) ; return this ; }
public BasicSliceOutput appendInt ( int value ) { writeInt ( value ) ; return this ; }
public BasicSliceOutput appendShort ( int value ) { writeShort ( value ) ; return this ; }
public BasicSliceOutput appendBytes ( byte [ ] source , int sourceIndex , int length ) { write ( source , sourceIndex , length ) ; return this ; }
public BasicSliceOutput appendBytes ( byte [ ] source ) { writeBytes ( source ) ; return this ; }
public BasicSliceOutput appendBytes ( Slice slice ) { writeBytes ( slice ) ; return this ; }
public Slice slice ( ) { return slice . slice ( 0 , size ) ; }
public String toString ( ) { return Objects . toStringHelper ( this ) . add ( " size " , size )
public String toString ( Charset charset ) { return slice . toString ( 0 , size , charset ) ; }
public void writeByte ( int value ) { slice = Slices . ensureSize ( slice , size + SIZE_OF_BYTE ) ; slice . setByte ( size , value ) ; size + = SIZE_OF_BYTE ; }
public void writeShort ( int value ) { slice = Slices . ensureSize ( slice , size + SIZE_OF_SHORT ) ; slice . setShort ( size , value ) ; size + = SIZE_OF_SHORT ; }
public void writeInt ( int value ) { slice = Slices . ensureSize ( slice , size + SIZE_OF_INT ) ; slice . setInt ( size , value ) ; size + = SIZE_OF_INT ; }
public void writeLong ( long value ) { slice = Slices . ensureSize ( slice , size + SIZE_OF_LONG ) ; slice . setLong ( size , value ) ; size + = SIZE_OF_LONG ; }
public void writeDouble ( double value ) { slice = Slices . ensureSize ( slice , size + SIZE_OF_DOUBLE ) ; slice . setDouble ( size , value ) ; size + = SIZE_OF_DOUBLE ; }
public void writeBytes ( byte [ ] source , int sourceIndex , int length ) { slice = Slices . ensureSize ( slice , size + length ) ; slice . setBytes ( size , source , sourceIndex , length ) ; size + = length ; }
public void writeBytes ( Slice source , int sourceIndex , int length ) { slice = Slices . ensureSize ( slice , size + length ) ; slice . setBytes ( size , source , sourceIndex , length ) ; size + = length ; }
public int writeBytes ( InputStream in , int length ) throws IOException { slice = Slices . ensureSize ( slice , size + length ) ; int writtenBytes = slice . setBytes ( size , in , length ) ; if ( writtenBytes > 0 ) { size + = writtenBytes ; } return writtenBytes ; }
public void writeZero ( int length ) { slice = Slices . ensureSize ( slice , size + length ) ; super . writeZero ( length ) ; }
public DynamicSliceOutput appendLong ( long value ) { writeLong ( value ) ; return this ; }
public DynamicSliceOutput appendDouble ( double value ) { writeDouble ( value ) ; return this ; }
public DynamicSliceOutput appendInt ( int value ) { writeInt ( value ) ; return this ; }
public DynamicSliceOutput appendShort ( int value ) { writeShort ( value ) ; return this ; }
public DynamicSliceOutput appendBytes ( byte [ ] source , int sourceIndex , int length ) { write ( source , sourceIndex , length ) ; return this ; }
public DynamicSliceOutput appendBytes ( byte [ ] source ) { writeBytes ( source ) ; return this ; }
public DynamicSliceOutput appendBytes ( Slice slice ) { writeBytes ( slice ) ; return this ; }
public int position ( ) { return ( int ) countingInputStream . getCount ( ) ; }
public void setPosition ( int position ) { throw new UnsupportedOperationException ( ) ; }
public boolean isReadable ( ) { try { int value = pushbackInputStream . read ( ) ;
public int skipBytes ( int n ) { try { return dataInputStream . skipBytes ( n ) ;
public int readUnsignedByte ( ) { try { return dataInputStream . readUnsignedByte ( ) ;
public int readUnsignedShort ( ) { try { return dataInputStream . readUnsignedShort ( ) ;
public int readInt ( ) { try { return dataInputStream . readInt ( ) ;
public long readLong ( ) { try { return dataInputStream . readLong ( ) ;
public short readShort ( ) { try { return dataInputStream . readShort ( ) ;
public byte readByte ( ) { try { return dataInputStream . readByte ( ) ;
public boolean readBoolean ( ) { try { return dataInputStream . readBoolean ( ) ;
public int read ( ) { try { return dataInputStream . read ( ) ;
public int read ( byte [ ] b ) { try { return dataInputStream . read ( b ) ;
public int read ( byte [ ] b , int off , int len ) { try { return dataInputStream . read ( b , off , len ) ;
public long skip ( long n ) { try { return dataInputStream . skip ( n ) ;
public int available ( ) { try { return countingInputStream . available ( ) ;
public void close ( ) { try { dataInputStream . close ( ) ;
public void readBytes ( byte [ ] destination , int destinationIndex , int length ) { readFully ( destination , destinationIndex , length ) ; }
public Slice readSlice ( int length ) { if ( length = = 0 ) { return Slices . EMPTY_SLICE ; } try { Slice newSlice = Slices . allocate ( length ) ;
public void readBytes ( Slice destination , int destinationIndex , int length ) { try { destination . setBytes ( destinationIndex , countingInputStream , length ) ;
public void readBytes ( OutputStream out , int length ) throws IOException { ByteStreams . copy ( ByteStreams . limit ( countingInputStream , length ) , out ) ; }
public void flush ( ) throws IOException { countingOutputStream . flush ( ) ; }
public void close ( ) throws IOException { countingOutputStream . close ( ) ; }
public void reset ( ) { throw new UnsupportedOperationException ( " OutputStream can not be reset " ) ; }
public int size ( ) { return Ints . checkedCast ( countingOutputStream . getCount ( ) ) ; }
public int writableBytes ( ) { return Integer . MAX_VALUE ; }
public boolean isWritable ( ) { return true ; }
public void writeByte ( int value ) { try { dataOutputStream . writeByte ( value ) ;
public void writeShort ( int value ) { try { dataOutputStream . writeShort ( value ) ;
public void writeInt ( int value ) { try { dataOutputStream . writeInt ( value ) ;
public void writeLong ( long value ) { try { dataOutputStream . writeLong ( value ) ;
public void writeDouble ( double value ) { try { dataOutputStream . writeDouble ( value ) ;
public void writeBytes ( Slice source , int sourceIndex , int length ) { try { source . getBytes ( sourceIndex , dataOutputStream , length ) ;
public void writeBytes ( byte [ ] source , int sourceIndex , int length ) { try { dataOutputStream . write ( source , sourceIndex , length ) ;
public int writeBytes ( InputStream in , int length ) throws IOException { int bytesRead = 0 ; byte [ ] bytes = new byte [ 4096 ] ; while ( bytesRead < length ) { int newBytes = in . read ( bytes ) ; if ( newBytes < 0 ) { break ; } dataOutputStream . write ( bytes , 0 , Math . min ( newBytes , length - bytesRead ) ) ; bytesRead + = newBytes ; } return bytesRead ; }
public SliceOutput appendLong ( long value ) { writeLong ( value ) ; return this ; }
public SliceOutput appendInt ( int value ) { writeInt ( value ) ; return this ; }
public SliceOutput appendShort ( int value ) { writeShort ( value ) ; return this ; }
public SliceOutput appendBytes ( byte [ ] source , int sourceIndex , int length ) { writeBytes ( source , sourceIndex , length ) ; return this ; }
public SliceOutput appendBytes ( byte [ ] source ) { writeBytes ( source ) ; return this ; }
public SliceOutput appendBytes ( Slice slice ) { writeBytes ( slice ) ; return this ; }
public Slice slice ( ) { throw new UnsupportedOperationException ( ) ; }
public String toString ( Charset charset ) { return toString ( ) ; }
public String toString ( ) { return Objects . toStringHelper ( this ) . add ( " countingOutputStream " , countingOutputStream )
public static long sizeOf ( boolean [ ] array ) { if ( array = = null ) { return 0 ; } return ARRAY_BOOLEAN_BASE_OFFSET + ( ( long ) ARRAY_BOOLEAN_INDEX_SCALE * array . length ) ; }
public static long sizeOf ( byte [ ] array ) { if ( array = = null ) { return 0 ; } return ARRAY_BYTE_BASE_OFFSET + ( ( long ) ARRAY_BYTE_INDEX_SCALE * array . length ) ; }
public static long sizeOf ( short [ ] array ) { if ( array = = null ) { return 0 ; } return ARRAY_SHORT_BASE_OFFSET + ( ( long ) ARRAY_SHORT_INDEX_SCALE * array . length ) ; }
public static long sizeOf ( int [ ] array ) { if ( array = = null ) { return 0 ; } return ARRAY_INT_BASE_OFFSET + ( ( long ) ARRAY_INT_INDEX_SCALE * array . length ) ; }
public static long sizeOf ( long [ ] array ) { if ( array = = null ) { return 0 ; } return ARRAY_LONG_BASE_OFFSET + ( ( long ) ARRAY_LONG_INDEX_SCALE * array . length ) ; }
public static long sizeOf ( float [ ] array ) { if ( array = = null ) { return 0 ; } return ARRAY_FLOAT_BASE_OFFSET + ( ( long ) ARRAY_FLOAT_INDEX_SCALE * array . length ) ; }
public static long sizeOf ( double [ ] array ) { if ( array = = null ) { return 0 ; } return ARRAY_DOUBLE_BASE_OFFSET + ( ( long ) ARRAY_DOUBLE_INDEX_SCALE * array . length ) ; }
public static long sizeOf ( Object [ ] array ) { if ( array = = null ) { return 0 ; } return ARRAY_OBJECT_BASE_OFFSET + ( ( long ) ARRAY_OBJECT_INDEX_SCALE * array . length ) ; }
public static Slice toUnsafeSlice ( ByteBuffer byteBuffer ) { checkNotNull ( byteBuffer , " byteBuffer is null " ) ; checkArgument ( byteBuffer instanceof DirectBuffer , " byteBuffer is not an instance of %s " , DirectBuffer . class . getName ( ) ) ; DirectBuffer directBuffer = ( DirectBuffer ) byteBuffer ; long address = directBuffer . address ( ) ; int capacity = byteBuffer . capacity ( ) ; return new Slice ( null , address , capacity , byteBuffer ) ; }
public void fill ( byte value ) { int offset = 0 ; int length = size ; long longValue = Longs . fromBytes ( value , value , value , value , value , value , value , value ) ; while ( length > = SIZE_OF_LONG ) { unsafe . putLong ( base , address + offset , longValue ) ; offset + = SIZE_OF_LONG ; length - = SIZE_OF_LONG ; } while ( length > 0 ) { unsafe . putByte ( base , address + offset , value ) ;
public void clear ( ) { clear ( 0 , size ) ; }
public void clear ( int offset , int length ) { while ( length > = SIZE_OF_LONG ) { unsafe . putLong ( base , address + offset , 0 ) ; offset + = SIZE_OF_LONG ; length - = SIZE_OF_LONG ; } while ( length > 0 ) { unsafe . putByte ( base , address + offset , ( byte ) 0 ) ;
public byte getByte ( int index ) { checkIndexLength ( index , SIZE_OF_BYTE ) ; return unsafe . getByte ( base , address + index ) ; }
public short getUnsignedByte ( int index ) { return ( short ) ( getByte ( index ) & 0xFF ) ; }
public short getShort ( int index ) { checkIndexLength ( index , SIZE_OF_SHORT ) ; return unsafe . getShort ( base , address + index ) ; }
public int getInt ( int index ) { checkIndexLength ( index , SIZE_OF_INT ) ; return unsafe . getInt ( base , address + index ) ; }
public long getLong ( int index ) { checkIndexLength ( index , SIZE_OF_LONG ) ; return unsafe . getLong ( base , address + index ) ; }
public float getFloat ( int index ) { checkIndexLength ( index , SIZE_OF_FLOAT ) ; return unsafe . getFloat ( base , address + index ) ; }
public double getDouble ( int index ) { checkIndexLength ( index , SIZE_OF_DOUBLE ) ; return unsafe . getDouble ( base , address + index ) ; }
public void getBytes ( int index , Slice destination ) { getBytes ( index , destination , 0 , destination . length ( ) ) ; }
public void getBytes ( int index , Slice destination , int destinationIndex , int length ) { destination . setBytes ( destinationIndex , this , index , length ) ; }
public void getBytes ( int index , byte [ ] destination ) { getBytes ( index , destination , 0 , destination . length ) ; }
public void getBytes ( int index , byte [ ] destination , int destinationIndex , int length ) { checkIndexLength ( index , length ) ; checkPositionIndexes ( destinationIndex , destinationIndex + length , destination . length ) ; copyMemory ( base , address + index , destination , ( long ) ARRAY_BYTE_BASE_OFFSET + destinationIndex , length ) ; }
public byte [ ] getBytes ( ) { return getBytes ( 0 , length ( ) ) ; }
public byte [ ] getBytes ( int index , int length ) { byte [ ] bytes = new byte [ length ] ; getBytes ( index , bytes , 0 , length ) ; return bytes ; }
public void getBytes ( int index , OutputStream out , int length ) throws IOException { checkIndexLength ( index , length ) ; byte [ ] buffer = new byte [ 4096 ] ; while ( length > 0 ) { int size = Math . min ( buffer . length , length ) ;
public void setByte ( int index , int value ) { checkIndexLength ( index , SIZE_OF_BYTE ) ; unsafe . putByte ( base , address + index , ( byte ) ( value & 0xFF ) ) ; }
public void setShort ( int index , int value ) { checkIndexLength ( index , SIZE_OF_SHORT ) ; unsafe . putShort ( base , address + index , ( short ) ( value & 0xFFFF ) ) ; }
public void setInt ( int index , int value ) { checkIndexLength ( index , SIZE_OF_INT ) ; unsafe . putInt ( base , address + index , value ) ; }
public void setLong ( int index , long value ) { checkIndexLength ( index , SIZE_OF_LONG ) ; unsafe . putLong ( base , address + index , value ) ; }
public void setFloat ( int index , float value ) { checkIndexLength ( index , SIZE_OF_FLOAT ) ; unsafe . putFloat ( base , address + index , value ) ; }
public void setDouble ( int index , double value ) { checkIndexLength ( index , SIZE_OF_DOUBLE ) ; unsafe . putDouble ( base , address + index , value ) ; }
public void setBytes ( int index , Slice source ) { setBytes ( index , source , 0 , source . length ( ) ) ; }
public void setBytes ( int index , Slice source , int sourceIndex , int length ) { checkIndexLength ( index , length ) ; checkPositionIndexes ( sourceIndex , sourceIndex + length , source . length ( ) ) ; copyMemory ( source . base , source . address + sourceIndex , base , address + index , length ) ; }
public void setBytes ( int index , byte [ ] source ) { setBytes ( index , source , 0 , source . length ) ; }
public void setBytes ( int index , byte [ ] source , int sourceIndex , int length ) { checkPositionIndexes ( sourceIndex , sourceIndex + length , source . length ) ; copyMemory ( source , ( long ) ARRAY_BYTE_BASE_OFFSET + sourceIndex , base , address + index , length ) ; }
public int setBytes ( int index , InputStream in , int length ) throws IOException { checkIndexLength ( index , length ) ; byte [ ] bytes = new byte [ 4096 ] ; int remaining = length ; while ( remaining > 0 ) { int bytesRead = in . read ( bytes , 0 , Math . min ( bytes . length , remaining ) ) ; if ( bytesRead < 0 ) { // if we didn't read anything return -1 if (remaining == length) { return -1; } break; } copyMemory(bytes, ARRAY_BYTE_BASE_OFFSET, base, address + index, bytesRead); remaining -= bytesRead; index += bytesRead; } return length - remaining; }
public Slice slice ( int index , int length ) { if ( ( index = = 0 ) & & ( length = = length ( ) ) ) { return this ; } checkIndexLength ( index , length ) ; if ( length = = 0 ) { return Slices . EMPTY_SLICE ; } return new Slice ( base , address + index , length , reference ) ; }
public int compareTo ( Slice that ) { if ( this = = that ) { return 0 ; } return compareTo ( 0 , size , that , 0 , that . size ) ; }
public int compareTo ( int offset , int length , Slice that , int otherOffset , int otherLength ) { if ( ( this = = that ) & & ( offset = = otherOffset ) & & ( length = = otherLength ) ) { return 0 ; } checkIndexLength ( offset , length ) ; that . checkIndexLength ( otherOffset , otherLength ) ; int compareLength = Math . min ( length , otherLength ) ; while ( compareLength > = SIZE_OF_LONG ) { long thisLong = unsafe . getLong ( base , address + offset ) ; thisLong = Long . reverseBytes ( thisLong ) ; long thatLong = unsafe . getLong ( that . base , that . address + otherOffset ) ; thatLong = Long . reverseBytes ( thatLong ) ; int v = UnsignedLongs . compare ( thisLong , thatLong ) ; if ( v ! = 0 ) { return v ; } offset + = SIZE_OF_LONG ; otherOffset + = SIZE_OF_LONG ; compareLength - = SIZE_OF_LONG ; } while ( compareLength > 0 ) { byte thisByte = unsafe . getByte ( base , address + offset ) ; byte thatByte = unsafe . getByte ( that . base , that . address + otherOffset ) ; int v = UnsignedBytes . compare ( thisByte , thatByte ) ; if ( v ! = 0 ) { return v ; } offset + + ; otherOffset + + ; compareLength - - ; } return Integer . compare ( size , that . size ) ; }
public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( ! ( o instanceof Slice ) ) { return false ; } Slice that = ( Slice ) o ; if ( length ( ) ! = that . length ( ) ) { return false ; } int offset = 0 ; int length = size ; while ( length > = SIZE_OF_LONG ) { long thisLong = unsafe . getLong ( base , address + offset ) ; long thatLong = unsafe . getLong ( that . base , that . address + offset ) ; if ( thisLong ! = thatLong ) { return false ; } offset + = SIZE_OF_LONG ; length - = SIZE_OF_LONG ; } while ( length > 0 ) { byte thisByte = unsafe . getByte ( base , address + offset ) ; byte thatByte = unsafe . getByte ( that . base , that . address + offset ) ; if ( thisByte ! = thatByte ) { return false ; } offset + + ; length - - ; } return true ; }
public int hashCode ( ) { if ( hash ! = 0 ) { return hash ; } hash = hashCode ( 0 , size ) ; return hash ; }
public int hashCode ( int offset , int length ) { checkIndexLength ( offset , length ) ; // this is basically murmur3-32, but the implementation has not been verified int seed = 0; int h1; int c1 = 0xcc9e2d51; int c2 = 0x1b873593; int len = length; h1 = seed; while (length >= SIZE_OF_INT) { int k1 = unsafe.getInt(base, address + offset); k1 *= c1; k1 = Integer.rotateLeft(k1, 15); k1 *= c2; h1 ^= k1; h1 = Integer.rotateLeft(h1, 13); h1 = h1 * 5 + 0xe6546b64; offset += SIZE_OF_INT; length -= SIZE_OF_INT; } // process remaining bytes int k1 = 0; switch (length) { case 3: k1 ^= toInt(unsafe.getByte(base, address + offset + 2)) << 16; //noinspection fallthrough case 2: k1 ^= toInt(unsafe.getByte(base, address + offset + 1)) << 8; //noinspection fallthrough case 1: k1 ^= toInt(unsafe.getByte(base, address + offset)); //noinspection fallthrough default: k1 *= c1; k1 = Integer.rotateLeft(k1, 15); k1 *= c2; h1 ^= k1; } // make hash h1 ^= len; h1 ^= h1 >>> 16; h1 *= 0x85ebca6b; h1 ^= h1 >>> 13; h1 *= 0xc2b2ae35; h1 ^= h1 >>> 16; return h1; }
public boolean equals ( int offset , int length , Slice that , int otherOffset , int otherLength ) { if ( length ! = otherLength ) { return false ; } if ( ( this = = that ) & & ( offset = = otherOffset ) ) { return true ; } checkIndexLength ( offset , length ) ; that . checkIndexLength ( otherOffset , otherLength ) ; while ( length > = SIZE_OF_LONG ) { long thisLong = unsafe . getLong ( base , address + offset ) ; long thatLong = unsafe . getLong ( that . base , that . address + otherOffset ) ; if ( thisLong ! = thatLong ) { return false ; } offset + = SIZE_OF_LONG ; otherOffset + = SIZE_OF_LONG ; length - = SIZE_OF_LONG ; } while ( length > 0 ) { byte thisByte = unsafe . getByte ( base , address + offset ) ; byte thatByte = unsafe . getByte ( that . base , that . address + otherOffset ) ; if ( thisByte ! = thatByte ) { return false ; } offset + + ; otherOffset + + ; length - - ; } return true ; }
public BasicSliceInput getInput ( ) { return new BasicSliceInput ( this ) ; }
public SliceOutput getOutput ( ) { return new BasicSliceOutput ( this ) ; }
public String toString ( Charset charset ) { return toString ( 0 , length ( ) , charset ) ; }
public String toString ( int index , int length , Charset charset ) { if ( length = = 0 ) { return " " ; } if ( base instanceof byte [ ] ) { return new String ( ( byte [ ] ) base , ( int ) ( ( address - ARRAY_BYTE_BASE_OFFSET ) + index ) , length , charset ) ; } // direct memory can only be converted to a string using a ByteBuffer return Slices.decodeString(toByteBuffer(index, length), charset); }
private ByteBuffer toByteBuffer ( int index , int length ) { if ( base instanceof byte [ ] ) { return ByteBuffer . wrap ( ( byte [ ] ) base , ( int ) ( ( address - ARRAY_BYTE_BASE_OFFSET ) + index ) , length ) ; } checkIndexLength ( index , length ) ; try { return ( ByteBuffer ) newByteBuffer . invokeExact ( address + index , length , ( Object ) reference ) ;
public String toString ( ) { return Objects . toStringHelper ( this ) . add ( " base " , identityToString ( base ) )
private static String identityToString ( Object o ) { if ( o = = null ) { return null ; } return o . getClass ( ) . getName ( ) + " @ " + Integer . toHexString ( System . identityHashCode ( o ) ) ; }
private static void copyMemory ( Object src , long srcAddress , Object dest , long destAddress , int length ) { int offset = 0 ; while ( length > = SIZE_OF_LONG ) { long srcLong = unsafe . getLong ( src , srcAddress + offset ) ; unsafe . putLong ( dest , destAddress + offset , srcLong ) ; offset + = SIZE_OF_LONG ; length - = SIZE_OF_LONG ; } while ( length > 0 ) { byte srcByte = unsafe . getByte ( src , srcAddress + offset ) ;
private void checkIndexLength ( int index , int length ) { checkPositionIndexes ( index , index + length , length ( ) ) ; }
public final long readUnsignedInt ( ) { return readInt ( ) & 0xFFFFFFFFL ; }
public final void readFully ( byte [ ] destination ) { readBytes ( destination ) ; }
public final void readBytes ( byte [ ] destination ) { readBytes ( destination , 0 , destination . length ) ; }
public final void readFully ( byte [ ] destination , int offset , int length ) { readBytes ( destination , offset , length ) ; }
public final void readBytes ( Slice destination ) { readBytes ( destination , 0 , destination . length ( ) ) ; }
public final void readBytes ( Slice destination , int length ) { readBytes ( destination , 0 , length ) ; }
public abstract void readBytes ( Slice destination , int destinationIndex , int length ) ; /** * Transfers this buffer's data to the specified stream starting at the * current {@code position}. * * @param length the number of bytes to transfer * @throws IndexOutOfBoundsException if {@code length} is greater than {@code this.available()} * @throws java.io.IOException if the specified stream threw an exception during I/O */ public abstract void readBytes ( OutputStream out , int length ) throws IOException ; @Override public abstract int skipBytes ( int length ) ; // // Unsupported operations // @Override public final void mark(int readLimit) { throw new UnsupportedOperationException(); } @Override public final void reset() { throw new UnsupportedOperationException(); } @Override public final boolean markSupported() { throw new UnsupportedOperationException(); } @Override public final char readChar() { throw new UnsupportedOperationException(); } @Override public final float readFloat() { throw new UnsupportedOperationException(); } @Override public final double readDouble() { throw new UnsupportedOperationException(); } @Override public final String readLine() { throw new UnsupportedOperationException(); } @Override public final String readUTF() { throw new UnsupportedOperationException(); } }
public abstract void readBytes ( OutputStream out , int length ) throws IOException ; @Override public abstract int skipBytes ( int length ) ; // // Unsupported operations // @Override public final void mark(int readLimit) { throw new UnsupportedOperationException(); } @Override public final void reset() { throw new UnsupportedOperationException(); } @Override public final boolean markSupported() { throw new UnsupportedOperationException(); } @Override public final char readChar() { throw new UnsupportedOperationException(); } @Override public final float readFloat() { throw new UnsupportedOperationException(); } @Override public final double readDouble() { throw new UnsupportedOperationException(); } @Override public final String readLine() { throw new UnsupportedOperationException(); } @Override public final String readUTF() { throw new UnsupportedOperationException(); } }
public abstract int skipBytes ( int length ) ; // // Unsupported operations // @Override public final void mark(int readLimit) { throw new UnsupportedOperationException(); } @Override public final void reset() { throw new UnsupportedOperationException(); } @Override public final boolean markSupported() { throw new UnsupportedOperationException(); } @Override public final char readChar() { throw new UnsupportedOperationException(); } @Override public final float readFloat() { throw new UnsupportedOperationException(); } @Override public final double readDouble() { throw new UnsupportedOperationException(); } @Override public final String readLine() { throw new UnsupportedOperationException(); } @Override public final String readUTF() { throw new UnsupportedOperationException(); } }
public final void mark ( int readLimit ) { throw new UnsupportedOperationException ( ) ; }
public final void reset ( ) { throw new UnsupportedOperationException ( ) ; }
public final boolean markSupported ( ) { throw new UnsupportedOperationException ( ) ; }
public final char readChar ( ) { throw new UnsupportedOperationException ( ) ; }
public final float readFloat ( ) { throw new UnsupportedOperationException ( ) ; }
public final double readDouble ( ) { throw new UnsupportedOperationException ( ) ; }
public final String readLine ( ) { throw new UnsupportedOperationException ( ) ; }
public final String readUTF ( ) { throw new UnsupportedOperationException ( ) ; }
public final void writeBoolean ( boolean value ) { writeByte ( value ? 1 : 0 ) ; }
public final void write ( int value ) { writeByte ( value ) ; }
public final void write ( byte [ ] source ) throws IOException { writeBytes ( source ) ; }
public final void write ( byte [ ] source , int sourceIndex , int length ) { writeBytes ( source , sourceIndex , length ) ; }
public void writeZero ( int length ) { if ( length = = 0 ) { return ; } if ( length < 0 ) { throw new IllegalArgumentException ( " length must be 0 or greater than 0. " ) ; } int nLong = length > > > 3 ; int nBytes = length & 7 ; for ( int i = nLong ; i > 0 ; i - - ) { writeLong ( 0 ) ; } if ( nBytes = = 4 ) { writeInt ( 0 ) ;
public abstract Slice slice ( ) ; /** * Decodes this buffer's readable bytes into a string with the specified * character set name. This method is identical to * {@code buf.toString(buf.readerIndex(), buf.readableBytes(), charsetName)}. * This method does not modify {@code readerIndex} or {@code writerIndex} of * this buffer. */ public abstract String toString ( Charset charset ) ; public abstract SliceOutput appendLong ( long value ) ; public abstract SliceOutput appendDouble ( double value ) ; public abstract SliceOutput appendInt ( int value ) ; public abstract SliceOutput appendShort ( int value ) ; public abstract SliceOutput appendBytes ( byte [ ] source , int sourceIndex , int length ) ; public abstract SliceOutput appendBytes ( byte [ ] source ) ; public abstract SliceOutput appendBytes ( Slice slice ) ; // // Unsupported operations // /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChar(int value) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeFloat(float v) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChars(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeUTF(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeBytes(String s) { throw new UnsupportedOperationException(); } }
public abstract String toString ( Charset charset ) ; public abstract SliceOutput appendLong ( long value ) ; public abstract SliceOutput appendDouble ( double value ) ; public abstract SliceOutput appendInt ( int value ) ; public abstract SliceOutput appendShort ( int value ) ; public abstract SliceOutput appendBytes ( byte [ ] source , int sourceIndex , int length ) ; public abstract SliceOutput appendBytes ( byte [ ] source ) ; public abstract SliceOutput appendBytes ( Slice slice ) ; // // Unsupported operations // /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChar(int value) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeFloat(float v) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChars(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeUTF(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeBytes(String s) { throw new UnsupportedOperationException(); } }
public abstract SliceOutput appendLong ( long value ) ; public abstract SliceOutput appendDouble ( double value ) ; public abstract SliceOutput appendInt ( int value ) ; public abstract SliceOutput appendShort ( int value ) ; public abstract SliceOutput appendBytes ( byte [ ] source , int sourceIndex , int length ) ; public abstract SliceOutput appendBytes ( byte [ ] source ) ; public abstract SliceOutput appendBytes ( Slice slice ) ; // // Unsupported operations // /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChar(int value) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeFloat(float v) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChars(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeUTF(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeBytes(String s) { throw new UnsupportedOperationException(); } }
public abstract SliceOutput appendDouble ( double value ) ; public abstract SliceOutput appendInt ( int value ) ; public abstract SliceOutput appendShort ( int value ) ; public abstract SliceOutput appendBytes ( byte [ ] source , int sourceIndex , int length ) ; public abstract SliceOutput appendBytes ( byte [ ] source ) ; public abstract SliceOutput appendBytes ( Slice slice ) ; // // Unsupported operations // /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChar(int value) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeFloat(float v) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChars(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeUTF(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeBytes(String s) { throw new UnsupportedOperationException(); } }
public abstract SliceOutput appendInt ( int value ) ; public abstract SliceOutput appendShort ( int value ) ; public abstract SliceOutput appendBytes ( byte [ ] source , int sourceIndex , int length ) ; public abstract SliceOutput appendBytes ( byte [ ] source ) ; public abstract SliceOutput appendBytes ( Slice slice ) ; // // Unsupported operations // /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChar(int value) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeFloat(float v) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChars(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeUTF(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeBytes(String s) { throw new UnsupportedOperationException(); } }
public abstract SliceOutput appendShort ( int value ) ; public abstract SliceOutput appendBytes ( byte [ ] source , int sourceIndex , int length ) ; public abstract SliceOutput appendBytes ( byte [ ] source ) ; public abstract SliceOutput appendBytes ( Slice slice ) ; // // Unsupported operations // /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChar(int value) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeFloat(float v) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChars(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeUTF(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeBytes(String s) { throw new UnsupportedOperationException(); } }
public abstract SliceOutput appendBytes ( byte [ ] source , int sourceIndex , int length ) ; public abstract SliceOutput appendBytes ( byte [ ] source ) ; public abstract SliceOutput appendBytes ( Slice slice ) ; // // Unsupported operations // /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChar(int value) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeFloat(float v) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChars(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeUTF(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeBytes(String s) { throw new UnsupportedOperationException(); } }
public abstract SliceOutput appendBytes ( byte [ ] source ) ; public abstract SliceOutput appendBytes ( Slice slice ) ; // // Unsupported operations // /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChar(int value) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeFloat(float v) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChars(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeUTF(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeBytes(String s) { throw new UnsupportedOperationException(); } }
public abstract SliceOutput appendBytes ( Slice slice ) ; // // Unsupported operations // /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChar(int value) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeFloat(float v) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeChars(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeUTF(String s) { throw new UnsupportedOperationException(); } /** * Unsupported operation * * @throws UnsupportedOperationException always */ @Override public void writeBytes(String s) { throw new UnsupportedOperationException(); } }
public void writeChar ( int value ) { throw new UnsupportedOperationException ( ) ; }
public void writeFloat ( float v ) { throw new UnsupportedOperationException ( ) ; }
public void writeChars ( String s ) { throw new UnsupportedOperationException ( ) ; }
public void writeUTF ( String s ) { throw new UnsupportedOperationException ( ) ; }
public void writeBytes ( String s ) { throw new UnsupportedOperationException ( ) ; }
public static Slice mapFileReadOnly ( File file ) throws IOException { return Slice . toUnsafeSlice ( Files . map ( file ) ) ; }
public static Slice ensureSize ( Slice existingSlice , int minWritableBytes ) { if ( existingSlice = = null ) { return allocate ( minWritableBytes ) ; } if ( minWritableBytes < = existingSlice . length ( ) ) { return existingSlice ; } int newCapacity ; if ( existingSlice . length ( ) = = 0 ) { newCapacity = 1 ; } else { newCapacity = existingSlice . length ( ) ; } int minNewCapacity = existingSlice . length ( ) + minWritableBytes ; while ( newCapacity < minNewCapacity ) { if ( newCapacity < SLICE_ALLOC_THRESHOLD ) { newCapacity < < = 1 ; } else { newCapacity * = SLICE_ALLOW_SKEW ; } } Slice newSlice = Slices . allocate ( newCapacity ) ; newSlice . setBytes ( 0 , existingSlice , 0 , existingSlice . length ( ) ) ; return newSlice ; }
public static Slice allocate ( int capacity ) { if ( capacity = = 0 ) { return EMPTY_SLICE ; } return new Slice ( new byte [ capacity ] ) ; }
public static Slice wrappedBuffer ( byte [ ] array ) { if ( array . length = = 0 ) { return EMPTY_SLICE ; } return new Slice ( array ) ; }
public static Slice copiedBuffer ( String string , Charset charset ) { checkNotNull ( string , " string is null " ) ; checkNotNull ( charset , " charset is null " ) ; return wrappedBuffer ( string . getBytes ( charset ) ) ; }
public static String decodeString ( ByteBuffer src , Charset charset ) { CharsetDecoder decoder = getDecoder ( charset ) ; CharBuffer dst = CharBuffer . allocate ( ( int ) ( ( double ) src . remaining ( ) * decoder . maxCharsPerByte ( ) ) ) ; try { CoderResult cr = decoder . decode ( src , dst , true ) ; if ( ! cr . isUnderflow ( ) ) { cr . throwException ( ) ; } cr = decoder . flush ( dst ) ; if ( ! cr . isUnderflow ( ) ) { cr . throwException ( ) ; } } catch ( CharacterCodingException x ) { throw new IllegalStateException ( x ) ; } return dst . flip ( ) . toString ( ) ; }
protected Map < Charset , CharsetDecoder > initialValue ( ) { return new IdentityHashMap < > ( ) ; }
private static CharsetDecoder getDecoder ( Charset charset ) { checkNotNull ( charset , " charset is null " ) ; Map < Charset , CharsetDecoder > map = decoders . get ( ) ; CharsetDecoder d = map . get ( charset ) ; if ( d ! = null ) { d . reset ( ) ; d . onMalformedInput ( CodingErrorAction . REPLACE ) ; d . onUnmappableCharacter ( CodingErrorAction . REPLACE ) ; return d ; } d = charset . newDecoder ( ) ; d . onMalformedInput ( CodingErrorAction . REPLACE ) ; d . onUnmappableCharacter ( CodingErrorAction . REPLACE ) ; map . put ( charset , d ) ; return d ; }
protected Slice allocate ( int size ) { if ( size = = 0 ) { return Slices . EMPTY_SLICE ; } return Slice . toUnsafeSlice ( ByteBuffer . allocateDirect ( size ) ) ; }
public void testFillAndClear ( ) { for ( byte size = 0 ; size < 100 ; size + + ) { Slice slice = allocate ( size ) ;
public void testEqualsHashCodeCompare ( ) { for ( int size = 0 ; size < 100 ; size + + ) { // self equals
private static void assertSlicesEquals ( Slice slice , Slice other ) { int size = slice . length ( ) ; assertEquals ( slice , other ) ; assertTrue ( slice . equals ( 0 , size , other , 0 , size ) ) ; assertEquals ( slice . hashCode ( ) , other . hashCode ( ) ) ; assertEquals ( slice . hashCode ( ) , other . hashCode ( 0 , size ) ) ; assertEquals ( slice . compareTo ( other ) , 0 ) ; assertEquals ( slice . compareTo ( 0 , size , other , 0 , size ) , 0 ) ; for ( int i = 0 ; i < slice . length ( ) ; i + + ) { assertTrue ( slice . equals ( i , size - i , other , i , size - i ) ) ; assertEquals ( slice . hashCode ( i , size - i ) , other . hashCode ( i , size - i ) ) ; assertEquals ( slice . compareTo ( i , size - i , other , i , size - i ) , 0 ) ; } for ( int i = 0 ; i < slice . length ( ) ; i + + ) { assertTrue ( slice . equals ( 0 , size - i , other , 0 , size - i ) ) ;
public void testToString ( ) { assertEquals ( Slices . copiedBuffer ( " apple " , UTF_8 ) . toString ( UTF_8 ) , " apple " ) ; for ( int size = 0 ; size < 100 ; size + + ) { for ( int index = 0 ; index < size ; index + + ) {
private static void assertToStrings ( Slice slice , int index ) { // fill slice with FF slice.fill((byte) 0xFF); // set and get the value char[] chars = new char[(slice.length() - index) / 2]; for (int i = 0; i < chars.length; i++) { chars[i] = (char) ('a' + (i % 26)); } String string = new String(chars); Slice value = Slices.copiedBuffer(string, UTF_8); slice.setBytes(index, value); assertEquals(slice.toString(index, value.length(), UTF_8), string); for (int length = 0; length < value.length(); length++) { slice.fill((byte) 0xFF);
public void testByte ( ) { for ( byte size = 0 ; size < 100 ; size + + ) { for ( byte index = 0 ; index < ( size - SIZE_OF_BYTE ) ; index + + ) {
private static void assertByte ( Slice slice , byte index ) { // fill slice with FF slice.fill((byte) 0xFF); // set and get unsigned value slice.setByte(index, 0xA5); assertEquals(slice.getUnsignedByte(index), 0x0000_00A5); // set and get the value slice.setByte(index, 0xA5); assertEquals(slice.getByte(index), (byte) 0xA5); try { slice.getByte(-1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getByte((slice.length() - SIZE_OF_BYTE) + 1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getByte(slice.length()); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getByte(slice.length() + 1);
public void testShort ( ) { for ( short size = 0 ; size < 100 ; size + + ) { for ( short index = 0 ; index < ( size - SIZE_OF_SHORT ) ; index + + ) {
private static void assertShort ( Slice slice , short index ) { // fill slice with FF slice.fill((byte) 0xFF); // set and get the value slice.setShort(index, 0xAA55); assertEquals(slice.getShort(index), (short) 0xAA55); try { slice.getShort(-1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getShort((slice.length() - SIZE_OF_SHORT) + 1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getShort(slice.length()); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getShort(slice.length() + 1);
public void testInt ( ) { for ( int size = 0 ; size < 100 ; size + + ) { for ( int index = 0 ; index < ( size - SIZE_OF_INT ) ; index + + ) {
private static void assertInt ( Slice slice , int index ) { // fill slice with FF slice.fill((byte) 0xFF); // set and get the value slice.setInt(index, 0xAAAA_5555); assertEquals(slice.getInt(index), 0xAAAA_5555); try { slice.getInt(-1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getInt((slice.length() - SIZE_OF_INT) + 1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getInt(slice.length()); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getInt(slice.length() + 1);
public void testLong ( ) { for ( int size = 0 ; size < 100 ; size + + ) { for ( int index = 0 ; index < ( size - SIZE_OF_LONG ) ; index + + ) {
private static void assertLong ( Slice slice , int index ) { // fill slice with FF slice.fill((byte) 0xFF); // set and get the value slice.setLong(index, 0xAAAA_AAAA_5555_5555L); assertEquals(slice.getLong(index), 0xAAAA_AAAA_5555_5555L); try { slice.getLong(-1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getLong((slice.length() - SIZE_OF_LONG) + 1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getLong(slice.length()); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getLong(slice.length() + 1);
public void testFloat ( ) { for ( int size = 0 ; size < 100 ; size + + ) { for ( int index = 0 ; index < ( size - SIZE_OF_FLOAT ) ; index + + ) {
private static void assertFloat ( Slice slice , int index ) { // fill slice with FF slice.fill((byte) 0xFF); // set and get the value slice.setFloat(index, intBitsToFloat(0xAAAA_5555)); assertEquals(floatToIntBits(slice.getFloat(index)), 0xAAAA_5555); try { slice.getFloat(-1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getFloat((slice.length() - SIZE_OF_FLOAT) + 1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getFloat(slice.length()); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getFloat(slice.length() + 1);
public void testDouble ( ) { for ( int size = 0 ; size < 100 ; size + + ) { for ( int index = 0 ; index < ( size - SIZE_OF_DOUBLE ) ; index + + ) {
private static void assertDouble ( Slice slice , int index ) { // fill slice with FF slice.fill((byte) 0xFF); // set and get the value slice.setDouble(index, longBitsToDouble(0xAAAA_AAAA_5555_5555L)); assertEquals(doubleToLongBits(slice.getDouble(index)), 0xAAAA_AAAA_5555_5555L); try { slice.getDouble(-1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getDouble((slice.length() - SIZE_OF_DOUBLE) + 1); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getDouble(slice.length()); fail("expected IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { } try { slice.getDouble(slice.length() + 1);
public void testBytesArray ( ) { for ( int size = 0 ; size < 100 ; size + + ) { for ( int index = 0 ; index < size ; index + + ) {
private static void assertBytesArray ( Slice slice , int index ) { // fill slice with FF slice.fill((byte) 0xFF); byte[] value = new byte[slice.length()]; Arrays.fill(value, (byte) 0xFF); assertEquals(slice.getBytes(), value); // set and get the value value = new byte[(slice.length() - index) / 2]; for (int i = 0; i < value.length; i++) { value[i] = (byte) i; } slice.setBytes(index, value); assertEquals(slice.getBytes(index, value.length), value); for (int length = 0; length < value.length; length++) { slice.fill((byte) 0xFF);
public void testBytesSlice ( ) { for ( int size = 0 ; size < 100 ; size + + ) { for ( int index = 0 ; index < size ; index + + ) {
private void assertBytesSlice ( Slice slice , int index ) { // fill slice with FF slice.fill((byte) 0xFF); // compare to self slice assertEquals(slice.slice(0, slice.length()), slice); Slice value = allocate(slice.length()); slice.getBytes(0, value, 0, slice.length()); assertEquals(value, slice); // set and get the value value = allocate((slice.length() - index) / 2); for (int i = 0; i < value.length(); i++) { value.setByte(i, i); } // check by slicing out the region slice.setBytes(index, value); assertEquals(value, slice.slice(index, value.length())); // check by getting out the region Slice tempValue = allocate(value.length()); slice.getBytes(index, tempValue, 0, tempValue.length()); assertEquals(tempValue, slice.slice(index, tempValue.length())); assertTrue(tempValue.equals(0, tempValue.length(), slice, index, tempValue.length())); for (int length = 0; length < value.length(); length++) { slice.fill((byte) 0xFF);
public void testBytesStreams ( ) throws Exception { for ( int size = 0 ; size < 100 ; size + + ) { for ( int index = 0 ; index < size ; index + + ) { assertBytesStreams ( allocate ( size ) , index ) ; } } assertBytesStreams ( allocate ( 16 * 1024 ) , 3 ) ; }
private static void assertBytesStreams ( Slice slice , int index ) throws Exception { // fill slice with FF slice.fill((byte) 0xFF); byte[] value = new byte[slice.length()]; Arrays.fill(value, (byte) 0xFF); assertEquals(slice.getBytes(), value); // set and get the value value = new byte[(slice.length() - index) / 2]; for (int i = 0; i < value.length; i++) { value[i] = (byte) i; } slice.setBytes(index, new ByteArrayInputStream(value), value.length); assertEquals(slice.getBytes(index, value.length), value); ByteArrayOutputStream out = new ByteArrayOutputStream(); slice.getBytes(index, out, value.length); assertEquals(slice.getBytes(index, value.length), out.toByteArray()); for (int length = 0; length < value.length; length++) { slice.fill((byte) 0xFF);
public void testMemoryMappedReads ( ) throws IOException { Path path = Files . createTempFile ( " longs " , null ) ; ImmutableList < Long > values = createRandomLongs ( 20000 ) ; Slice output = allocate ( values . size ( ) * Longs . BYTES ) ; for ( int i = 0 ; i < values . size ( ) ; i + + ) { output . setLong ( i * Longs . BYTES , values . get ( i ) ) ; } Files . write ( path , output . getBytes ( ) ) ; Slice slice = Slices . mapFileReadOnly ( path . toFile ( ) ) ; for ( int i = 0 ; i < values . size ( ) ; i + + ) { long actual = slice . getLong ( i * Longs . BYTES ) ; long expected = values . get ( i ) ; assertEquals ( actual , expected ) ; } assertEquals ( slice . getBytes ( ) , output . getBytes ( ) ) ; }
private static ImmutableList < Long > createRandomLongs ( int count ) { Random random = new Random ( ) ; ImmutableList . Builder < Long > list = ImmutableList . builder ( ) ; for ( int i = 0 ; i < count ; i + + ) { list . add ( random . nextLong ( ) ) ; } return list . build ( ) ; }
protected Slice allocate ( int size ) { return Slices . allocate ( size ) ; }
public float readFloat ( ) { float v = slice . getFloat ( position ) ; position + = SIZE_OF_FLOAT ; return v ; }
public double readDouble ( ) { double v = slice . getDouble ( position ) ; position + = SIZE_OF_DOUBLE ; return v ; }
public float readFloat ( ) { try { return dataInputStream . readFloat ( ) ;
public double readDouble ( ) { try { return dataInputStream . readDouble ( ) ;
public abstract void readBytes ( Slice destination , int destinationIndex , int length ) ; /** * Transfers this buffer's data to the specified stream starting at the * current {@code position}. * * @param length the number of bytes to transfer * @throws IndexOutOfBoundsException if {@code length} is greater than {@code this.available()} * @throws java.io.IOException if the specified stream threw an exception during I/O */ public abstract void readBytes ( OutputStream out , int length ) throws IOException ; @Override public abstract int skipBytes ( int length ) ; // // Unsupported operations // @Override public final void mark(int readLimit) { throw new UnsupportedOperationException(); } @Override public final void reset() { throw new UnsupportedOperationException(); } @Override public final boolean markSupported() { throw new UnsupportedOperationException(); } @Override public final char readChar() { throw new UnsupportedOperationException(); } @Override public abstract float readFloat(); @Override public abstract double readDouble(); @Override public final String readLine() { throw new UnsupportedOperationException(); } @Override public final String readUTF() { throw new UnsupportedOperationException(); } }
public abstract void readBytes ( OutputStream out , int length ) throws IOException ; @Override public abstract int skipBytes ( int length ) ; // // Unsupported operations // @Override public final void mark(int readLimit) { throw new UnsupportedOperationException(); } @Override public final void reset() { throw new UnsupportedOperationException(); } @Override public final boolean markSupported() { throw new UnsupportedOperationException(); } @Override public final char readChar() { throw new UnsupportedOperationException(); } @Override public abstract float readFloat(); @Override public abstract double readDouble(); @Override public final String readLine() { throw new UnsupportedOperationException(); } @Override public final String readUTF() { throw new UnsupportedOperationException(); } }
public abstract int skipBytes ( int length ) ; // // Unsupported operations // @Override public final void mark(int readLimit) { throw new UnsupportedOperationException(); } @Override public final void reset() { throw new UnsupportedOperationException(); } @Override public final boolean markSupported() { throw new UnsupportedOperationException(); } @Override public final char readChar() { throw new UnsupportedOperationException(); } @Override public abstract float readFloat(); @Override public abstract double readDouble(); @Override public final String readLine() { throw new UnsupportedOperationException(); } @Override public final String readUTF() { throw new UnsupportedOperationException(); } }
public abstract float readFloat ( ) ; @Override public abstract double readDouble ( ) ; @Override public final String readLine ( ) { throw new UnsupportedOperationException ( ) ; } @Override public final String readUTF ( ) { throw new UnsupportedOperationException ( ) ; } }
public abstract double readDouble ( ) ; @Override public final String readLine ( ) { throw new UnsupportedOperationException ( ) ; } @Override public final String readUTF ( ) { throw new UnsupportedOperationException ( ) ; } }
public String toStringUtf8 ( ) { return toString ( UTF_8 ) ; }
public static Slice utf8Slice ( String string ) { return copiedBuffer ( string , UTF_8 ) ; }
public void testUtf8Conversion ( ) { String s = " apple \ u2603 snowman " ; Slice slice = Slices . copiedBuffer ( s , UTF_8 ) ; assertEquals ( Slices . utf8Slice ( s ) , slice ) ; assertEquals ( slice . toStringUtf8 ( ) , s ) ; assertEquals ( Slices . utf8Slice ( s ) . toStringUtf8 ( ) , s ) ; }
public static long sizeOf ( char [ ] array ) { if ( array = = null ) { return 0 ; } return ARRAY_CHAR_BASE_OFFSET + ( ( long ) ARRAY_CHAR_INDEX_SCALE * array . length ) ; }
public int compareTo ( int offset , int length , Slice that , int otherOffset , int otherLength ) { if ( ( this = = that ) & & ( offset = = otherOffset ) & & ( length = = otherLength ) ) { return 0 ; } checkIndexLength ( offset , length ) ; that . checkIndexLength ( otherOffset , otherLength ) ; int compareLength = Math . min ( length , otherLength ) ; while ( compareLength > = SIZE_OF_LONG ) { long thisLong = unsafe . getLong ( base , address + offset ) ; thisLong = Long . reverseBytes ( thisLong ) ; long thatLong = unsafe . getLong ( that . base , that . address + otherOffset ) ; thatLong = Long . reverseBytes ( thatLong ) ; int v = UnsignedLongs . compare ( thisLong , thatLong ) ; if ( v ! = 0 ) { return v ; } offset + = SIZE_OF_LONG ; otherOffset + = SIZE_OF_LONG ; compareLength - = SIZE_OF_LONG ; } while ( compareLength > 0 ) { byte thisByte = unsafe . getByte ( base , address + offset ) ; byte thatByte = unsafe . getByte ( that . base , that . address + otherOffset ) ; int v = UnsignedBytes . compare ( thisByte , thatByte ) ; if ( v ! = 0 ) { return v ; } offset + + ; otherOffset + + ; compareLength - - ; } return Integer . compare ( length , otherLength ) ; }
public Object getBase ( ) { return base ; }
public long getAddress ( ) { return address ; }
public List < AutoKeeperConnectionStat > findConnectionByWatcherPath ( String path ) ; }
public void collectorServerStat ( String address ) { List < String > netAddress = splitAddress ( address ) ; if ( netAddress . isEmpty ( ) ) { return ; } String ip = netAddress . get ( 0 ) ; String port = netAddress . get ( 1 ) ; String [ ] cmd = { " /bin/bash " , " -c " , String . format ( CMD_STAT , ip , port ) } ; String cmdresult = collector ( cmd ) ; String [ ] result = cmdresult . split ( WRAP ) ; AutoKeeperServerStat summary = new AutoKeeperServerStat ( ) ; summary . setOriginalContent ( cmdresult ) ; for ( String line : result ) { if ( line . contains ( MODE_FOLLOWER ) ) { summary . setQuorumType ( AutoKeeperQuorumType . FOLLOWER ) ; } else if ( line . contains ( MODE_LEADERER ) ) { summary . setQuorumType ( AutoKeeperQuorumType . LEADER ) ; } else if ( line . contains ( MODE_STANDALONE ) ) { summary . setQuorumType ( AutoKeeperQuorumType . STANDALONE ) ; } else if ( line . contains ( MODE_OBSERVER ) ) { summary . setQuorumType ( AutoKeeperQuorumType . OBSERVER ) ; } else if ( line . contains ( STRING_LATENCY ) ) { List < String > latency = Arrays . asList ( StringUtils . trimToEmpty ( line . replace ( STRING_LATENCY , StringUtils . EMPTY ) ) . split ( " / " ) ) ; summary . setMinLatency ( Long . parseLong ( latency . get ( 0 ) ) ) ; summary . setAvgLatency ( Long . parseLong ( latency . get ( 1 ) ) ) ; summary . setMaxLatency ( Long . parseLong ( latency . get ( 2 ) ) ) ; } else if ( line . contains ( STRING_OUTSTANDING ) ) { summary . setQueued ( Long . parseLong ( StringUtils . trimToEmpty ( line . replace ( STRING_OUTSTANDING , StringUtils . EMPTY ) ) ) ) ; } else if ( line . contains ( NODE_COUNT ) ) { summary . setNodeCount ( Long . parseLong ( StringUtils . trimToEmpty ( line . replace ( NODE_COUNT , StringUtils . EMPTY ) ) ) ) ; } else if ( line . contains ( STRING_SENT ) ) { summary . setSent ( Long . parseLong ( StringUtils . trimToEmpty ( line . replace ( STRING_SENT , StringUtils . EMPTY ) ) ) ) ; } else if ( line . contains ( STRING_RECEIVED ) ) { summary . setRecved ( Long . parseLong ( StringUtils . trimToEmpty ( line . replace ( STRING_RECEIVED , StringUtils . EMPTY ) ) ) ) ; } } autoKeeperData . joinServer ( address , summary ) ; }
public void collectorEphemeralStat ( String address ) { List < String > netAddress = splitAddress ( address ) ; if ( netAddress . isEmpty ( ) ) { return ; } String ip = netAddress . get ( 0 ) ; String port = netAddress . get ( 1 ) ; String [ ] cmd = { " /bin/bash " , " -c " , String . format ( CMD_DUMP , ip , port ) } ; String cmdresult = collector ( cmd ) ; Map < String , List < String > > pathMap = groupSessionPath ( cmdresult ) ; List < AutoKeeperEphemeralStat > autoKeeperEphemeralStats = new ArrayList < AutoKeeperEphemeralStat > ( ) ; for ( Map . Entry < String , List < String > > entry : pathMap . entrySet ( ) ) { AutoKeeperEphemeralStat autoKeeperEphemeralStat = new AutoKeeperEphemeralStat ( ) ; autoKeeperEphemeralStat . setSessionId ( entry . getKey ( ) ) ; autoKeeperEphemeralStat . setPaths ( entry . getValue ( ) ) ; autoKeeperEphemeralStats . add ( autoKeeperEphemeralStat ) ; } autoKeeperData . joinEphemeral ( address , autoKeeperEphemeralStats ) ;
public void collectorWatchStat ( String address ) { List < String > netAddress = splitAddress ( address ) ; if ( netAddress . isEmpty ( ) ) { return ; } String ip = netAddress . get ( 0 ) ; String port = netAddress . get ( 1 ) ; String [ ] cmd = { " /bin/bash " , " -c " , String . format ( CMD_WCHC , ip , port ) } ; String cmdresult = collector ( cmd ) ; Map < String , List < String > > pathMap = groupSessionPath ( cmdresult ) ; List < AutoKeeperWatchStat > autoKeeperWatchStats = new ArrayList < AutoKeeperWatchStat > ( ) ; for ( Map . Entry < String , List < String > > entry : pathMap . entrySet ( ) ) { AutoKeeperWatchStat autoKeeperWatchStat = new AutoKeeperWatchStat ( ) ; autoKeeperWatchStat . setSessionId ( entry . getKey ( ) ) ; autoKeeperWatchStat . setPaths ( entry . getValue ( ) ) ; autoKeeperWatchStats . add ( autoKeeperWatchStat ) ; } autoKeeperData . joinWatch ( address , autoKeeperWatchStats ) ;
public static String collector ( String [ ] command ) { Result result = null ; try { result = Exec . execute ( command ) ;
private List < String > splitAddress ( String address ) { List < String > ipPort = Arrays . asList ( address . split ( " : " ) ) ; if ( ipPort . size ( ) ! = 2 ) { return new ArrayList < String > ( ) ; } return ipPort ; }
private Map < String , List < String > > groupSessionPath ( String cmdresult ) { String [ ] result = cmdresult . split ( WRAP ) ; Map < String , List < String > > pathMap = new HashMap < String , List < String > > ( ) ; String sessionId = StringUtils . EMPTY ; for ( String line : result ) { line = StringUtils . trimToEmpty ( line ) ; if ( StringUtils . isBlank ( line ) ) { continue ; } if ( line . startsWith ( " 0x " ) ) { sessionId = line . replace ( COLON , StringUtils . EMPTY ) ; pathMap . put ( sessionId , new ArrayList < String > ( ) ) ; } else if ( line . startsWith ( " / " ) ) { List < String > paths = pathMap . get ( sessionId ) ; paths . add ( line ) ; } } return pathMap ; }
public void afterPropertiesSet ( ) throws Exception { collectorExecutor = Executors . newScheduledThreadPool ( singleSize , new NamedThreadFactory ( " collector-thread " , true ) ) ; startCollect ( ) ; }
public void run ( ) { List < AutoKeeperCluster > autoKeeperClusters = autoKeeperClusterService . listAutoKeeperClusters ( ) ; if ( ! autoKeeperClusters . isEmpty ( ) ) { autoKeeperData . persist ( ) ;
public void setAutoKeeperClusterService ( AutoKeeperClusterService autoKeeperClusterService ) { this . autoKeeperClusterService = autoKeeperClusterService ; }
public void setAutoKeeperData ( AutoKeeperData autoKeeperData ) { this . autoKeeperData = autoKeeperData ; }
public void setCollectInterval ( long collectInterval ) { this . collectInterval = collectInterval ; }
public void joinServer ( String address , AutoKeeperServerStat summary ) { serverStats . put ( address , summary ) ; }
public void joinEphemeral ( String address , List < AutoKeeperEphemeralStat > ephemerals ) { for ( AutoKeeperEphemeralStat ephemeral : ephemerals ) { if ( connectionStats . containsKey ( ephemeral . getSessionId ( ) ) ) {
public void joinWatch ( String address , List < AutoKeeperWatchStat > watches ) { for ( AutoKeeperWatchStat watch : watches ) { if ( connectionStats . containsKey ( watch . getSessionId ( ) ) ) {
public void persist ( ) { serverStats . clear ( ) ; connectionStats . clear ( ) ; }
public Map < String , AutoKeeperServerStat > getServerStats ( ) { return serverStats ; }
public Map < String , AutoKeeperConnectionStat > getConnectionStats ( ) { return connectionStats ; }
public AutoKeeperServerStat findServerStat ( String serverAddress ) { return autoKeeperData . getServerStats ( ) . get ( serverAddress ) ; }
public AutoKeeperServerStat findServerStatBySessionId ( String sessionId ) { String serverAddress = autoKeeperData . getConnectionStats ( ) . get ( sessionId ) . getServerAddress ( ) ; return findServerStat ( serverAddress ) ; }
public AutoKeeperConnectionStat findConnectionBySessionId ( String sessionId ) { return autoKeeperData . getConnectionStats ( ) . get ( sessionId ) ; }
public AutoKeeperConnectionStat findConnectionByEphemeralPath ( String path ) { for ( AutoKeeperConnectionStat connection : autoKeeperData . getConnectionStats ( ) . values ( ) ) { for ( AutoKeeperEphemeralStat ephemeral : connection . getEphemeralStats ( ) ) { if ( ephemeral . getPaths ( ) . contains ( path ) ) { return connection ; } } } return null ; }
public List < AutoKeeperConnectionStat > findConnectionByWatcherPath ( String path ) { List < AutoKeeperConnectionStat > connections = new ArrayList < AutoKeeperConnectionStat > ( ) ; for ( AutoKeeperConnectionStat connection : autoKeeperData . getConnectionStats ( ) . values ( ) ) { for ( AutoKeeperWatchStat watch : connection . getWatchStats ( ) ) { if ( watch . getPaths ( ) . contains ( path ) ) { connections . add ( connection ) ; } } } return connections ; }
public void destroyDataSource ( DataSource dataSource ) { try { // for filter to destroy custom datasource
private DataSource preCreate ( Long pipelineId , DbMediaSource dbMediaSource ) { if ( CollectionUtils . isEmpty ( dataSourceHandlers ) ) { return null ; } DataSource dataSource = null ; for ( DataSourceHanlder handler : dataSourceHandlers ) { if ( handler . support ( dbMediaSource ) ) { dataSource = handler . create ( pipelineId , dbMediaSource ) ; if ( dataSource ! = null ) { return dataSource ; } } } return null ; }
public boolean letHandlerDestroyIfSupport ( Long pipelineId , DataSource source ) { boolean destroied = false ; if ( CollectionUtils . isEmpty ( this . dataSourceHandlers ) ) { return destroied ; } for ( DataSourceHanlder handler : this . dataSourceHandlers ) { if ( handler . support ( source ) ) { handler . destory ( pipelineId ) ; destroied = true ; return destroied ; } } return destroied ;
public void setMaxWait ( int maxWait ) { this . maxWait = maxWait ; }
public void setMinIdle ( int minIdle ) { this . minIdle = minIdle ; }
public void setInitialSize ( int initialSize ) { this . initialSize = initialSize ; }
public void setMaxActive ( int maxActive ) { this . maxActive = maxActive ; }
public void setMaxIdle ( int maxIdle ) { this . maxIdle = maxIdle ; }
public void setNumTestsPerEvictionRun ( int numTestsPerEvictionRun ) { this . numTestsPerEvictionRun = numTestsPerEvictionRun ; }
public void setTimeBetweenEvictionRunsMillis ( int timeBetweenEvictionRunsMillis ) { this . timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis ; }
public void setRemoveAbandonedTimeout ( int removeAbandonedTimeout ) { this . removeAbandonedTimeout = removeAbandonedTimeout ; }
public void setMinEvictableIdleTimeMillis ( int minEvictableIdleTimeMillis ) { this . minEvictableIdleTimeMillis = minEvictableIdleTimeMillis ; }
public void setDataSourceHandlers ( List < DataSourceHanlder > dataSourceHandlers ) { this . dataSourceHandlers = dataSourceHandlers ; }
public void sendAlarm ( AlarmMessage data ) { try { if ( ! queue . offer ( data , 2 , TimeUnit . SECONDS ) ) {
private void sendAlarmInternal ( ) { AlarmMessage data = null ; try { data = queue . take ( ) ;
protected abstract void doSend ( AlarmMessage data ) throws Exception ; public void afterPropertiesSet ( ) throws Exception { executor = Executors . newFixedThreadPool ( 1 ) ; executor . submit ( new Runnable ( ) { public void run ( ) { while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { sendAlarmInternal ( ) ; LockSupport . parkNanos ( period * 1000L * 1000L ) ; } } } ) ; } @Override public void destroy ( ) throws Exception { if ( executor ! = null & & ! executor . isShutdown ( ) ) { executor . shutdown ( ) ; executor . awaitTermination ( 2 , TimeUnit . SECONDS ) ; } if ( ! queue . isEmpty ( ) ) { int size = queue . size ( ) ; logger . warn ( String . format ( " there are %d alarms wait to be sent \ n %s " , size , dumpQueue ( ) ) ) ; } } protected String dumpQueue ( ) { if ( queue . isEmpty ( ) ) { return StringUtils . EMPTY ; } StringBuilder sb = new StringBuilder ( ) ; for ( AlarmMessage data : queue ) { sb . append ( data . toString ( ) ) . append ( " \ n " ) ; } return sb . toString ( ) ; } // ============= setter =============== public void setPeriod(int period) { this.period = period; } }
public void afterPropertiesSet ( ) throws Exception { executor = Executors . newFixedThreadPool ( 1 ) ; executor . submit ( new Runnable ( ) {
public void run ( ) { while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { sendAlarmInternal ( ) ;
public void destroy ( ) throws Exception { if ( executor ! = null & & ! executor . isShutdown ( ) ) { executor . shutdown ( ) ; executor . awaitTermination ( 2 , TimeUnit . SECONDS ) ; } if ( ! queue . isEmpty ( ) ) { int size = queue . size ( ) ;
protected String dumpQueue ( ) { if ( queue . isEmpty ( ) ) { return StringUtils . EMPTY ; } StringBuilder sb = new StringBuilder ( ) ; for ( AlarmMessage data : queue ) { sb . append ( data . toString ( ) ) . append ( " \ n " ) ; } return sb . toString ( ) ; }
public void setPeriod ( int period ) { this . period = period ; }
public String getMessage ( ) { return message ; }
public void setMessage ( String message ) { this . message = message ; }
public String getReceiveKey ( ) { return receiveKey ; }
public void setReceiveKey ( String receiveKey ) { this . receiveKey = receiveKey ; }
public String toString ( ) { return ToStringBuilder . reflectionToString ( this , OtterToStringStyle . DEFAULT_STYLE ) ; }
private void doSendMail ( SimpleMailMessage mail ) { if ( mailSender instanceof JavaMailSenderImpl ) { JavaMailSenderImpl mailSenderImpl = ( JavaMailSenderImpl ) mailSender ;
private boolean isMail ( String receiveKey ) { return StringUtils . contains ( receiveKey , '@' ) ; }
private boolean isSms ( String receiveKey ) { return false ; }
private String convertToReceiver ( SystemParameter systemParameter , String receiveKey ) { if ( StringUtils . equalsIgnoreCase ( systemParameter . getDefaultAlarmReceiveKey ( ) , receiveKey ) ) { return systemParameter . getDefaultAlarmReceiver ( ) ;
public void setMailSender ( JavaMailSender mailSender ) { this . mailSender = mailSender ; }
public void setUsername ( String username ) { this . username = username ; }
public void setSystemParameterService ( SystemParameterService systemParameterService ) { this . systemParameterService = systemParameterService ; }
public Node findNode ( Long nid ) { return nodeCache . get ( nid ) ; }
public Channel findChannel ( Long channelId ) { return channelCache . get ( channelId ) ; }
public Channel findChannelByPipelineId ( Long pipelineId ) { Long channelId = channelMapping . get ( pipelineId ) ; return channelCache . get ( channelId ) ; }
public Pipeline findPipeline ( Long pipelineId ) { Long channelId = channelMapping . get ( pipelineId ) ; Channel channel = channelCache . get ( channelId ) ; List < Pipeline > pipelines = channel . getPipelines ( ) ; for ( Pipeline pipeline : pipelines ) { if ( pipeline . getId ( ) . equals ( pipelineId ) ) { return pipeline ; } } throw new ConfigException ( " no pipeline for pipelineId[ " + pipelineId + " ] " ) ; }
public Node apply ( Long key , Node oldValue ) { Node node = nodeService . findById ( key ) ; if ( node = = null ) { return oldValue ;
private void updateMapping ( Channel channel , Long excludeId ) { Long channelId = channel . getId ( ) ; List < Pipeline > pipelines = channel . getPipelines ( ) ; for ( Pipeline pipeline : pipelines ) { if ( excludeId = = null | | ! pipeline . getId ( ) . equals ( excludeId ) ) {
public void setChannelService ( ChannelService channelService ) { this . channelService = channelService ; }
public void setNodeService ( NodeService nodeService ) { this . nodeService = nodeService ; }
public void afterPropertiesSet ( ) throws Exception { nodeMonitor . addListener ( this ) ; executor = Executors . newFixedThreadPool ( 1 ) ; executor . submit ( new Runnable ( ) {
public void run ( ) { while ( true ) { DeadNodeDelayed delay = null ;
public void destroy ( ) throws Exception { nodeMonitor . removeListener ( this ) ; executor . shutdownNow ( ) ; }
public long getNid ( ) { return nid ; }
public long getNow ( ) { return now ; }
public long getDelay ( TimeUnit unit ) { long currNow = System . currentTimeMillis ( ) - MILL_ORIGIN ; long d = unit . convert ( now + timeout - currNow , TimeUnit . MILLISECONDS ) ; return d ; }
public int compareTo ( Delayed other ) { if ( other = = this ) { // compare zero ONLY if same object return 0;
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( int ) ( nid ^ ( nid > > > 32 ) ) ; return result ; }
public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null ) { return false ; } if ( ! ( obj instanceof DeadNodeDelayed ) ) { return false ; } DeadNodeDelayed other = ( DeadNodeDelayed ) obj ; if ( nid ! = other . nid ) { return false ; } return true ; }
public void setNodeMonitor ( NodeMonitor nodeMonitor ) { this . nodeMonitor = nodeMonitor ; }
public void setArbitrateManageService ( ArbitrateManageService arbitrateManageService ) { this . arbitrateManageService = arbitrateManageService ; }
public void setExceptionRuleMonitor ( PassiveMonitor exceptionRuleMonitor ) { this . exceptionRuleMonitor = exceptionRuleMonitor ; }
public T insert ( T entityObj ) ; public void delete ( Long identity ) ; public void update ( T entityObj ) ; public List < T > listAll ( ) ; public List < T > listByCondition ( Map condition ) ; public List < T > listByMultiId ( Long . . . identities ) ; public T findById ( Long identity ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; public boolean checkUnique ( T entityObj ) ; }
public void delete ( Long identity ) ; public void update ( T entityObj ) ; public List < T > listAll ( ) ; public List < T > listByCondition ( Map condition ) ; public List < T > listByMultiId ( Long . . . identities ) ; public T findById ( Long identity ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; public boolean checkUnique ( T entityObj ) ; }
public void update ( T entityObj ) ; public List < T > listAll ( ) ; public List < T > listByCondition ( Map condition ) ; public List < T > listByMultiId ( Long . . . identities ) ; public T findById ( Long identity ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; public boolean checkUnique ( T entityObj ) ; }
public List < T > listAll ( ) ; public List < T > listByCondition ( Map condition ) ; public List < T > listByMultiId ( Long . . . identities ) ; public T findById ( Long identity ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; public boolean checkUnique ( T entityObj ) ; }
public List < T > listByCondition ( Map condition ) ; public List < T > listByMultiId ( Long . . . identities ) ; public T findById ( Long identity ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; public boolean checkUnique ( T entityObj ) ; }
public List < T > listByMultiId ( Long . . . identities ) ; public T findById ( Long identity ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; public boolean checkUnique ( T entityObj ) ; }
public T findById ( Long identity ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; public boolean checkUnique ( T entityObj ) ; }
public int getCount ( ) ; public int getCount ( Map condition ) ; public boolean checkUnique ( T entityObj ) ; }
public int getCount ( Map condition ) ; public boolean checkUnique ( T entityObj ) ; }
public void create ( T entityObj ) ; public void remove ( Long identity ) ; public void modify ( T entityObj ) ; public T findById ( Long identity ) ; public List < T > listByIds ( Long . . . identities ) ; public List < T > listAll ( ) ; public List < T > listByCondition ( Map condition ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; }
public void remove ( Long identity ) ; public void modify ( T entityObj ) ; public T findById ( Long identity ) ; public List < T > listByIds ( Long . . . identities ) ; public List < T > listAll ( ) ; public List < T > listByCondition ( Map condition ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; }
public void modify ( T entityObj ) ; public T findById ( Long identity ) ; public List < T > listByIds ( Long . . . identities ) ; public List < T > listAll ( ) ; public List < T > listByCondition ( Map condition ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; }
public T findById ( Long identity ) ; public List < T > listByIds ( Long . . . identities ) ; public List < T > listAll ( ) ; public List < T > listByCondition ( Map condition ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; }
public List < T > listByIds ( Long . . . identities ) ; public List < T > listAll ( ) ; public List < T > listByCondition ( Map condition ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; }
public List < T > listAll ( ) ; public List < T > listByCondition ( Map condition ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; }
public List < T > listByCondition ( Map condition ) ; public int getCount ( ) ; public int getCount ( Map condition ) ; }
public int getCount ( ) ; public int getCount ( Map condition ) ; }
public INVALID_TYPE getType ( ) { return type ; }
Map < Long , List < AlarmRule > > getAlarmRules ( AlarmRuleStatus status ) ; List < AlarmRule > getAlarmRules ( Long pipelineId ) ; List < AlarmRule > getAlarmRules ( Long pipelineId , AlarmRuleStatus status ) ; List < AlarmRule > listAllAlarmRules ( Map condition ) ; public int getCount ( ) ; }
List < AlarmRule > getAlarmRules ( Long pipelineId ) ; List < AlarmRule > getAlarmRules ( Long pipelineId , AlarmRuleStatus status ) ; List < AlarmRule > listAllAlarmRules ( Map condition ) ; public int getCount ( ) ; }
List < AlarmRule > getAlarmRules ( Long pipelineId , AlarmRuleStatus status ) ; List < AlarmRule > listAllAlarmRules ( Map condition ) ; public int getCount ( ) ; }
List < AlarmRule > listAllAlarmRules ( Map condition ) ; public int getCount ( ) ; }
public AlarmRuleDO insert ( AlarmRuleDO entityObj ) ; public void update ( AlarmRuleDO entityObj ) ; public void delete ( Long id ) ; public AlarmRuleDO findById ( Long alarmRuleId ) ; public List < AlarmRuleDO > listByPipelineId ( Long pipelineId ) ; public List < AlarmRuleDO > listByPipelineId ( Long pipelineId , AlarmRuleStatus status ) ; public List < AlarmRuleDO > listAll ( ) ; public List < AlarmRuleDO > listAllByPipeline ( Map condition ) ; public List < AlarmRuleDO > listByStatus ( AlarmRuleStatus status ) ; public int getCount ( ) ; }
public void update ( AlarmRuleDO entityObj ) ; public void delete ( Long id ) ; public AlarmRuleDO findById ( Long alarmRuleId ) ; public List < AlarmRuleDO > listByPipelineId ( Long pipelineId ) ; public List < AlarmRuleDO > listByPipelineId ( Long pipelineId , AlarmRuleStatus status ) ; public List < AlarmRuleDO > listAll ( ) ; public List < AlarmRuleDO > listAllByPipeline ( Map condition ) ; public List < AlarmRuleDO > listByStatus ( AlarmRuleStatus status ) ; public int getCount ( ) ; }
public void delete ( Long id ) ; public AlarmRuleDO findById ( Long alarmRuleId ) ; public List < AlarmRuleDO > listByPipelineId ( Long pipelineId ) ; public List < AlarmRuleDO > listByPipelineId ( Long pipelineId , AlarmRuleStatus status ) ; public List < AlarmRuleDO > listAll ( ) ; public List < AlarmRuleDO > listAllByPipeline ( Map condition ) ; public List < AlarmRuleDO > listByStatus ( AlarmRuleStatus status ) ; public int getCount ( ) ; }
public AlarmRuleDO findById ( Long alarmRuleId ) ; public List < AlarmRuleDO > listByPipelineId ( Long pipelineId ) ; public List < AlarmRuleDO > listByPipelineId ( Long pipelineId , AlarmRuleStatus status ) ; public List < AlarmRuleDO > listAll ( ) ; public List < AlarmRuleDO > listAllByPipeline ( Map condition ) ; public List < AlarmRuleDO > listByStatus ( AlarmRuleStatus status ) ; public int getCount ( ) ; }
public List < AlarmRuleDO > listByPipelineId ( Long pipelineId ) ; public List < AlarmRuleDO > listByPipelineId ( Long pipelineId , AlarmRuleStatus status ) ; public List < AlarmRuleDO > listAll ( ) ; public List < AlarmRuleDO > listAllByPipeline ( Map condition ) ; public List < AlarmRuleDO > listByStatus ( AlarmRuleStatus status ) ; public int getCount ( ) ; }
public List < AlarmRuleDO > listByPipelineId ( Long pipelineId , AlarmRuleStatus status ) ; public List < AlarmRuleDO > listAll ( ) ; public List < AlarmRuleDO > listAllByPipeline ( Map condition ) ; public List < AlarmRuleDO > listByStatus ( AlarmRuleStatus status ) ; public int getCount ( ) ; }
public List < AlarmRuleDO > listAll ( ) ; public List < AlarmRuleDO > listAllByPipeline ( Map condition ) ; public List < AlarmRuleDO > listByStatus ( AlarmRuleStatus status ) ; public int getCount ( ) ; }
public List < AlarmRuleDO > listAllByPipeline ( Map condition ) ; public List < AlarmRuleDO > listByStatus ( AlarmRuleStatus status ) ; public int getCount ( ) ; }
public List < AlarmRuleDO > listByStatus ( AlarmRuleStatus status ) ; public int getCount ( ) ; }
public void setId ( Long id ) { this . id = id ; }
public Long getPipelineId ( ) { return pipelineId ; }
public void setPipelineId ( Long pipelineId ) { this . pipelineId = pipelineId ; }
public AlarmRuleStatus getStatus ( ) { return status ; }
public void setStatus ( AlarmRuleStatus status ) { this . status = status ; }
public MonitorName getMonitorName ( ) { return monitorName ; }
public void setMonitorName ( MonitorName monitorName ) { this . monitorName = monitorName ; }
public String getReceiverKey ( ) { return receiverKey ; }
public void setReceiverKey ( String receiverKey ) { this . receiverKey = receiverKey ; }
public String getMatchValue ( ) { return matchValue ; }
public void setMatchValue ( String matchValue ) { this . matchValue = matchValue ; }
public AlarmRuleParameter getAlarmRuleParameter ( ) { return alarmRuleParameter ; }
public void setAlarmRuleParameter ( AlarmRuleParameter alarmRuleParameter ) { this . alarmRuleParameter = alarmRuleParameter ; }
public String getDescription ( ) { return description ; }
public void setDescription ( String description ) { this . description = description ; }
public Date getGmtCreate ( ) { return gmtCreate ; }
public void setGmtCreate ( Date gmtCreate ) { this . gmtCreate = gmtCreate ; }
public Date getGmtModified ( ) { return gmtModified ; }
public void setGmtModified ( Date gmtModified ) { this . gmtModified = gmtModified ; }
public Long getIntervalTime ( ) { return intervalTime ; }
public void setIntervalTime ( Long intervalTime ) { this . intervalTime = intervalTime ; }
public String getPauseTime ( ) { return pauseTime ; }
public void setPauseTime ( String pauseTime ) { this . pauseTime = pauseTime ; }
public Boolean getAutoRecovery ( ) { return autoRecovery ; }
public void setAutoRecovery ( Boolean autoRecovery ) { this . autoRecovery = autoRecovery ; }
public Integer getRecoveryThresold ( ) { return recoveryThresold ; }
public void setRecoveryThresold ( Integer recoveryThresold ) { this . recoveryThresold = recoveryThresold ; }
public void setParameter ( ParameterSetter setter , Object parameter ) throws SQLException { setter . setString ( JsonUtils . marshalToString ( parameter ) ) ; }
public Object getResult ( ResultGetter getter ) throws SQLException { return JsonUtils . unmarshalFromString ( getter . getString ( ) , AlarmRuleParameter . class ) ; }
public Object valueOf ( String s ) { return JsonUtils . unmarshalFromString ( s , AlarmRuleParameter . class ) ; }
public AlarmRuleDO insert ( AlarmRuleDO entityObj ) { Assert . assertNotNull ( entityObj ) ; getSqlMapClientTemplate ( ) . insert ( " insertAlarmRule " , entityObj ) ; return entityObj ; }
public void update ( AlarmRuleDO entityObj ) { Assert . assertNotNull ( entityObj ) ; getSqlMapClientTemplate ( ) . update ( " updateAlarmRule " , entityObj ) ; }
public void delete ( Long id ) { Assert . assertNotNull ( id ) ; getSqlMapClientTemplate ( ) . update ( " deleteAlarmRuleById " , id ) ; }
public AlarmRuleDO findById ( Long alarmRuleId ) { Assert . assertNotNull ( alarmRuleId ) ; AlarmRuleDO alarmRuleDo = ( AlarmRuleDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findByRuleId " , alarmRuleId ) ; return alarmRuleDo ; }
public List < AlarmRuleDO > listByPipelineId ( Long pipelineId ) { Assert . assertNotNull ( pipelineId ) ; List < AlarmRuleDO > alarmRuleDos = getSqlMapClientTemplate ( ) . queryForList ( " listAlarmByPipelineId " , pipelineId ) ; return alarmRuleDos ; }
public List < AlarmRuleDO > listByPipelineId ( Long pipelineId , AlarmRuleStatus status ) { List < AlarmRuleDO > alarmRuleDos = listByPipelineId ( pipelineId ) ; List < AlarmRuleDO > result = new ArrayList < AlarmRuleDO > ( ) ; for ( AlarmRuleDO alarmRuleDo : alarmRuleDos ) { if ( alarmRuleDo . getStatus ( ) . equals ( status ) ) { result . add ( alarmRuleDo ) ; } } return result ; }
public List < AlarmRuleDO > listAll ( ) { List < AlarmRuleDO > alarmRuleDos = getSqlMapClientTemplate ( ) . queryForList ( " listAllAlarmRule " ) ; return alarmRuleDos ; }
public List < AlarmRuleDO > listAllByPipeline ( Map condition ) { List < AlarmRuleDO > alarmRuleDos = getSqlMapClientTemplate ( ) . queryForList ( " listAllAlarmOrderByPipeline " , condition ) ; return alarmRuleDos ; }
public List < AlarmRuleDO > listByStatus ( AlarmRuleStatus status ) { List < AlarmRuleDO > alarmRuleDos = getSqlMapClientTemplate ( ) . queryForList ( " listAlarmByStatus " , status ) ; return alarmRuleDos ; }
public int getCount ( ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getAlarmRuleCount " ) ; return count . intValue ( ) ; }
public void create ( AlarmRule alarmRule ) { Assert . assertNotNull ( alarmRule ) ; alarmRuleDao . insert ( modelToDo ( alarmRule ) ) ; }
public void modify ( AlarmRule alarmRule ) { AlarmRuleDO alarmRuleDo = modelToDo ( alarmRule ) ; alarmRuleDao . update ( alarmRuleDo ) ;
public void remove ( Long alarmRuleId ) { alarmRuleDao . delete ( alarmRuleId ) ; }
private void switchAlarmRuleStatus ( Long alarmRuleId , AlarmRuleStatus alarmRuleStatus , String pauseTime ) { AlarmRuleDO alarmRuleDo = alarmRuleDao . findById ( alarmRuleId ) ; if ( null = = alarmRuleDo ) { String exceptionCause = " query alarmRule: " + alarmRuleId + " return null. " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } alarmRuleDo . setStatus ( alarmRuleStatus ) ; if ( alarmRuleDo . getAlarmRuleParameter ( ) ! = null ) { alarmRuleDo . getAlarmRuleParameter ( ) . setPauseTime ( pauseTime ) ; } else if ( StringUtils . isNotEmpty ( pauseTime ) ) { alarmRuleDo . setAlarmRuleParameter ( new AlarmRuleParameter ( ) ) ; alarmRuleDo . getAlarmRuleParameter ( ) . setPauseTime ( pauseTime ) ; } alarmRuleDao . update ( alarmRuleDo ) ; }
public void enableMonitor ( Long alarmRuleId ) { switchAlarmRuleStatus ( alarmRuleId , AlarmRuleStatus . ENABLE , null ) ; }
public void disableMonitor ( Long alarmRuleId ) { switchAlarmRuleStatus ( alarmRuleId , AlarmRuleStatus . DISABLE , null ) ; }
public void disableMonitor ( Long alarmRuleId , String pauseTime ) { switchAlarmRuleStatus ( alarmRuleId , AlarmRuleStatus . ENABLE , pauseTime ) ; }
public AlarmRule getAlarmRuleById ( Long AlarmRuleId ) { Assert . assertNotNull ( AlarmRuleId ) ; return doToModel ( alarmRuleDao . findById ( AlarmRuleId ) ) ; }
public List < AlarmRule > getAllAlarmRules ( AlarmRuleStatus status ) { Assert . assertNotNull ( status ) ; List < AlarmRuleDO > alarmRuleDos = alarmRuleDao . listByStatus ( status ) ; return doToModel ( alarmRuleDos ) ; }
public Map < Long , List < AlarmRule > > getAlarmRules ( AlarmRuleStatus status ) { Assert . assertNotNull ( status ) ; List < AlarmRule > alarmRules = getAllAlarmRules ( status ) ; Map < Long , List < AlarmRule > > result = new HashMap < Long , List < AlarmRule > > ( ) ; for ( AlarmRule alarmRule : alarmRules ) { List < AlarmRule > rules = result . get ( alarmRule . getPipelineId ( ) ) ; if ( rules = = null ) { rules = new ArrayList < AlarmRule > ( ) ; } if ( ! rules . contains ( alarmRule ) ) { rules . add ( alarmRule ) ; } result . put ( alarmRule . getPipelineId ( ) , rules ) ; } return result ; }
public List < AlarmRule > getAlarmRules ( Long pipelineId ) { Assert . assertNotNull ( pipelineId ) ; List < AlarmRuleDO > alarmRuleDos = alarmRuleDao . listByPipelineId ( pipelineId ) ; return doToModel ( alarmRuleDos ) ; }
public List < AlarmRule > getAlarmRules ( Long pipelineId , AlarmRuleStatus status ) { Assert . assertNotNull ( pipelineId ) ; Assert . assertNotNull ( status ) ; List < AlarmRuleDO > alarmRuleDos = alarmRuleDao . listByPipelineId ( pipelineId , status ) ; return doToModel ( alarmRuleDos ) ; }
public List < AlarmRule > listAllAlarmRules ( Map condition ) { List < AlarmRule > alarmRules = doToModel ( alarmRuleDao . listAllByPipeline ( condition ) ) ; return alarmRules ; }
public int getCount ( ) { return alarmRuleDao . getCount ( ) ; }
private List < AlarmRule > doToModel ( List < AlarmRuleDO > alarmRuleDos ) { List < AlarmRule > alarmRules = new ArrayList < AlarmRule > ( ) ; for ( AlarmRuleDO alarmRuleDo : alarmRuleDos ) { alarmRules . add ( doToModel ( alarmRuleDo ) ) ; } return alarmRules ; }
private AlarmRuleDO modelToDo ( AlarmRule alarmRule ) { AlarmRuleDO alarmRuleDo = new AlarmRuleDO ( ) ; alarmRuleDo . setId ( alarmRule . getId ( ) ) ; alarmRuleDo . setMatchValue ( alarmRule . getMatchValue ( ) ) ; alarmRuleDo . setMonitorName ( alarmRule . getMonitorName ( ) ) ; alarmRuleDo . setReceiverKey ( alarmRule . getReceiverKey ( ) ) ; alarmRuleDo . setPipelineId ( alarmRule . getPipelineId ( ) ) ; alarmRuleDo . setStatus ( alarmRule . getStatus ( ) ) ; alarmRuleDo . setDescription ( alarmRule . getDescription ( ) ) ; alarmRuleDo . setGmtCreate ( alarmRule . getGmtCreate ( ) ) ; alarmRuleDo . setGmtModified ( alarmRule . getGmtModified ( ) ) ; AlarmRuleParameter alarmRuleParameter = new AlarmRuleParameter ( ) ; alarmRuleParameter . setIntervalTime ( alarmRule . getIntervalTime ( ) ) ; if ( alarmRule . getPauseTime ( ) ! = null ) { SimpleDateFormat format = new SimpleDateFormat ( TIMESTAMP_FORMAT ) ; alarmRuleParameter . setPauseTime ( format . format ( alarmRule . getPauseTime ( ) ) ) ; } alarmRuleParameter . setAutoRecovery ( alarmRule . getAutoRecovery ( ) ) ; alarmRuleParameter . setRecoveryThresold ( alarmRule . getRecoveryThresold ( ) ) ; alarmRuleDo . setAlarmRuleParameter ( alarmRuleParameter ) ; return alarmRuleDo ; }
public void setAlarmRuleDao ( AlarmRuleDAO alarmRuleDao ) { this . alarmRuleDao = alarmRuleDao ; }
public AutoKeeperCluster findAutoKeeperClusterById ( Long id ) ; public List < AutoKeeperCluster > listAutoKeeperClusters ( ) ; public void modifyAutoKeeperCluster ( AutoKeeperCluster autoKeeperCluster ) ; public void createAutoKeeperCluster ( AutoKeeperCluster autoKeeperCluster ) ; public void removeAutoKeeperCluster ( Long id ) ; public Integer getCount ( ) ; }
public List < AutoKeeperCluster > listAutoKeeperClusters ( ) ; public void modifyAutoKeeperCluster ( AutoKeeperCluster autoKeeperCluster ) ; public void createAutoKeeperCluster ( AutoKeeperCluster autoKeeperCluster ) ; public void removeAutoKeeperCluster ( Long id ) ; public Integer getCount ( ) ; }
public void modifyAutoKeeperCluster ( AutoKeeperCluster autoKeeperCluster ) ; public void createAutoKeeperCluster ( AutoKeeperCluster autoKeeperCluster ) ; public void removeAutoKeeperCluster ( Long id ) ; public Integer getCount ( ) ; }
public void createAutoKeeperCluster ( AutoKeeperCluster autoKeeperCluster ) ; public void removeAutoKeeperCluster ( Long id ) ; public Integer getCount ( ) ; }
public void removeAutoKeeperCluster ( Long id ) ; public Integer getCount ( ) ; }
public AutoKeeperClusterDO findAutoKeeperClusterById ( Long id ) ; public List < AutoKeeperClusterDO > listAutoKeeperClusters ( ) ; public void updateAutoKeeperCluster ( AutoKeeperClusterDO autoKeeperClusterDo ) ; public void insertAutoKeeperClusterDO ( AutoKeeperClusterDO autoKeeperClusterDo ) ; public void delete ( Long clusterId ) ; public Integer getCount ( ) ; }
public List < AutoKeeperClusterDO > listAutoKeeperClusters ( ) ; public void updateAutoKeeperCluster ( AutoKeeperClusterDO autoKeeperClusterDo ) ; public void insertAutoKeeperClusterDO ( AutoKeeperClusterDO autoKeeperClusterDo ) ; public void delete ( Long clusterId ) ; public Integer getCount ( ) ; }
public void updateAutoKeeperCluster ( AutoKeeperClusterDO autoKeeperClusterDo ) ; public void insertAutoKeeperClusterDO ( AutoKeeperClusterDO autoKeeperClusterDo ) ; public void delete ( Long clusterId ) ; public Integer getCount ( ) ; }
public void insertAutoKeeperClusterDO ( AutoKeeperClusterDO autoKeeperClusterDo ) ; public void delete ( Long clusterId ) ; public Integer getCount ( ) ; }
public void delete ( Long clusterId ) ; public Integer getCount ( ) ; }
public String getClusterName ( ) { return clusterName ; }
public void setClusterName ( String clusterName ) { this . clusterName = clusterName ; }
public String getServerList ( ) { return serverList ; }
public void setServerList ( String serverList ) { this . serverList = serverList ; }
public AutoKeeperClusterDO findAutoKeeperClusterById ( Long id ) { Assert . assertNotNull ( id ) ; return ( AutoKeeperClusterDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findAutoKeeperClusterById " , id ) ; }
public List < AutoKeeperClusterDO > listAutoKeeperClusters ( ) { List < AutoKeeperClusterDO > autoKeeperClusterDOs = getSqlMapClientTemplate ( ) . queryForList ( " listAutoKeeperClusters " ) ; return autoKeeperClusterDOs ; }
public void updateAutoKeeperCluster ( AutoKeeperClusterDO autoKeeperClusterDo ) { Assert . assertNotNull ( autoKeeperClusterDo ) ; getSqlMapClientTemplate ( ) . update ( " updateAutoKeeperCluster " , autoKeeperClusterDo ) ; }
public void insertAutoKeeperClusterDO ( AutoKeeperClusterDO autoKeeperClusterDo ) { Assert . assertNotNull ( autoKeeperClusterDo ) ; getSqlMapClientTemplate ( ) . insert ( " insertAutoKeeperCluster " , autoKeeperClusterDo ) ; }
public void delete ( Long clusterId ) { Assert . assertNotNull ( clusterId ) ; getSqlMapClientTemplate ( ) . insert ( " deleteAutoKeeperClusterById " , clusterId ) ; }
public Integer getCount ( ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getAutoKeeperClusterCount " ) ; return count . intValue ( ) ; }
public AutoKeeperCluster findAutoKeeperClusterById ( Long id ) { AutoKeeperClusterDO autoKeeperClusterDO = autoKeeperClusterDao . findAutoKeeperClusterById ( id ) ; return autoKeeperClusterDO = = null ? null : doToModel ( autoKeeperClusterDO ) ; }
public List < AutoKeeperCluster > listAutoKeeperClusters ( ) { return doToModel ( autoKeeperClusterDao . listAutoKeeperClusters ( ) ) ; }
public void modifyAutoKeeperCluster ( AutoKeeperCluster autoKeeperCluster ) { autoKeeperClusterDao . updateAutoKeeperCluster ( modelToDo ( autoKeeperCluster ) ) ; }
public void createAutoKeeperCluster ( AutoKeeperCluster autoKeeperCluster ) { autoKeeperClusterDao . insertAutoKeeperClusterDO ( modelToDo ( autoKeeperCluster ) ) ; }
public void removeAutoKeeperCluster ( Long id ) { autoKeeperClusterDao . delete ( id ) ; }
private AutoKeeperCluster doToModel ( AutoKeeperClusterDO autoKeeperClusterDo ) { AutoKeeperCluster autoKeeperCluster = new AutoKeeperCluster ( ) ; autoKeeperCluster . setId ( autoKeeperClusterDo . getId ( ) ) ; autoKeeperCluster . setClusterName ( autoKeeperClusterDo . getClusterName ( ) ) ; autoKeeperCluster . setDescription ( autoKeeperClusterDo . getDescription ( ) ) ; autoKeeperCluster . setServerList ( JsonUtils . unmarshalFromString ( autoKeeperClusterDo . getServerList ( ) , new TypeReference < List < String > > ( ) { } ) ) ; autoKeeperCluster . setGmtCreate ( autoKeeperClusterDo . getGmtCreate ( ) ) ; autoKeeperCluster . setGmtModified ( autoKeeperClusterDo . getGmtModified ( ) ) ; return autoKeeperCluster ; }
public Integer getCount ( ) { return autoKeeperClusterDao . getCount ( ) ; }
private List < AutoKeeperCluster > doToModel ( List < AutoKeeperClusterDO > autoKeeperClusterDos ) { List < AutoKeeperCluster > autoKeeperClusters = new ArrayList < AutoKeeperCluster > ( ) ; for ( AutoKeeperClusterDO autoKeeperClusterDo : autoKeeperClusterDos ) { autoKeeperClusters . add ( doToModel ( autoKeeperClusterDo ) ) ; } return autoKeeperClusters ; }
private AutoKeeperClusterDO modelToDo ( AutoKeeperCluster autoKeeperCluster ) { AutoKeeperClusterDO autokeeperClusterDo = new AutoKeeperClusterDO ( ) ; autokeeperClusterDo . setId ( autoKeeperCluster . getId ( ) ) ; autokeeperClusterDo . setClusterName ( autoKeeperCluster . getClusterName ( ) ) ; autokeeperClusterDo . setDescription ( autoKeeperCluster . getDescription ( ) ) ; autokeeperClusterDo . setServerList ( JsonUtils . marshalToString ( autoKeeperCluster . getServerList ( ) ) ) ; autokeeperClusterDo . setGmtCreate ( autoKeeperCluster . getGmtCreate ( ) ) ; autokeeperClusterDo . setGmtModified ( autoKeeperCluster . getGmtModified ( ) ) ; return autokeeperClusterDo ; }
public void setAutoKeeperClusterDao ( AutoKeeperClusterDAO autoKeeperClusterDao ) { this . autoKeeperClusterDao = autoKeeperClusterDao ; }
public void create ( Canal canal ) ; public void remove ( Long canalId ) ; public void modify ( Canal canal ) ; public List < Canal > listByIds ( Long . . . identities ) ; public List < Canal > listAll ( ) ; public Canal findById ( Long canalId ) ; public Canal findByName ( String name ) ; public int getCount ( Map condition ) ; public List < Canal > listByCondition ( Map condition ) ; }
public void remove ( Long canalId ) ; public void modify ( Canal canal ) ; public List < Canal > listByIds ( Long . . . identities ) ; public List < Canal > listAll ( ) ; public Canal findById ( Long canalId ) ; public Canal findByName ( String name ) ; public int getCount ( Map condition ) ; public List < Canal > listByCondition ( Map condition ) ; }
public void modify ( Canal canal ) ; public List < Canal > listByIds ( Long . . . identities ) ; public List < Canal > listAll ( ) ; public Canal findById ( Long canalId ) ; public Canal findByName ( String name ) ; public int getCount ( Map condition ) ; public List < Canal > listByCondition ( Map condition ) ; }
public List < Canal > listByIds ( Long . . . identities ) ; public List < Canal > listAll ( ) ; public Canal findById ( Long canalId ) ; public Canal findByName ( String name ) ; public int getCount ( Map condition ) ; public List < Canal > listByCondition ( Map condition ) ; }
public List < Canal > listAll ( ) ; public Canal findById ( Long canalId ) ; public Canal findByName ( String name ) ; public int getCount ( Map condition ) ; public List < Canal > listByCondition ( Map condition ) ; }
public Canal findById ( Long canalId ) ; public Canal findByName ( String name ) ; public int getCount ( Map condition ) ; public List < Canal > listByCondition ( Map condition ) ; }
public Canal findByName ( String name ) ; public int getCount ( Map condition ) ; public List < Canal > listByCondition ( Map condition ) ; }
public int getCount ( Map condition ) ; public List < Canal > listByCondition ( Map condition ) ; }
public CanalStatus getStatus ( ) { return status ; }
public void setStatus ( CanalStatus status ) { this . status = status ; }
public CanalParameter getParameters ( ) { return parameters ; }
public void setParameters ( CanalParameter parameters ) { this . parameters = parameters ; }
public Object getResult ( ResultGetter getter ) throws SQLException { return JsonUtils . unmarshalFromString ( getter . getString ( ) , CanalParameter . class ) ; }
public Object valueOf ( String s ) { return JsonUtils . unmarshalFromString ( s , CanalParameter . class ) ; }
public CanalDO insert ( CanalDO canal ) { Assert . assertNotNull ( canal ) ; getSqlMapClientTemplate ( ) . insert ( " insertCanal " , canal ) ; return canal ; }
public void delete ( Long canalId ) { Assert . assertNotNull ( canalId ) ; getSqlMapClientTemplate ( ) . delete ( " deleteCanalById " , canalId ) ; }
public void update ( CanalDO canal ) { Assert . assertNotNull ( canal ) ; getSqlMapClientTemplate ( ) . update ( " updateCanal " , canal ) ; }
public List < CanalDO > listAll ( ) { return ( List < CanalDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listCanals " ) ; }
public List < CanalDO > listByMultiId ( Long . . . identities ) { List < CanalDO > canalDos = getSqlMapClientTemplate ( ) . queryForList ( " listCanalByIds " , identities ) ; return canalDos ; }
public boolean checkUnique ( CanalDO canal ) { int count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " checkCanalUnique " , canal ) ; return count = = 0 ? true : false ; }
public CanalDO findByName ( String name ) { Assert . assertNotNull ( name ) ; return ( CanalDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findCanalByName " , name ) ; }
public CanalDO findById ( Long identity ) { throw new UnsupportedOperationException ( ) ; }
public int getCount ( Map condition ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getCanalCount " , condition ) ; return count . intValue ( ) ; }
public List < CanalDO > listByCondition ( Map condition ) { List < CanalDO > canalDos = getSqlMapClientTemplate ( ) . queryForList ( " listCanals " , condition ) ; return canalDos ; }
public void create ( final Canal canal ) { Assert . assertNotNull ( canal ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { CanalDO canalDO = modelToDo ( canal ) ;
public void remove ( final Long canalId ) { Assert . assertNotNull ( canalId ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { Canal canal = findById ( canalId ) ;
public void modify ( final Canal canal ) { Assert . assertNotNull ( canal ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { CanalDO canalDo = modelToDo ( canal ) ;
public List < Canal > listByIds ( Long . . . identities ) { List < Canal > canals = new ArrayList < Canal > ( ) ; try { List < CanalDO > canalDos = null ; if ( identities . length < 1 ) { canalDos = canalDao . listAll ( ) ; if ( canalDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any canal, maybe hasn't create any canal. " ) ; return canals ; } } else { canalDos = canalDao . listByMultiId ( identities ) ; if ( canalDos . isEmpty ( ) ) { String exceptionCause = " couldn't query any canal by canalIds: " + Arrays . toString ( identities ) ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } } canals = doToModel ( canalDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query channels has an exception! " ) ; throw new ManagerException ( e ) ; } return canals ; }
public List < Canal > listAll ( ) { return listByIds ( ) ; }
public Canal findById ( Long canalId ) { Assert . assertNotNull ( canalId ) ; List < Canal > canals = listByIds ( canalId ) ; if ( canals . size ( ) ! = 1 ) { String exceptionCause = " query canalId: " + canalId + " return null. " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } return canals . get ( 0 ) ; }
public Canal findByName ( String name ) { Assert . assertNotNull ( name ) ; CanalDO canalDo = canalDao . findByName ( name ) ; if ( canalDo = = null ) { String exceptionCause = " query name: " + name + " return null. " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } return doToModel ( canalDo ) ; }
public int getCount ( Map condition ) { return canalDao . getCount ( condition ) ; }
public List < Canal > listByCondition ( Map condition ) { List < CanalDO > canalDos = canalDao . listByCondition ( condition ) ; if ( canalDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any canal by the condition: " + JsonUtils . marshalToString ( condition ) ) ; return new ArrayList < Canal > ( ) ; } return doToModel ( canalDos ) ; }
private CanalDO modelToDo ( Canal canal ) { CanalDO canalDo = new CanalDO ( ) ; try { canalDo . setId ( canal . getId ( ) ) ; canalDo . setName ( canal . getName ( ) ) ; canalDo . setStatus ( canal . getStatus ( ) ) ; canalDo . setDescription ( canal . getDesc ( ) ) ; canalDo . setParameters ( canal . getCanalParameter ( ) ) ; canalDo . setGmtCreate ( canal . getGmtCreate ( ) ) ; canalDo . setGmtModified ( canal . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the canal Model to Do has an exception " ) ; throw new ManagerException ( e ) ; } return canalDo ; }
private Canal doToModel ( CanalDO canalDo ) { Canal canal = new Canal ( ) ; try { canal . setId ( canalDo . getId ( ) ) ; canal . setName ( canalDo . getName ( ) ) ; canal . setStatus ( canalDo . getStatus ( ) ) ; canal . setDesc ( canalDo . getDescription ( ) ) ; CanalParameter parameter = canalDo . getParameters ( ) ; AutoKeeperCluster zkCluster = autoKeeperClusterService . findAutoKeeperClusterById ( parameter . getZkClusterId ( ) ) ; if ( zkCluster ! = null ) { parameter . setZkClusters ( Arrays . asList ( StringUtils . join ( zkCluster . getServerList ( ) , ',' ) ) ) ; } canal . setCanalParameter ( canalDo . getParameters ( ) ) ; canal . setGmtCreate ( canalDo . getGmtCreate ( ) ) ; canal . setGmtModified ( canalDo . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the canal Do to Model has an exception " ) ; throw new ManagerException ( e ) ; } return canal ; }
private List < Canal > doToModel ( List < CanalDO > canalDos ) { List < Canal > canals = new ArrayList < Canal > ( ) ; for ( CanalDO canalDo : canalDos ) { canals . add ( doToModel ( canalDo ) ) ; } return canals ; }
public void setCanalDao ( CanalDAO canalDao ) { this . canalDao = canalDao ; }
public void setTransactionTemplate ( TransactionTemplate transactionTemplate ) { this . transactionTemplate = transactionTemplate ; }
public void setArbitrateViewService ( ArbitrateViewService arbitrateViewService ) { this . arbitrateViewService = arbitrateViewService ; }
public Channel findByPipelineId ( Long pipelineId ) ; public Channel findByIdWithoutColumn ( Long pipelineId ) ; public List < Channel > listByPipelineIds ( Long . . . pipelineIds ) ; public List < Channel > listByNodeId ( Long nodeId ) ; public List < Channel > listOnlyChannels ( Long . . . identities ) ; public List < Long > listAllChannelId ( ) ; public List < Channel > listByNodeId ( Long nodeId , ChannelStatus . . . status ) ; public List < Channel > listByConditionWithoutColumn ( Map condition ) ; public void stopChannel ( Long channelId ) ; public void notifyChannel ( Long channelId ) ; public void startChannel ( Long channelId ) ; }
public Channel findByIdWithoutColumn ( Long pipelineId ) ; public List < Channel > listByPipelineIds ( Long . . . pipelineIds ) ; public List < Channel > listByNodeId ( Long nodeId ) ; public List < Channel > listOnlyChannels ( Long . . . identities ) ; public List < Long > listAllChannelId ( ) ; public List < Channel > listByNodeId ( Long nodeId , ChannelStatus . . . status ) ; public List < Channel > listByConditionWithoutColumn ( Map condition ) ; public void stopChannel ( Long channelId ) ; public void notifyChannel ( Long channelId ) ; public void startChannel ( Long channelId ) ; }
public List < Channel > listByPipelineIds ( Long . . . pipelineIds ) ; public List < Channel > listByNodeId ( Long nodeId ) ; public List < Channel > listOnlyChannels ( Long . . . identities ) ; public List < Long > listAllChannelId ( ) ; public List < Channel > listByNodeId ( Long nodeId , ChannelStatus . . . status ) ; public List < Channel > listByConditionWithoutColumn ( Map condition ) ; public void stopChannel ( Long channelId ) ; public void notifyChannel ( Long channelId ) ; public void startChannel ( Long channelId ) ; }
public List < Channel > listByNodeId ( Long nodeId ) ; public List < Channel > listOnlyChannels ( Long . . . identities ) ; public List < Long > listAllChannelId ( ) ; public List < Channel > listByNodeId ( Long nodeId , ChannelStatus . . . status ) ; public List < Channel > listByConditionWithoutColumn ( Map condition ) ; public void stopChannel ( Long channelId ) ; public void notifyChannel ( Long channelId ) ; public void startChannel ( Long channelId ) ; }
public List < Channel > listOnlyChannels ( Long . . . identities ) ; public List < Long > listAllChannelId ( ) ; public List < Channel > listByNodeId ( Long nodeId , ChannelStatus . . . status ) ; public List < Channel > listByConditionWithoutColumn ( Map condition ) ; public void stopChannel ( Long channelId ) ; public void notifyChannel ( Long channelId ) ; public void startChannel ( Long channelId ) ; }
public List < Long > listAllChannelId ( ) ; public List < Channel > listByNodeId ( Long nodeId , ChannelStatus . . . status ) ; public List < Channel > listByConditionWithoutColumn ( Map condition ) ; public void stopChannel ( Long channelId ) ; public void notifyChannel ( Long channelId ) ; public void startChannel ( Long channelId ) ; }
public List < Channel > listByNodeId ( Long nodeId , ChannelStatus . . . status ) ; public List < Channel > listByConditionWithoutColumn ( Map condition ) ; public void stopChannel ( Long channelId ) ; public void notifyChannel ( Long channelId ) ; public void startChannel ( Long channelId ) ; }
public List < Channel > listByConditionWithoutColumn ( Map condition ) ; public void stopChannel ( Long channelId ) ; public void notifyChannel ( Long channelId ) ; public void startChannel ( Long channelId ) ; }
public void stopChannel ( Long channelId ) ; public void notifyChannel ( Long channelId ) ; public void startChannel ( Long channelId ) ; }
public void notifyChannel ( Long channelId ) ; public void startChannel ( Long channelId ) ; }
public ChannelStatus getStatus ( ) { return status ; }
public void setStatus ( ChannelStatus status ) { this . status = status ; }
public ChannelParameter getParameters ( ) { return parameters ; }
public void setParameters ( ChannelParameter parameters ) { this . parameters = parameters ; }
public Object getResult ( ResultGetter getter ) throws SQLException { return JsonUtils . unmarshalFromString ( getter . getString ( ) , ChannelParameter . class ) ; }
public Object valueOf ( String s ) { return JsonUtils . unmarshalFromString ( s , ChannelParameter . class ) ; }
public ChannelDO insert ( ChannelDO entityObj ) { Assert . assertNotNull ( entityObj ) ; getSqlMapClientTemplate ( ) . insert ( " insertChannel " , entityObj ) ; return entityObj ; }
public void delete ( Long identity ) { Assert . assertNotNull ( identity ) ; getSqlMapClientTemplate ( ) . delete ( " deleteChannelById " , identity ) ; }
public void update ( ChannelDO entityObj ) { Assert . assertNotNull ( entityObj ) ; getSqlMapClientTemplate ( ) . update ( " updateChannel " , entityObj ) ; }
public boolean checkUnique ( ChannelDO entityObj ) { Assert . assertNotNull ( entityObj ) ; int count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " checkChannelUnique " , entityObj ) ; return count = = 0 ? true : false ; }
public List < ChannelDO > listAll ( ) { List < ChannelDO > channels = getSqlMapClientTemplate ( ) . queryForList ( " listChannels " ) ; return channels ; }
public List < ChannelDO > listChannelPks ( ) { List < ChannelDO > channels = getSqlMapClientTemplate ( ) . queryForList ( " listChannelPks " ) ; return channels ; }
public List < ChannelDO > listByCondition ( Map condition ) { List < ChannelDO > channelDos = getSqlMapClientTemplate ( ) . queryForList ( " listChannels " , condition ) ; return channelDos ; }
public int getCount ( ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getChannelCount " ) ; return count . intValue ( ) ; }
public int getCount ( Map condition ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getChannelCount " , condition ) ; return count . intValue ( ) ; }
public List < ChannelDO > listByMultiId ( Long . . . identities ) { List < ChannelDO > channelDos = getSqlMapClientTemplate ( ) . queryForList ( " listChannelByIds " , identities ) ; return channelDos ; }
public ChannelDO findById ( Long identity ) { Assert . assertNotNull ( identity ) ; return ( ChannelDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findChannelById " , identity ) ; }
public void create ( final Channel channel ) { Assert . assertNotNull ( channel ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try {
public void modify ( Channel channel ) { Assert . assertNotNull ( channel ) ; try { ChannelDO channelDo = modelToDo ( channel ) ;
public void remove ( final Long channelId ) { Assert . assertNotNull ( channelId ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { arbitrateManageService . channelEvent ( ) . destory ( channelId ) ;
public List < Channel > listByIds ( Long . . . identities ) { List < Channel > channels = new ArrayList < Channel > ( ) ; try { List < ChannelDO > channelDos = null ; if ( identities . length < 1 ) { channelDos = channelDao . listAll ( ) ; if ( channelDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any channel, maybe hasn't create any channel. " ) ; return channels ; } } else { channelDos = channelDao . listByMultiId ( identities ) ; if ( channelDos . isEmpty ( ) ) { String exceptionCause = " couldn't query any channel by channelIds: " + Arrays . toString ( identities ) ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } } channels = doToModel ( channelDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query channels has an exception! " ) ; throw new ManagerException ( e ) ; } return channels ; }
public List < Channel > listAll ( ) { return listByIds ( ) ; }
public List < Channel > listOnlyChannels ( Long . . . identities ) { List < Channel > channels = new ArrayList < Channel > ( ) ; try { List < ChannelDO > channelDos = null ; if ( identities . length < 1 ) { channelDos = channelDao . listAll ( ) ; if ( channelDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any channel, maybe hasn't create any channel. " ) ; return channels ; } } else { channelDos = channelDao . listByMultiId ( identities ) ; if ( channelDos . isEmpty ( ) ) { String exceptionCause = " couldn't query any channel by channelIds: " + Arrays . toString ( identities ) ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } } channels = doToModelOnlyChannels ( channelDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query channels has an exception! " ) ; throw new ManagerException ( e ) ; } return channels ; }
public List < Channel > listByCondition ( Map condition ) { List < ChannelDO > channelDos = channelDao . listByCondition ( condition ) ; if ( channelDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any channel by the condition: " + JsonUtils . marshalToString ( condition ) ) ; return new ArrayList < Channel > ( ) ; } return doToModel ( channelDos ) ; }
public List < Channel > listByConditionWithoutColumn ( Map condition ) { List < ChannelDO > channelDos = channelDao . listByCondition ( condition ) ; if ( channelDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any channel by the condition: " + JsonUtils . marshalToString ( condition ) ) ; return new ArrayList < Channel > ( ) ; } return doToModelWithColumn ( channelDos ) ; }
public List < Long > listAllChannelId ( ) { List < ChannelDO > channelDos = channelDao . listChannelPks ( ) ; List < Long > channelPks = new ArrayList < Long > ( ) ; if ( channelDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any channel " ) ; } for ( ChannelDO channelDo : channelDos ) { channelPks . add ( channelDo . getId ( ) ) ; } return channelPks ; }
public Channel findById ( Long channelId ) { Assert . assertNotNull ( channelId ) ; List < Channel > channels = listByIds ( channelId ) ; if ( channels . size ( ) ! = 1 ) { String exceptionCause = " query channelId: " + channelId + " return null. " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } return channels . get ( 0 ) ; }
public Channel findByIdWithoutColumn ( Long channelId ) { List < ChannelDO > channelDos = channelDao . listByMultiId ( channelId ) ; if ( channelDos . size ( ) ! = 1 ) { String exceptionCause = " query channelId: " + channelId + " return null. " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } List < Channel > channels = doToModelWithColumn ( channelDos ) ; return channels . get ( 0 ) ; }
public Channel findByPipelineId ( Long pipelineId ) { Pipeline pipeline = pipelineService . findById ( pipelineId ) ; Channel channel = findById ( pipeline . getChannelId ( ) ) ; return channel ; }
public List < Channel > listByPipelineIds ( Long . . . pipelineIds ) { List < Channel > channels = new ArrayList < Channel > ( ) ; try { List < Pipeline > pipelines = pipelineService . listByIds ( pipelineIds ) ; List < Long > channelIds = new ArrayList < Long > ( ) ; for ( Pipeline pipeline : pipelines ) { if ( ! channelIds . contains ( pipeline . getChannelId ( ) ) ) { channelIds . add ( pipeline . getChannelId ( ) ) ; } } channels = listByIds ( channelIds . toArray ( new Long [ channelIds . size ( ) ] ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## list query channel by pipelineIds: " + pipelineIds . toString ( ) + " has an exception! " ) ; throw new ManagerException ( e ) ; } return channels ; }
public List < Channel > listByNodeId ( Long nodeId ) { return listByNodeId ( nodeId , new ChannelStatus [ ] { } ) ; }
public int getCount ( ) { return channelDao . getCount ( ) ; }
public int getCount ( Map condition ) { return channelDao . getCount ( condition ) ; }
private void switchChannelStatus ( final Long channelId , final ChannelStatus channelStatus ) { transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { final ChannelDO channelDo = channelDao . findById ( channelId ) ;
public void stopChannel ( Long channelId ) { switchChannelStatus ( channelId , ChannelStatus . STOP ) ; }
public void startChannel ( Long channelId ) { switchChannelStatus ( channelId , ChannelStatus . START ) ; }
public void notifyChannel ( Long channelId ) { switchChannelStatus ( channelId , null ) ; }
private ChannelDO modelToDo ( Channel channel ) { ChannelDO channelDO = new ChannelDO ( ) ; try { channelDO . setId ( channel . getId ( ) ) ; channelDO . setName ( channel . getName ( ) ) ; channelDO . setDescription ( channel . getDescription ( ) ) ; channelDO . setStatus ( channel . getStatus ( ) ) ; channelDO . setParameters ( channel . getParameters ( ) ) ; channelDO . setGmtCreate ( channel . getGmtCreate ( ) ) ; channelDO . setGmtModified ( channel . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the channel Model to Do has an exception " ) ; throw new ManagerException ( e ) ; } return channelDO ; }
public void setPipelineService ( PipelineService pipelineService ) { this . pipelineService = pipelineService ; }
public void setChannelDao ( ChannelDAO channelDao ) { this . channelDao = channelDao ; }
public void setConfigRemoteService ( ConfigRemoteService configRemoteService ) { this . configRemoteService = configRemoteService ; }
public void removeByDataMediaPairId ( Long dataMediaPairId ) ; public List < ColumnGroup > listByDataMediaPairId ( Long dataMediaPairId ) ; public Map < Long , List < ColumnGroup > > listByDataMediaPairIds ( Long . . . dataMediaPairId ) ; }
public List < ColumnGroup > listByDataMediaPairId ( Long dataMediaPairId ) ; public Map < Long , List < ColumnGroup > > listByDataMediaPairIds ( Long . . . dataMediaPairId ) ; }
public Map < Long , List < ColumnGroup > > listByDataMediaPairIds ( Long . . . dataMediaPairId ) ; }
public List < ColumnPair > listByDataMediaPairId ( Long dataMediaPairId ) ; public Map < Long , List < ColumnPair > > listByDataMediaPairIds ( Long . . . dataMediaPairIds ) ; public void createBatch ( List < ColumnPair > dataColumnPairs ) ; public void removeByDataMediaPairId ( Long dataMediaPairId ) ; }
public Map < Long , List < ColumnPair > > listByDataMediaPairIds ( Long . . . dataMediaPairIds ) ; public void createBatch ( List < ColumnPair > dataColumnPairs ) ; public void removeByDataMediaPairId ( Long dataMediaPairId ) ; }
public void createBatch ( List < ColumnPair > dataColumnPairs ) ; public void removeByDataMediaPairId ( Long dataMediaPairId ) ; }
public void removeByDataMediaPairId ( Long dataMediaPairId ) ; }
public List < DataColumnPairDO > listByDataMediaPairId ( Long dataMediaPairId ) ; public List < DataColumnPairDO > listByDataMediaPairIds ( Long . . . dataMediaPairIds ) ; public void insertBatch ( List < DataColumnPairDO > dataColumnPairDos ) ; public void deleteByDataMediaPairId ( Long dataMediaPairId ) ; }
public List < DataColumnPairDO > listByDataMediaPairIds ( Long . . . dataMediaPairIds ) ; public void insertBatch ( List < DataColumnPairDO > dataColumnPairDos ) ; public void deleteByDataMediaPairId ( Long dataMediaPairId ) ; }
public void insertBatch ( List < DataColumnPairDO > dataColumnPairDos ) ; public void deleteByDataMediaPairId ( Long dataMediaPairId ) ; }
public void deleteByDataMediaPairId ( Long dataMediaPairId ) ; }
public void deleteByDataMediaPairId ( Long dataMediaPairId ) ; public List < DataColumnPairGroupDO > ListByDataMediaPairId ( Long dataMediaPairId ) ; public List < DataColumnPairGroupDO > ListByDataMediaPairIds ( Long . . . dataMediaPairIds ) ; }
public List < DataColumnPairGroupDO > ListByDataMediaPairId ( Long dataMediaPairId ) ; public List < DataColumnPairGroupDO > ListByDataMediaPairIds ( Long . . . dataMediaPairIds ) ; }
public List < DataColumnPairGroupDO > ListByDataMediaPairIds ( Long . . . dataMediaPairIds ) ; }
public String getSourceColumnName ( ) { return sourceColumnName ; }
public void setSourceColumnName ( String sourceColumnName ) { this . sourceColumnName = sourceColumnName ; }
public String getTargetColumnName ( ) { return targetColumnName ; }
public void setTargetColumnName ( String targetColumnName ) { this . targetColumnName = targetColumnName ; }
public Long getDataMediaPairId ( ) { return dataMediaPairId ; }
public void setDataMediaPairId ( Long dataMediaPairId ) { this . dataMediaPairId = dataMediaPairId ; }
public String getColumnPairContent ( ) { return columnPairContent ; }
public void setColumnPairContent ( String columnPairContent ) { this . columnPairContent = columnPairContent ; }
public DataColumnPairGroupDO insert ( DataColumnPairGroupDO dataColumnPairDo ) { Assert . assertNotNull ( dataColumnPairDo ) ; getSqlMapClientTemplate ( ) . insert ( " insertDataColumnPair " , dataColumnPairDo ) ; return dataColumnPairDo ; }
public void insertBatch ( List < DataColumnPairDO > dataColumnPairDos ) { try { getSqlMapClientTemplate ( ) . getSqlMapClient ( ) . startBatch ( ) ;
public void delete ( Long dataColumnPairId ) { Assert . assertNotNull ( dataColumnPairId ) ; getSqlMapClientTemplate ( ) . delete ( " deleteDataColumnPairById " , dataColumnPairId ) ; }
public void deleteByDataMediaPairId ( Long dataMediaPairId ) { Assert . assertNotNull ( dataMediaPairId ) ; getSqlMapClientTemplate ( ) . delete ( " deleteDataColumnPairByDataMediaPairId " , dataMediaPairId ) ; }
public void update ( DataColumnPairGroupDO dataColumnPairDo ) { Assert . assertNotNull ( dataColumnPairDo ) ; getSqlMapClientTemplate ( ) . update ( " updateDataColumnPair " , dataColumnPairDo ) ;
public List < DataColumnPairDO > listAll ( ) { List < DataColumnPairDO > dataColumnPairGroupDos = getSqlMapClientTemplate ( ) . queryForList ( " listDataColumnPairs " ) ; return dataColumnPairGroupDos ; }
public List < DataColumnPairDO > listByCondition ( Map condition ) { return null ; }
public List < DataColumnPairDO > listByMultiId ( Long . . . identities ) { return null ; }
public DataColumnPairDO findById ( Long identity ) { Assert . assertNotNull ( identity ) ; return ( DataColumnPairDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findDataColumnPairById " , identity ) ; }
public int getCount ( Map condition ) { return 0 ; }
public boolean checkUnique ( DataColumnPairGroupDO entityObj ) { return false ; }
public List < DataColumnPairDO > listByDataMediaPairId ( Long dataMediaPairId ) { List < DataColumnPairDO > dataColumnPairDos = getSqlMapClientTemplate ( ) . queryForList ( " listDataColumnPairByDataMediaPairId " , dataMediaPairId ) ; return dataColumnPairDos ; }
public List < DataColumnPairDO > listByDataMediaPairIds ( Long . . . dataMediaPairIds ) { List < DataColumnPairDO > dataColumnPairDos = getSqlMapClientTemplate ( ) . queryForList ( " listDataColumnPairByDataMediaPairIds " , dataMediaPairIds ) ; return dataColumnPairDos ; }
public DataColumnPairDO insert ( DataColumnPairDO entityObj ) { // TODO Auto-generated method stub return null; }
public void update ( DataColumnPairDO entityObj ) { // TODO Auto-generated method stub } public boolean checkUnique(DataColumnPairDO entityObj) { // TODO Auto-generated method stub return false; } }
public boolean checkUnique ( DataColumnPairDO entityObj ) { // TODO Auto-generated method stub return false; }
public DataColumnPairGroupDO insert ( DataColumnPairGroupDO entityObj ) { Assert . assertNotNull ( entityObj ) ; getSqlMapClientTemplate ( ) . insert ( " insertDataColumnPairGroup " , entityObj ) ; return entityObj ; }
public void delete ( Long identity ) { // TODO Auto-generated method stub } public void deleteByDataMediaPairId(Long dataMediaPairId) { Assert.assertNotNull(dataMediaPairId); getSqlMapClientTemplate().delete("deleteDataColumnPairGroupByDataMediaPairId", dataMediaPairId); } public void update(DataColumnPairGroupDO entityObj) { // TODO Auto-generated method stub } public List<DataColumnPairGroupDO> listAll() { // TODO Auto-generated method stub return null; } public List<DataColumnPairGroupDO> ListByDataMediaPairId(Long dataMediaPairId) { Assert.assertNotNull(dataMediaPairId); List<DataColumnPairGroupDO> dataColumnPairGroupDos = getSqlMapClientTemplate().queryForList("listDataColumnPairGroupByDataMediaPairId", dataMediaPairId); return dataColumnPairGroupDos; } public List<DataColumnPairGroupDO> ListByDataMediaPairIds(Long... dataMediaPairIds) { Assert.assertNotNull(dataMediaPairIds); List<DataColumnPairGroupDO> dataColumnPairGroupDos = getSqlMapClientTemplate().queryForList("listDataColumnPairGroupByDataMediaPairIds", dataMediaPairIds); return dataColumnPairGroupDos; } public List<DataColumnPairGroupDO> listByCondition(Map condition) { // TODO Auto-generated method stub return null; } public List<DataColumnPairGroupDO> listByMultiId(Long... identities) { // TODO Auto-generated method stub return null; } public DataColumnPairGroupDO findById(Long identity) { // TODO Auto-generated method stub return null; } public int getCount() { // TODO Auto-generated method stub return 0; } public int getCount(Map condition) { // TODO Auto-generated method stub return 0; } public boolean checkUnique(DataColumnPairGroupDO entityObj) { // TODO Auto-generated method stub return false; } }
public void deleteByDataMediaPairId ( Long dataMediaPairId ) { Assert . assertNotNull ( dataMediaPairId ) ; getSqlMapClientTemplate ( ) . delete ( " deleteDataColumnPairGroupByDataMediaPairId " , dataMediaPairId ) ;
public void update ( DataColumnPairGroupDO entityObj ) { // TODO Auto-generated method stub } public List<DataColumnPairGroupDO> listAll() { // TODO Auto-generated method stub return null; } public List<DataColumnPairGroupDO> ListByDataMediaPairId(Long dataMediaPairId) { Assert.assertNotNull(dataMediaPairId); List<DataColumnPairGroupDO> dataColumnPairGroupDos = getSqlMapClientTemplate().queryForList("listDataColumnPairGroupByDataMediaPairId", dataMediaPairId); return dataColumnPairGroupDos; } public List<DataColumnPairGroupDO> ListByDataMediaPairIds(Long... dataMediaPairIds) { Assert.assertNotNull(dataMediaPairIds); List<DataColumnPairGroupDO> dataColumnPairGroupDos = getSqlMapClientTemplate().queryForList("listDataColumnPairGroupByDataMediaPairIds", dataMediaPairIds); return dataColumnPairGroupDos; } public List<DataColumnPairGroupDO> listByCondition(Map condition) { // TODO Auto-generated method stub return null; } public List<DataColumnPairGroupDO> listByMultiId(Long... identities) { // TODO Auto-generated method stub return null; } public DataColumnPairGroupDO findById(Long identity) { // TODO Auto-generated method stub return null; } public int getCount() { // TODO Auto-generated method stub return 0; } public int getCount(Map condition) { // TODO Auto-generated method stub return 0; } public boolean checkUnique(DataColumnPairGroupDO entityObj) { // TODO Auto-generated method stub return false; } }
public List < DataColumnPairGroupDO > listAll ( ) { // TODO Auto-generated method stub return null; }
public List < DataColumnPairGroupDO > ListByDataMediaPairId ( Long dataMediaPairId ) { Assert . assertNotNull ( dataMediaPairId ) ; List < DataColumnPairGroupDO > dataColumnPairGroupDos = getSqlMapClientTemplate ( ) . queryForList ( " listDataColumnPairGroupByDataMediaPairId " , dataMediaPairId ) ; return dataColumnPairGroupDos ; }
public List < DataColumnPairGroupDO > ListByDataMediaPairIds ( Long . . . dataMediaPairIds ) { Assert . assertNotNull ( dataMediaPairIds ) ; List < DataColumnPairGroupDO > dataColumnPairGroupDos = getSqlMapClientTemplate ( ) . queryForList ( " listDataColumnPairGroupByDataMediaPairIds " , dataMediaPairIds ) ; return dataColumnPairGroupDos ; }
public List < DataColumnPairGroupDO > listByCondition ( Map condition ) { // TODO Auto-generated method stub return null; }
public List < DataColumnPairGroupDO > listByMultiId ( Long . . . identities ) { // TODO Auto-generated method stub return null; }
public DataColumnPairGroupDO findById ( Long identity ) { // TODO Auto-generated method stub return null; }
public int getCount ( ) { // TODO Auto-generated method stub return 0; }
public int getCount ( Map condition ) { // TODO Auto-generated method stub return 0; }
public boolean checkUnique ( DataColumnPairGroupDO entityObj ) { // TODO Auto-generated method stub return false; }
public void create ( ColumnGroup entityObj ) { Assert . assertNotNull ( entityObj ) ; try { DataColumnPairGroupDO dataColumnPairGroupDo = modelToDo ( entityObj ) ;
public List < ColumnGroup > listByDataMediaPairId ( Long dataMediaPairId ) { Assert . assertNotNull ( dataMediaPairId ) ; List < DataColumnPairGroupDO > dataColumnPairGroupDos = dataColumnPairGroupDao . ListByDataMediaPairId ( dataMediaPairId ) ; if ( CollectionUtils . isEmpty ( dataColumnPairGroupDos ) ) { return new ArrayList < ColumnGroup > ( ) ; } return doToModel ( dataColumnPairGroupDos ) ; }
public Map < Long , List < ColumnGroup > > listByDataMediaPairIds ( Long . . . dataMediaPairIds ) { Assert . assertNotNull ( dataMediaPairIds ) ; Map < Long , List < ColumnGroup > > dataColumnGroups = new HashMap < Long , List < ColumnGroup > > ( ) ; try { List < DataColumnPairGroupDO > dataColumnPairGroupDos = dataColumnPairGroupDao . ListByDataMediaPairIds ( dataMediaPairIds ) ; if ( CollectionUtils . isEmpty ( dataColumnPairGroupDos ) ) { logger . debug ( " DEBUG ## couldn't query any dataColumnPairGroup, maybe hasn't create any dataColumnPairGroup. " ) ; return dataColumnGroups ; } for ( DataColumnPairGroupDO dataColumnPairGroupDo : dataColumnPairGroupDos ) { List < ColumnGroup > columnGroups = dataColumnGroups . get ( dataColumnPairGroupDo . getDataMediaPairId ( ) ) ; if ( columnGroups ! = null ) { if ( ! columnGroups . contains ( doToModel ( dataColumnPairGroupDo ) ) ) { columnGroups . add ( doToModel ( dataColumnPairGroupDo ) ) ; } } else { columnGroups = new ArrayList < ColumnGroup > ( ) ; columnGroups . add ( doToModel ( dataColumnPairGroupDo ) ) ; dataColumnGroups . put ( dataColumnPairGroupDo . getDataMediaPairId ( ) , columnGroups ) ; } } } catch ( Exception e ) { logger . error ( " ERROR ## query dataColumnPairGroup by dataMediaId: " + dataMediaPairIds + " has an exception! " ) ; throw new ManagerException ( e ) ; } return dataColumnGroups ; }
public void removeByDataMediaPairId ( Long dataMediaPairId ) { Assert . assertNotNull ( dataMediaPairId ) ; dataColumnPairGroupDao . deleteByDataMediaPairId ( dataMediaPairId ) ; }
public ColumnGroup findById ( Long identity ) { return null ; }
public List < ColumnGroup > listByIds ( Long . . . identities ) { return null ; }
public List < ColumnGroup > listAll ( ) { return null ; }
public List < ColumnGroup > listByCondition ( Map condition ) { return null ; }
private ColumnGroup doToModel ( DataColumnPairGroupDO dataColumnPairGroupDo ) { ColumnGroup columnGroup = new ColumnGroup ( ) ; columnGroup . setId ( dataColumnPairGroupDo . getId ( ) ) ; List < ColumnPair > columnPairs = new ArrayList < ColumnPair > ( ) ; if ( StringUtils . isNotBlank ( dataColumnPairGroupDo . getColumnPairContent ( ) ) ) { columnPairs = JsonUtils . unmarshalFromString ( dataColumnPairGroupDo . getColumnPairContent ( ) , new TypeReference < ArrayList < ColumnPair > > ( ) { } ) ; } columnGroup . setColumnPairs ( columnPairs ) ; columnGroup . setDataMediaPairId ( dataColumnPairGroupDo . getDataMediaPairId ( ) ) ; columnGroup . setGmtCreate ( dataColumnPairGroupDo . getGmtCreate ( ) ) ; columnGroup . setGmtModified ( dataColumnPairGroupDo . getGmtModified ( ) ) ; return columnGroup ; }
private List < ColumnGroup > doToModel ( List < DataColumnPairGroupDO > dataColumnPairGroupDos ) { List < ColumnGroup > columnGroups = new ArrayList < ColumnGroup > ( ) ; for ( DataColumnPairGroupDO dataColumnPairGroupDO : dataColumnPairGroupDos ) { columnGroups . add ( doToModel ( dataColumnPairGroupDO ) ) ; } return columnGroups ; }
private DataColumnPairGroupDO modelToDo ( ColumnGroup columnGroup ) { DataColumnPairGroupDO dataColumnPairGroupDo = new DataColumnPairGroupDO ( ) ; dataColumnPairGroupDo . setId ( columnGroup . getId ( ) ) ; dataColumnPairGroupDo . setColumnPairContent ( JsonUtils . marshalToString ( columnGroup . getColumnPairs ( ) ) ) ; dataColumnPairGroupDo . setDataMediaPairId ( columnGroup . getDataMediaPairId ( ) ) ; dataColumnPairGroupDo . setGmtCreate ( columnGroup . getGmtCreate ( ) ) ; dataColumnPairGroupDo . setGmtModified ( columnGroup . getGmtModified ( ) ) ; return dataColumnPairGroupDo ; }
public DataColumnPairGroupDAO getDataColumnPairGroupDao ( ) { return dataColumnPairGroupDao ; }
public void setDataColumnPairGroupDao ( DataColumnPairGroupDAO dataColumnPairGroupDao ) { this . dataColumnPairGroupDao = dataColumnPairGroupDao ; }
public DataColumnPairService getDataColumnPairService ( ) { return dataColumnPairService ; }
public void setDataColumnPairService ( DataColumnPairService dataColumnPairService ) { this . dataColumnPairService = dataColumnPairService ; }
public void create ( ColumnPair entityObj ) { Assert . assertNotNull ( entityObj ) ; try { DataColumnPairDO dataColumnPairDo = modelToDo ( entityObj ) ;
public void createBatch ( List < ColumnPair > dataColumnPairs ) { Assert . assertNotNull ( dataColumnPairs ) ; try {
public void remove ( Long identity ) { Assert . assertNotNull ( identity ) ; try { dataColumnPairDao . delete ( identity ) ;
public void modify ( ColumnPair entityObj ) { Assert . assertNotNull ( entityObj ) ; try { DataColumnPairDO dataColumnPairDo = modelToDo ( entityObj ) ;
public ColumnPair findById ( Long identity ) { Assert . assertNotNull ( identity ) ; DataColumnPairDO columePairDo = dataColumnPairDao . findById ( identity ) ; if ( columePairDo = = null ) { return null ; } return doToModel ( columePairDo ) ;
public List < ColumnPair > listByIds ( Long . . . identities ) { return null ; }
public List < ColumnPair > listAll ( ) { return null ; }
public List < ColumnPair > listByDataMediaPairId ( Long dataMediaPairId ) { Assert . assertNotNull ( dataMediaPairId ) ; List < ColumnPair > dataColumnPairs = new ArrayList < ColumnPair > ( ) ; try { List < DataColumnPairDO > dataColumnPairDos = dataColumnPairDao . listByDataMediaPairId ( dataMediaPairId ) ; if ( dataColumnPairDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any dataColumnPair, maybe hasn't create any dataColumnPair. " ) ; return dataColumnPairs ; } dataColumnPairs = doToModel ( dataColumnPairDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query dataColumnPair by dataMediaId: " + dataMediaPairId + " has an exception! " ) ; throw new ManagerException ( e ) ; } return dataColumnPairs ; }
public Map < Long , List < ColumnPair > > listByDataMediaPairIds ( Long . . . dataMediaPairIds ) { Assert . assertNotNull ( dataMediaPairIds ) ; Map < Long , List < ColumnPair > > dataColumnPairs = new HashMap < Long , List < ColumnPair > > ( ) ; try { List < DataColumnPairDO > dataColumnPairDos = dataColumnPairDao . listByDataMediaPairIds ( dataMediaPairIds ) ; if ( dataColumnPairDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any dataColumnPair, maybe hasn't create any dataColumnPair. " ) ; return dataColumnPairs ; } for ( DataColumnPairDO dataColumnPairDo : dataColumnPairDos ) { List < ColumnPair > columnPairs = dataColumnPairs . get ( dataColumnPairDo . getDataMediaPairId ( ) ) ; if ( columnPairs ! = null ) { if ( ! columnPairs . contains ( doToModel ( dataColumnPairDo ) ) ) { columnPairs . add ( doToModel ( dataColumnPairDo ) ) ; } } else { columnPairs = new ArrayList < ColumnPair > ( ) ; columnPairs . add ( doToModel ( dataColumnPairDo ) ) ; dataColumnPairs . put ( dataColumnPairDo . getDataMediaPairId ( ) , columnPairs ) ; } } } catch ( Exception e ) { logger . error ( " ERROR ## query dataColumnPair by dataMediaId: " + dataMediaPairIds + " has an exception! " ) ; throw new ManagerException ( e ) ; } return dataColumnPairs ; }
public void removeByDataMediaPairId ( Long dataMediaPairId ) { Assert . assertNotNull ( dataMediaPairId ) ; try { dataColumnPairDao . deleteByDataMediaPairId ( dataMediaPairId ) ;
public List < ColumnPair > listByCondition ( Map condition ) { return null ; }
private ColumnPair doToModel ( DataColumnPairDO dataColumnPairDo ) { Column sourceColumn = dataColumnPairDo . getSourceColumnName ( ) = = null ? null : new Column ( dataColumnPairDo . getSourceColumnName ( ) ) ; Column targetColumn = dataColumnPairDo . getTargetColumnName ( ) = = null ? null : new Column ( dataColumnPairDo . getTargetColumnName ( ) ) ; ColumnPair columnPair = new ColumnPair ( sourceColumn , targetColumn ) ; columnPair . setId ( dataColumnPairDo . getId ( ) ) ; columnPair . setDataMediaPairId ( dataColumnPairDo . getDataMediaPairId ( ) ) ; columnPair . setGmtCreate ( dataColumnPairDo . getGmtCreate ( ) ) ; columnPair . setGmtModified ( dataColumnPairDo . getGmtModified ( ) ) ; return columnPair ; }
private List < ColumnPair > doToModel ( List < DataColumnPairDO > dataColumnPairDos ) { List < ColumnPair > columnPairs = new ArrayList < ColumnPair > ( ) ; for ( DataColumnPairDO dataColumnPairDo : dataColumnPairDos ) { columnPairs . add ( doToModel ( dataColumnPairDo ) ) ; } return columnPairs ; }
private DataColumnPairDO modelToDo ( ColumnPair dataColumnPair ) { DataColumnPairDO dataColumnPairDo = new DataColumnPairDO ( ) ; dataColumnPairDo . setId ( dataColumnPair . getId ( ) ) ; dataColumnPairDo . setSourceColumnName ( dataColumnPair . getSourceColumn ( ) = = null ? null : dataColumnPair . getSourceColumn ( ) . getName ( ) ) ; dataColumnPairDo . setTargetColumnName ( dataColumnPair . getTargetColumn ( ) = = null ? null : dataColumnPair . getTargetColumn ( ) . getName ( ) ) ; dataColumnPairDo . setDataMediaPairId ( dataColumnPair . getDataMediaPairId ( ) ) ; dataColumnPairDo . setGmtCreate ( dataColumnPair . getGmtCreate ( ) ) ; dataColumnPairDo . setGmtModified ( dataColumnPair . getGmtModified ( ) ) ; return dataColumnPairDo ; }
public DataColumnPairDAO getDataColumnPairDao ( ) { return dataColumnPairDao ; }
public void setDataColumnPairDao ( DataColumnPairDAO dataColumnPairDao ) { this . dataColumnPairDao = dataColumnPairDao ; }
public void create ( DataMatrix DataMatrix ) ; public void remove ( Long DataMatrixId ) ; public void modify ( DataMatrix DataMatrix ) ; public List < DataMatrix > listByIds ( Long . . . identities ) ; public List < DataMatrix > listAll ( ) ; public DataMatrix findById ( Long DataMatrixId ) ; public DataMatrix findByGroupKey ( String name ) ; public int getCount ( Map condition ) ; public List < DataMatrix > listByCondition ( Map condition ) ; }
public void remove ( Long DataMatrixId ) ; public void modify ( DataMatrix DataMatrix ) ; public List < DataMatrix > listByIds ( Long . . . identities ) ; public List < DataMatrix > listAll ( ) ; public DataMatrix findById ( Long DataMatrixId ) ; public DataMatrix findByGroupKey ( String name ) ; public int getCount ( Map condition ) ; public List < DataMatrix > listByCondition ( Map condition ) ; }
public void modify ( DataMatrix DataMatrix ) ; public List < DataMatrix > listByIds ( Long . . . identities ) ; public List < DataMatrix > listAll ( ) ; public DataMatrix findById ( Long DataMatrixId ) ; public DataMatrix findByGroupKey ( String name ) ; public int getCount ( Map condition ) ; public List < DataMatrix > listByCondition ( Map condition ) ; }
public List < DataMatrix > listByIds ( Long . . . identities ) ; public List < DataMatrix > listAll ( ) ; public DataMatrix findById ( Long DataMatrixId ) ; public DataMatrix findByGroupKey ( String name ) ; public int getCount ( Map condition ) ; public List < DataMatrix > listByCondition ( Map condition ) ; }
public List < DataMatrix > listAll ( ) ; public DataMatrix findById ( Long DataMatrixId ) ; public DataMatrix findByGroupKey ( String name ) ; public int getCount ( Map condition ) ; public List < DataMatrix > listByCondition ( Map condition ) ; }
public DataMatrix findById ( Long DataMatrixId ) ; public DataMatrix findByGroupKey ( String name ) ; public int getCount ( Map condition ) ; public List < DataMatrix > listByCondition ( Map condition ) ; }
public DataMatrix findByGroupKey ( String name ) ; public int getCount ( Map condition ) ; public List < DataMatrix > listByCondition ( Map condition ) ; }
public int getCount ( Map condition ) ; public List < DataMatrix > listByCondition ( Map condition ) ; }
public List < DataMatrix > listByCondition ( Map condition ) ; }
public String getGroupKey ( ) { return groupKey ; }
public void setGroupKey ( String groupKey ) { this . groupKey = groupKey ; }
public String getMaster ( ) { return master ; }
public void setMaster ( String master ) { this . master = master ; }
public void setSlave ( String slave ) { this . slave = slave ; }
public DataMatrixDO insert ( DataMatrixDO matrixDo ) { Assert . assertNotNull ( matrixDo ) ; getSqlMapClientTemplate ( ) . insert ( " insertDataMatrix " , matrixDo ) ; return matrixDo ; }
public void delete ( Long matrixId ) { Assert . assertNotNull ( matrixId ) ; getSqlMapClientTemplate ( ) . delete ( " deleteDataMatrixById " , matrixId ) ; }
public void update ( DataMatrixDO matrixDo ) { Assert . assertNotNull ( matrixDo ) ; getSqlMapClientTemplate ( ) . update ( " updateDataMatrix " , matrixDo ) ; }
public List < DataMatrixDO > listAll ( ) { return ( List < DataMatrixDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listDataMatrixs " ) ; }
public List < DataMatrixDO > listByMultiId ( Long . . . identities ) { List < DataMatrixDO > DataMatrixDOs = getSqlMapClientTemplate ( ) . queryForList ( " listDataMatrixByIds " , identities ) ; return DataMatrixDOs ; }
public boolean checkUnique ( DataMatrixDO matrixDo ) { int count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " checkDataMatrixUnique " , matrixDo ) ; return count = = 0 ? true : false ; }
public DataMatrixDO findByGroupKey ( String groupKey ) { Assert . assertNotNull ( groupKey ) ; return ( DataMatrixDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findDataMatrixByGroupKey " , groupKey ) ; }
public DataMatrixDO findById ( Long identity ) { throw new UnsupportedOperationException ( ) ; }
public int getCount ( Map condition ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getDataMatrixCount " , condition ) ; return count . intValue ( ) ; }
public List < DataMatrixDO > listByCondition ( Map condition ) { List < DataMatrixDO > DataMatrixDOs = getSqlMapClientTemplate ( ) . queryForList ( " listDataMatrixs " , condition ) ; return DataMatrixDOs ; }
public void create ( final DataMatrix matrix ) { Assert . assertNotNull ( matrix ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { DataMatrixDO matrixlDO = modelToDo ( matrix ) ;
public void remove ( final Long matrixId ) { Assert . assertNotNull ( matrixId ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { dataMatrixDao . delete ( matrixId ) ;
public void modify ( final DataMatrix matrix ) { Assert . assertNotNull ( matrix ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { DataMatrixDO matrixDo = modelToDo ( matrix ) ;
public List < DataMatrix > listByIds ( Long . . . identities ) { List < DataMatrix > matrixs = new ArrayList < DataMatrix > ( ) ; try { List < DataMatrixDO > matrixDos = null ; if ( identities . length < 1 ) { matrixDos = dataMatrixDao . listAll ( ) ; if ( matrixDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any canal, maybe hasn't create any canal. " ) ; return matrixs ; } } else { matrixDos = dataMatrixDao . listByMultiId ( identities ) ; if ( matrixDos . isEmpty ( ) ) { String exceptionCause = " couldn't query any canal by matrixIds: " + Arrays . toString ( identities ) ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } } matrixs = doToModel ( matrixDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query channels has an exception! " ) ; throw new ManagerException ( e ) ; } return matrixs ; }
public List < DataMatrix > listAll ( ) { return listByIds ( ) ; }
public DataMatrix findById ( Long matrixId ) { Assert . assertNotNull ( matrixId ) ; List < DataMatrix > canals = listByIds ( matrixId ) ; if ( canals . size ( ) ! = 1 ) { String exceptionCause = " query matrixId: " + matrixId + " return null. " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } return canals . get ( 0 ) ; }
public DataMatrix findByGroupKey ( String groupKey ) { Assert . assertNotNull ( groupKey ) ; DataMatrixDO matrixDo = dataMatrixDao . findByGroupKey ( groupKey ) ; if ( matrixDo = = null ) { String exceptionCause = " query name: " + groupKey + " return null. " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } return doToModel ( matrixDo ) ; }
public int getCount ( Map condition ) { return dataMatrixDao . getCount ( condition ) ; }
public List < DataMatrix > listByCondition ( Map condition ) { List < DataMatrixDO > matrixDos = dataMatrixDao . listByCondition ( condition ) ; if ( matrixDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any canal by the condition: " + JsonUtils . marshalToString ( condition ) ) ; return new ArrayList < DataMatrix > ( ) ; } return doToModel ( matrixDos ) ; }
private DataMatrixDO modelToDo ( DataMatrix matrix ) { DataMatrixDO matrixDo = new DataMatrixDO ( ) ; try { matrixDo . setId ( matrix . getId ( ) ) ; matrixDo . setGroupKey ( matrix . getGroupKey ( ) ) ; matrixDo . setDescription ( matrix . getDescription ( ) ) ; matrixDo . setMaster ( matrix . getMaster ( ) ) ; matrixDo . setSlave ( matrix . getSlave ( ) ) ; matrixDo . setGmtCreate ( matrix . getGmtCreate ( ) ) ; matrixDo . setGmtModified ( matrix . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the matrix Model to Do has an exception " ) ; throw new ManagerException ( e ) ; } return matrixDo ; }
private DataMatrix doToModel ( DataMatrixDO matrixDo ) { DataMatrix matrix = new DataMatrix ( ) ; try { matrix . setId ( matrixDo . getId ( ) ) ; matrix . setGroupKey ( matrixDo . getGroupKey ( ) ) ; matrix . setDescription ( matrixDo . getDescription ( ) ) ; matrix . setMaster ( matrixDo . getMaster ( ) ) ; matrix . setSlave ( matrixDo . getSlave ( ) ) ; matrix . setGmtCreate ( matrixDo . getGmtCreate ( ) ) ; matrix . setGmtModified ( matrixDo . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the canal Do to Model has an exception " ) ; throw new ManagerException ( e ) ; } return matrix ; }
private List < DataMatrix > doToModel ( List < DataMatrixDO > matrixDos ) { List < DataMatrix > matrixs = new ArrayList < DataMatrix > ( ) ; for ( DataMatrixDO matrixDo : matrixDos ) { matrixs . add ( doToModel ( matrixDo ) ) ; } return matrixs ; }
public void setDataMatrixDao ( DataMatrixDAO dataMatrixDao ) { this . dataMatrixDao = dataMatrixDao ; }
public List < DataMedia > listByDataMediaSourceId ( Long dataMediaSourceId ) ; public Long createReturnId ( DataMedia dataMedia ) ; public List < String > queryColumnByMedia ( DataMedia dataMedia ) ; public List < String > queryColumnByMediaId ( Long dataMediaId ) ; }
public Long createReturnId ( DataMedia dataMedia ) ; public List < String > queryColumnByMedia ( DataMedia dataMedia ) ; public List < String > queryColumnByMediaId ( Long dataMediaId ) ; }
public List < String > queryColumnByMedia ( DataMedia dataMedia ) ; public List < String > queryColumnByMediaId ( Long dataMediaId ) ; }
public List < String > queryColumnByMediaId ( Long dataMediaId ) ; }
public List < DataMediaDO > listByDataMediaSourceId ( Long dataMediaSourceId ) ; public DataMediaDO checkUniqueAndReturnExist ( DataMediaDO dataMedia ) ; }
public DataMediaDO checkUniqueAndReturnExist ( DataMediaDO dataMedia ) ; }
public String getNamespace ( ) { return namespace ; }
public void setNamespace ( String namespace ) { this . namespace = namespace ; }
public String getProperties ( ) { return properties ; }
public void setProperties ( String properties ) { this . properties = properties ; }
public Long getDataMediaSourceId ( ) { return dataMediaSourceId ; }
public void setDataMediaSourceId ( Long dataMediaSourceId ) { this . dataMediaSourceId = dataMediaSourceId ; }
public DataMediaDO insert ( DataMediaDO dataMedia ) { Assert . assertNotNull ( dataMedia ) ; getSqlMapClientTemplate ( ) . insert ( " insertDataMedia " , dataMedia ) ; return dataMedia ; }
public void delete ( Long dataMediaId ) { Assert . assertNotNull ( dataMediaId ) ; getSqlMapClientTemplate ( ) . delete ( " deleteDataMediaById " , dataMediaId ) ; }
public void update ( DataMediaDO dataMedia ) { Assert . assertNotNull ( dataMedia ) ; getSqlMapClientTemplate ( ) . update ( " updateDataMedia " , dataMedia ) ; }
public boolean checkUnique ( DataMediaDO dataMedia ) { int count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " checkDataMediaUnique " , dataMedia ) ; return count = = 0 ? true : false ; }
public DataMediaDO checkUniqueAndReturnExist ( DataMediaDO dataMedia ) { return ( DataMediaDO ) getSqlMapClientTemplate ( ) . queryForObject ( " checkDataMediaUniqueAndReturnTheExist " , dataMedia ) ;
public DataMediaDO findById ( Long dataMediaId ) { Assert . assertNotNull ( dataMediaId ) ; return ( DataMediaDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findDataMediaById " , dataMediaId ) ; }
public List < DataMediaDO > listAll ( ) { return ( List < DataMediaDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listDataMedias " ) ; }
public List < DataMediaDO > listByDataMediaSourceId ( Long dataMediaSourceId ) { Assert . assertNotNull ( dataMediaSourceId ) ; return ( List < DataMediaDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listDataMediasByDataMediaSourceId " , dataMediaSourceId ) ;
public List < DataMediaDO > listByCondition ( Map condition ) { List < DataMediaDO > dataMediaDos = getSqlMapClientTemplate ( ) . queryForList ( " listDataMedias " , condition ) ; return dataMediaDos ; }
public List < DataMediaDO > listByMultiId ( Long . . . identities ) { List < DataMediaDO > dataMediaDos = getSqlMapClientTemplate ( ) . queryForList ( " listDataMediaByIds " , identities ) ; return dataMediaDos ; }
public int getCount ( ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getDataMediaCount " ) ; return count . intValue ( ) ; }
public int getCount ( Map condition ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getDataMediaCount " , condition ) ; return count . intValue ( ) ; }
public List < String > queryColumnByMediaId ( Long dataMediaId ) { return queryColumnByMedia ( findById ( dataMediaId ) ) ; }
public void create ( DataMedia dataMedia ) { Assert . assertNotNull ( dataMedia ) ; try { DataMediaDO dataMediaDo = modelToDo ( dataMedia ) ;
public Long createReturnId ( DataMedia dataMedia ) { Assert . assertNotNull ( dataMedia ) ; try { DataMediaDO dataMediaDo = modelToDo ( dataMedia ) ;
public void remove ( Long dataMediaId ) { Assert . assertNotNull ( dataMediaId ) ; try { dataMediaDao . delete ( dataMediaId ) ;
public void modify ( DataMedia dataMedia ) { Assert . assertNotNull ( dataMedia ) ; try { DataMediaDO dataMediaDo = modelToDo ( dataMedia ) ;
public List < DataMedia > listAll ( ) { return listByIds ( ) ; }
public List < DataMedia > listByCondition ( Map condition ) { List < DataMedia > dataMedias = new ArrayList < DataMedia > ( ) ; try { List < DataMediaDO > dataMediaDos = dataMediaDao . listByCondition ( condition ) ; if ( dataMediaDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any dataMedias by the condition: " + JsonUtils . marshalToString ( condition ) ) ; return dataMedias ; } dataMedias = doToModel ( dataMediaDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query dataMedias by condition has an exception! " ) ; throw new ManagerException ( e ) ; } return dataMedias ; }
public DataMedia findById ( Long dataMediaId ) { Assert . assertNotNull ( dataMediaId ) ; List < DataMedia > dataMedias = listByIds ( dataMediaId ) ; if ( dataMedias . size ( ) ! = 1 ) { String exceptionCause = " query dataMediaId: " + dataMediaId + " but return " + dataMedias . size ( ) + " dataMedia. " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } return dataMedias . get ( 0 ) ;
public List < DataMedia > listByIds ( Long . . . identities ) { List < DataMedia > dataMedias = new ArrayList < DataMedia > ( ) ; try { List < DataMediaDO > dataMediaDos = null ; if ( identities . length < 1 ) { dataMediaDos = dataMediaDao . listAll ( ) ; if ( dataMediaDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any dataMedia, maybe hasn't create any dataMedia. " ) ; return dataMedias ; } } else { dataMediaDos = dataMediaDao . listByMultiId ( identities ) ; if ( dataMediaDos . isEmpty ( ) ) { String exceptionCause = " couldn't query any dataMedia by dataMediaIds: " + Arrays . toString ( identities ) ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } } dataMedias = doToModel ( dataMediaDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query dataMedias has an exception! " ) ; throw new ManagerException ( e ) ; } return dataMedias ; }
public List < DataMedia > listByDataMediaSourceId ( Long dataMediaSourceId ) { Assert . assertNotNull ( dataMediaSourceId ) ; List < DataMediaDO > dataMediaDos = null ; try { dataMediaDos = dataMediaDao . listByDataMediaSourceId ( dataMediaSourceId ) ; if ( dataMediaDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any dataMedia, maybe hasn't create any dataMedia. " ) ; return new ArrayList < DataMedia > ( ) ; } } catch ( Exception e ) { logger . error ( " ERROR ## query dataMedias by sourceId: " + dataMediaSourceId + " has an exception! " ) ; throw new ManagerException ( e ) ; } return doToModel ( dataMediaDos ) ; }
public int getCount ( ) { return dataMediaDao . getCount ( ) ; }
public int getCount ( Map condition ) { return dataMediaDao . getCount ( condition ) ; }
private DataMediaDO modelToDo ( DataMedia dataMedia ) { DataMediaDO dataMediaDo = new DataMediaDO ( ) ; try { dataMediaDo . setId ( dataMedia . getId ( ) ) ; dataMediaDo . setName ( dataMedia . getName ( ) ) ; dataMediaDo . setNamespace ( dataMedia . getNamespace ( ) ) ; dataMediaDo . setDataMediaSourceId ( dataMedia . getSource ( ) . getId ( ) ) ; // if (dataMedia instanceof DbDataMedia) { // dataMediaDo.setProperties(JsonUtils.marshalToString((DbDataMedia) dataMedia)); // } dataMediaDo.setProperties(JsonUtils.marshalToString(dataMedia)); dataMediaDo.setGmtCreate(dataMedia.getGmtCreate()); dataMediaDo.setGmtModified(dataMedia.getGmtModified()); } catch (Exception e) { logger.error("ERROR ## change the dataMedia Model to Do has an exception"); throw new ManagerException(e); } return dataMediaDo; }
private DataMedia doToModel ( DataMediaDO dataMediaDo ) { DataMedia dataMedia = null ; try { DataMediaSource dataMediaSource = dataMediaSourceService . findById ( dataMediaDo . getDataMediaSourceId ( ) ) ; if ( dataMediaSource . getType ( ) . isMysql ( ) | | dataMediaSource . getType ( ) . isOracle ( ) ) { dataMedia = JsonUtils . unmarshalFromString ( dataMediaDo . getProperties ( ) , DbDataMedia . class ) ; dataMedia . setSource ( dataMediaSource ) ; } else if ( dataMediaSource . getType ( ) . isNapoli ( ) | | dataMediaSource . getType ( ) . isMq ( ) ) { dataMedia = JsonUtils . unmarshalFromString ( dataMediaDo . getProperties ( ) , MqDataMedia . class ) ; dataMedia . setSource ( dataMediaSource ) ; } dataMedia . setId ( dataMediaDo . getId ( ) ) ; dataMedia . setGmtCreate ( dataMediaDo . getGmtCreate ( ) ) ; dataMedia . setGmtModified ( dataMediaDo . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the dataMedia Do to Model has an exception " ) ; throw new ManagerException ( e ) ; } return dataMedia ; }
private List < DataMedia > doToModel ( List < DataMediaDO > dataMediaDos ) { List < DataMedia > dataMedias = new ArrayList < DataMedia > ( ) ; for ( DataMediaDO dataMediaDo : dataMediaDos ) { dataMedias . add ( doToModel ( dataMediaDo ) ) ; } return dataMedias ; }
public void setDataMediaDao ( DataMediaDAO dataMediaDao ) { this . dataMediaDao = dataMediaDao ; }
public void setDataMediaSourceService ( DataMediaSourceService dataMediaSourceService ) { this . dataMediaSourceService = dataMediaSourceService ; }
public void setDataSourceCreator ( DataSourceCreator dataSourceCreator ) { this . dataSourceCreator = dataSourceCreator ; }
public List < DataMediaPair > listByPipelineId ( Long pipelineId ) ; public List < DataMediaPair > listByPipelineIdWithoutColumn ( Long pipelineId ) ; public List < DataMediaPair > listByDataMediaId ( Long dataMediaId ) ; public Long createAndReturnId ( DataMediaPair dataMediaPair ) ; public boolean createIfNotExist ( DataMediaPair dataMediaPair ) ; }
public List < DataMediaPair > listByPipelineIdWithoutColumn ( Long pipelineId ) ; public List < DataMediaPair > listByDataMediaId ( Long dataMediaId ) ; public Long createAndReturnId ( DataMediaPair dataMediaPair ) ; public boolean createIfNotExist ( DataMediaPair dataMediaPair ) ; }
public List < DataMediaPair > listByDataMediaId ( Long dataMediaId ) ; public Long createAndReturnId ( DataMediaPair dataMediaPair ) ; public boolean createIfNotExist ( DataMediaPair dataMediaPair ) ; }
public Long createAndReturnId ( DataMediaPair dataMediaPair ) ; public boolean createIfNotExist ( DataMediaPair dataMediaPair ) ; }
public boolean createIfNotExist ( DataMediaPair dataMediaPair ) ; }
public List < DataMediaPairDO > listByPipelineId ( Long pipelineId ) ; public List < DataMediaPairDO > listByDataMediaId ( Long dataMediaId ) ; }
public List < DataMediaPairDO > listByDataMediaId ( Long dataMediaId ) ; }
public Long getSourceDataMediaId ( ) { return sourceDataMediaId ; }
public void setSourceDataMediaId ( Long sourceDataMediaId ) { this . sourceDataMediaId = sourceDataMediaId ; }
public Long getTargetDataMediaId ( ) { return targetDataMediaId ; }
public void setTargetDataMediaId ( Long targetDataMediaId ) { this . targetDataMediaId = targetDataMediaId ; }
public Long getPullWeight ( ) { return pullWeight ; }
public void setPullWeight ( Long pullWeight ) { this . pullWeight = pullWeight ; }
public Long getPushWeight ( ) { return pushWeight ; }
public void setPushWeight ( Long pushWeight ) { this . pushWeight = pushWeight ; }
public String getResolver ( ) { return resolver ; }
public void setResolver ( String resolver ) { this . resolver = resolver ; }
public String getFilter ( ) { return filter ; }
public void setFilter ( String filter ) { this . filter = filter ; }
public ColumnPairMode getColumnPairMode ( ) { return columnPairMode ; }
public void setColumnPairMode ( ColumnPairMode columnPairMode ) { this . columnPairMode = columnPairMode ; }
public DataMediaPairDO insert ( DataMediaPairDO dataMediaPair ) { Assert . assertNotNull ( dataMediaPair ) ; getSqlMapClientTemplate ( ) . insert ( " insertDataMediaPair " , dataMediaPair ) ; return dataMediaPair ; }
public void insertColumnPairs ( List < ColumnPair > ColumnPairs ) { Assert . assertNotNull ( ColumnPairs ) ; getSqlMapClientTemplate ( ) . insert ( " insertColumnPairs " , ColumnPairs ) ; }
public void delete ( Long dataMediaPairId ) { Assert . assertNotNull ( dataMediaPairId ) ; getSqlMapClientTemplate ( ) . delete ( " deleteDataMediaPairById " , dataMediaPairId ) ; }
public void update ( DataMediaPairDO dataMediaPair ) { Assert . assertNotNull ( dataMediaPair ) ; getSqlMapClientTemplate ( ) . update ( " updateDataMediaPair " , dataMediaPair ) ; }
public boolean checkUnique ( DataMediaPairDO dataMediaPair ) { int count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " checkDataMediaPairUnique " , dataMediaPair ) ; return count = = 0 ? true : false ; }
public DataMediaPairDO findById ( Long dataMediaPairId ) { Assert . assertNotNull ( dataMediaPairId ) ; return ( DataMediaPairDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findDataMediaPairById " , dataMediaPairId ) ; }
public List < DataMediaPairDO > listAll ( ) { return ( List < DataMediaPairDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listDataMediaPairs " ) ; }
public List < DataMediaPairDO > listByPipelineId ( Long pipelineId ) { Assert . assertNotNull ( pipelineId ) ; return ( List < DataMediaPairDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listDataMediaPairsByPipelineId " , pipelineId ) ;
public List < DataMediaPairDO > listByCondition ( Map condition ) { List < DataMediaPairDO > dataMediaPairDos = getSqlMapClientTemplate ( ) . queryForList ( " listDataMediaPairs " , condition ) ; return dataMediaPairDos ; }
public List < DataMediaPairDO > listByDataMediaId ( Long dataMediaId ) { Assert . assertNotNull ( dataMediaId ) ; return ( List < DataMediaPairDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listDataMediaPairsByDataMediaId " , dataMediaId ) ;
public List < DataMediaPairDO > listByMultiId ( Long . . . identities ) { List < DataMediaPairDO > dataMediaPairDos = getSqlMapClientTemplate ( ) . queryForList ( " listDataMediaPairByIds " , identities ) ; return dataMediaPairDos ; }
public int getCount ( ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getDataMediaPairCount " ) ; return count . intValue ( ) ; }
public int getCount ( Map condition ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getDataMediaPairCount " , condition ) ; return count . intValue ( ) ; }
public void create ( DataMediaPair dataMediaPair ) { createAndReturnId ( dataMediaPair ) ; }
public Long createAndReturnId ( DataMediaPair dataMediaPair ) { Assert . assertNotNull ( dataMediaPair ) ; try { DataMediaPairDO dataMediaPairDo = modelToDo ( dataMediaPair ) ;
public boolean createIfNotExist ( DataMediaPair dataMediaPair ) { Assert . assertNotNull ( dataMediaPair ) ; try { DataMediaPairDO dataMediaPairDo = modelToDo ( dataMediaPair ) ;
public void remove ( Long dataMediaPairId ) { Assert . assertNotNull ( dataMediaPairId ) ; try { dataMediaPairDao . delete ( dataMediaPairId ) ;
public void modify ( DataMediaPair dataMediaPair ) { Assert . assertNotNull ( dataMediaPair ) ; try { DataMediaPairDO dataMediaPairDo = modelToDo ( dataMediaPair ) ;
public List < DataMediaPair > listByIds ( Long . . . identities ) { List < DataMediaPair > dataMediaPairs = new ArrayList < DataMediaPair > ( ) ; try { List < DataMediaPairDO > dataMediaPairDos = null ; if ( identities . length < 1 ) { dataMediaPairDos = dataMediaPairDao . listAll ( ) ; if ( dataMediaPairDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any dataMediaPair, maybe hasn't create any dataMediaPair. " ) ; return dataMediaPairs ; } } else { dataMediaPairDos = dataMediaPairDao . listByMultiId ( identities ) ; if ( dataMediaPairDos . isEmpty ( ) ) { String exceptionCause = " couldn't query any dataMediaPair by dataMediaPairIds: " + Arrays . toString ( identities ) ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } } dataMediaPairs = doToModel ( dataMediaPairDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query dataMediaPairs has an exception! " , e ) ; throw new ManagerException ( e ) ; } return dataMediaPairs ;
public List < DataMediaPair > listAll ( ) { return listByIds ( ) ; }
public List < DataMediaPair > listByCondition ( Map condition ) { List < DataMediaPair > dataMediaPairs = new ArrayList < DataMediaPair > ( ) ; try { List < DataMediaPairDO > dataMediaPairDos = dataMediaPairDao . listByCondition ( condition ) ; if ( dataMediaPairDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any DataMediaPairs by the condition: " + JsonUtils . marshalToString ( condition ) ) ; return dataMediaPairs ; } dataMediaPairs = doToModel ( dataMediaPairDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query dataMediaPairs by condition has an exception! " , e ) ; throw new ManagerException ( e ) ; } return dataMediaPairs ; }
public DataMediaPair findById ( Long dataMediaPairId ) { Assert . assertNotNull ( dataMediaPairId ) ; List < DataMediaPair > dataMediaPairs = listByIds ( dataMediaPairId ) ; if ( dataMediaPairs . size ( ) ! = 1 ) { String exceptionCause = " query dataMediaPairId: " + dataMediaPairId + " but return " + dataMediaPairs . size ( ) + " Pairs. " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } return dataMediaPairs . get ( 0 ) ; }
public List < DataMediaPair > listByPipelineId ( Long pipelineId ) { Assert . assertNotNull ( pipelineId ) ; List < DataMediaPair > dataMediaPairs = new ArrayList < DataMediaPair > ( ) ; try { List < DataMediaPairDO > dataMediaPairDos = dataMediaPairDao . listByPipelineId ( pipelineId ) ; if ( dataMediaPairDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any dataMediaPair, maybe hasn't create any dataMediaPair. " ) ; return dataMediaPairs ; } dataMediaPairs = doToModel ( dataMediaPairDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query dataMediaPairs by pipelineId: " + pipelineId + " has an exception! " , e ) ; throw new ManagerException ( e ) ; } return dataMediaPairs ; }
public List < DataMediaPair > listByPipelineIdWithoutColumn ( Long pipelineId ) { Assert . assertNotNull ( pipelineId ) ; List < DataMediaPair > dataMediaPairs = new ArrayList < DataMediaPair > ( ) ; try { List < DataMediaPairDO > dataMediaPairDos = dataMediaPairDao . listByPipelineId ( pipelineId ) ; if ( dataMediaPairDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any dataMediaPair, maybe hasn't create any dataMediaPair. " ) ; return dataMediaPairs ; } dataMediaPairs = doToModelWithoutOther ( dataMediaPairDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query dataMediaPairs by pipelineId: " + pipelineId + " has an exception! " , e ) ; throw new ManagerException ( e ) ; } return dataMediaPairs ; }
public List < DataMediaPair > listByDataMediaId ( Long dataMediaId ) { Assert . assertNotNull ( dataMediaId ) ; List < DataMediaPair > dataMediaPairs = new ArrayList < DataMediaPair > ( ) ; try { List < DataMediaPairDO > dataMediaPairDos = dataMediaPairDao . listByDataMediaId ( dataMediaId ) ; if ( dataMediaPairDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any dataMediaPair, maybe hasn't create any dataMediaPair. " ) ; return dataMediaPairs ; } dataMediaPairs = doToModel ( dataMediaPairDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query dataMediaPairs by dataMediaId: " + dataMediaId + " has an exception! " , e ) ; throw new ManagerException ( e ) ; } return dataMediaPairs ; }
public int getCount ( ) { return dataMediaPairDao . getCount ( ) ; }
public int getCount ( Map condition ) { return dataMediaPairDao . getCount ( condition ) ; }
private List < DataMediaPair > doToModel ( List < DataMediaPairDO > dataMediaPairDos ) { List < Long > dataMediaPairIds = new ArrayList < Long > ( ) ; for ( DataMediaPairDO dataMediaPairDo : dataMediaPairDos ) { dataMediaPairIds . add ( dataMediaPairDo . getId ( ) ) ; } Map < Long , List < ColumnPair > > columnPairMap = dataColumnPairService . listByDataMediaPairIds ( dataMediaPairIds . toArray ( new Long [ dataMediaPairIds . size ( ) ] ) ) ; Map < Long , List < ColumnGroup > > columnPairGroupMap = dataColumnPairGroupService . listByDataMediaPairIds ( dataMediaPairIds . toArray ( new Long [ dataMediaPairIds . size ( ) ] ) ) ; List < DataMediaPair > dataMediaPairs = new ArrayList < DataMediaPair > ( ) ; for ( DataMediaPairDO dataMediaPairDo : dataMediaPairDos ) { List < ColumnPair > columnPairs = columnPairMap . get ( dataMediaPairDo . getId ( ) ) = = null ? new ArrayList < ColumnPair > ( ) : columnPairMap . get ( dataMediaPairDo . getId ( ) ) ; List < ColumnGroup > columnGroups = columnPairGroupMap . get ( dataMediaPairDo . getId ( ) ) = = null ? new ArrayList < ColumnGroup > ( ) : columnPairGroupMap . get ( dataMediaPairDo . getId ( ) ) ; dataMediaPairs . add ( doToModel ( dataMediaPairDo , columnPairs , columnGroups ) ) ; } return dataMediaPairs ; }
private List < DataMediaPair > doToModelWithoutOther ( List < DataMediaPairDO > dataMediaPairDos ) { List < DataMediaPair > dataMediaPairs = new ArrayList < DataMediaPair > ( ) ; for ( DataMediaPairDO dataMediaPairDo : dataMediaPairDos ) { dataMediaPairs . add ( doToModel ( dataMediaPairDo , null , null ) ) ; } return dataMediaPairs ; }
private DataMediaPairDO modelToDo ( DataMediaPair dataMediaPair ) { DataMediaPairDO dataMediaPairDo = new DataMediaPairDO ( ) ; try { dataMediaPairDo . setId ( dataMediaPair . getId ( ) ) ; dataMediaPairDo . setPipelineId ( dataMediaPair . getPipelineId ( ) ) ; dataMediaPairDo . setSourceDataMediaId ( dataMediaPair . getSource ( ) . getId ( ) ) ; dataMediaPairDo . setTargetDataMediaId ( dataMediaPair . getTarget ( ) . getId ( ) ) ; dataMediaPairDo . setFilter ( JsonUtils . marshalToString ( dataMediaPair . getFilterData ( ) ) ) ; dataMediaPairDo . setResolver ( JsonUtils . marshalToString ( dataMediaPair . getResolverData ( ) ) ) ; dataMediaPairDo . setPullWeight ( dataMediaPair . getPullWeight ( ) ) ; dataMediaPairDo . setPushWeight ( dataMediaPair . getPushWeight ( ) ) ; dataMediaPairDo . setColumnPairMode ( dataMediaPair . getColumnPairMode ( ) ) ; dataMediaPairDo . setGmtCreate ( dataMediaPair . getGmtCreate ( ) ) ; dataMediaPairDo . setGmtModified ( dataMediaPair . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the dataMediaPair Model to Do has an exception " , e ) ; throw new ManagerException ( e ) ; } return dataMediaPairDo ; }
public void setDataMediaPairDao ( DataMediaPairDAO dataMediaPairDao ) { this . dataMediaPairDao = dataMediaPairDao ; }
public void setDataMediaService ( DataMediaService dataMediaService ) { this . dataMediaService = dataMediaService ; }
public void setDataColumnPairGroupService ( DataColumnPairGroupService dataColumnPairGroupService ) { this . dataColumnPairGroupService = dataColumnPairGroupService ; }
public DataMediaType getType ( ) { return type ; }
public void setType ( DataMediaType type ) { this . type = type ; }
public DataMediaSourceDO insert ( DataMediaSourceDO dataMediaSourceDO ) { Assert . assertNotNull ( dataMediaSourceDO ) ; getSqlMapClientTemplate ( ) . insert ( " insertDataMediaSource " , dataMediaSourceDO ) ; return dataMediaSourceDO ; }
public void delete ( Long dataMediaSourceId ) { Assert . assertNotNull ( dataMediaSourceId ) ; getSqlMapClientTemplate ( ) . delete ( " deleteDataMediaSourceById " , dataMediaSourceId ) ; }
public void update ( DataMediaSourceDO dataMediaSourceDO ) { Assert . assertNotNull ( dataMediaSourceDO ) ; getSqlMapClientTemplate ( ) . update ( " updateDataMediaSource " , dataMediaSourceDO ) ; }
public boolean checkUnique ( DataMediaSourceDO dataMediaSourceDO ) { int count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " checkDataMediaSourceUnique " , dataMediaSourceDO ) ; return count = = 0 ? true : false ; }
public DataMediaSourceDO findById ( Long dataMediaSourceId ) { Assert . assertNotNull ( dataMediaSourceId ) ; return ( DataMediaSourceDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findDataMediaSourceById " , dataMediaSourceId ) ;
public List < DataMediaSourceDO > listByCondition ( Map condition ) { List < DataMediaSourceDO > dataMediaSourceDos = getSqlMapClientTemplate ( ) . queryForList ( " listDataMediaSources " , condition ) ; return dataMediaSourceDos ; }
public List < DataMediaSourceDO > listAll ( ) { return ( List < DataMediaSourceDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listDataMediaSources " ) ; }
public List < DataMediaSourceDO > listByMultiId ( Long . . . identities ) { List < DataMediaSourceDO > dataMediaSourceDos = getSqlMapClientTemplate ( ) . queryForList ( " listSourceByIds " , identities ) ; return dataMediaSourceDos ; }
public int getCount ( ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getSourceCount " ) ; return count . intValue ( ) ; }
public int getCount ( Map condition ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getSourceCount " , condition ) ; return count . intValue ( ) ; }
public void create ( DataMediaSource dataMediaSource ) { Assert . assertNotNull ( dataMediaSource ) ; try { DataMediaSourceDO dataMediaSourceDo = modelToDo ( dataMediaSource ) ;
public void remove ( Long dataMediaSourceId ) { Assert . assertNotNull ( dataMediaSourceId ) ; try { dataMediaSourceDao . delete ( dataMediaSourceId ) ;
public void modify ( DataMediaSource dataMediaSource ) { Assert . assertNotNull ( dataMediaSource ) ; try { DataMediaSourceDO dataMediaSourceDo = modelToDo ( dataMediaSource ) ;
public List < DataMediaSource > listAll ( ) { return listByIds ( ) ; }
public List < DataMediaSource > listByCondition ( Map condition ) { List < DataMediaSource > dataMediaSources = new ArrayList < DataMediaSource > ( ) ; try { List < DataMediaSourceDO > dataMediaSourceDos = dataMediaSourceDao . listByCondition ( condition ) ; if ( dataMediaSourceDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any DataMediaSources by the condition: " + JsonUtils . marshalToString ( condition ) ) ; return dataMediaSources ; } dataMediaSources = doToModel ( dataMediaSourceDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query DataMediaSources by condition has an exception! " ) ; throw new ManagerException ( e ) ; } return dataMediaSources ; }
public List < DataMediaSource > listByIds ( Long . . . identities ) { List < DataMediaSourceDO > dataMediaSourceDos = null ; if ( identities . length < 1 ) { dataMediaSourceDos = dataMediaSourceDao . listAll ( ) ; if ( dataMediaSourceDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any dataMediaSource, maybe hasn't create any dataMediaSource. " ) ; return new ArrayList < DataMediaSource > ( ) ; } } else { dataMediaSourceDos = dataMediaSourceDao . listByMultiId ( identities ) ; if ( dataMediaSourceDos . isEmpty ( ) ) { String exceptionCause = " couldn't query any dataMediaSource by dataMediaSourceIds: " + Arrays . toString ( identities ) ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } } return doToModel ( dataMediaSourceDos ) ; }
public DataMediaSource findById ( Long dataMediaSourceId ) { Assert . assertNotNull ( dataMediaSourceId ) ; List < DataMediaSource > dataMediaSources = listByIds ( dataMediaSourceId ) ; if ( dataMediaSources . size ( ) ! = 1 ) { String exceptionCause = " query dataMediaSourceId: " + dataMediaSourceId + " but return " + dataMediaSources . size ( ) + " dataMediaSource. " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } return dataMediaSources . get ( 0 ) ;
public int getCount ( ) { return dataMediaSourceDao . getCount ( ) ; }
public int getCount ( Map condition ) { return dataMediaSourceDao . getCount ( condition ) ; }
private DataMediaSourceDO modelToDo ( DataMediaSource dataMediaSource ) { DataMediaSourceDO dataMediaSourceDo = new DataMediaSourceDO ( ) ; try { dataMediaSourceDo . setId ( dataMediaSource . getId ( ) ) ; dataMediaSourceDo . setName ( dataMediaSource . getName ( ) ) ; dataMediaSourceDo . setType ( dataMediaSource . getType ( ) ) ; if ( dataMediaSource instanceof DbMediaSource ) { dataMediaSourceDo . setProperties ( JsonUtils . marshalToString ( ( DbMediaSource ) dataMediaSource ) ) ; } else if ( dataMediaSource instanceof MqMediaSource ) { dataMediaSourceDo . setProperties ( JsonUtils . marshalToString ( ( MqMediaSource ) dataMediaSource ) ) ; } dataMediaSourceDo . setGmtCreate ( dataMediaSource . getGmtCreate ( ) ) ; dataMediaSourceDo . setGmtModified ( dataMediaSource . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the dataMediaSource Model to Do has an exception " ) ; throw new ManagerException ( e ) ; } return dataMediaSourceDo ; }
private DataMediaSource doToModel ( DataMediaSourceDO dataMediaSourceDo ) { DataMediaSource dataMediaSource = new DbMediaSource ( ) ; try { if ( dataMediaSourceDo . getType ( ) . isMysql ( ) | | dataMediaSourceDo . getType ( ) . isOracle ( ) ) { dataMediaSource = JsonUtils . unmarshalFromString ( dataMediaSourceDo . getProperties ( ) , DbMediaSource . class ) ; } else if ( dataMediaSourceDo . getType ( ) . isNapoli ( ) | | dataMediaSourceDo . getType ( ) . isMq ( ) ) { dataMediaSource = JsonUtils . unmarshalFromString ( dataMediaSourceDo . getProperties ( ) , MqMediaSource . class ) ; } dataMediaSource . setId ( dataMediaSourceDo . getId ( ) ) ; dataMediaSource . setGmtCreate ( dataMediaSourceDo . getGmtCreate ( ) ) ; dataMediaSource . setGmtModified ( dataMediaSourceDo . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the dataMediaSource Do to Model has an exception " ) ; throw new ManagerException ( e ) ; } return dataMediaSource ; }
private List < DataMediaSource > doToModel ( List < DataMediaSourceDO > dataMediaSourceDos ) { List < DataMediaSource > dataMediaSources = new ArrayList < DataMediaSource > ( ) ; for ( DataMediaSourceDO dataMediaSourceDo : dataMediaSourceDos ) { dataMediaSources . add ( doToModel ( dataMediaSourceDo ) ) ; } return dataMediaSources ; }
public void setDataMediaSourceDao ( DataMediaSourceDAO dataMediaSourceDao ) { this . dataMediaSourceDao = dataMediaSourceDao ; }
public void setIp ( String ip ) { this . ip = ip ; }
public void setPort ( Long port ) { this . port = port ; }
public NodeStatus getStatus ( ) { return status ; }
public void setStatus ( NodeStatus status ) { this . status = status ; }
public NodeParameter getParameters ( ) { return parameters ; }
public void setParameters ( NodeParameter parameters ) { this . parameters = parameters ; }
public NodeDO insert ( NodeDO node ) { Assert . assertNotNull ( node ) ; getSqlMapClientTemplate ( ) . insert ( " insertNode " , node ) ; return node ; }
public void delete ( Long nodeId ) { Assert . assertNotNull ( nodeId ) ; getSqlMapClientTemplate ( ) . delete ( " deleteNodeById " , nodeId ) ; }
public void update ( NodeDO node ) { Assert . assertNotNull ( node ) ; getSqlMapClientTemplate ( ) . update ( " updateNode " , node ) ; }
public boolean checkUnique ( NodeDO node ) { int count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " checkNodeUnique " , node ) ; return count = = 0 ? true : false ; }
public List < NodeDO > listByCondition ( Map condition ) { List < NodeDO > nodeDos = getSqlMapClientTemplate ( ) . queryForList ( " listNodes " , condition ) ; return nodeDos ; }
public NodeDO findById ( Long nodeId ) { Assert . assertNotNull ( nodeId ) ; return ( NodeDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findNodeById " , nodeId ) ; }
public List < NodeDO > listAll ( ) { return ( List < NodeDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listNodes " ) ; }
public List < NodeDO > listByMultiId ( Long . . . identities ) { List < NodeDO > nodeDos = getSqlMapClientTemplate ( ) . queryForList ( " listNodeByIds " , identities ) ; return nodeDos ; }
public int getCount ( ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getNodeCount " ) ; return count . intValue ( ) ; }
public int getCount ( Map condition ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getNodeCount " , condition ) ; return count . intValue ( ) ; }
public Object getResult ( ResultGetter getter ) throws SQLException { return JsonUtils . unmarshalFromString ( getter . getString ( ) , NodeParameter . class ) ; }
public Object valueOf ( String s ) { return JsonUtils . unmarshalFromString ( s , NodeParameter . class ) ; }
public void create ( final Node node ) { Assert . assertNotNull ( node ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { NodeDO nodeDo = modelToDo ( node ) ;
public void remove ( final Long nodeId ) { Assert . assertNotNull ( nodeId ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { nodeDao . delete ( nodeId ) ;
public void modify ( final Node node ) { Assert . assertNotNull ( node ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
public List < Node > listAll ( ) { return listByIds ( ) ; }
public Node findById ( Long nodeId ) { Assert . assertNotNull ( nodeId ) ; List < Node > nodes = listByIds ( nodeId ) ; if ( nodes . size ( ) ! = 1 ) { String exceptionCause = " query nodeId: " + nodeId + " return null. " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } return nodes . get ( 0 ) ;
public int getCount ( ) { return nodeDao . getCount ( ) ; }
public int getCount ( Map condition ) { return nodeDao . getCount ( condition ) ; }
private NodeDO modelToDo ( Node node ) { NodeDO nodeDo = new NodeDO ( ) ; try { nodeDo . setId ( node . getId ( ) ) ; nodeDo . setIp ( node . getIp ( ) ) ; nodeDo . setName ( node . getName ( ) ) ; nodeDo . setPort ( node . getPort ( ) ) ; nodeDo . setDescription ( node . getDescription ( ) ) ; nodeDo . setStatus ( node . getStatus ( ) ) ; nodeDo . setParameters ( node . getParameters ( ) ) ; nodeDo . setGmtCreate ( node . getGmtCreate ( ) ) ; nodeDo . setGmtModified ( node . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the node Model to Do has an exception " ) ; throw new ManagerException ( e ) ; } return nodeDo ; }
private List < Node > doToModel ( List < NodeDO > nodeDos ) { List < Node > nodes = new ArrayList < Node > ( ) ; for ( NodeDO nodeDo : nodeDos ) { nodes . add ( doToModel ( nodeDo ) ) ; } return nodes ; }
public void setNodeDao ( NodeDAO nodeDao ) { this . nodeDao = nodeDao ; }
public void createOrUpdate ( SystemParameter systemParameter ) ; public SystemParameter find ( ) ; }
public SystemParameter getValue ( ) { return value ; }
public void setValue ( SystemParameter value ) { this . value = value ; }
public SystemParameterDO insert ( SystemParameterDO systemParameter ) { Assert . assertNotNull ( systemParameter ) ; getSqlMapClientTemplate ( ) . insert ( " insertParameter " , systemParameter ) ; return systemParameter ; }
public void update ( SystemParameterDO systemParameter ) { throw new UnsupportedOperationException ( ) ; }
public void delete ( Long parameterId ) { throw new UnsupportedOperationException ( ) ; }
public boolean checkUnique ( SystemParameterDO systemParameter ) { throw new UnsupportedOperationException ( ) ; }
public SystemParameterDO findById ( Long parameterId ) { throw new UnsupportedOperationException ( ) ; }
public int getCount ( ) { throw new UnsupportedOperationException ( ) ; }
public int getCount ( Map condition ) { throw new UnsupportedOperationException ( ) ; }
public List < SystemParameterDO > listAll ( ) { return ( List < SystemParameterDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listParameters " ) ; }
public List < SystemParameterDO > listByCondition ( Map condition ) { throw new UnsupportedOperationException ( ) ; }
public List < SystemParameterDO > listByMultiId ( Long . . . identities ) { throw new UnsupportedOperationException ( ) ; }
public Object getResult ( ResultGetter getter ) throws SQLException { return JsonUtils . unmarshalFromString ( getter . getString ( ) , SystemParameter . class ) ; }
public Object valueOf ( String s ) { return JsonUtils . unmarshalFromString ( s , SystemParameter . class ) ; }
public void createOrUpdate ( SystemParameter systemParameter ) { Assert . assertNotNull ( systemParameter ) ; try { SystemParameterDO systemParameterDo = modelToDo ( systemParameter ) ;
public SystemParameter find ( ) { List < SystemParameterDO > systemParameterDos = systemParameterDao . listAll ( ) ; if ( systemParameterDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any SystemParameter, maybe hasn't create any SystemParameter. " ) ;
private SystemParameterDO modelToDo ( SystemParameter systemParameter ) { SystemParameterDO systemParameterDo = new SystemParameterDO ( ) ; systemParameterDo . setValue ( systemParameter ) ; return systemParameterDo ; }
private SystemParameter doToModel ( SystemParameterDO systemParameterDo ) { return systemParameterDo . getValue ( ) ; }
public void setsystemParameterDao ( SystemParameterDAO systemParameterDao ) { this . systemParameterDao = systemParameterDao ; }
public List < Pipeline > listByChannelIds ( Long . . . channelIds ) ; public List < Pipeline > listByChannelIdsWithoutOther ( Long . . . channelIds ) ; public List < Pipeline > listByChannelIdsWithoutColumn ( Long . . . channelIds ) ; public List < Pipeline > listByNodeId ( Long nodeId ) ; public boolean hasRelation ( Long nodeId ) ; public List < Pipeline > listByDestinationWithoutOther ( String destination ) ; }
public List < Pipeline > listByChannelIdsWithoutOther ( Long . . . channelIds ) ; public List < Pipeline > listByChannelIdsWithoutColumn ( Long . . . channelIds ) ; public List < Pipeline > listByNodeId ( Long nodeId ) ; public boolean hasRelation ( Long nodeId ) ; public List < Pipeline > listByDestinationWithoutOther ( String destination ) ; }
public List < Pipeline > listByChannelIdsWithoutColumn ( Long . . . channelIds ) ; public List < Pipeline > listByNodeId ( Long nodeId ) ; public boolean hasRelation ( Long nodeId ) ; public List < Pipeline > listByDestinationWithoutOther ( String destination ) ; }
public List < Pipeline > listByNodeId ( Long nodeId ) ; public boolean hasRelation ( Long nodeId ) ; public List < Pipeline > listByDestinationWithoutOther ( String destination ) ; }
public boolean hasRelation ( Long nodeId ) ; public List < Pipeline > listByDestinationWithoutOther ( String destination ) ; }
public List < Pipeline > listByDestinationWithoutOther ( String destination ) ; }
public List < PipelineDO > listByChannelIds ( Long . . . channelId ) ; public List < PipelineDO > listByDestinationCondition ( String destination ) ; }
public List < PipelineDO > listByDestinationCondition ( String destination ) ; }
public void insertBatch ( List < PipelineNodeRelationDO > pipelineNodeRelationDos ) ; public void updateByNodeId ( Long . . . nodeId ) ; public void deleteByPipelineId ( Long pipelineId ) ; public void deleteByNodeId ( Long . . . nodeId ) ; public List < PipelineNodeRelationDO > listByPipelineIds ( Long . . . pipelineId ) ; public List < PipelineNodeRelationDO > listByNodeId ( Long nodeId ) ; }
public void updateByNodeId ( Long . . . nodeId ) ; public void deleteByPipelineId ( Long pipelineId ) ; public void deleteByNodeId ( Long . . . nodeId ) ; public List < PipelineNodeRelationDO > listByPipelineIds ( Long . . . pipelineId ) ; public List < PipelineNodeRelationDO > listByNodeId ( Long nodeId ) ; }
public void deleteByPipelineId ( Long pipelineId ) ; public void deleteByNodeId ( Long . . . nodeId ) ; public List < PipelineNodeRelationDO > listByPipelineIds ( Long . . . pipelineId ) ; public List < PipelineNodeRelationDO > listByNodeId ( Long nodeId ) ; }
public void deleteByNodeId ( Long . . . nodeId ) ; public List < PipelineNodeRelationDO > listByPipelineIds ( Long . . . pipelineId ) ; public List < PipelineNodeRelationDO > listByNodeId ( Long nodeId ) ; }
public List < PipelineNodeRelationDO > listByPipelineIds ( Long . . . pipelineId ) ; public List < PipelineNodeRelationDO > listByNodeId ( Long nodeId ) ; }
public List < PipelineNodeRelationDO > listByNodeId ( Long nodeId ) ; }
public PipelineParameter getParameters ( ) { return parameters ; }
public void setParameters ( PipelineParameter parameters ) { this . parameters = parameters ; }
public Long getChannelId ( ) { return channelId ; }
public void setChannelId ( Long channelId ) { this . channelId = channelId ; }
public boolean isSelect ( ) { return this . equals ( Location . SELECT ) ; }
public boolean isExtract ( ) { return this . equals ( Location . EXTRACT ) ; }
public boolean isLoad ( ) { return this . equals ( Location . LOAD ) ; }
public void setNodeId ( Long nodeId ) { this . nodeId = nodeId ; }
public Long getPipelineId ( ) { return PipelineId ; }
public void setPipelineId ( Long pipelineId ) { PipelineId = pipelineId ; }
public Location getLocation ( ) { return location ; }
public void setLocation ( Location location ) { this . location = location ; }
public PipelineDO insert ( PipelineDO pipelineDo ) { Assert . assertNotNull ( pipelineDo ) ; getSqlMapClientTemplate ( ) . insert ( " insertPipeline " , pipelineDo ) ; return pipelineDo ; }
public void delete ( Long pipelineId ) { Assert . assertNotNull ( pipelineId ) ; getSqlMapClientTemplate ( ) . delete ( " deletePipelineById " , pipelineId ) ; }
public void update ( PipelineDO pipelineDO ) { Assert . assertNotNull ( pipelineDO ) ; getSqlMapClientTemplate ( ) . update ( " updatePipeline " , pipelineDO ) ; }
public boolean checkUnique ( PipelineDO pipelineDO ) { int count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " checkPipelineUnique " , pipelineDO ) ; return count = = 0 ? true : false ; }
public PipelineDO findById ( Long pipelineId ) { Assert . assertNotNull ( pipelineId ) ; return ( PipelineDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findPipelineById " , pipelineId ) ; }
public List < PipelineDO > listByChannelIds ( Long . . . channelId ) { Assert . assertNotNull ( channelId ) ; return ( List < PipelineDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listPipelinesByChannelIds " , channelId ) ; }
public List < PipelineDO > listByCondition ( Map condition ) { List < PipelineDO > pipelineDos = getSqlMapClientTemplate ( ) . queryForList ( " listPipelines " , condition ) ; return pipelineDos ; }
public List < PipelineDO > listAll ( ) { List < PipelineDO > pipelines = getSqlMapClientTemplate ( ) . queryForList ( " listPipelines " ) ; return pipelines ; }
public List < PipelineDO > listByMultiId ( Long . . . identities ) { List < PipelineDO > pipelineDos = getSqlMapClientTemplate ( ) . queryForList ( " listPipelineByIds " , identities ) ; return pipelineDos ; }
public int getCount ( ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getPipelineCount " ) ; return count . intValue ( ) ; }
public int getCount ( Map condition ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getPipelineCount " , condition ) ; return count . intValue ( ) ; }
public List < PipelineDO > listByDestinationCondition ( String canalName ) { Map < String , String > map = new HashMap < String , String > ( ) ; map . put ( " searchKey " , canalName ) ; List < PipelineDO > pipelineDos = getSqlMapClientTemplate ( ) . queryForList ( " listByDestinationCondition " , map ) ; return pipelineDos ; }
public PipelineNodeRelationDO insert ( PipelineNodeRelationDO pipelineNodeRelationDo ) { Assert . assertNotNull ( pipelineNodeRelationDo ) ; getSqlMapClientTemplate ( ) . insert ( " insertPipelineNodeRelation " , pipelineNodeRelationDo ) ; return pipelineNodeRelationDo ; }
public void insertBatch ( List < PipelineNodeRelationDO > pipelineNodeRelationDos ) { try { getSqlMapClientTemplate ( ) . getSqlMapClient ( ) . startBatch ( ) ;
public void delete ( Long pipelineNodeRelationId ) { Assert . assertNotNull ( pipelineNodeRelationId ) ; getSqlMapClientTemplate ( ) . delete ( " deletePipelineNodeRelationById " , pipelineNodeRelationId ) ; }
public void update ( PipelineNodeRelationDO pipelineNodeRelationDo ) { Assert . assertNotNull ( pipelineNodeRelationDo ) ; getSqlMapClientTemplate ( ) . update ( " updatePipelineNodeRelation " , pipelineNodeRelationDo ) ; }
public List < PipelineNodeRelationDO > listByPipelineIds ( Long . . . pipelineId ) { Assert . assertNotNull ( pipelineId ) ; return ( List < PipelineNodeRelationDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listRelationsByPipelineIds " , pipelineId ) ;
public List < PipelineNodeRelationDO > listByNodeId ( Long nodeId ) { Assert . assertNotNull ( nodeId ) ; return ( List < PipelineNodeRelationDO > ) getSqlMapClientTemplate ( ) . queryForList ( " listRelationsByNodeId " , nodeId ) ; }
public boolean checkUnique ( PipelineNodeRelationDO entityObj ) { // TODO Auto-generated method stub return false; }
public List < PipelineNodeRelationDO > listByCondition ( Map condition ) { // TODO Auto-generated method stub return null; }
public List < PipelineNodeRelationDO > listAll ( ) { // TODO Auto-generated method stub return null; }
public List < PipelineNodeRelationDO > listByMultiId ( Long . . . identities ) { // TODO Auto-generated method stub return null; }
public PipelineNodeRelationDO findById ( Long identity ) { // TODO Auto-generated method stub return null; }
public void updateByNodeId ( Long . . . nodeId ) { // TODO Auto-generated method stub } public void deleteByPipelineId(Long pipelineId) { getSqlMapClientTemplate().delete("deleteRelationByPipelineId", pipelineId); } public void deleteByNodeId(Long... nodeId) { // TODO Auto-generated method stub } public int getCount() { Integer count = (Integer) getSqlMapClientTemplate().queryForObject("getRelationCount"); return count.intValue(); } public int getCount(Map condition) { // TODO Auto-generated method stub return 0; } }
public void deleteByPipelineId ( Long pipelineId ) { getSqlMapClientTemplate ( ) . delete ( " deleteRelationByPipelineId " , pipelineId ) ; }
public void deleteByNodeId ( Long . . . nodeId ) { // TODO Auto-generated method stub } public int getCount() { Integer count = (Integer) getSqlMapClientTemplate().queryForObject("getRelationCount"); return count.intValue(); } public int getCount(Map condition) { // TODO Auto-generated method stub return 0; } }
public int getCount ( ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getRelationCount " ) ; return count . intValue ( ) ; }
public void setParameter ( ParameterSetter setter , Object parameter ) throws SQLException { setter . setString ( JsonUtils . marshalToStringWithoutTransient ( parameter ) ) ; }
public Object getResult ( ResultGetter getter ) throws SQLException { return JsonUtils . unmarshalFromString ( getter . getString ( ) , PipelineParameter . class ) ; }
public Object valueOf ( String s ) { return JsonUtils . unmarshalFromString ( s , PipelineParameter . class ) ; }
public void create ( final Pipeline pipeline ) { Assert . assertNotNull ( pipeline ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { PipelineDO pipelineDo = modelToDo ( pipeline ) ;
public void modify ( Pipeline pipeline ) { Assert . assertNotNull ( pipeline ) ; try {
public void remove ( final Long pipelineId ) { Assert . assertNotNull ( pipelineId ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) {
protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { PipelineDO pipelineDO = pipelineDao . findById ( pipelineId ) ;
public int getCount ( ) { return pipelineDao . getCount ( ) ; }
public int getCount ( Map condition ) { return pipelineDao . getCount ( condition ) ; }
public Pipeline findById ( Long pipelineId ) { Assert . assertNotNull ( pipelineId ) ; List < Pipeline > pipeline = listByIds ( pipelineId ) ; if ( pipeline . size ( ) ! = 1 ) { String exceptionCause = " query pipeline by pipelineId: " + pipelineId + " but return " + pipeline . size ( ) + " pipeline! " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } return pipeline . get ( 0 ) ; }
public List < Pipeline > listByChannelIds ( Long . . . channelId ) { Assert . assertNotNull ( channelId ) ; List < Pipeline > pipelines = new ArrayList < Pipeline > ( ) ; try { List < PipelineDO > pipelineDos = pipelineDao . listByChannelIds ( channelId ) ; if ( pipelineDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## query pipeline by channelId: " + channelId + " return null. " ) ; return pipelines ; } pipelines = doToModel ( pipelineDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query pipelines by channelIds: " + channelId . toString ( ) + " has an exception! " ) ; throw new ManagerException ( e ) ; } return pipelines ; }
public List < Pipeline > listByChannelIdsWithoutOther ( Long . . . channelIds ) { Assert . assertNotNull ( channelIds ) ; List < Pipeline > pipelines = new ArrayList < Pipeline > ( ) ; try { List < PipelineDO > pipelineDos = pipelineDao . listByChannelIds ( channelIds ) ; if ( pipelineDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## query pipeline by channelId: " + channelIds + " return null. " ) ; return pipelines ; } pipelines = doToModelWithoutOther ( pipelineDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query pipelines by channelIds: " + channelIds . toString ( ) + " has an exception! " ) ; throw new ManagerException ( e ) ; } return pipelines ; }
public List < Pipeline > listByChannelIdsWithoutColumn ( Long . . . channelIds ) { Assert . assertNotNull ( channelIds ) ; List < Pipeline > pipelines = new ArrayList < Pipeline > ( ) ; try { List < PipelineDO > pipelineDos = pipelineDao . listByChannelIds ( channelIds ) ; if ( pipelineDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## query pipeline by channelId: " + channelIds + " return null. " ) ; return pipelines ; } pipelines = doToModelWithoutColumn ( pipelineDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query pipelines by channelIds: " + channelIds . toString ( ) + " has an exception! " ) ; throw new ManagerException ( e ) ; } return pipelines ; }
public List < Pipeline > listByNodeId ( Long nodeId ) { Assert . assertNotNull ( nodeId ) ; List < Pipeline > pipelines = new ArrayList < Pipeline > ( ) ; try { List < PipelineNodeRelationDO > relations = pipelineNodeRelationDao . listByNodeId ( nodeId ) ; if ( relations . isEmpty ( ) ) { logger . debug ( " DEBUG ## query the relation by nodeId: " + nodeId + " return null,maybe hasn't create any relations. " ) ; return pipelines ; } List < Long > piplineIds = new ArrayList < Long > ( ) ; for ( PipelineNodeRelationDO relation : relations ) { piplineIds . add ( relation . getPipelineId ( ) ) ; } List < PipelineDO > pipelineDos = pipelineDao . listByMultiId ( piplineIds . toArray ( new Long [ piplineIds . size ( ) ] ) ) ; if ( pipelineDos . isEmpty ( ) ) { String exceptionCause = " query the pipelines by pipelineIds: " + piplineIds . toString ( ) + " return null! " ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } pipelines = doToModel ( pipelineDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query the pipelines by nodeId: " + nodeId + " has an exception! " ) ; throw new ManagerException ( e ) ; } return pipelines ; }
public List < Pipeline > listByCondition ( Map condition ) { List < PipelineDO > pipelineDos = pipelineDao . listByCondition ( condition ) ; if ( pipelineDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any pipelines by the condition: " + JsonUtils . marshalToString ( condition ) ) ; return new ArrayList < Pipeline > ( ) ; } return doToModel ( pipelineDos ) ; }
public List < Pipeline > listByIds ( Long . . . identities ) { List < Pipeline > pipelines = new ArrayList < Pipeline > ( ) ; try { List < PipelineDO > pipelineDos = new ArrayList < PipelineDO > ( ) ; if ( identities . length < 1 ) { pipelineDos = pipelineDao . listAll ( ) ; if ( pipelineDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any pipeline, maybe hasn't create any pipeline. " ) ; return pipelines ; } } else { pipelineDos = pipelineDao . listByMultiId ( identities ) ; if ( pipelineDos . isEmpty ( ) ) { String exceptionCause = " couldn't query any pipeline by pipelineIds: " + Arrays . toString ( identities ) ; logger . error ( " ERROR ## " + exceptionCause ) ; throw new ManagerException ( exceptionCause ) ; } } pipelines = doToModel ( pipelineDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query pipelines has an exception! " ) ; throw new ManagerException ( e ) ; } return pipelines ; }
public List < Pipeline > listAll ( ) { return listByIds ( ) ; }
public boolean hasRelation ( Long nodeId ) { List < PipelineNodeRelationDO > relations = pipelineNodeRelationDao . listByNodeId ( nodeId ) ; if ( relations . isEmpty ( ) ) { return false ;
public List < Pipeline > listByDestinationWithoutOther ( String destination ) { Assert . assertNotNull ( destination ) ; List < Pipeline > pipelines = new ArrayList < Pipeline > ( ) ; try { List < PipelineDO > pipelineDos = pipelineDao . listByDestinationCondition ( destination ) ; if ( pipelineDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## query pipeline by destination: " + destination + " return null. " ) ; return pipelines ; } pipelines = doToModelWithoutOther ( pipelineDos ) ; } catch ( Exception e ) { logger . error ( " ERROR ## query pipelines by destination: " + destination + " has an exception! " ) ; throw new ManagerException ( e ) ; } return pipelines ; }
private Pipeline doToModelWithoutOther ( PipelineDO pipelineDo ) { Pipeline pipeline = new Pipeline ( ) ; try { pipeline . setId ( pipelineDo . getId ( ) ) ; pipeline . setName ( pipelineDo . getName ( ) ) ; pipeline . setParameters ( pipelineDo . getParameters ( ) ) ; pipeline . setDescription ( pipelineDo . getDescription ( ) ) ; pipeline . setGmtCreate ( pipelineDo . getGmtCreate ( ) ) ; pipeline . setGmtModified ( pipelineDo . getGmtModified ( ) ) ; pipeline . setChannelId ( pipelineDo . getChannelId ( ) ) ; pipeline . getParameters ( ) . setMainstemClientId ( pipeline . getId ( ) . shortValue ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the pipeline Do to Model has an exception " ) ; throw new ManagerException ( e ) ; } return pipeline ; }
private List < Pipeline > doToModel ( List < PipelineDO > pipelineDos ) { List < Pipeline > pipelines = new ArrayList < Pipeline > ( ) ; for ( PipelineDO pipelineDo : pipelineDos ) { pipelines . add ( doToModel ( pipelineDo ) ) ; } return pipelines ; }
private List < Pipeline > doToModelWithoutOther ( List < PipelineDO > pipelineDos ) { List < Pipeline > pipelines = new ArrayList < Pipeline > ( ) ; for ( PipelineDO pipelineDo : pipelineDos ) { pipelines . add ( doToModelWithoutOther ( pipelineDo ) ) ; } return pipelines ; }
private List < Pipeline > doToModelWithoutColumn ( List < PipelineDO > pipelineDos ) { List < Pipeline > pipelines = new ArrayList < Pipeline > ( ) ; for ( PipelineDO pipelineDo : pipelineDos ) { pipelines . add ( doToModelWithoutColumn ( pipelineDo ) ) ; } return pipelines ; }
private PipelineDO modelToDo ( Pipeline pipeline ) { PipelineDO pipelineDO = new PipelineDO ( ) ; try { pipelineDO . setId ( pipeline . getId ( ) ) ; pipelineDO . setName ( pipeline . getName ( ) ) ; pipelineDO . setParameters ( pipeline . getParameters ( ) ) ; pipelineDO . setDescription ( pipeline . getDescription ( ) ) ; pipelineDO . setChannelId ( pipeline . getChannelId ( ) ) ; pipelineDO . setGmtCreate ( pipeline . getGmtCreate ( ) ) ; pipelineDO . setGmtModified ( pipeline . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## change the pipeline Model to Do has an exception " ) ; throw new ManagerException ( e ) ; } return pipelineDO ; }
public void setPipelineDao ( PipelineDAO pipelineDao ) { this . pipelineDao = pipelineDao ; }
public void setPipelineNodeRelationDao ( PipelineNodeRelationDAO pipelineNodeRelationDao ) { this . pipelineNodeRelationDao = pipelineNodeRelationDao ; }
public void setDataMediaPairService ( DataMediaPairService dataMediaPairService ) { this . dataMediaPairService = dataMediaPairService ; }
public void create ( Event event ) ; public List < LogRecord > listByPipelineId ( Long pipelineId ) ; public List < LogRecord > listByPipelineIdWithoutContent ( Long pipelineId ) ; }
public List < LogRecord > listByPipelineId ( Long pipelineId ) ; public List < LogRecord > listByPipelineIdWithoutContent ( Long pipelineId ) ; }
public List < LogRecord > listByPipelineIdWithoutContent ( Long pipelineId ) ; }
public List < LogRecordDO > listByPipelineId ( Long pipelineId ) ; public List < LogRecordDO > listByPipelineIdWithoutContent ( Long pipelineId ) ; }
public List < LogRecordDO > listByPipelineIdWithoutContent ( Long pipelineId ) ; }
public void setNid ( Long nid ) { this . nid = nid ; }
public void setTitle ( String title ) { this . title = title ; }
public LogRecordDO insert ( LogRecordDO entityObj ) { Assert . assertNotNull ( entityObj ) ; getSqlMapClientTemplate ( ) . insert ( " insertLogRecord " , entityObj ) ; return entityObj ; }
public void delete ( Long identity ) { Assert . assertNotNull ( identity ) ; getSqlMapClientTemplate ( ) . delete ( " deleteLogRecordById " , identity ) ;
public void update ( LogRecordDO entityObj ) { Assert . assertNotNull ( entityObj ) ; getSqlMapClientTemplate ( ) . update ( " updateLogRecord " , entityObj ) ;
public List < LogRecordDO > listAll ( ) { List < LogRecordDO > logRecordDos = getSqlMapClientTemplate ( ) . queryForList ( " listLogRecords " ) ; return logRecordDos ; }
public List < LogRecordDO > listByCondition ( Map condition ) { List < LogRecordDO > logRecordDos = getSqlMapClientTemplate ( ) . queryForList ( " listLogRecordsWithCondition " , condition ) ; return logRecordDos ; }
public List < LogRecordDO > listByMultiId ( Long . . . identities ) { // TODO Auto-generated method stub return null; }
public LogRecordDO findById ( Long identity ) { Assert . assertNotNull ( identity ) ; return ( LogRecordDO ) getSqlMapClientTemplate ( ) . queryForObject ( " findLogRecordById " , identity ) ; }
public int getCount ( ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getLogRecordCount " ) ; return count . intValue ( ) ; }
public int getCount ( Map condition ) { Integer count = ( Integer ) getSqlMapClientTemplate ( ) . queryForObject ( " getLogRecordCountWithPIdAndSearchKey " , condition ) ; return count . intValue ( ) ; }
public boolean checkUnique ( LogRecordDO entityObj ) { // TODO Auto-generated method stub return false; }
public List < LogRecordDO > listByPipelineId ( Long pipelineId ) { List < LogRecordDO > logRecordDos = getSqlMapClientTemplate ( ) . queryForList ( " listLogRecordsByPipelineId " , pipelineId ) ; return logRecordDos ; }
public List < LogRecordDO > listByPipelineIdWithoutContent ( Long pipelineId ) { List < LogRecordDO > logRecordDos = getSqlMapClientTemplate ( ) . queryForList ( " listLogRecordsByPipelineIdWithoutContent " , pipelineId ) ; return logRecordDos ; }
public void create ( Event event ) { LogRecord logRecord = new LogRecord ( ) ; if ( event instanceof NodeAlarmEvent ) { NodeAlarmEvent nodeAlarmEvent = ( NodeAlarmEvent ) event ; Pipeline tempPipeline = new Pipeline ( ) ; tempPipeline . setId ( nodeAlarmEvent . getPipelineId ( ) ) ; logRecord . setPipeline ( tempPipeline ) ; logRecord . setNid ( nodeAlarmEvent . getNid ( ) ) ; logRecord . setTitle ( nodeAlarmEvent . getTitle ( ) ) ; logRecord . setMessage ( nodeAlarmEvent . getMessage ( ) ) ; } create ( logRecord ) ; }
public void create ( LogRecord entityObj ) { Assert . assertNotNull ( entityObj ) ; logRecordDao . insert ( modelToDo ( entityObj ) ) ; }
public void remove ( Long identity ) { Assert . assertNotNull ( identity ) ; logRecordDao . delete ( identity ) ;
public LogRecord findById ( Long identity ) { return null ; }
public List < LogRecord > listByPipelineId ( Long pipelineId ) { Assert . assertNotNull ( pipelineId ) ; List < LogRecordDO > logRecordDos = logRecordDao . listByPipelineId ( pipelineId ) ; return doToModel ( logRecordDos ) ; }
public List < LogRecord > listByPipelineIdWithoutContent ( Long pipelineId ) { Assert . assertNotNull ( pipelineId ) ; List < LogRecordDO > logRecordDos = logRecordDao . listByPipelineIdWithoutContent ( pipelineId ) ; return doToModel ( logRecordDos ) ; }
public List < LogRecord > listByIds ( Long . . . identities ) { return null ; }
public List < LogRecord > listAll ( ) { List < LogRecordDO > logRecordDos = logRecordDao . listAll ( ) ; return doToModel ( logRecordDos ) ; }
public List < LogRecord > listByCondition ( Map condition ) { List < LogRecordDO > logRecordDos = logRecordDao . listByCondition ( condition ) ; if ( logRecordDos . isEmpty ( ) ) { logger . debug ( " DEBUG ## couldn't query any log record by the condition: " + JsonUtils . marshalToString ( condition ) ) ; return new ArrayList < LogRecord > ( ) ; } return doToModel ( logRecordDos ) ; }
public int getCount ( Map condition ) { return logRecordDao . getCount ( condition ) ; }
private LogRecordDO modelToDo ( LogRecord entityObj ) { LogRecordDO logRecordDo = new LogRecordDO ( ) ; try { if ( entityObj . getPipeline ( ) ! = null & & entityObj . getPipeline ( ) . getId ( ) > 0 ) { Channel channel = channelService . findByPipelineId ( entityObj . getPipeline ( ) . getId ( ) ) ; logRecordDo . setChannelId ( channel . getId ( ) ) ; logRecordDo . setPipelineId ( entityObj . getPipeline ( ) . getId ( ) ) ; } else { logRecordDo . setChannelId ( - 1l ) ; logRecordDo . setPipelineId ( - 1l ) ; } logRecordDo . setNid ( entityObj . getNid ( ) ) ; logRecordDo . setTitle ( entityObj . getTitle ( ) ) ; String message = entityObj . getMessage ( ) ; if ( message ! = null & & message . length ( ) > 65535 ) { message = message . substring ( 0 , 65535 ) ; } logRecordDo . setMessage ( message ) ; logRecordDo . setGmtCreate ( entityObj . getGmtCreate ( ) ) ; logRecordDo . setGmtModified ( entityObj . getGmtModified ( ) ) ; } catch ( Exception e ) { logger . error ( " ERROR ## has an error where write log to db " ) ; throw new ManagerException ( e ) ; } return logRecordDo ; }
private List < LogRecord > doToModel ( List < LogRecordDO > logRecordDos ) { List < LogRecord > logRecords = new ArrayList < LogRecord > ( ) ; try { for ( LogRecordDO logRecordDo : logRecordDos ) { logRecords . add ( doToModel ( logRecordDo ) ) ; } } catch ( Exception e ) { logger . error ( " ERROR ## " ) ; throw new ManagerException ( e ) ; } return logRecords ; }
public ChannelService getChannelService ( ) { return channelService ; }
public LogRecordDAO getLogRecordDao ( ) { return logRecordDao ; }
public void setLogRecordDao ( LogRecordDAO logRecordDao ) { this . logRecordDao = logRecordDao ; }
public Object getResult ( ResultGetter getter ) throws SQLException { return JsonUtils . unmarshalFromString ( getter . getString ( ) , new TypeReference < List < Long > > ( ) { } ) ;
public Object valueOf ( String s ) { return JsonUtils . unmarshalFromString ( s , List . class ) ; }
public Object getResult ( ResultGetter getter ) throws SQLException { return JsonUtils . unmarshalFromString ( getter . getString ( ) , Map . class ) ; }
public Object valueOf ( String s ) { return JsonUtils . unmarshalFromString ( s , Map . class ) ; }
public AlarmMessage control ( AlarmRule rule , String message , AlarmMessage data ) ; }
public void recovery ( AlarmRule alarmRule , long alarmCount ) ; }
public void explore ( ) ; public void explore ( Long . . . pipelineIds ) ; public void explore ( List < AlarmRule > rules ) ; }
public void explore ( Long . . . pipelineIds ) ; public void explore ( List < AlarmRule > rules ) ; }
public static void register ( MonitorName monitorName , Monitor explorer ) { MonitorRuleExplorerRegisty . register ( monitorName , null , explorer ) ; }
synchronized public static void register ( MonitorName monitorName , String explorerName , Monitor explorer ) { if ( monitorName = = null | | explorer = = null ) { return ; } if ( ! AbstractRuleMonitor . class . isAssignableFrom ( explorer . getClass ( ) ) ) { throw new UnsupportedOperationException ( " only accept AbstractRuleMonitorExplorer or it's subclass to regist " ) ; } Map < String , Monitor > explorers = registy . get ( monitorName ) ; if ( explorers = = null ) { explorers = new ConcurrentHashMap < String , Monitor > ( 16 ) ; registy . put ( monitorName , explorers ) ; } if ( explorerName = = null ) { explorerName = explorer . getClass ( ) . getName ( ) ; } explorers . put ( explorerName , explorer ) ; }
public static Collection < Monitor > findExplorer ( MonitorName monitorName ) { if ( monitorName = = null ) { return Collections . EMPTY_LIST ; } Map < String , Monitor > explorers = registy . get ( monitorName ) ; if ( CollectionUtils . isEmpty ( explorers ) ) { return Collections . EMPTY_LIST ; } return explorers . values ( ) ; }
public static void unRegister ( MonitorName monitorName , Monitor explorer ) { if ( monitorName = = null | | explorer = = null ) { return ; } Map < String , Monitor > explorers = registy . get ( monitorName ) ; if ( CollectionUtils . isEmpty ( explorers ) ) { return ; } String explorerName = explorer . getClass ( ) . getName ( ) ; explorers . remove ( explorerName ) ; }
public static void unRegister ( MonitorName monitorName , String explorerName ) { if ( monitorName = = null | | explorerName = = null ) { return ; } Map < String , Monitor > explorers = registy . get ( monitorName ) ; if ( CollectionUtils . isEmpty ( explorers ) ) { return ; } explorers . remove ( explorerName ) ; }
public void feed ( Object data , Long pipelineId ) ; public void feed ( Object data , List < AlarmRule > rules ) ; }
public void feed ( Object data , List < AlarmRule > rules ) ; }
public void explore ( ) { throw new UnsupportedOperationException ( ) ; }
public void explore ( Long . . . pipelineIds ) { throw new UnsupportedOperationException ( ) ; }
public void feed ( Object data , Long pipelineId ) { throw new UnsupportedOperationException ( ) ; }
public void feed ( Object data , List < AlarmRule > rules ) { throw new UnsupportedOperationException ( ) ; }
protected void sendAlarm ( AlarmRule rule , String message ) { AlarmMessage data = new AlarmMessage ( ) ; data . setMessage ( message ) ; data . setReceiveKey ( rule . getReceiverKey ( ) ) ; data = alarmController . control ( rule , message , data ) ; postProcessAlarmData ( data ) ; if ( data = = null ) { log . info ( " has suppressed alarm : " + message ) ; return ; } alarmService . sendAlarm ( data ) ; log . info ( " has send alarm : " + data + " ; rule is " + rule ) ; }
protected void logRecordAlarm ( Long pipelineId , MonitorName monitorName , String message ) { logRecordAlarm ( pipelineId , - 1l , monitorName , message ) ; }
protected void logRecordAlarm ( Long pipelineId , Long nodeId , MonitorName monitorName , String message ) { Pipeline pipeline = new Pipeline ( ) ; pipeline . setId ( pipelineId ) ; LogRecord logRecord = new LogRecord ( ) ; logRecord . setTitle ( monitorName . toString ( ) ) ; logRecord . setNid ( nodeId ) ; logRecord . setPipeline ( pipeline ) ; logRecord . setMessage ( message ) ; logRecordService . create ( logRecord ) ; }
protected boolean checkInPeriod ( Calendar now , String start , String end ) { return isAfter ( now , start ) & & ! isAfter ( now , end ) ; }
protected boolean isAfter ( Calendar now , String time ) { String [ ] hourAndMin = StringUtils . split ( time , " : " ) ; if ( hourAndMin = = null | | hourAndMin . length ! = 2 ) { log . error ( " error period time format in rule : " + time ) ; return isInPeriodWhenErrorFormat ( ) ; } int hour ; int min ; try { hour = Integer . parseInt ( hourAndMin [ 0 ] ) ; min = Integer . parseInt ( hourAndMin [ 1 ] ) ; } catch ( NumberFormatException e ) { log . error ( " error period time format in rule : " + time , e ) ; return isInPeriodWhenErrorFormat ( ) ; } if ( hour > 24 | | min > 60 ) { log . error ( " error period time format in rule : " + time ) ; return isInPeriodWhenErrorFormat ( ) ; } Calendar when = ( Calendar ) now . clone ( ) ; when . set ( Calendar . HOUR_OF_DAY , hour ) ; when . set ( Calendar . MINUTE , min ) ; return ! now . before ( when ) ; }
protected boolean isInPeriodWhenErrorFormat ( ) { return true ; }
protected boolean isInPeriodWhenNoPeriod ( ) { return true ; }
protected Calendar currentCalendar ( ) { Calendar calendar = Calendar . getInstance ( ) ; return calendar ; }
public long getChannelId ( ) { return channelId ; }
public void setStop ( boolean stop ) { this . stop = stop ; }
public long getDelay ( TimeUnit unit ) { long currNow = System . currentTimeMillis ( ) - MILL_ORIGIN ; long d = unit . convert ( now + timeout - currNow , TimeUnit . MILLISECONDS ) ; return d ; }
public int compareTo ( Delayed other ) { if ( other = = this ) { // compare zero ONLY if same object return 0;
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( int ) ( channelId ^ ( channelId > > > 32 ) ) ; return result ; }
public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null ) { return false ; } if ( ! ( obj instanceof DeadNodeDelayed ) ) { return false ; } AlarmRecoveryDelayed other = ( AlarmRecoveryDelayed ) obj ; if ( channelId ! = other . channelId ) { return false ; } return true ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( matchValue = = null ) ? 0 : matchValue . hashCode ( ) ) ; result = prime * result + ( ( monitorName = = null ) ? 0 : monitorName . hashCode ( ) ) ; result = prime * result + ( ( pipelineId = = null ) ? 0 : pipelineId . hashCode ( ) ) ; result = prime * result + ( ( receiveKey = = null ) ? 0 : receiveKey . hashCode ( ) ) ; return result ; }
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PoolKey other = ( PoolKey ) obj ; if ( matchValue = = null ) { if ( other . matchValue ! = null ) return false ; } else if ( ! matchValue . equals ( other . matchValue ) ) return false ; if ( monitorName ! = other . monitorName ) return false ; if ( pipelineId = = null ) { if ( other . pipelineId ! = null ) return false ; } else if ( ! pipelineId . equals ( other . pipelineId ) ) return false ; if ( receiveKey = = null ) { if ( other . receiveKey ! = null ) return false ; } else if ( ! receiveKey . equals ( other . receiveKey ) ) return false ; return true ; }
public void addSuppressTimes ( ) { suppressTimes + + ; }
public long getSuppressTimes ( ) { return suppressTimes ; }
public Long getLastAlarmTime ( ) { return lastAlarmTime ; }
public void updateAlarmTime ( Long lastAlarmTime ) { this . lastAlarmTime = lastAlarmTime ; }
public void setRestartAlarmRecovery ( AlarmRecovery restartAlarmRecovery ) { this . restartAlarmRecovery = restartAlarmRecovery ; }
private boolean checkDelayTime ( AlarmRule rule , Long delayTime ) { if ( ! inPeriod ( rule ) ) { return false ; } String matchValue = rule . getMatchValue ( ) ; matchValue = StringUtils . substringBeforeLast ( matchValue , " @ " ) ; Long maxDelayTime = Long . parseLong ( StringUtils . trim ( matchValue ) ) ; if ( delayTime > = maxDelayTime * 1000 ) { sendAlarm ( rule , String . format ( DELAY_TIME_MESSAGE , rule . getPipelineId ( ) , delayTime ) ) ; return true ; } return false ; }
public void setDelayStatService ( DelayStatService delayStatService ) { this . delayStatService = delayStatService ; }
public void explore ( List < AlarmRule > rules ) { throw new UnsupportedOperationException ( ) ; }
private boolean checkEnable ( AlarmRule rule , Date now ) { return rule . getPauseTime ( ) = = null | | rule . getPauseTime ( ) . before ( now ) ; }
private void check ( AlarmRule rule , NodeAlarmEvent alarmEvent ) { if ( ! inPeriod ( rule ) ) { return ; } String matchValue = rule . getMatchValue ( ) ; matchValue = StringUtils . substringBeforeLast ( matchValue , " @ " ) ; String [ ] matchValues = StringUtils . split ( matchValue , " , " ) ; for ( String match : matchValues ) { if ( StringUtils . containsIgnoreCase ( alarmEvent . getMessage ( ) , match ) ) {
private void concurrentProcess ( Map < Long , List < AlarmRule > > rules ) { ExecutorCompletionService completionExecutor = new ExecutorCompletionService ( executor ) ; List < Future > futures = new ArrayList < Future > ( ) ; for ( Entry < Long , List < AlarmRule > > entry : rules . entrySet ( ) ) { final List < AlarmRule > alarmRules = entry . getValue ( ) ; futures . add ( completionExecutor . submit ( new Callable < Object > ( ) { @Override public Object call ( ) throws Exception { pipelineMonitor . explore ( alarmRules ) ; return null ; } } ) ) ; } List < Throwable > exceptions = new ArrayList < Throwable > ( ) ; int index = 0 ; int size = futures . size ( ) ; while ( index < size ) { try { Future < ? > future = completionExecutor . take ( ) ; future . get ( ) ; } catch ( InterruptedException e ) { exceptions . add ( e ) ; } catch ( ExecutionException e ) { exceptions . add ( e ) ; } index + + ; } if ( ! exceptions . isEmpty ( ) ) { StringBuilder sb = new StringBuilder ( exceptions . size ( ) + " exception happens in global monitor \ n " ) ;
public Object call ( ) throws Exception { pipelineMonitor . explore ( alarmRules ) ; return null ; }
private void serialProcess ( Map < Long , List < AlarmRule > > rules ) { for ( Entry < Long , List < AlarmRule > > entry : rules . entrySet ( ) ) { List < AlarmRule > alarmRules = entry . getValue ( ) ;
private void concurrentProcess ( List < Long > channelIds ) { ExecutorCompletionService completionExecutor = new ExecutorCompletionService ( executor ) ; List < Future > futures = new ArrayList < Future > ( ) ; for ( final Long channelId : channelIds ) { futures . add ( completionExecutor . submit ( new Callable < Object > ( ) { @Override public Object call ( ) throws Exception { ChannelStatus status = arbitrateManageService . channelEvent ( ) . status ( channelId ) ; if ( status . isPause ( ) ) { restartAlarmRecovery . recovery ( channelId ) ; } return null ; } } ) ) ; } List < Throwable > exceptions = new ArrayList < Throwable > ( ) ; int index = 0 ; int size = futures . size ( ) ; while ( index < size ) { try { Future < ? > future = completionExecutor . take ( ) ; future . get ( ) ; } catch ( InterruptedException e ) { exceptions . add ( e ) ; } catch ( ExecutionException e ) { exceptions . add ( e ) ; } index + + ; } if ( ! exceptions . isEmpty ( ) ) { StringBuilder sb = new StringBuilder ( exceptions . size ( ) + " exception happens in global monitor \ n " ) ;
public Object call ( ) throws Exception { ChannelStatus status = arbitrateManageService . channelEvent ( ) . status ( channelId ) ; if ( status . isPause ( ) ) { restartAlarmRecovery . recovery ( channelId ) ; } return null ; }
private void serialProcess ( List < Long > channelIds ) { for ( Long channelId : channelIds ) { ChannelStatus status = arbitrateManageService . channelEvent ( ) . status ( channelId ) ;
public void afterPropertiesSet ( ) throws Exception { nThreads = nThreads < = 0 ? DEFAULT_THREADS : nThreads ; executor = new ThreadPoolExecutor ( nThreads , nThreads , 0 , TimeUnit . MILLISECONDS , new LinkedBlockingQueue < Runnable > ( nThreads * 2 ) ,
public void destroy ( ) throws Exception { if ( executor ! = null & & ! executor . isShutdown ( ) ) { executor . shutdown ( ) ;
public void explore ( Long . . . pipelineIds ) { throw new UnsupportedOperationException ( " doesn't support right now " ) ; }
public void explore ( List < AlarmRule > rules ) { throw new UnsupportedOperationException ( " doesn't support right now " ) ; }
public void setnThreads ( int nThreads ) { this . nThreads = nThreads ; }
public void setNeedConcurrent ( boolean needConcurrent ) { this . needConcurrent = needConcurrent ; }
public void setAlarmRuleService ( AlarmRuleService alarmRuleService ) { this . alarmRuleService = alarmRuleService ; }
public void setPipelineMonitor ( Monitor pipelineMonitor ) { this . pipelineMonitor = pipelineMonitor ; }
public void setRecoveryPaused ( boolean recoveryPaused ) { this . recoveryPaused = recoveryPaused ; }
public void explore ( List < AlarmRule > rules ) { if ( CollectionUtils . isEmpty ( rules ) ) { return ; } Long pipelineId = rules . get ( 0 ) . getPipelineId ( ) ; ThroughputCondition condition = new ThroughputCondition ( ) ; condition . setPipelineId ( pipelineId ) ; condition . setType ( ThroughputType . ROW ) ; ThroughputStat stat = throughputStatService . findThroughputStatByPipelineId ( condition ) ; long latestSyncTime = 0 L ; if ( stat ! = null & & stat . getGmtModified ( ) ! = null ) { Date modifiedDate = stat . getGmtModified ( ) ; latestSyncTime = modifiedDate . getTime ( ) ; } long now = System . currentTimeMillis ( ) ; long elapsed = now - latestSyncTime ; boolean flag = false ; for ( AlarmRule rule : rules ) { flag | = checkTimeout ( rule , elapsed ) ; } if ( flag ) { logRecordAlarm ( pipelineId , MonitorName . PIPELINETIMEOUT ,
public void explore ( List < AlarmRule > rules ) { if ( CollectionUtils . isEmpty ( rules ) ) { return ; } Long pipelineId = rules . get ( 0 ) . getPipelineId ( ) ; Pipeline pipeline = pipelineService . findById ( pipelineId ) ; PositionEventData data = arbitrateViewService . getCanalCursor ( pipeline . getParameters ( ) . getDestinationName ( ) , pipeline . getParameters ( ) . getMainstemClientId ( ) ) ; long latestSyncTime = 0 L ; if ( data ! = null & & data . getModifiedTime ( ) ! = null ) { Date modifiedDate = data . getModifiedTime ( ) ; latestSyncTime = modifiedDate . getTime ( ) ; } else { return ; } long now = System . currentTimeMillis ( ) ; long elapsed = now - latestSyncTime ; boolean flag = false ; for ( AlarmRule rule : rules ) { flag | = checkTimeout ( rule , elapsed ) ; } if ( flag ) { logRecordAlarm ( pipelineId , MonitorName . POSITIONTIMEOUT ,
public Activity getContext ( ) { return contextReference . get ( ) ; }
protected String getPreferencesBaseKey ( ) { return getClass ( ) . getPackage ( ) . getName ( ) ; }
private SharedPreferences getPreferences ( ) { if ( contextReference . get ( ) ! = null ) return contextReference . get ( ) . getPreferences ( Activity . MODE_PRIVATE ) ; return null ; }
public void release ( ) { if ( contextReference ! = null ) contextReference . clear ( ) ;
protected boolean saveString ( String key , String value ) { SharedPreferences sp = getPreferences ( ) ; if ( sp ! = null ) { SharedPreferences . Editor spe = sp . edit ( ) ; spe . putString ( key , value ) ; spe . commit ( ) ; return true ; } return false ; }
protected String loadString ( String key , String defValue ) { SharedPreferences sp = getPreferences ( ) ; if ( sp ! = null ) return sp . getString ( key , defValue ) ; return defValue ; }
protected boolean saveBoolean ( String key , Boolean value ) { SharedPreferences sp = getPreferences ( ) ; if ( sp ! = null ) { SharedPreferences . Editor spe = sp . edit ( ) ; spe . putBoolean ( key , value ) ; spe . commit ( ) ; return true ; } return false ; }
protected boolean loadBoolean ( String key , boolean defValue ) { SharedPreferences sp = getPreferences ( ) ; if ( sp ! = null ) return sp . getBoolean ( key , defValue ) ; return defValue ; }
private String getPreferencesCacheKey ( ) { return getPreferencesBaseKey ( ) + CACHE_KEY ; }
private void load ( ) { for ( String cachedProductId : loadString ( getPreferencesCacheKey ( ) , " " ) . split ( Pattern . quote ( CACHE_DELIMITER ) ) ) if ( cachedProductId ! = null & & cachedProductId . length ( ) > 0 )
private void flush ( ) { saveString ( getPreferencesCacheKey ( ) , TextUtils . join ( CACHE_DELIMITER , products ) ) ; }
public boolean includes ( String productId ) { return products ! = null & & products . indexOf ( productId ) > - 1 ; }
public void put ( String productId ) { if ( products . indexOf ( productId ) < 0 ) {
public void putAll ( Collection < ? extends String > productIds ) { products . addAll ( productIds ) ; flush ( ) ; }
public String toString ( ) { return TextUtils . join ( " , " , products ) ; }
public void onServiceDisconnected ( ComponentName name ) { billingService = null ; }
public void onServiceConnected ( ComponentName name , IBinder service ) { billingService = IInAppBillingService . Stub . asInterface ( service ) ; if ( ! isPurchaseHistoryRestored ( ) & & loadOwnedProductsFromGoogle ( ) ) { setPurchaseHistoryRestored ( ) ; onPurchaseHistoryRestored ( ) ; } onBillingInitialized ( ) ; }
public void release ( ) { if ( serviceConnection ! = null & & getContext ( ) ! = null ) getContext ( ) . unbindService ( serviceConnection ) ; cachedProducts . release ( ) ; super . release ( ) ; }
public void setBillingHandler ( IBillingHandler handler ) { eventHandler = handler ; }
public boolean loadOwnedProductsFromGoogle ( ) { if ( billingService ! = null ) { try { Bundle bundle = billingService . getPurchases ( 3 , contextPackageName , " inapp " , null ) ; int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { ArrayList < String > responseList = bundle . getStringArrayList ( Constants . INAPP_PURCHASE_ITEM_LIST ) ; cachedProducts . clear ( ) ; cachedProducts . putAll ( responseList ) ; } return true ; } catch ( RemoteException e ) { onBillingError ( Constants . BILLING_ERROR_FAILED_LOAD_PURCHASED_PRODUCTS , e ) ; Log . e ( LOG_TAG , e . toString ( ) ) ; } } return false ; }
public boolean isPurchased ( String productId ) { return cachedProducts . includes ( productId ) ; }
public boolean purchase ( String productId ) { if ( billingService ! = null ) { try { purchasePayload = UUID . randomUUID ( ) . toString ( ) ; Bundle bundle = billingService . getBuyIntent ( 3 , contextPackageName , productId , " inapp " , purchasePayload ) ; if ( bundle ! = null ) { int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { PendingIntent pendingIntent = bundle . getParcelable ( Constants . BUY_INTENT ) ; if ( getContext ( ) ! = null ) getContext ( ) . startIntentSenderForResult ( pendingIntent . getIntentSender ( ) , PURCHASE_FLOW_REQUEST_CODE , new Intent ( ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) ) ; else onBillingError ( Constants . BILLING_ERROR_LOST_CONTEXT , null ) ; } else if ( response = = Constants . BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED ) { cachedProducts . put ( productId ) ; onProductPurchased ( productId ) ; } else onBillingError ( Constants . BILLING_ERROR_FAILED_TO_INITIALIZE_PURCHASE , null ) ; } return true ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } } return false ; }
public boolean handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode = = PURCHASE_FLOW_REQUEST_CODE ) { int responseCode = data . getIntExtra ( Constants . RESPONSE_CODE , Constants . BILLING_RESPONSE_RESULT_OK ) ; if ( resultCode = = Activity . RESULT_OK & & responseCode = = Constants . BILLING_RESPONSE_RESULT_OK ) { String purchaseData = data . getStringExtra ( Constants . INAPP_PURCHASE_DATA ) ; try { JSONObject jo = new JSONObject ( purchaseData ) ; String productId = jo . getString ( " productId " ) ; String developerPayload = jo . getString ( " developerPayload " ) ; if ( purchasePayload . equals ( developerPayload ) ) { cachedProducts . put ( productId ) ; onProductPurchased ( productId ) ; } else { Log . e ( LOG_TAG , String . format ( " Payload mismatch: %s != %s " , purchasePayload , developerPayload ) ) ; onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } } else onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; return true ; } return false ; }
private boolean isPurchaseHistoryRestored ( ) { return loadBoolean ( getPreferencesBaseKey ( ) + RESTORE_KEY , false ) ; }
public void setPurchaseHistoryRestored ( ) { saveBoolean ( getPreferencesBaseKey ( ) + RESTORE_KEY , true ) ; }
public void onProductPurchased ( String productId ) { if ( eventHandler ! = null ) eventHandler . onProductPurchased ( productId ) ;
public void onPurchaseHistoryRestored ( ) { if ( eventHandler ! = null ) eventHandler . onPurchaseHistoryRestored ( ) ;
public void onBillingError ( int errorCode , Throwable error ) { if ( eventHandler ! = null ) eventHandler . onBillingError ( errorCode , error ) ;
public void onBillingInitialized ( ) { if ( eventHandler ! = null ) eventHandler . onBillingInitialized ( ) ;
void onProductPurchased ( String productId ) ; void onPurchaseHistoryRestored ( ) ; void onBillingError ( int errorCode , Throwable error ) ; void onBillingInitialized ( ) ; }
void onPurchaseHistoryRestored ( ) ; void onBillingError ( int errorCode , Throwable error ) ; void onBillingInitialized ( ) ; }
void onBillingError ( int errorCode , Throwable error ) ; void onBillingInitialized ( ) ; }
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; bp = new BillingProcessor ( this ) ; bp . setBillingHandler ( this ) ; }
public void onDestroy ( ) { if ( bp ! = null ) bp . release ( ) ; super . onDestroy ( ) ; }
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( ! bp . handleActivityResult ( requestCode , resultCode , data ) ) super . onActivityResult ( requestCode , resultCode , data ) ;
public void onPurchaseHistoryRestored ( ) { Log . d ( LOG_TAG , " onPurchaseHistoryRestored " ) ; }
public void onProductPurchased ( String productId ) { Log . d ( LOG_TAG , " onProductPurchased: " + productId ) ; }
public void onBillingError ( int errorCode , Throwable error ) { Log . d ( LOG_TAG , " onBillingError: " + Integer . toString ( errorCode ) ) ; }
public void onBillingInitialized ( ) { bp . purchase ( " com.anjlab.test.iab.p6 " ) ; }
public void release ( ) { if ( serviceConnection ! = null & & getContext ( ) ! = null ) { try { getContext ( ) . unbindService ( serviceConnection ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } billingService = null ; } cachedProducts . release ( ) ; super . release ( ) ; }
public boolean handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode = = PURCHASE_FLOW_REQUEST_CODE ) { int responseCode = data . getIntExtra ( Constants . RESPONSE_CODE , Constants . BILLING_RESPONSE_RESULT_OK ) ; if ( resultCode = = Activity . RESULT_OK & & responseCode = = Constants . BILLING_RESPONSE_RESULT_OK ) { String purchaseData = data . getStringExtra ( Constants . INAPP_PURCHASE_DATA ) ; try { JSONObject jo = new JSONObject ( purchaseData ) ; String productId = jo . getString ( " productId " ) ; String developerPayload = jo . getString ( " developerPayload " ) ; if ( purchasePayload . equals ( developerPayload ) ) { cachedProducts . put ( productId ) ; onProductPurchased ( productId ) ; } else { Log . e ( LOG_TAG , String . format ( " Payload mismatch: %s != %s " , purchasePayload , developerPayload ) ) ; onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } } else onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; return true ; } return false ; }
private void bindPlayServices ( ) { try { getContext ( ) . bindService ( new Intent ( " com.android.vending.billing.InAppBillingService.BIND " ) , serviceConnection , Context . BIND_AUTO_CREATE ) ;
public boolean isInitialized ( ) { return billingService ! = null ; }
public boolean loadOwnedProductsFromGoogle ( ) { if ( billingService ! = null ) { try { Bundle bundle = billingService . getPurchases ( 3 , contextPackageName , " inapp " , null ) ; int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; boolean cachedProductsCleared = false ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { ArrayList < String > responseList = bundle . getStringArrayList ( Constants . INAPP_PURCHASE_ITEM_LIST ) ; cachedProducts . clear ( ) ; cachedProducts . putAll ( responseList ) ; cachedProductsCleared = true ; } // attempt to load subscriptions bundle = billingService.getPurchases(3, contextPackageName, "subs", null); response = bundle.getInt(Constants.RESPONSE_CODE); if (response == Constants.BILLING_RESPONSE_RESULT_OK) { ArrayList<String> responseList = bundle.getStringArrayList(Constants.INAPP_PURCHASE_ITEM_LIST); if(!cachedProductsCleared) cachedProducts.clear(); cachedProducts.putAll(responseList); } return true; } catch (RemoteException e) { onBillingError(Constants.BILLING_ERROR_FAILED_LOAD_PURCHASED_PRODUCTS, e); Log.e(LOG_TAG, e.toString()); } } return false; }
public boolean purchase ( String productId ) { return purchase ( productId , BillingPurchaseType . OneTime ) ; }
public boolean purchase ( String productId , BillingPurchaseType purchaseType ) { if ( billingService ! = null ) { try { purchasePayload = UUID . randomUUID ( ) . toString ( ) ; String type = toPurchaseTypeString ( purchaseType ) ; Bundle bundle = billingService . getBuyIntent ( 3 , contextPackageName , productId , type , purchasePayload ) ; if ( bundle ! = null ) { int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { PendingIntent pendingIntent = bundle . getParcelable ( Constants . BUY_INTENT ) ; if ( getContext ( ) ! = null ) getContext ( ) . startIntentSenderForResult ( pendingIntent . getIntentSender ( ) , PURCHASE_FLOW_REQUEST_CODE , new Intent ( ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) ) ; else onBillingError ( Constants . BILLING_ERROR_LOST_CONTEXT , null ) ; } else if ( response = = Constants . BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED ) { cachedProducts . put ( productId ) ; onProductPurchased ( productId ) ; } else onBillingError ( Constants . BILLING_ERROR_FAILED_TO_INITIALIZE_PURCHASE , null ) ; } return true ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } } return false ; }
private String toPurchaseTypeString ( BillingPurchaseType purchaseType ) { String type = " inapp " ; if ( purchaseType = = BillingPurchaseType . Subscription ) type = " subs " ; return type ; }
private String getPreferencesCacheKey ( ) { return getPreferencesBaseKey ( ) + cacheKey ; }
public List < String > getContents ( ) { return new ArrayList < String > ( products ) ; }
public void onServiceConnected ( ComponentName name , IBinder service ) { billingService = IInAppBillingService . Stub . asInterface ( service ) ; if ( ! isPurchaseHistoryRestored ( ) & & loadOwnedPurchasesFromGoogle ( ) ) { setPurchaseHistoryRestored ( ) ; onPurchaseHistoryRestored ( ) ; } onBillingInitialized ( ) ; }
public void verifyPurchasesWithKeySignature ( String signature ) { signatureBase64 = signature ; }
public boolean isPurchased ( String productId ) { return cachedProducts . includes ( productId ) ; }
public boolean isSubscribed ( String productId ) { return cachedSubscriptions . includes ( productId ) ; }
public List < String > listOwnedProducts ( ) { return cachedProducts . getContents ( ) ; }
public List < String > listOwnedSubscriptions ( ) { return cachedSubscriptions . getContents ( ) ; }
private boolean loadPurchasesByType ( String type , BillingCache cacheStorage ) { try { Bundle bundle = billingService . getPurchases ( Constants . GOOGLE_API_VERSION , contextPackageName , type , null ) ;
public boolean loadOwnedPurchasesFromGoogle ( ) { return billingService ! = null & & loadPurchasesByType ( Constants . PRODUCT_TYPE_MANAGED , cachedProducts ) & &
public boolean purchase ( String productId ) { return purchase ( productId , Constants . PRODUCT_TYPE_MANAGED , cachedProducts ) ; }
public boolean subscribe ( String productId ) { return purchase ( productId , Constants . PRODUCT_TYPE_SUBSCRIPTION , cachedSubscriptions ) ; }
private boolean purchase ( String productId , String purchaseType , BillingCache cacheStorage ) { if ( billingService ! = null ) { try { purchasePayload = UUID . randomUUID ( ) . toString ( ) ; Bundle bundle = billingService . getBuyIntent ( Constants . GOOGLE_API_VERSION , contextPackageName , productId , purchaseType , purchasePayload ) ; if ( bundle ! = null ) { int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { PendingIntent pendingIntent = bundle . getParcelable ( Constants . BUY_INTENT ) ; if ( getContext ( ) ! = null ) getContext ( ) . startIntentSenderForResult ( pendingIntent . getIntentSender ( ) , PURCHASE_FLOW_REQUEST_CODE , new Intent ( ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) ) ; else onBillingError ( Constants . BILLING_ERROR_LOST_CONTEXT , null ) ; } else if ( response = = Constants . BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED ) { cacheStorage . put ( productId ) ; onProductPurchased ( productId ) ; } else onBillingError ( Constants . BILLING_ERROR_FAILED_TO_INITIALIZE_PURCHASE , null ) ; } return true ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } } return false ; }
public boolean handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode = = PURCHASE_FLOW_REQUEST_CODE ) { int responseCode = data . getIntExtra ( Constants . RESPONSE_CODE , Constants . BILLING_RESPONSE_RESULT_OK ) ; if ( resultCode = = Activity . RESULT_OK & & responseCode = = Constants . BILLING_RESPONSE_RESULT_OK ) { String purchaseData = data . getStringExtra ( Constants . INAPP_PURCHASE_DATA ) ; String dataSignature = data . getStringExtra ( Constants . RESPONSE_INAPP_SIGNATURE ) ; try { JSONObject jo = new JSONObject ( purchaseData ) ; String productId = jo . getString ( " productId " ) ; String developerPayload = jo . getString ( " developerPayload " ) ; if ( purchasePayload . equals ( developerPayload ) ) { if ( verifyPurchaseSignature ( purchaseData , dataSignature ) ) { cachedProducts . put ( productId ) ; onProductPurchased ( productId ) ; } else { Log . e ( LOG_TAG , " Public key signature doesn't match! " ) ; onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } else { Log . e ( LOG_TAG , String . format ( " Payload mismatch: %s != %s " , purchasePayload , developerPayload ) ) ; onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } } else onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; return true ; } return false ; }
private boolean verifyPurchaseSignature ( String purchaseData , String dataSignature ) { if ( ! TextUtils . isEmpty ( signatureBase64 ) ) { try { return Security . verifyPurchase ( signatureBase64 , purchaseData , dataSignature ) ; } catch ( Exception e ) { return false ; } } return true ; }
public static boolean verifyPurchase ( String base64PublicKey , String signedData , String signature ) { if ( TextUtils . isEmpty ( signedData ) | | TextUtils . isEmpty ( base64PublicKey ) | | TextUtils . isEmpty ( signature ) ) { Log . e ( TAG , " Purchase verification failed: missing data. " ) ; return false ; } PublicKey key = Security . generatePublicKey ( base64PublicKey ) ; return Security . verify ( key , signedData , signature ) ; }
public static PublicKey generatePublicKey ( String encodedPublicKey ) { try { byte [ ] decodedKey = Base64 . decode ( encodedPublicKey , Base64 . DEFAULT ) ;
public static boolean verify ( PublicKey publicKey , String signedData , String signature ) { Signature sig ; try { sig = Signature . getInstance ( SIGNATURE_ALGORITHM ) ; sig . initVerify ( publicKey ) ; sig . update ( signedData . getBytes ( ) ) ; if ( ! sig . verify ( Base64 . decode ( signature , Base64 . DEFAULT ) ) ) { Log . e ( TAG , " Signature verification failed. " ) ; return false ; } return true ; } catch ( NoSuchAlgorithmException e ) { Log . e ( TAG , " NoSuchAlgorithmException. " ) ; } catch ( InvalidKeyException e ) { Log . e ( TAG , " Invalid key specification. " ) ; } catch ( SignatureException e ) { Log . e ( TAG , " Signature exception. " ) ; } catch ( IllegalArgumentException e ) { Log . e ( TAG , " Base64 decoding failed. " ) ; } return false ; }
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; bp = new BillingProcessor ( this ) ; bp . verifyPurchasesWithKeySignature ( PUBLIC_KEY ) ; bp . setBillingHandler ( this ) ; }
public void onPurchaseHistoryRestored ( ) { Log . d ( LOG_TAG , " onPurchaseHistoryRestored " ) ; for ( String sku : bp . listOwnedProducts ( ) ) Log . d ( LOG_TAG , " Owned Managed Product: " + sku ) ; for ( String sku : bp . listOwnedSubscriptions ( ) ) Log . d ( LOG_TAG , " Owned Subscription: " + sku ) ;
public void onBillingInitialized ( ) { bp . purchase ( " com.anjlab.test.iab.s2.p5 " ) ; }
public void verifyPurchasesWithLicenseKey ( String signature ) { signatureBase64 = signature ; }
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; bp = new BillingProcessor ( this ) ; bp . verifyPurchasesWithLicenseKey ( PUBLIC_KEY ) ; bp . setBillingHandler ( this ) ; }
private void load ( ) { for ( String entry : loadString ( getPreferencesCacheKey ( ) , " " ) . split ( Pattern . quote ( ENTRY_DELIMITER ) ) ) if ( ! TextUtils . isEmpty ( entry ) ) {
private void flush ( ) { ArrayList < String > output = new ArrayList < String > ( ) ; for ( String productId : data . keySet ( ) ) output . add ( productId + LINE_DELIMITER + data . get ( productId ) ) ; saveString ( getPreferencesCacheKey ( ) , TextUtils . join ( ENTRY_DELIMITER , output ) ) ; }
public boolean includesProduct ( String productId ) { return data ! = null & & data . containsKey ( productId ) ; }
public String getProductPurchaseToken ( String productId ) { return data . containsKey ( productId ) ? data . get ( productId ) : null ; }
public void put ( String productId , String purchaseToken ) { if ( ! data . containsKey ( productId ) ) {
public void remove ( String productId ) { if ( data . containsKey ( productId ) ) {
public List < String > getContents ( ) { return new ArrayList < String > ( data . keySet ( ) ) ; }
public String toString ( ) { return TextUtils . join ( " , " , data . keySet ( ) ) ; }
public void onServiceConnected ( ComponentName name , IBinder service ) { billingService = IInAppBillingService . Stub . asInterface ( service ) ; if ( ! isPurchaseHistoryRestored ( ) & & loadOwnedPurchasesFromGoogle ( ) ) { setPurchaseHistoryRestored ( ) ; onPurchaseHistoryRestored ( ) ; } onBillingInitialized ( ) ; }
public boolean isPurchased ( String productId ) { return cachedProducts . includesProduct ( productId ) ; }
public boolean isSubscribed ( String productId ) { return cachedSubscriptions . includesProduct ( productId ) ; }
private boolean loadPurchasesByType ( String type , BillingCache cacheStorage ) { if ( isInitialized ( ) ) try { Bundle bundle = billingService . getPurchases ( Constants . GOOGLE_API_VERSION , contextPackageName , type , null ) ; if ( bundle . getInt ( Constants . RESPONSE_CODE ) = = Constants . BILLING_RESPONSE_RESULT_OK ) { cacheStorage . clear ( ) ; for ( String purchaseData : bundle . getStringArrayList ( Constants . INAPP_PURCHASE_DATA_LIST ) ) { JSONObject purchase = new JSONObject ( purchaseData ) ; cacheStorage . put ( purchase . getString ( " productId " ) , purchase . getString ( " purchaseToken " ) ) ; } } return true ; } catch ( Exception e ) { onBillingError ( Constants . BILLING_ERROR_FAILED_LOAD_PURCHASES , e ) ; Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
public boolean loadOwnedPurchasesFromGoogle ( ) { return isInitialized ( ) & & loadPurchasesByType ( Constants . PRODUCT_TYPE_MANAGED , cachedProducts ) & &
private boolean purchase ( String productId , String purchaseType , BillingCache cacheStorage ) { if ( isInitialized ( ) ) { try { purchasePayload = UUID . randomUUID ( ) . toString ( ) ; Bundle bundle = billingService . getBuyIntent ( Constants . GOOGLE_API_VERSION , contextPackageName , productId , purchaseType , purchasePayload ) ; if ( bundle ! = null ) { int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { PendingIntent pendingIntent = bundle . getParcelable ( Constants . BUY_INTENT ) ; if ( getContext ( ) ! = null ) getContext ( ) . startIntentSenderForResult ( pendingIntent . getIntentSender ( ) , PURCHASE_FLOW_REQUEST_CODE , new Intent ( ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) ) ; else onBillingError ( Constants . BILLING_ERROR_LOST_CONTEXT , null ) ; } else if ( response = = Constants . BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED ) { if ( ! isPurchased ( productId ) & & ! isSubscribed ( productId ) ) loadOwnedPurchasesFromGoogle ( ) ; onProductPurchased ( productId ) ; } else onBillingError ( Constants . BILLING_ERROR_FAILED_TO_INITIALIZE_PURCHASE , null ) ; } return true ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } } return false ; }
public boolean consumePurchase ( String productId ) { if ( isInitialized ( ) ) { try { String purchaseToken = cachedProducts . getProductPurchaseToken ( productId ) ; if ( ! TextUtils . isEmpty ( purchaseToken ) ) { int response = billingService . consumePurchase ( Constants . GOOGLE_API_VERSION , contextPackageName , purchaseToken ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { cachedProducts . remove ( productId ) ; Log . d ( LOG_TAG , " Successfully consumed " + productId + " purchase. " ) ; return true ; } else { onBillingError ( response , null ) ; Log . e ( LOG_TAG , String . format ( " Failed to consume %s: error %d " , productId , response ) ) ; } } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } } return false ; }
public boolean handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode = = PURCHASE_FLOW_REQUEST_CODE ) { int responseCode = data . getIntExtra ( Constants . RESPONSE_CODE , Constants . BILLING_RESPONSE_RESULT_OK ) ; if ( resultCode = = Activity . RESULT_OK & & responseCode = = Constants . BILLING_RESPONSE_RESULT_OK ) { String purchaseData = data . getStringExtra ( Constants . INAPP_PURCHASE_DATA ) ; String dataSignature = data . getStringExtra ( Constants . RESPONSE_INAPP_SIGNATURE ) ; try { JSONObject purchase = new JSONObject ( purchaseData ) ; String productId = purchase . getString ( " productId " ) ; String purchaseToken = purchase . getString ( " purchaseToken " ) ; String developerPayload = purchase . getString ( " developerPayload " ) ; if ( purchasePayload . equals ( developerPayload ) ) { if ( verifyPurchaseSignature ( purchaseData , dataSignature ) ) { cachedProducts . put ( productId , purchaseToken ) ; onProductPurchased ( productId ) ; } else { Log . e ( LOG_TAG , " Public key signature doesn't match! " ) ; onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } else { Log . e ( LOG_TAG , String . format ( " Payload mismatch: %s != %s " , purchasePayload , developerPayload ) ) ; onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } } else onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; return true ; } return false ; }
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; findViewById ( R . id . consumeButton ) . setOnClickListener ( this ) ; findViewById ( R . id . purchaseButton ) . setOnClickListener ( this ) ; bp = new BillingProcessor ( this ) ; // bp.verifyPurchasesWithLicenseKey("YOUR MERCHANT KEY HERE"); bp.setBillingHandler(this); }
public void onPurchaseHistoryRestored ( ) { showToast ( " onPurchaseHistoryRestored " ) ; for ( String sku : bp . listOwnedProducts ( ) ) Log . d ( LOG_TAG , " Owned Managed Product: " + sku ) ; for ( String sku : bp . listOwnedSubscriptions ( ) ) Log . d ( LOG_TAG , " Owned Subscription: " + sku ) ;
public void onProductPurchased ( String productId ) { showToast ( " onProductPurchased: " + productId ) ; updateTextView ( ) ; }
public void onBillingError ( int errorCode , Throwable error ) { showToast ( " onBillingError: " + Integer . toString ( errorCode ) ) ; }
public void onBillingInitialized ( ) { readyToPurchase = true ; updateTextView ( ) ; }
private void updateTextView ( ) { TextView text = ( TextView ) findViewById ( R . id . textView ) ; text . setText ( String . format ( " %s is%s purchased " , PRODUCT_ID , bp . isPurchased ( PRODUCT_ID ) ? " " : " not " ) ) ; }
private void showToast ( String message ) { Toast . makeText ( this , message , Toast . LENGTH_SHORT ) . show ( ) ; }
public void onClick ( View v ) { if ( readyToPurchase ) switch ( v . getId ( ) ) {
public boolean purchase ( String productId ) { return purchase ( productId , Constants . PRODUCT_TYPE_MANAGED ) ; }
public boolean subscribe ( String productId ) { return purchase ( productId , Constants . PRODUCT_TYPE_SUBSCRIPTION ) ; }
private boolean purchase ( String productId , String purchaseType ) { if ( isInitialized ( ) ) { try { purchasePayload = String . format ( " %s:%s " , purchaseType , UUID . randomUUID ( ) ) ; Bundle bundle = billingService . getBuyIntent ( Constants . GOOGLE_API_VERSION , contextPackageName , productId , purchaseType , purchasePayload ) ; if ( bundle ! = null ) { int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { PendingIntent pendingIntent = bundle . getParcelable ( Constants . BUY_INTENT ) ; if ( getContext ( ) ! = null ) getContext ( ) . startIntentSenderForResult ( pendingIntent . getIntentSender ( ) , PURCHASE_FLOW_REQUEST_CODE , new Intent ( ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) ) ; else onBillingError ( Constants . BILLING_ERROR_LOST_CONTEXT , null ) ; } else if ( response = = Constants . BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED ) { if ( ! isPurchased ( productId ) & & ! isSubscribed ( productId ) ) loadOwnedPurchasesFromGoogle ( ) ; onProductPurchased ( productId ) ; } else onBillingError ( Constants . BILLING_ERROR_FAILED_TO_INITIALIZE_PURCHASE , null ) ; } return true ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } } return false ; }
public boolean handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode = = PURCHASE_FLOW_REQUEST_CODE ) { int responseCode = data . getIntExtra ( Constants . RESPONSE_CODE , Constants . BILLING_RESPONSE_RESULT_OK ) ; if ( resultCode = = Activity . RESULT_OK & & responseCode = = Constants . BILLING_RESPONSE_RESULT_OK ) { String purchaseData = data . getStringExtra ( Constants . INAPP_PURCHASE_DATA ) ; String dataSignature = data . getStringExtra ( Constants . RESPONSE_INAPP_SIGNATURE ) ; try { JSONObject purchase = new JSONObject ( purchaseData ) ; String productId = purchase . getString ( " productId " ) ; String purchaseToken = purchase . getString ( " purchaseToken " ) ; String developerPayload = purchase . getString ( " developerPayload " ) ; if ( purchasePayload . equals ( developerPayload ) ) { if ( verifyPurchaseSignature ( purchaseData , dataSignature ) ) { BillingCache cache = developerPayload . startsWith ( Constants . PRODUCT_TYPE_SUBSCRIPTION ) ? cachedSubscriptions : cachedProducts ; cache . put ( productId , purchaseToken ) ; onProductPurchased ( productId ) ; } else { Log . e ( LOG_TAG , " Public key signature doesn't match! " ) ; onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } else { Log . e ( LOG_TAG , String . format ( " Payload mismatch: %s != %s " , purchasePayload , developerPayload ) ) ; onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } } else onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; return true ; } return false ; }
public boolean loadOwnedPurchasesFromGoogle ( ) { return isInitialized ( ) & & restorePurchases ( ) & & restoreSubscriptions ( ) ; }
public boolean restorePurchases ( ) { return isInitialized ( ) & & loadPurchasesByType ( Constants . PRODUCT_TYPE_MANAGED , cachedProducts ) ; }
public boolean restoreSubscriptions ( ) { return isInitialized ( ) & & loadPurchasesByType ( Constants . PRODUCT_TYPE_SUBSCRIPTION , cachedSubscriptions ) ; }
private void setPurchaseHistoryRestored ( ) { saveBoolean ( getPreferencesBaseKey ( ) + RESTORE_KEY , true ) ; }
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; findViewById ( R . id . consumeButton ) . setOnClickListener ( this ) ; findViewById ( R . id . purchaseButton ) . setOnClickListener ( this ) ; findViewById ( R . id . subscribeButton ) . setOnClickListener ( this ) ; findViewById ( R . id . updateSubscriptionsButton ) . setOnClickListener ( this ) ; bp = new BillingProcessor ( this ) ; // bp.verifyPurchasesWithLicenseKey("YOUR MERCHANT KEY HERE"); bp.setBillingHandler(this); }
public void onDestroy ( ) { if ( bp ! = null ) bp . release ( ) ; super . onDestroy ( ) ; }
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( ! bp . handleActivityResult ( requestCode , resultCode , data ) ) super . onActivityResult ( requestCode , resultCode , data ) ;
public void onPurchaseHistoryRestored ( ) { showToast ( " onPurchaseHistoryRestored " ) ; for ( String sku : bp . listOwnedProducts ( ) ) Log . d ( LOG_TAG , " Owned Managed Product: " + sku ) ; for ( String sku : bp . listOwnedSubscriptions ( ) ) Log . d ( LOG_TAG , " Owned Subscription: " + sku ) ; updateTextViews ( ) ; }
public void onProductPurchased ( String productId ) { showToast ( " onProductPurchased: " + productId ) ; updateTextViews ( ) ; }
public void onBillingError ( int errorCode , Throwable error ) { showToast ( " onBillingError: " + Integer . toString ( errorCode ) ) ; }
public void onBillingInitialized ( ) { readyToPurchase = true ; updateTextViews ( ) ; }
private void updateTextViews ( ) { TextView text = ( TextView ) findViewById ( R . id . productIdTextView ) ; text . setText ( String . format ( " %s is%s purchased " , PRODUCT_ID , bp . isPurchased ( PRODUCT_ID ) ? " " : " not " ) ) ; text = ( TextView ) findViewById ( R . id . subscriptionIdTextView ) ; text . setText ( String . format ( " %s is%s subscribed " , SUBSCRIPTION_ID , bp . isSubscribed ( SUBSCRIPTION_ID ) ? " " : " not " ) ) ; }
private void showToast ( String message ) { Toast . makeText ( this , message , Toast . LENGTH_SHORT ) . show ( ) ; }
private void load ( ) { for ( String entry : loadString ( getPreferencesCacheKey ( ) , " " ) . split ( Pattern . quote ( ENTRY_DELIMITER ) ) ) { if ( ! TextUtils . isEmpty ( entry ) ) {
public void put ( String productId , String purchaseToken ) { if ( ! data . containsKey ( productId ) ) { data . put ( productId , purchaseToken ) ;
public void remove ( String productId ) { if ( data . containsKey ( productId ) ) { data . remove ( productId ) ;
public void onServiceConnected ( ComponentName name , IBinder service ) { billingService = IInAppBillingService . Stub . asInterface ( service ) ; if ( ! isPurchaseHistoryRestored ( ) & & loadOwnedPurchasesFromGoogle ( ) ) { setPurchaseHistoryRestored ( ) ; if ( eventHandler ! = null ) eventHandler . onPurchaseHistoryRestored ( ) ; } if ( eventHandler ! = null ) eventHandler . onBillingInitialized ( ) ;
private boolean loadPurchasesByType ( String type , BillingCache cacheStorage ) { if ( ! isInitialized ( ) ) return false ; try { Bundle bundle = billingService . getPurchases ( Constants . GOOGLE_API_VERSION , contextPackageName , type , null ) ; if ( bundle . getInt ( Constants . RESPONSE_CODE ) = = Constants . BILLING_RESPONSE_RESULT_OK ) { cacheStorage . clear ( ) ; for ( String purchaseData : bundle . getStringArrayList ( Constants . INAPP_PURCHASE_DATA_LIST ) ) { JSONObject purchase = new JSONObject ( purchaseData ) ; cacheStorage . put ( purchase . getString ( " productId " ) , purchase . getString ( " purchaseToken " ) ) ; } } return true ; } catch ( Exception e ) { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_LOAD_PURCHASES , e ) ; Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private boolean purchase ( String productId , String purchaseType , BillingCache cacheStorage ) { if ( ! isInitialized ( ) ) return false ; try { purchasePayload = UUID . randomUUID ( ) . toString ( ) ; Bundle bundle = billingService . getBuyIntent ( Constants . GOOGLE_API_VERSION , contextPackageName , productId , purchaseType , purchasePayload ) ; if ( bundle ! = null ) { int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { PendingIntent pendingIntent = bundle . getParcelable ( Constants . BUY_INTENT ) ; if ( getContext ( ) ! = null ) getContext ( ) . startIntentSenderForResult ( pendingIntent . getIntentSender ( ) , PURCHASE_FLOW_REQUEST_CODE , new Intent ( ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) ) ; else if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_LOST_CONTEXT , null ) ; } else if ( response = = Constants . BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED ) { if ( ! isPurchased ( productId ) & & ! isSubscribed ( productId ) ) loadOwnedPurchasesFromGoogle ( ) ; if ( eventHandler ! = null ) eventHandler . onProductPurchased ( productId ) ; } else if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_TO_INITIALIZE_PURCHASE , null ) ; } return true ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
public boolean consumePurchase ( String productId ) { if ( ! isInitialized ( ) ) return false ; try { String purchaseToken = cachedProducts . getProductPurchaseToken ( productId ) ; if ( ! TextUtils . isEmpty ( purchaseToken ) ) { int response = billingService . consumePurchase ( Constants . GOOGLE_API_VERSION , contextPackageName , purchaseToken ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { cachedProducts . remove ( productId ) ; Log . d ( LOG_TAG , " Successfully consumed " + productId + " purchase. " ) ; return true ; } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( response , null ) ; Log . e ( LOG_TAG , String . format ( " Failed to consume %s: error %d " , productId , response ) ) ; } } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
public boolean handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode ! = PURCHASE_FLOW_REQUEST_CODE ) return false ; int responseCode = data . getIntExtra ( Constants . RESPONSE_CODE , Constants . BILLING_RESPONSE_RESULT_OK ) ; if ( resultCode = = Activity . RESULT_OK & & responseCode = = Constants . BILLING_RESPONSE_RESULT_OK ) { String purchaseData = data . getStringExtra ( Constants . INAPP_PURCHASE_DATA ) ; String dataSignature = data . getStringExtra ( Constants . RESPONSE_INAPP_SIGNATURE ) ; try { JSONObject purchase = new JSONObject ( purchaseData ) ; String productId = purchase . getString ( " productId " ) ; String purchaseToken = purchase . getString ( " purchaseToken " ) ; String developerPayload = purchase . getString ( " developerPayload " ) ; if ( purchasePayload . equals ( developerPayload ) ) { if ( verifyPurchaseSignature ( purchaseData , dataSignature ) ) { cachedProducts . put ( productId , purchaseToken ) ; if ( eventHandler ! = null ) eventHandler . onProductPurchased ( productId ) ; } else { Log . e ( LOG_TAG , " Public key signature doesn't match! " ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } else { Log . e ( LOG_TAG , String . format ( " Payload mismatch: %s != %s " , purchasePayload , developerPayload ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } return true ; }
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; bp = new BillingProcessor ( this , LICENSE_KEY , new BillingProcessor . IBillingHandler ( ) { @Override
public void onProductPurchased ( String productId ) { showToast ( " onProductPurchased: " + productId ) ; updateTextViews ( ) ; }
public void onBillingError ( int errorCode , Throwable error ) { showToast ( " onBillingError: " + Integer . toString ( errorCode ) ) ; }
public void onBillingInitialized ( ) { readyToPurchase = true ; updateTextViews ( ) ; }
public void onPurchaseHistoryRestored ( ) { showToast ( " onPurchaseHistoryRestored " ) ; for ( String sku : bp . listOwnedProducts ( ) ) Log . d ( LOG_TAG , " Owned Managed Product: " + sku ) ; for ( String sku : bp . listOwnedSubscriptions ( ) ) Log . d ( LOG_TAG , " Owned Subscription: " + sku ) ; updateTextViews ( ) ; }
public void onDestroy ( ) { if ( bp ! = null ) bp . release ( ) ; super . onDestroy ( ) ; }
private void updateTextViews ( ) { TextView text = ( TextView ) findViewById ( R . id . productIdTextView ) ; text . setText ( String . format ( " %s is%s purchased " , PRODUCT_ID , bp . isPurchased ( PRODUCT_ID ) ? " " : " not " ) ) ; text = ( TextView ) findViewById ( R . id . subscriptionIdTextView ) ; text . setText ( String . format ( " %s is%s subscribed " , SUBSCRIPTION_ID , bp . isSubscribed ( SUBSCRIPTION_ID ) ? " " : " not " ) ) ; }
public void onClick ( View v ) { if ( ! readyToPurchase ) { showToast ( " Billing not initialized. " ) ; return ; } switch ( v . getId ( ) ) { case R . id . purchaseButton :
protected String getPreferencesBaseKey ( ) { return context . getPackageName ( ) + " _preferences " ; }
private SharedPreferences getPreferences ( ) { if ( context ! = null ) return PreferenceManager . getDefaultSharedPreferences ( context ) ; return null ; }
public void onServiceConnected ( ComponentName name , IBinder service ) { billingService = IInAppBillingService . Stub . asInterface ( service ) ; if ( loadOwnedPurchasesFromGoogle ( ) & & ! isPurchaseHistoryRestored ( ) ) { setPurchaseHistoryRestored ( ) ; if ( eventHandler ! = null ) eventHandler . onPurchaseHistoryRestored ( ) ; } if ( eventHandler ! = null ) eventHandler . onBillingInitialized ( ) ;
protected String getPreferencesBaseKey ( ) { return contextReference . get ( ) . getPackageName ( ) + " _preferences " ; }
private SharedPreferences getPreferences ( ) { if ( contextReference . get ( ) ! = null ) return PreferenceManager . getDefaultSharedPreferences ( contextReference . get ( ) ) ; return null ; }
private SharedPreferences getPreferences ( ) { if ( contextReference . get ( ) ! = null ) return PreferenceManager . getDefaultSharedPreferences ( contextReference . get ( ) ) ; return null ; }
public String getPrice ( String productId , String purchaseType , String packageName ) { if ( billingService ! = null ) { try { ArrayList < String > skuList = new ArrayList < String > ( ) ; skuList . add ( productId ) ; Bundle products = new Bundle ( ) ; products . putStringArrayList ( Constants . PRODUCTS_LIST , skuList ) ; Bundle skuDetails = billingService . getSkuDetails ( Constants . GOOGLE_API_VERSION , packageName , purchaseType , products ) ; int response = skuDetails . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { ArrayList < String > responseList = skuDetails . getStringArrayList ( Constants . DETAILS_LIST ) ; for ( String thisResponse : responseList ) { JSONObject object = new JSONObject ( thisResponse ) ; String responseProductId = object . getString ( Constants . RESPONSE_PRODUCT_ID ) ; if ( productId . equals ( responseProductId ) ) return object . getString ( Constants . RESPONSE_PRICE ) ; } } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( response , null ) ; Log . e ( LOG_TAG , String . format ( " Failed to retrieve price for %s: error %d " , productId , response ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } return null ; }
private boolean purchase ( String productId , String purchaseType ) { if ( ! isInitialized ( ) | | TextUtils . isEmpty ( productId ) | | TextUtils . isEmpty ( purchaseType ) ) return false ; try { purchasePayload = purchaseType + " : " + UUID . randomUUID ( ) . toString ( ) ; Bundle bundle = billingService . getBuyIntent ( Constants . GOOGLE_API_VERSION , contextPackageName , productId , purchaseType , purchasePayload ) ; if ( bundle ! = null ) { int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { PendingIntent pendingIntent = bundle . getParcelable ( Constants . BUY_INTENT ) ; if ( getContext ( ) ! = null ) getContext ( ) . startIntentSenderForResult ( pendingIntent . getIntentSender ( ) , PURCHASE_FLOW_REQUEST_CODE , new Intent ( ) , 0 , 0 , 0 ) ; else if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_LOST_CONTEXT , null ) ; } else if ( response = = Constants . BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED ) { if ( ! isPurchased ( productId ) & & ! isSubscribed ( productId ) ) loadOwnedPurchasesFromGoogle ( ) ; if ( eventHandler ! = null ) eventHandler . onProductPurchased ( productId ) ; } else if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_TO_INITIALIZE_PURCHASE , null ) ; } return true ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
public String getPrice ( String productId , String purchaseType ) { if ( billingService ! = null ) { try { ArrayList < String > skuList = new ArrayList < String > ( ) ; skuList . add ( productId ) ; Bundle products = new Bundle ( ) ; products . putStringArrayList ( Constants . PRODUCTS_LIST , skuList ) ; Bundle skuDetails = billingService . getSkuDetails ( Constants . GOOGLE_API_VERSION , contextPackageName , purchaseType , products ) ; int response = skuDetails . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { ArrayList < String > responseList = skuDetails . getStringArrayList ( Constants . DETAILS_LIST ) ; for ( String thisResponse : responseList ) { JSONObject object = new JSONObject ( thisResponse ) ; String responseProductId = object . getString ( Constants . RESPONSE_PRODUCT_ID ) ; if ( productId . equals ( responseProductId ) ) return object . getString ( Constants . RESPONSE_PRICE ) ; } } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( response , null ) ; Log . e ( LOG_TAG , String . format ( " Failed to retrieve price for %s: error %d " , productId , response ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } return null ; }
public boolean handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode ! = PURCHASE_FLOW_REQUEST_CODE ) return false ; int responseCode = data . getIntExtra ( Constants . RESPONSE_CODE , Constants . BILLING_RESPONSE_RESULT_OK ) ; if ( resultCode = = Activity . RESULT_OK & & responseCode = = Constants . BILLING_RESPONSE_RESULT_OK ) { String purchaseData = data . getStringExtra ( Constants . INAPP_PURCHASE_DATA ) ; String dataSignature = data . getStringExtra ( Constants . RESPONSE_INAPP_SIGNATURE ) ; try { JSONObject purchase = new JSONObject ( purchaseData ) ; String productId = purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) ; String purchaseToken = purchase . getString ( Constants . RESPONSE_PURCHASE_TOKEN ) ; String developerPayload = purchase . getString ( Constants . RESPONSE_PAYLOAD ) ; if ( developerPayload = = null ) developerPayload = " " ; boolean purchasedSubscription = purchasePayload . startsWith ( Constants . PRODUCT_TYPE_SUBSCRIPTION ) ; if ( purchasePayload . equals ( developerPayload ) ) { if ( verifyPurchaseSignature ( purchaseData , dataSignature ) ) { BillingCache cache = purchasedSubscription ? cachedSubscriptions : cachedProducts ; cache . put ( productId , purchaseToken ) ; if ( eventHandler ! = null ) eventHandler . onProductPurchased ( productId ) ; } else { Log . e ( LOG_TAG , " Public key signature doesn't match! " ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } else { Log . e ( LOG_TAG , String . format ( " Payload mismatch: %s != %s " , purchasePayload , developerPayload ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } return true ; }
private SkuDetails getSkuDetails ( String productId , String purchaseType ) { if ( billingService ! = null ) { try { ArrayList < String > skuList = new ArrayList < String > ( ) ; skuList . add ( productId ) ; Bundle products = new Bundle ( ) ; products . putStringArrayList ( Constants . PRODUCTS_LIST , skuList ) ; Bundle skuDetails = billingService . getSkuDetails ( Constants . GOOGLE_API_VERSION , contextPackageName , purchaseType , products ) ; int response = skuDetails . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { for ( String responseLine : skuDetails . getStringArrayList ( Constants . DETAILS_LIST ) ) { Log . d ( LOG_TAG , responseLine ) ; JSONObject object = new JSONObject ( responseLine ) ; String responseProductId = object . getString ( Constants . RESPONSE_PRODUCT_ID ) ; if ( productId . equals ( responseProductId ) ) return new SkuDetails ( object ) ; } } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( response , null ) ; Log . e ( LOG_TAG , String . format ( " Failed to retrieve info for %s: error %d " , productId , response ) ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , String . format ( " Failed to call getSkuDetails %s " , e . toString ( ) ) ) ; } } return null ; }
public SkuDetails getPurchaseDetails ( String productId ) { return getSkuDetails ( productId , Constants . PRODUCT_TYPE_MANAGED ) ; }
public SkuDetails getSubscriptionDetails ( String productId ) { return getSkuDetails ( productId , Constants . PRODUCT_TYPE_SUBSCRIPTION ) ; }
public String toString ( ) { return String . format ( " %s: %s(%s) %f in %s (%s) " , productId , title , description , priceValue , currency , priceText ) ; }
private void showToast ( String message ) { Toast . makeText ( this , message , Toast . LENGTH_LONG ) . show ( ) ; }
public String getDetails ( String productId ) { return data . containsKey ( productId ) ? data . get ( productId ) : null ; }
public void put ( String productId , String details ) { if ( ! data . containsKey ( productId ) ) { data . put ( productId , details ) ;
private boolean loadPurchasesByType ( String type , BillingCache cacheStorage ) { if ( ! isInitialized ( ) ) return false ; try { Bundle bundle = billingService . getPurchases ( Constants . GOOGLE_API_VERSION , contextPackageName , type , null ) ; if ( bundle . getInt ( Constants . RESPONSE_CODE ) = = Constants . BILLING_RESPONSE_RESULT_OK ) { cacheStorage . clear ( ) ; for ( String purchaseData : bundle . getStringArrayList ( Constants . INAPP_PURCHASE_DATA_LIST ) ) { JSONObject purchase = new JSONObject ( purchaseData ) ; cacheStorage . put ( purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) , purchaseData ) ; } } return true ; } catch ( Exception e ) { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_LOAD_PURCHASES , e ) ; Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private boolean purchase ( String productId , String purchaseType ) { if ( ! isInitialized ( ) | | TextUtils . isEmpty ( productId ) | | TextUtils . isEmpty ( purchaseType ) ) return false ; try { purchasePayload = purchaseType + " : " + UUID . randomUUID ( ) . toString ( ) ; Bundle bundle = billingService . getBuyIntent ( Constants . GOOGLE_API_VERSION , contextPackageName , productId , purchaseType , purchasePayload ) ; if ( bundle ! = null ) { int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { PendingIntent pendingIntent = bundle . getParcelable ( Constants . BUY_INTENT ) ; if ( getContext ( ) ! = null ) getContext ( ) . startIntentSenderForResult ( pendingIntent . getIntentSender ( ) , PURCHASE_FLOW_REQUEST_CODE , new Intent ( ) , 0 , 0 , 0 ) ; else if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_LOST_CONTEXT , null ) ; } else if ( response = = Constants . BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED ) { if ( ! isPurchased ( productId ) & & ! isSubscribed ( productId ) ) loadOwnedPurchasesFromGoogle ( ) ; if ( eventHandler ! = null ) { TransactionDetails details = getPurchaseTransactionDetails ( productId ) ; if ( details = = null ) details = getSubscriptionTransactionDetails ( productId ) ; eventHandler . onProductPurchased ( productId , details ) ; } } else if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_TO_INITIALIZE_PURCHASE , null ) ; } return true ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private TransactionDetails getPurchaseTransactionDetails ( String productId , BillingCache cache ) { String details = cache . getDetails ( productId ) ; if ( ! TextUtils . isEmpty ( details ) ) { try { return new TransactionDetails ( new JSONObject ( details ) ) ; } catch ( JSONException e ) { Log . e ( LOG_TAG , " Failed to load saved purchase details for " + productId ) ; } } return null ; }
public boolean consumePurchase ( String productId ) { if ( ! isInitialized ( ) ) return false ; try { TransactionDetails transactionDetails = getPurchaseTransactionDetails ( productId , cachedProducts ) ; if ( transactionDetails ! = null & & ! TextUtils . isEmpty ( transactionDetails . purchaseToken ) ) { int response = billingService . consumePurchase ( Constants . GOOGLE_API_VERSION , contextPackageName , transactionDetails . purchaseToken ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { cachedProducts . remove ( productId ) ; Log . d ( LOG_TAG , " Successfully consumed " + productId + " purchase. " ) ; return true ; } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( response , null ) ; Log . e ( LOG_TAG , String . format ( " Failed to consume %s: error %d " , productId , response ) ) ; } } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private SkuDetails getSkuDetails ( String productId , String purchaseType ) { if ( billingService ! = null ) { try { ArrayList < String > skuList = new ArrayList < String > ( ) ; skuList . add ( productId ) ; Bundle products = new Bundle ( ) ; products . putStringArrayList ( Constants . PRODUCTS_LIST , skuList ) ; Bundle skuDetails = billingService . getSkuDetails ( Constants . GOOGLE_API_VERSION , contextPackageName , purchaseType , products ) ; int response = skuDetails . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { for ( String responseLine : skuDetails . getStringArrayList ( Constants . DETAILS_LIST ) ) { JSONObject object = new JSONObject ( responseLine ) ; String responseProductId = object . getString ( Constants . RESPONSE_PRODUCT_ID ) ; if ( productId . equals ( responseProductId ) ) return new SkuDetails ( object ) ; } } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( response , null ) ; Log . e ( LOG_TAG , String . format ( " Failed to retrieve info for %s: error %d " , productId , response ) ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , String . format ( " Failed to call getSkuDetails %s " , e . toString ( ) ) ) ; } } return null ; }
public SkuDetails getPurchaseListingDetails ( String productId ) { return getSkuDetails ( productId , Constants . PRODUCT_TYPE_MANAGED ) ; }
public SkuDetails getSubscriptionListingDetails ( String productId ) { return getSkuDetails ( productId , Constants . PRODUCT_TYPE_SUBSCRIPTION ) ; }
public TransactionDetails getPurchaseTransactionDetails ( String productId ) { return getPurchaseTransactionDetails ( productId , cachedProducts ) ; }
public TransactionDetails getSubscriptionTransactionDetails ( String productId ) { return getPurchaseTransactionDetails ( productId , cachedSubscriptions ) ; }
public boolean handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode ! = PURCHASE_FLOW_REQUEST_CODE ) return false ; int responseCode = data . getIntExtra ( Constants . RESPONSE_CODE , Constants . BILLING_RESPONSE_RESULT_OK ) ; if ( resultCode = = Activity . RESULT_OK & & responseCode = = Constants . BILLING_RESPONSE_RESULT_OK ) { String purchaseData = data . getStringExtra ( Constants . INAPP_PURCHASE_DATA ) ; String dataSignature = data . getStringExtra ( Constants . RESPONSE_INAPP_SIGNATURE ) ; try { JSONObject purchase = new JSONObject ( purchaseData ) ; String productId = purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) ; String developerPayload = purchase . getString ( Constants . RESPONSE_PAYLOAD ) ; if ( developerPayload = = null ) developerPayload = " " ; boolean purchasedSubscription = purchasePayload . startsWith ( Constants . PRODUCT_TYPE_SUBSCRIPTION ) ; if ( purchasePayload . equals ( developerPayload ) ) { if ( verifyPurchaseSignature ( purchaseData , dataSignature ) ) { BillingCache cache = purchasedSubscription ? cachedSubscriptions : cachedProducts ; cache . put ( productId , purchaseData ) ; if ( eventHandler ! = null ) eventHandler . onProductPurchased ( productId , new TransactionDetails ( purchase ) ) ; } else { Log . e ( LOG_TAG , " Public key signature doesn't match! " ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } else { Log . e ( LOG_TAG , String . format ( " Payload mismatch: %s != %s " , purchasePayload , developerPayload ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } return true ; }
public String toString ( ) { return String . format ( " %s purchased at %s(%s). Token: %s " , productId , purchaseTime , orderId , purchaseToken ) ; }
public void onProductPurchased ( String productId , TransactionDetails details ) { showToast ( " onProductPurchased: " + productId ) ; updateTextViews ( ) ; }
private void flush ( ) { ArrayList < String > output = new ArrayList < String > ( ) ; for ( String productId : data . keySet ( ) ) { PurchaseInfo info = data . get ( productId ) ; output . add ( productId + LINE_DELIMITER + info . jsonObject + LINE_DELIMITER + info . signature ) ; } saveString ( getPreferencesCacheKey ( ) , TextUtils . join ( ENTRY_DELIMITER , output ) ) ; }
public PurchaseInfo getDetails ( String productId ) { return data . containsKey ( productId ) ? data . get ( productId ) : null ; }
public void put ( String productId , String details , String signature ) { if ( ! data . containsKey ( productId ) ) { data . put ( productId , new PurchaseInfo ( details , signature ) ) ;
private boolean loadPurchasesByType ( String type , BillingCache cacheStorage ) { if ( ! isInitialized ( ) ) return false ; try { Bundle bundle = billingService . getPurchases ( Constants . GOOGLE_API_VERSION , contextPackageName , type , null ) ; if ( bundle . getInt ( Constants . RESPONSE_CODE ) = = Constants . BILLING_RESPONSE_RESULT_OK ) { cacheStorage . clear ( ) ; ArrayList < String > purchaseList = bundle . getStringArrayList ( Constants . INAPP_PURCHASE_DATA_LIST ) ; ArrayList < String > signatureList = bundle . getStringArrayList ( Constants . RESPONSE_INAPP_SIGNATURE ) ; for ( int i = 0 ; i < purchaseList . size ( ) ; i + + ) { JSONObject purchase = new JSONObject ( purchaseList . get ( i ) ) ; String signature = signatureList . get ( i ) ; cacheStorage . put ( purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) , purchaseList . get ( i ) , signature ) ; } } return true ; } catch ( Exception e ) { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_LOAD_PURCHASES , e ) ; Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private TransactionDetails getPurchaseTransactionDetails ( String productId , BillingCache cache ) { PurchaseInfo details = cache . getDetails ( productId ) ; if ( ! TextUtils . isEmpty ( details . jsonObject ) ) { try { return new TransactionDetails ( details ) ; } catch ( JSONException e ) { Log . e ( LOG_TAG , " Failed to load saved purchase details for " + productId ) ; } } return null ; }
public boolean handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode ! = PURCHASE_FLOW_REQUEST_CODE ) return false ; int responseCode = data . getIntExtra ( Constants . RESPONSE_CODE , Constants . BILLING_RESPONSE_RESULT_OK ) ; if ( resultCode = = Activity . RESULT_OK & & responseCode = = Constants . BILLING_RESPONSE_RESULT_OK ) { String purchaseData = data . getStringExtra ( Constants . INAPP_PURCHASE_DATA ) ; String dataSignature = data . getStringExtra ( Constants . RESPONSE_INAPP_SIGNATURE ) ; try { JSONObject purchase = new JSONObject ( purchaseData ) ; String productId = purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) ; String developerPayload = purchase . getString ( Constants . RESPONSE_PAYLOAD ) ; if ( developerPayload = = null ) developerPayload = " " ; boolean purchasedSubscription = purchasePayload . startsWith ( Constants . PRODUCT_TYPE_SUBSCRIPTION ) ; if ( purchasePayload . equals ( developerPayload ) ) { if ( verifyPurchaseSignature ( purchaseData , dataSignature ) ) { BillingCache cache = purchasedSubscription ? cachedSubscriptions : cachedProducts ; cache . put ( productId , purchaseData , dataSignature ) ; if ( eventHandler ! = null ) eventHandler . onProductPurchased ( productId , new TransactionDetails ( new PurchaseInfo ( purchaseData , dataSignature ) ) ) ; } else { Log . e ( LOG_TAG , " Public key signature doesn't match! " ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } else { Log . e ( LOG_TAG , String . format ( " Payload mismatch: %s != %s " , purchasePayload , developerPayload ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } return true ; }
public String toString ( ) { return String . format ( " %s purchased at %s(%s). Token: %s, Signature: %s " , productId , purchaseTime , orderId , purchaseToken , purchaseInfo . signature ) ; }
private boolean loadPurchasesByType ( String type , BillingCache cacheStorage ) { if ( ! isInitialized ( ) ) return false ; try { Bundle bundle = billingService . getPurchases ( Constants . GOOGLE_API_VERSION , contextPackageName , type , null ) ; if ( bundle . getInt ( Constants . RESPONSE_CODE ) = = Constants . BILLING_RESPONSE_RESULT_OK ) { cacheStorage . clear ( ) ; ArrayList < String > purchaseList = bundle . getStringArrayList ( Constants . INAPP_PURCHASE_DATA_LIST ) ; ArrayList < String > signatureList = bundle . getStringArrayList ( Constants . RESPONSE_INAPP_SIGNATURE ) ; for ( int i = 0 ; i < purchaseList . size ( ) ; i + + ) { String jsonData = purchaseList . get ( i ) ; JSONObject purchase = new JSONObject ( jsonData ) ; String signature = signatureList . get ( i ) ; cacheStorage . put ( purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) , jsonData , signature ) ; } } return true ; } catch ( Exception e ) { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_LOAD_PURCHASES , e ) ; Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private void flush ( ) { ArrayList < String > output = new ArrayList < String > ( ) ; for ( String productId : data . keySet ( ) ) { PurchaseInfo info = data . get ( productId ) ; output . add ( productId + LINE_DELIMITER + info . responseData + LINE_DELIMITER + info . signature ) ; } saveString ( getPreferencesCacheKey ( ) , TextUtils . join ( ENTRY_DELIMITER , output ) ) ; }
private TransactionDetails getPurchaseTransactionDetails ( String productId , BillingCache cache ) { PurchaseInfo details = cache . getDetails ( productId ) ; if ( ! TextUtils . isEmpty ( details . responseData ) ) { try { return new TransactionDetails ( details ) ; } catch ( JSONException e ) { Log . e ( LOG_TAG , " Failed to load saved purchase details for " + productId ) ; } } return null ; }
private boolean loadPurchasesByType ( String type , BillingCache cacheStorage ) { if ( ! isInitialized ( ) ) return false ; try { Bundle bundle = billingService . getPurchases ( Constants . GOOGLE_API_VERSION , contextPackageName , type , null ) ; if ( bundle . getInt ( Constants . RESPONSE_CODE ) = = Constants . BILLING_RESPONSE_RESULT_OK ) { cacheStorage . clear ( ) ; ArrayList < String > purchaseList = bundle . getStringArrayList ( Constants . INAPP_PURCHASE_DATA_LIST ) ; ArrayList < String > signatureList = bundle . getStringArrayList ( Constants . RESPONSE_INAPP_SIGNATURE ) ; for ( int i = 0 ; i < purchaseList . size ( ) ; i + + ) { String jsonData = purchaseList . get ( i ) ; JSONObject purchase = new JSONObject ( jsonData ) ; cacheStorage . put ( purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) , jsonData , signatureList . get ( i ) ) ; } } return true ; } catch ( Exception e ) { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_LOAD_PURCHASES , e ) ; Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private TransactionDetails getPurchaseTransactionDetails ( String productId , BillingCache cache ) { PurchaseInfo details = cache . getDetails ( productId ) ; if ( details ! = null & & ! TextUtils . isEmpty ( details . responseData ) ) { try { return new TransactionDetails ( details ) ; } catch ( JSONException e ) { Log . e ( LOG_TAG , " Failed to load saved purchase details for " + productId ) ; } } return null ; }
private boolean loadPurchasesByType ( String type , BillingCache cacheStorage ) { if ( ! isInitialized ( ) ) return false ; try { Bundle bundle = billingService . getPurchases ( Constants . GOOGLE_API_VERSION , contextPackageName , type , null ) ; if ( bundle . getInt ( Constants . RESPONSE_CODE ) = = Constants . BILLING_RESPONSE_RESULT_OK ) { cacheStorage . clear ( ) ; ArrayList < String > purchaseList = bundle . getStringArrayList ( Constants . INAPP_PURCHASE_DATA_LIST ) ; ArrayList < String > signatureList = bundle . getStringArrayList ( Constants . RESPONSE_INAPP_SIGNATURE ) ; for ( int i = 0 ; i < purchaseList . size ( ) ; i + + ) { String jsonData = purchaseList . get ( i ) ; JSONObject purchase = new JSONObject ( jsonData ) ; String signature = signatureList ! = null & & signatureList . size ( ) > i ? signatureList . get ( i ) : null ; cacheStorage . put ( purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) , jsonData , signature ) ; } } return true ; } catch ( Exception e ) { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_LOAD_PURCHASES , e ) ; Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private boolean purchase ( String productId , String purchaseType ) { if ( ! isInitialized ( ) | | TextUtils . isEmpty ( productId ) | | TextUtils . isEmpty ( purchaseType ) ) return false ; try { String purchasePayload = purchaseType + " : " + UUID . randomUUID ( ) . toString ( ) ; savePurchasePayload ( purchasePayload ) ; Bundle bundle = billingService . getBuyIntent ( Constants . GOOGLE_API_VERSION , contextPackageName , productId , purchaseType , purchasePayload ) ; if ( bundle ! = null ) { int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { PendingIntent pendingIntent = bundle . getParcelable ( Constants . BUY_INTENT ) ; if ( getContext ( ) ! = null ) getContext ( ) . startIntentSenderForResult ( pendingIntent . getIntentSender ( ) , PURCHASE_FLOW_REQUEST_CODE , new Intent ( ) , 0 , 0 , 0 ) ; else if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_LOST_CONTEXT , null ) ; } else if ( response = = Constants . BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED ) { if ( ! isPurchased ( productId ) & & ! isSubscribed ( productId ) ) loadOwnedPurchasesFromGoogle ( ) ; if ( eventHandler ! = null ) { TransactionDetails details = getPurchaseTransactionDetails ( productId ) ; if ( details = = null ) details = getSubscriptionTransactionDetails ( productId ) ; eventHandler . onProductPurchased ( productId , details ) ; } } else if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_TO_INITIALIZE_PURCHASE , null ) ; } return true ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
public boolean handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode ! = PURCHASE_FLOW_REQUEST_CODE ) return false ; int responseCode = data . getIntExtra ( Constants . RESPONSE_CODE , Constants . BILLING_RESPONSE_RESULT_OK ) ; Log . d ( LOG_TAG , String . format ( " resultCode = %d, responseCode = %d " , resultCode , responseCode ) ) ; String purchasePayload = getPurchasePayload ( ) ; if ( resultCode = = Activity . RESULT_OK & & responseCode = = Constants . BILLING_RESPONSE_RESULT_OK & & ! TextUtils . isEmpty ( purchasePayload ) ) { String purchaseData = data . getStringExtra ( Constants . INAPP_PURCHASE_DATA ) ; String dataSignature = data . getStringExtra ( Constants . RESPONSE_INAPP_SIGNATURE ) ; try { JSONObject purchase = new JSONObject ( purchaseData ) ; String productId = purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) ; String developerPayload = purchase . getString ( Constants . RESPONSE_PAYLOAD ) ; if ( developerPayload = = null ) developerPayload = " " ; boolean purchasedSubscription = purchasePayload . startsWith ( Constants . PRODUCT_TYPE_SUBSCRIPTION ) ; if ( purchasePayload . equals ( developerPayload ) ) { if ( verifyPurchaseSignature ( purchaseData , dataSignature ) ) { BillingCache cache = purchasedSubscription ? cachedSubscriptions : cachedProducts ; cache . put ( productId , purchaseData , dataSignature ) ; if ( eventHandler ! = null ) eventHandler . onProductPurchased ( productId , new TransactionDetails ( new PurchaseInfo ( purchaseData , dataSignature ) ) ) ; } else { Log . e ( LOG_TAG , " Public key signature doesn't match! " ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } else { Log . e ( LOG_TAG , String . format ( " Payload mismatch: %s != %s " , purchasePayload , developerPayload ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } return true ; }
private void savePurchasePayload ( String value ) { saveString ( getPreferencesBaseKey ( ) + PURCHASE_PAYLOAD_CACHE_KEY , value ) ; }
private String getPurchasePayload ( ) { return loadString ( getPreferencesBaseKey ( ) + PURCHASE_PAYLOAD_CACHE_KEY , null ) ; }
private SharedPreferences getPreferences ( ) { if ( contextReference . get ( ) ! = null ) return PreferenceManager . getDefaultSharedPreferences ( contextReference . get ( ) ) ; return null ; }
private void load ( ) { for ( String entry : loadString ( getPreferencesCacheKey ( ) , " " ) . split ( Pattern . quote ( ENTRY_DELIMITER ) ) ) { if ( ! TextUtils . isEmpty ( entry ) ) {
private void flush ( ) { ArrayList < String > output = new ArrayList < String > ( ) ; for ( String productId : data . keySet ( ) ) { PurchaseInfo info = data . get ( productId ) ; output . add ( productId + LINE_DELIMITER + info . responseData + LINE_DELIMITER + info . signature ) ; } saveString ( getPreferencesCacheKey ( ) , TextUtils . join ( ENTRY_DELIMITER , output ) ) ; }
public PurchaseInfo getDetails ( String productId ) { return data . containsKey ( productId ) ? data . get ( productId ) : null ; }
public void put ( String productId , String details , String signature ) { if ( ! data . containsKey ( productId ) ) { data . put ( productId , new PurchaseInfo ( details , signature ) ) ;
public void remove ( String productId ) { if ( data . containsKey ( productId ) ) { data . remove ( productId ) ;
public List < String > getContents ( ) { return new ArrayList < String > ( data . keySet ( ) ) ; }
public void onServiceConnected ( ComponentName name , IBinder service ) { billingService = IInAppBillingService . Stub . asInterface ( service ) ; if ( ! isPurchaseHistoryRestored ( ) & & loadOwnedPurchasesFromGoogle ( ) ) { setPurchaseHistoryRestored ( ) ; if ( eventHandler ! = null ) eventHandler . onPurchaseHistoryRestored ( ) ; } if ( eventHandler ! = null ) eventHandler . onBillingInitialized ( ) ;
private void bindPlayServices ( ) { try { getContext ( ) . bindService ( new Intent ( " com.android.vending.billing.InAppBillingService.BIND " ) , serviceConnection , Context . BIND_AUTO_CREATE ) ;
public void release ( ) { if ( serviceConnection ! = null & & getContext ( ) ! = null ) { try { getContext ( ) . unbindService ( serviceConnection ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } billingService = null ; } cachedProducts . release ( ) ; super . release ( ) ; }
public boolean isPurchased ( String productId ) { return cachedProducts . includesProduct ( productId ) ; }
public boolean isSubscribed ( String productId ) { return cachedSubscriptions . includesProduct ( productId ) ; }
public List < String > listOwnedProducts ( ) { return cachedProducts . getContents ( ) ; }
public List < String > listOwnedSubscriptions ( ) { return cachedSubscriptions . getContents ( ) ; }
private boolean loadPurchasesByType ( String type , BillingCache cacheStorage ) { if ( ! isInitialized ( ) ) return false ; try { Bundle bundle = billingService . getPurchases ( Constants . GOOGLE_API_VERSION , contextPackageName , type , null ) ; if ( bundle . getInt ( Constants . RESPONSE_CODE ) = = Constants . BILLING_RESPONSE_RESULT_OK ) { cacheStorage . clear ( ) ; ArrayList < String > purchaseList = bundle . getStringArrayList ( Constants . INAPP_PURCHASE_DATA_LIST ) ; ArrayList < String > signatureList = bundle . getStringArrayList ( Constants . RESPONSE_INAPP_SIGNATURE ) ; for ( int i = 0 ; i < purchaseList . size ( ) ; i + + ) { String jsonData = purchaseList . get ( i ) ; JSONObject purchase = new JSONObject ( jsonData ) ; String signature = signatureList ! = null & & signatureList . size ( ) > i ? signatureList . get ( i ) : null ; cacheStorage . put ( purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) , jsonData , signature ) ; } } return true ; } catch ( Exception e ) { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_LOAD_PURCHASES , e ) ; Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
public boolean loadOwnedPurchasesFromGoogle ( ) { return isInitialized ( ) & & loadPurchasesByType ( Constants . PRODUCT_TYPE_MANAGED , cachedProducts ) & &
public boolean purchase ( String productId ) { return purchase ( productId , Constants . PRODUCT_TYPE_MANAGED ) ; }
public boolean subscribe ( String productId ) { return purchase ( productId , Constants . PRODUCT_TYPE_SUBSCRIPTION ) ; }
private boolean purchase ( String productId , String purchaseType ) { if ( ! isInitialized ( ) | | TextUtils . isEmpty ( productId ) | | TextUtils . isEmpty ( purchaseType ) ) return false ; try { String purchasePayload = purchaseType + " : " + UUID . randomUUID ( ) . toString ( ) ; savePurchasePayload ( purchasePayload ) ; Bundle bundle = billingService . getBuyIntent ( Constants . GOOGLE_API_VERSION , contextPackageName , productId , purchaseType , purchasePayload ) ; if ( bundle ! = null ) { int response = bundle . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { PendingIntent pendingIntent = bundle . getParcelable ( Constants . BUY_INTENT ) ; if ( getContext ( ) ! = null ) getContext ( ) . startIntentSenderForResult ( pendingIntent . getIntentSender ( ) , PURCHASE_FLOW_REQUEST_CODE , new Intent ( ) , 0 , 0 , 0 ) ; else if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_LOST_CONTEXT , null ) ; } else if ( response = = Constants . BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED ) { if ( ! isPurchased ( productId ) & & ! isSubscribed ( productId ) ) loadOwnedPurchasesFromGoogle ( ) ; if ( eventHandler ! = null ) { TransactionDetails details = getPurchaseTransactionDetails ( productId ) ; if ( details = = null ) details = getSubscriptionTransactionDetails ( productId ) ; eventHandler . onProductPurchased ( productId , details ) ; } } else if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_TO_INITIALIZE_PURCHASE , null ) ; } return true ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private TransactionDetails getPurchaseTransactionDetails ( String productId , BillingCache cache ) { PurchaseInfo details = cache . getDetails ( productId ) ; if ( details ! = null & & ! TextUtils . isEmpty ( details . responseData ) ) { try { return new TransactionDetails ( details ) ; } catch ( JSONException e ) { Log . e ( LOG_TAG , " Failed to load saved purchase details for " + productId ) ; } } return null ; }
public boolean consumePurchase ( String productId ) { if ( ! isInitialized ( ) ) return false ; try { TransactionDetails transactionDetails = getPurchaseTransactionDetails ( productId , cachedProducts ) ; if ( transactionDetails ! = null & & ! TextUtils . isEmpty ( transactionDetails . purchaseToken ) ) { int response = billingService . consumePurchase ( Constants . GOOGLE_API_VERSION , contextPackageName , transactionDetails . purchaseToken ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { cachedProducts . remove ( productId ) ; Log . d ( LOG_TAG , " Successfully consumed " + productId + " purchase. " ) ; return true ; } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( response , null ) ; Log . e ( LOG_TAG , String . format ( " Failed to consume %s: error %d " , productId , response ) ) ; } } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private SkuDetails getSkuDetails ( String productId , String purchaseType ) { if ( billingService ! = null ) { try { ArrayList < String > skuList = new ArrayList < String > ( ) ; skuList . add ( productId ) ; Bundle products = new Bundle ( ) ; products . putStringArrayList ( Constants . PRODUCTS_LIST , skuList ) ; Bundle skuDetails = billingService . getSkuDetails ( Constants . GOOGLE_API_VERSION , contextPackageName , purchaseType , products ) ; int response = skuDetails . getInt ( Constants . RESPONSE_CODE ) ; if ( response = = Constants . BILLING_RESPONSE_RESULT_OK ) { for ( String responseLine : skuDetails . getStringArrayList ( Constants . DETAILS_LIST ) ) { JSONObject object = new JSONObject ( responseLine ) ; String responseProductId = object . getString ( Constants . RESPONSE_PRODUCT_ID ) ; if ( productId . equals ( responseProductId ) ) return new SkuDetails ( object ) ; } } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( response , null ) ; Log . e ( LOG_TAG , String . format ( " Failed to retrieve info for %s: error %d " , productId , response ) ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , String . format ( " Failed to call getSkuDetails %s " , e . toString ( ) ) ) ; } } return null ; }
public SkuDetails getPurchaseListingDetails ( String productId ) { return getSkuDetails ( productId , Constants . PRODUCT_TYPE_MANAGED ) ; }
public SkuDetails getSubscriptionListingDetails ( String productId ) { return getSkuDetails ( productId , Constants . PRODUCT_TYPE_SUBSCRIPTION ) ; }
public TransactionDetails getPurchaseTransactionDetails ( String productId ) { return getPurchaseTransactionDetails ( productId , cachedProducts ) ; }
public TransactionDetails getSubscriptionTransactionDetails ( String productId ) { return getPurchaseTransactionDetails ( productId , cachedSubscriptions ) ; }
public boolean handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode ! = PURCHASE_FLOW_REQUEST_CODE ) return false ; int responseCode = data . getIntExtra ( Constants . RESPONSE_CODE , Constants . BILLING_RESPONSE_RESULT_OK ) ; Log . d ( LOG_TAG , String . format ( " resultCode = %d, responseCode = %d " , resultCode , responseCode ) ) ; String purchasePayload = getPurchasePayload ( ) ; if ( resultCode = = Activity . RESULT_OK & & responseCode = = Constants . BILLING_RESPONSE_RESULT_OK & & ! TextUtils . isEmpty ( purchasePayload ) ) { String purchaseData = data . getStringExtra ( Constants . INAPP_PURCHASE_DATA ) ; String dataSignature = data . getStringExtra ( Constants . RESPONSE_INAPP_SIGNATURE ) ; try { JSONObject purchase = new JSONObject ( purchaseData ) ; String productId = purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) ; String developerPayload = purchase . getString ( Constants . RESPONSE_PAYLOAD ) ; if ( developerPayload = = null ) developerPayload = " " ; boolean purchasedSubscription = purchasePayload . startsWith ( Constants . PRODUCT_TYPE_SUBSCRIPTION ) ; if ( purchasePayload . equals ( developerPayload ) ) { if ( verifyPurchaseSignature ( purchaseData , dataSignature ) ) { BillingCache cache = purchasedSubscription ? cachedSubscriptions : cachedProducts ; cache . put ( productId , purchaseData , dataSignature ) ; if ( eventHandler ! = null ) eventHandler . onProductPurchased ( productId , new TransactionDetails ( new PurchaseInfo ( purchaseData , dataSignature ) ) ) ; } else { Log . e ( LOG_TAG , " Public key signature doesn't match! " ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } else { Log . e ( LOG_TAG , String . format ( " Payload mismatch: %s != %s " , purchasePayload , developerPayload ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_INVALID_SIGNATURE , null ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , e . toString ( ) ) ; if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } } else { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_OTHER_ERROR , null ) ; } return true ; }
private boolean verifyPurchaseSignature ( String purchaseData , String dataSignature ) { if ( ! TextUtils . isEmpty ( signatureBase64 ) ) { try { return Security . verifyPurchase ( signatureBase64 , purchaseData , dataSignature ) ; } catch ( Exception e ) { return false ; } } return true ; }
private void savePurchasePayload ( String value ) { saveString ( getPreferencesBaseKey ( ) + PURCHASE_PAYLOAD_CACHE_KEY , value ) ; }
private String getPurchasePayload ( ) { return loadString ( getPreferencesBaseKey ( ) + PURCHASE_PAYLOAD_CACHE_KEY , null ) ; }
public String toString ( ) { return String . format ( " %s: %s(%s) %f in %s (%s) " , productId , title , description , priceValue , currency , priceText ) ; }
public String toString ( ) { return String . format ( " %s purchased at %s(%s). Token: %s, Signature: %s " , productId , purchaseTime , orderId , purchaseToken , purchaseInfo . signature ) ; }
private String getPreferencesVersionKey ( ) { return getPreferencesCacheKey ( ) + VERSION_KEY ; }
private void load ( ) { for ( String entry : loadString ( getPreferencesCacheKey ( ) , " " ) . split ( Pattern . quote ( ENTRY_DELIMITER ) ) ) { if ( ! TextUtils . isEmpty ( entry ) ) { String [ ] parts = entry . split ( Pattern . quote ( LINE_DELIMITER ) ) ; if ( parts . length > 1 ) data . put ( parts [ 0 ] , new PurchaseInfo ( parts [ 1 ] , parts [ 2 ] ) ) ; } } version = getCurrentVersion ( ) ; }
private void flush ( ) { ArrayList < String > output = new ArrayList < String > ( ) ; for ( String productId : data . keySet ( ) ) { PurchaseInfo info = data . get ( productId ) ; output . add ( productId + LINE_DELIMITER + info . responseData + LINE_DELIMITER + info . signature ) ; } saveString ( getPreferencesCacheKey ( ) , TextUtils . join ( ENTRY_DELIMITER , output ) ) ; version = Long . toString ( new Date ( ) . getTime ( ) ) ; saveString ( getPreferencesVersionKey ( ) , version ) ; }
public boolean includesProduct ( String productId ) { reloadDataIfNeeded ( ) ; return data . containsKey ( productId ) ; }
public PurchaseInfo getDetails ( String productId ) { reloadDataIfNeeded ( ) ; return data . containsKey ( productId ) ? data . get ( productId ) : null ; }
public void put ( String productId , String details , String signature ) { reloadDataIfNeeded ( ) ; if ( ! data . containsKey ( productId ) ) { data . put ( productId , new PurchaseInfo ( details , signature ) ) ;
public void remove ( String productId ) { reloadDataIfNeeded ( ) ; if ( data . containsKey ( productId ) ) { data . remove ( productId ) ;
public void clear ( ) { reloadDataIfNeeded ( ) ; data . clear ( ) ; flush ( ) ; }
private String getCurrentVersion ( ) { return loadString ( getPreferencesVersionKey ( ) , " 0 " ) ; }
private void reloadDataIfNeeded ( ) { if ( ! version . equalsIgnoreCase ( getCurrentVersion ( ) ) ) { data . clear ( ) ;
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; TextView title = ( TextView ) findViewById ( R . id . titleTextView ) ; title . setText ( String . format ( getString ( R . string . title ) , getIntent ( ) . getIntExtra ( ACTIVITY_NUMBER , 1 ) ) ) ; bp = new BillingProcessor ( this , LICENSE_KEY , new BillingProcessor . IBillingHandler ( ) { @Override
public void onProductPurchased ( String productId , TransactionDetails details ) { showToast ( " onProductPurchased: " + productId ) ; updateTextViews ( ) ; }
protected void onResume ( ) { super . onResume ( ) ; updateTextViews ( ) ; }
private void load ( ) { for ( String entry : loadString ( getPreferencesCacheKey ( ) , " " ) . split ( Pattern . quote ( ENTRY_DELIMITER ) ) ) { if ( ! TextUtils . isEmpty ( entry ) ) { String [ ] parts = entry . split ( Pattern . quote ( LINE_DELIMITER ) ) ; if ( parts . length > 2 ) data . put ( parts [ 0 ] , new PurchaseInfo ( parts [ 1 ] , parts [ 2 ] ) ) ; } } version = getCurrentVersion ( ) ; }
private boolean loadPurchasesByType ( String type , BillingCache cacheStorage ) { if ( ! isInitialized ( ) ) return false ; try { Bundle bundle = billingService . getPurchases ( Constants . GOOGLE_API_VERSION , contextPackageName , type , null ) ; if ( bundle . getInt ( Constants . RESPONSE_CODE ) = = Constants . BILLING_RESPONSE_RESULT_OK ) { cacheStorage . clear ( ) ; ArrayList < String > purchaseList = bundle . getStringArrayList ( Constants . INAPP_PURCHASE_DATA_LIST ) ; ArrayList < String > signatureList = bundle . getStringArrayList ( Constants . RESPONSE_INAPP_SIGNATURE_LIST ) ; for ( int i = 0 ; i < purchaseList . size ( ) ; i + + ) { String jsonData = purchaseList . get ( i ) ; JSONObject purchase = new JSONObject ( jsonData ) ; String signature = signatureList ! = null & & signatureList . size ( ) > i ? signatureList . get ( i ) : null ; cacheStorage . put ( purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) , jsonData , signature ) ; } } return true ; } catch ( Exception e ) { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_LOAD_PURCHASES , e ) ; Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private boolean loadPurchasesByType ( String type , BillingCache cacheStorage ) { if ( ! isInitialized ( ) ) return false ; try { Bundle bundle = billingService . getPurchases ( Constants . GOOGLE_API_VERSION , contextPackageName , type , null ) ; if ( bundle . getInt ( Constants . RESPONSE_CODE ) = = Constants . BILLING_RESPONSE_RESULT_OK ) { cacheStorage . clear ( ) ; ArrayList < String > purchaseList = bundle . getStringArrayList ( Constants . INAPP_PURCHASE_DATA_LIST ) ; ArrayList < String > signatureList = bundle . getStringArrayList ( Constants . INAPP_DATA_SIGNATURE_LIST ) ; for ( int i = 0 ; i < purchaseList . size ( ) ; i + + ) { String jsonData = purchaseList . get ( i ) ; JSONObject purchase = new JSONObject ( jsonData ) ; String signature = signatureList ! = null & & signatureList . size ( ) > i ? signatureList . get ( i ) : null ; cacheStorage . put ( purchase . getString ( Constants . RESPONSE_PRODUCT_ID ) , jsonData , signature ) ; } } return true ; } catch ( Exception e ) { if ( eventHandler ! = null ) eventHandler . onBillingError ( Constants . BILLING_ERROR_FAILED_LOAD_PURCHASES , e ) ; Log . e ( LOG_TAG , e . toString ( ) ) ; } return false ; }
private void load ( ) { for ( String entry : loadString ( getPreferencesCacheKey ( ) , " " ) . split ( Pattern . quote ( ENTRY_DELIMITER ) ) ) { if ( ! TextUtils . isEmpty ( entry ) ) { String [ ] parts = entry . split ( Pattern . quote ( LINE_DELIMITER ) ) ; if ( parts . length > 2 ) { data . put ( parts [ 0 ] , new PurchaseInfo ( parts [ 1 ] , parts [ 2 ] ) ) ; } else if ( parts . length > 1 ) { data . put ( parts [ 0 ] , new PurchaseInfo ( parts [ 1 ] , null ) ) ; } } } version = getCurrentVersion ( ) ; }
private void bindPlayServices ( ) { try { Intent iapIntent = new Intent ( " com.android.vending.billing.InAppBillingService.BIND " ) ;
private HashMap < String , Boolean > parseFeature ( String optString ) { if ( optString . equals ( NULL ) ) { return null ;
private String updateUrl ( String url ) { Uri newUrl = Uri . parse ( url ) ; if ( newUrl . isRelative ( ) ) { url = this . webView . getUrl ( ) . substring ( 0 , this . webView . getUrl ( ) . lastIndexOf ( " / " ) + 1 ) + url ; } return url ; }
public String openExternal ( String url ) { try { Intent intent = null ;
private void closeDialog ( ) { try { this . inAppWebView . loadUrl ( " about:blank " ) ; JSONObject obj = new JSONObject ( ) ; obj . put ( " type " , EXIT_EVENT ) ; sendUpdate ( obj , false ) ; } catch ( JSONException ex ) { Log . d ( LOG_TAG , " Should never happen " ) ; } if ( dialog ! = null ) { dialog . dismiss ( ) ;
private void goBack ( ) { if ( this . inAppWebView . canGoBack ( ) ) { this . inAppWebView . goBack ( ) ;
private void goForward ( ) { if ( this . inAppWebView . canGoForward ( ) ) { this . inAppWebView . goForward ( ) ;
private void navigate ( String url ) { InputMethodManager imm = ( InputMethodManager ) this . cordova . getActivity ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( edittext . getWindowToken ( ) , 0 ) ; if ( ! url . startsWith ( " http " ) & & ! url . startsWith ( " file: " ) ) { this . inAppWebView . loadUrl ( " http:// " + url ) ; } else { this . inAppWebView . loadUrl ( url ) ; } this . inAppWebView . requestFocus ( ) ; }
private boolean getShowLocationBar ( ) { return this . showLocationBar ; }
private int dpToPixels ( int dipValue ) { int value = ( int ) TypedValue . applyDimension ( TypedValue . COMPLEX_UNIT_DIP , ( float ) dipValue , cordova . getActivity ( ) . getResources ( ) . getDisplayMetrics ( ) ) ; return value ; }
public void onDismiss ( DialogInterface dialog ) { try { JSONObject obj = new JSONObject ( ) ;
public void onClick ( View v ) { goBack ( ) ; }
public void onClick ( View v ) { goForward ( ) ; }
public boolean onKey ( View v , int keyCode , KeyEvent event ) { // If the event is a key-down event on the "enter" button if ((event.getAction() == KeyEvent.ACTION_DOWN) && (keyCode == KeyEvent.KEYCODE_ENTER)) { navigate(edittext.getText().toString()); return true; } return false; }
public void onClick ( View v ) { closeDialog ( ) ; }
private void sendUpdate ( JSONObject obj , boolean keepCallback ) { sendUpdate ( obj , keepCallback , PluginResult . Status . OK ) ; }
* / private void sendUpdate ( JSONObject obj , boolean keepCallback , PluginResult . Status status ) { PluginResult result = new PluginResult ( status , obj ) ; result . setKeepCallback ( keepCallback ) ; this . callbackContext . sendPluginResult ( result ) ; }
public void onExceededDatabaseQuota ( String url , String databaseIdentifier , long currentQuota , long estimatedSize , long totalUsedQuota , WebStorage . QuotaUpdater quotaUpdater ) { LOG . d ( LOG_TAG , " onExceededDatabaseQuota estimatedSize: %d currentQuota: %d totalUsedQuota: %d " , estimatedSize , currentQuota , totalUsedQuota ) ; if ( estimatedSize < MAX_QUOTA ) {
public void onGeolocationPermissionsShowPrompt ( String origin , Callback callback ) { super . onGeolocationPermissionsShowPrompt ( origin , callback ) ; callback . invoke ( origin , true , false ) ; }
public void onPageFinished ( WebView view , String url ) { super . onPageFinished ( view , url ) ; try { JSONObject obj = new JSONObject ( ) ;
public void onReceivedError ( WebView view , int errorCode , String description , String failingUrl ) { super . onReceivedError ( view , errorCode , description , failingUrl ) ; try { JSONObject obj = new JSONObject ( ) ;
private void injectDeferredObject ( String source , String jsWrapper ) { String scriptToInject ; if ( jsWrapper ! = null ) { org . json . JSONArray jsonEsc = new org . json . JSONArray ( ) ; jsonEsc . put ( source ) ; String jsonRepr = jsonEsc . toString ( ) ; String jsonSourceString = jsonRepr . substring ( 1 , jsonRepr . length ( ) - 1 ) ; scriptToInject = String . format ( jsWrapper , jsonSourceString ) ; } else { scriptToInject = source ; } // This action will have the side-effect of blurring the currently focused element this.inAppWebView.loadUrl("javascript:" + scriptToInject); }
public boolean onJsPrompt ( WebView view , String url , String message , String defaultValue , JsPromptResult result ) { // See if the prompt string uses the 'gap-iab' protocol. If so, the remainder should be the id of a callback to execute. if (defaultValue != null && defaultValue.startsWith("gap-iab://")) { PluginResult scriptResult; String scriptCallbackId = defaultValue.substring(10); if (scriptCallbackId.startsWith("InAppBrowser")) { if(message == null || message.length() == 0) { scriptResult = new PluginResult(PluginResult.Status.OK, new JSONArray()); } else { try { scriptResult = new PluginResult(PluginResult.Status.OK, new JSONArray(message)); } catch(JSONException e) { scriptResult = new PluginResult(PluginResult.Status.JSON_EXCEPTION, e.getMessage()); } } this.webView.sendPluginResult(scriptResult, scriptCallbackId); result.confirm(""); return true; } } return false; }
public void run ( ) { dialog . show ( ) ; }
private void closeDialog ( ) { try { final WebView childView = this . inAppWebView ; Runnable runnable = new Runnable ( ) { @Override public void run ( ) { childView . loadUrl ( " about:blank " ) ; } } ; this . cordova . getActivity ( ) . runOnUiThread ( runnable ) ; JSONObject obj = new JSONObject ( ) ; obj . put ( " type " , EXIT_EVENT ) ; sendUpdate ( obj , false ) ; } catch ( JSONException ex ) { Log . d ( LOG_TAG , " Should never happen " ) ; } if ( dialog ! = null ) { dialog . dismiss ( ) ;
public void run ( ) { childView . loadUrl ( " about:blank " ) ; }
public void onExceededDatabaseQuota ( String url , String databaseIdentifier , long currentQuota , long estimatedSize , long totalUsedQuota , WebStorage . QuotaUpdater quotaUpdater ) { LOG . d ( LOG_TAG , " onExceededDatabaseQuota estimatedSize: %d currentQuota: %d totalUsedQuota: %d " , estimatedSize , currentQuota , totalUsedQuota ) ; if ( estimatedSize < MAX_QUOTA ) {
public void onGeolocationPermissionsShowPrompt ( String origin , Callback callback ) { super . onGeolocationPermissionsShowPrompt ( origin , callback ) ; callback . invoke ( origin , true , false ) ; }
public boolean onJsPrompt ( WebView view , String url , String message , String defaultValue , JsPromptResult result ) { // See if the prompt string uses the 'gap-iab' protocol. If so, the remainder should be the id of a callback to execute. if (defaultValue != null && defaultValue.startsWith("gap-iab://")) { PluginResult scriptResult; String scriptCallbackId = defaultValue.substring(10); if (scriptCallbackId.startsWith("InAppBrowser")) { if(message == null || message.length() == 0) { scriptResult = new PluginResult(PluginResult.Status.OK, new JSONArray()); } else { try { scriptResult = new PluginResult(PluginResult.Status.OK, new JSONArray(message)); } catch(JSONException e) { scriptResult = new PluginResult(PluginResult.Status.JSON_EXCEPTION, e.getMessage()); } } this.webView.sendPluginResult(scriptResult, scriptCallbackId); result.confirm(""); return true; } } return false; }
public boolean onJsPrompt ( WebView view , String url , String message , String defaultValue , JsPromptResult result ) { // See if the prompt string uses the 'gap-iab' protocol. If so, the remainder should be the id of a callback to execute. if (defaultValue != null && defaultValue.startsWith("gap")) { if(defaultValue.startsWith("gap-iab://")) { PluginResult scriptResult; String scriptCallbackId = defaultValue.substring(10); if (scriptCallbackId.startsWith("InAppBrowser")) { if(message == null || message.length() == 0) { scriptResult = new PluginResult(PluginResult.Status.OK, new JSONArray()); } else { try { scriptResult = new PluginResult(PluginResult.Status.OK, new JSONArray(message)); } catch(JSONException e) { scriptResult = new PluginResult(PluginResult.Status.JSON_EXCEPTION, e.getMessage()); } } this.webView.sendPluginResult(scriptResult, scriptCallbackId); result.confirm(""); return true; } } else { // Anything else with a gap: prefix should get this message LOG.w(LOG_TAG, "InAppBrowser does not support Cordova API calls: " + url + " " + defaultValue); result.cancel(); return true; } } return false; }
public void closeDialog ( ) { final WebView childView = this . inAppWebView ; // The JS protects against multiple calls, so this should happen only when // closeDialog() is called by other native code. if (childView == null) { return; } try { Runnable runnable = new Runnable() { @Override public void run() { childView.loadUrl("about:blank"); } }; this.cordova.getActivity().runOnUiThread(runnable); JSONObject obj = new JSONObject(); obj.put("type", EXIT_EVENT); sendUpdate(obj, false); } catch (JSONException ex) { Log.d(LOG_TAG, "Should never happen"); } if (dialog != null) { dialog.dismiss();
public void onReset ( ) { closeDialog ( ) ; }
public void onDismiss ( DialogInterface dialog ) { closeDialog ( ) ; }
private void sendUpdate ( JSONObject obj , boolean keepCallback , PluginResult . Status status ) { if ( callbackContext ! = null ) { PluginResult result = new PluginResult ( status , obj ) ;
public void run ( ) { String result = " " ; // SELF if (SELF.equals(target)) { Log.d(LOG_TAG, "in self"); // load in webview if (url.startsWith("file://") || url.startsWith("javascript:") || Config.isUrlWhiteListed(url)) { webView.loadUrl(url); } //Load the dialer else if (url.startsWith(WebView.SCHEME_TEL)) { try { Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(url)); cordova.getActivity().startActivity(intent); } catch (android.content.ActivityNotFoundException e) { LOG.e(LOG_TAG, "Error dialing " + url + ": " + e.toString()); } } // load in InAppBrowser else { result = showWebPage(url, features); } } // SYSTEM else if (SYSTEM.equals(target)) { Log.d(LOG_TAG, "in system"); result = openExternal(url); } // BLANK - or anything else else { Log.d(LOG_TAG, "in blank"); result = showWebPage(url, features); } PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, result); pluginResult.setKeepCallback(true); callbackContext.sendPluginResult(pluginResult); }
public void run ( ) { dialog . show ( ) ; }
private void injectDeferredObject ( String source , String jsWrapper ) { String scriptToInject ; if ( jsWrapper ! = null ) { org . json . JSONArray jsonEsc = new org . json . JSONArray ( ) ; jsonEsc . put ( source ) ; String jsonRepr = jsonEsc . toString ( ) ; String jsonSourceString = jsonRepr . substring ( 1 , jsonRepr . length ( ) - 1 ) ; scriptToInject = String . format ( jsWrapper , jsonSourceString ) ; } else { scriptToInject = source ; } final String finalScriptToInject = scriptToInject ; // This action will have the side-effect of blurring the currently focused element this.cordova.getActivity().runOnUiThread(new Runnable() { @Override
public void run ( ) { inAppWebView . loadUrl ( " javascript: " + finalScriptToInject ) ; }
public void closeDialog ( ) { final WebView childView = this . inAppWebView ; // The JS protects against multiple calls, so this should happen only when // closeDialog() is called by other native code. if (childView == null) { return; } this.cordova.getActivity().runOnUiThread(new Runnable() { @Override public void run() { childView.loadUrl("about:blank"); if (dialog != null) { dialog.dismiss(); } } }); try { JSONObject obj = new JSONObject();
public void run ( ) { childView . loadUrl ( " about:blank " ) ; if ( dialog ! = null ) { dialog . dismiss ( ) ;
public void run ( ) { String result = " " ; // SELF if (SELF.equals(target)) { Log.d(LOG_TAG, "in self"); // load in webview if (url.startsWith("file://") || url.startsWith("javascript:") || Config.isUrlWhiteListed(url)) { webView.loadUrl(url); } //Load the dialer else if (url.startsWith(AmazonWebView.SCHEME_TEL)) { try { Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(url)); cordova.getActivity().startActivity(intent); } catch (android.content.ActivityNotFoundException e) { LOG.e(LOG_TAG, "Error dialing " + url + ": " + e.toString()); } } // load in InAppBrowser else { result = showWebPage(url, features); } } // SYSTEM else if (SYSTEM.equals(target)) { Log.d(LOG_TAG, "in system"); result = openExternal(url); } // BLANK - or anything else else { Log.d(LOG_TAG, "in blank"); result = showWebPage(url, features); } PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, result); pluginResult.setKeepCallback(true); callbackContext.sendPluginResult(pluginResult); }
private void injectDeferredObject ( String source , String jsWrapper ) { final String scriptToInject ; if ( jsWrapper ! = null ) { org . json . JSONArray jsonEsc = new org . json . JSONArray ( ) ; jsonEsc . put ( source ) ; String jsonRepr = jsonEsc . toString ( ) ; String jsonSourceString = jsonRepr . substring ( 1 , jsonRepr . length ( ) - 1 ) ; scriptToInject = String . format ( jsWrapper , jsonSourceString ) ; } else { scriptToInject = source ; } final String finalScriptToInject = scriptToInject ; // This action will have the side-effect of blurring the currently focused element this.cordova.getActivity().runOnUiThread(new Runnable() { @Override
public void closeDialog ( ) { this . cordova . getActivity ( ) . runOnUiThread ( new Runnable ( ) { public void run ( ) {
public void run ( ) { if ( dialog ! = null ) { dialog . dismiss ( ) ;
private void goBack ( ) { this . cordova . getActivity ( ) . runOnUiThread ( new Runnable ( ) { public void run ( ) {
public void run ( ) { if ( InAppBrowser . this . inAppWebView . canGoBack ( ) ) { InAppBrowser . this . inAppWebView . goBack ( ) ;
private void goForward ( ) { this . cordova . getActivity ( ) . runOnUiThread ( new Runnable ( ) { public void run ( ) {
public void run ( ) { if ( InAppBrowser . this . inAppWebView . canGoForward ( ) ) { InAppBrowser . this . inAppWebView . goForward ( ) ;
private void navigate ( final String url ) { InputMethodManager imm = ( InputMethodManager ) this . cordova . getActivity ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( edittext . getWindowToken ( ) , 0 ) ; this . cordova . getActivity ( ) . runOnUiThread ( new Runnable ( ) { public void run ( ) {
public void run ( ) { if ( ! url . startsWith ( " http " ) & & ! url . startsWith ( " file: " ) ) { InAppBrowser . this . inAppWebView . loadUrl ( " http:// " + url ) ; } else { InAppBrowser . this . inAppWebView . loadUrl ( url ) ; } InAppBrowser . this . inAppWebView . requestFocus ( ) ; }
public void onPageFinished ( AmazonWebView view , String url ) { super . onPageFinished ( view , url ) ; try { JSONObject obj = new JSONObject ( ) ;
public void onReceivedError ( AmazonWebView view , int errorCode , String description , String failingUrl ) { super . onReceivedError ( view , errorCode , description , failingUrl ) ; try { JSONObject obj = new JSONObject ( ) ;
public void onExceededDatabaseQuota ( String url , String databaseIdentifier , long currentQuota , long estimatedSize , long totalUsedQuota , AmazonWebStorage . QuotaUpdater quotaUpdater ) { LOG . d ( LOG_TAG , " onExceededDatabaseQuota estimatedSize: %d currentQuota: %d totalUsedQuota: %d " , estimatedSize , currentQuota , totalUsedQuota ) ; if ( estimatedSize < MAX_QUOTA ) {
public boolean onJsPrompt ( AmazonWebView view , String url , String message , String defaultValue , AmazonJsPromptResult result ) { // See if the prompt string uses the 'gap-iab' protocol. If so, the remainder should be the id of a callback to execute. if (defaultValue != null && defaultValue.startsWith("gap")) { if(defaultValue.startsWith("gap-iab://")) { PluginResult scriptResult; String scriptCallbackId = defaultValue.substring(10); if (scriptCallbackId.startsWith("InAppBrowser")) { if(message == null || message.length() == 0) { scriptResult = new PluginResult(PluginResult.Status.OK, new JSONArray()); } else { try { scriptResult = new PluginResult(PluginResult.Status.OK, new JSONArray(message)); } catch(JSONException e) { scriptResult = new PluginResult(PluginResult.Status.JSON_EXCEPTION, e.getMessage()); } } this.webView.sendPluginResult(scriptResult, scriptCallbackId); result.confirm(""); return true; } } else { // Anything else with a gap: prefix should get this message LOG.w(LOG_TAG, "InAppBrowser does not support Cordova API calls: " + url + " " + defaultValue); result.cancel(); return true; } } return false; }
public void onExceededDatabaseQuota ( String url , String databaseIdentifier , long currentQuota , long estimatedSize , long totalUsedQuota , WebStorage . QuotaUpdater quotaUpdater ) { LOG . d ( LOG_TAG , " onExceededDatabaseQuota estimatedSize: %d currentQuota: %d totalUsedQuota: %d " , estimatedSize , currentQuota , totalUsedQuota ) ; quotaUpdater . updateQuota ( MAX_QUOTA ) ; }
private void injectDeferredObject ( String source , String jsWrapper ) { String scriptToInject ; if ( jsWrapper ! = null ) { org . json . JSONArray jsonEsc = new org . json . JSONArray ( ) ; jsonEsc . put ( source ) ; String jsonRepr = jsonEsc . toString ( ) ; String jsonSourceString = jsonRepr . substring ( 1 , jsonRepr . length ( ) - 1 ) ; scriptToInject = String . format ( jsWrapper , jsonSourceString ) ; } else { scriptToInject = source ; } final String finalScriptToInject = scriptToInject ; this . cordova . getActivity ( ) . runOnUiThread ( new Runnable ( ) { @SuppressLint ( " NewApi " )
public void run ( ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . KITKAT ) { // This action will have the side-effect of blurring the currently focused element
public void closeDialog ( ) { final WebView childView = this . inAppWebView ; // The JS protects against multiple calls, so this should happen only when // closeDialog() is called by other native code. if (childView == null) { return; } this.cordova.getActivity().runOnUiThread(new Runnable() { @Override public void run() { childView.setWebViewClient(new WebViewClient() { // NB: wait for about:blank before dismissing public void onPageFinished(WebView view, String url) { if (dialog != null) { dialog.dismiss(); } } }); // NB: From SDK 19: "If you call methods on WebView from any thread // other than your app's UI thread, it can cause unexpected results." // http://developer.android.com/guide/webapps/migrating.html#Threads childView.loadUrl("about:blank"); } }); try { JSONObject obj = new JSONObject();
public void run ( ) { childView . setWebViewClient ( new WebViewClient ( ) { // NB: wait for about:blank before dismissing public void onPageFinished(WebView view, String url) { if (dialog != null) { dialog.dismiss(); } } }); // NB: From SDK 19: "If you call methods on WebView from any thread // other than your app's UI thread, it can cause unexpected results." // http://developer.android.com/guide/webapps/migrating.html#Threads childView.loadUrl("about:blank"); }
public void onPageFinished ( WebView view , String url ) { if ( dialog ! = null ) { dialog . dismiss ( ) ;
private InAppBrowser getInAppBrowser ( ) { return this ; }
public void setInAppBroswer ( InAppBrowser browser ) { this . inAppBrowser = browser ; }
public void onBackPressed ( ) { if ( this . inAppBrowser = = null ) { this . dismiss ( ) ;
public void goBack ( ) { if ( this . inAppWebView . canGoBack ( ) ) { this . inAppWebView . goBack ( ) ;
public boolean canGoBack ( ) { return this . inAppWebView . canGoBack ( ) ; }
public boolean hardwareBack ( ) { return hadwareBackButton ; }
private void injectDeferredObject ( String source , String jsWrapper ) { final String scriptToInject ; if ( jsWrapper ! = null ) { org . json . JSONArray jsonEsc = new org . json . JSONArray ( ) ; jsonEsc . put ( source ) ; String jsonRepr = jsonEsc . toString ( ) ; String jsonSourceString = jsonRepr . substring ( 1 , jsonRepr . length ( ) - 1 ) ; scriptToInject = String . format ( jsWrapper , jsonSourceString ) ; } else { scriptToInject = source ; } final String finalScriptToInject = scriptToInject ; this . cordova . getActivity ( ) . runOnUiThread ( new Runnable ( ) { @SuppressLint ( " NewApi " )
public void closeDialog ( ) { final AmazonWebView childView = this . inAppWebView ; // The JS protects against multiple calls, so this should happen only when // closeDialog() is called by other native code. if (childView == null) { return; } this.cordova.getActivity().runOnUiThread(new Runnable() { @Override public void run() { childView.setWebViewClient(new AmazonWebViewClient() { // NB: wait for about:blank before dismissing public void onPageFinished(AmazonWebView view, String url) { if (dialog != null) { dialog.dismiss(); } } }); // NB: From SDK 19: "If you call methods on WebView from any thread // other than your app's UI thread, it can cause unexpected results." // http://developer.android.com/guide/webapps/migrating.html#Threads childView.loadUrl("about:blank"); } }); try { JSONObject obj = new JSONObject();
public void run ( ) { childView . setWebViewClient ( new AmazonWebViewClient ( ) { // NB: wait for about:blank before dismissing public void onPageFinished(AmazonWebView view, String url) { if (dialog != null) { dialog.dismiss(); } } }); // NB: From SDK 19: "If you call methods on WebView from any thread // other than your app's UI thread, it can cause unexpected results." // http://developer.android.com/guide/webapps/migrating.html#Threads childView.loadUrl("about:blank"); }
public void onPageFinished ( AmazonWebView view , String url ) { if ( dialog ! = null ) { dialog . dismiss ( ) ;
public void run ( ) { String result = " " ; // SELF if (SELF.equals(target)) { Log.d(LOG_TAG, "in self"); // load in webview if (url.startsWith("file://") || url.startsWith("javascript:") || Config.isUrlWhiteListed(url)) { Log.d(LOG_TAG, "loading in webview"); webView.loadUrl(url); } //Load the dialer else if (url.startsWith(WebView.SCHEME_TEL)) { try { Log.d(LOG_TAG, "loading in dialer"); Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(url)); cordova.getActivity().startActivity(intent); } catch (android.content.ActivityNotFoundException e) { LOG.e(LOG_TAG, "Error dialing " + url + ": " + e.toString()); } } // load in InAppBrowser else { Log.d(LOG_TAG, "loading in InAppBrowser"); result = showWebPage(url, features); } } // SYSTEM else if (SYSTEM.equals(target)) { Log.d(LOG_TAG, "in system"); result = openExternal(url); } // BLANK - or anything else else { Log.d(LOG_TAG, "in blank"); result = showWebPage(url, features); } PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, result); pluginResult.setKeepCallback(true); callbackContext.sendPluginResult(pluginResult); }
private boolean getShowZoomControls ( ) { return this . showZoomControls ; }
public void run ( ) { String result = " " ; // SELF if (SELF.equals(target)) { Log.d(LOG_TAG, "in self"); // load in webview if (url.startsWith("file://") || url.startsWith("javascript:") || Config.isUrlWhiteListed(url)) { Log.d(LOG_TAG, "loading in webview"); webView.loadUrl(url); } //Load the dialer else if (url.startsWith(AmazonWebView.SCHEME_TEL)) { try { Log.d(LOG_TAG, "loading in dialer"); Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(url)); cordova.getActivity().startActivity(intent); } catch (android.content.ActivityNotFoundException e) { LOG.e(LOG_TAG, "Error dialing " + url + ": " + e.toString()); } } // load in InAppBrowser else { Log.d(LOG_TAG, "loading in InAppBrowser"); result = showWebPage(url, features); } } // SYSTEM else if (SYSTEM.equals(target)) { Log.d(LOG_TAG, "in system"); result = openExternal(url); } // BLANK - or anything else else { Log.d(LOG_TAG, "in blank"); result = showWebPage(url, features); } PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, result); pluginResult.setKeepCallback(true); callbackContext.sendPluginResult(pluginResult); }
public static List < VirtualMachineDescriptor > list ( ) { throw new UnsupportedOperationException ( " You should add tools.jar to classpath " ) ; }
public static VirtualMachine attach ( String id ) throws AttachNotSupportedException , IOException { throw new UnsupportedOperationException ( " You should add tools.jar to classpath " ) ; }
public static VirtualMachine attach ( VirtualMachineDescriptor vmd ) throws AttachNotSupportedException , IOException { throw new UnsupportedOperationException ( " You should add tools.jar to classpath " ) ; }
public abstract Properties getSystemProperties ( ) throws IOException ; /** * Returns the current <i>agent properties</i> in the target virtual * machine. * * <p> The target virtual machine can maintain a list of properties on * behalf of agents. The manner in which this is done, the names of the * properties, and the types of values that are allowed, is implementation * specific. Agent properties are typically used to store communication * end-points and other agent configuration details. For example, a debugger * agent might create an agent property for its transport address. * * <p> This method returns the agent properties whose key and value is a * <tt>String</tt>. Properties whose key or value is not a <tt>String</tt> * are omitted. If there are no agent properties maintained in the target * virtual machine then an empty property list is returned. * * @return The agent properties * * @throws IOException * If an I/O error occurs */ public abstract Properties getAgentProperties ( ) throws IOException ; /** * Returns a hash-code value for this VirtualMachine. The hash * code is based upon the VirtualMachine's components, and satifies * the general contract of the {@link java.lang.Object#hashCode() * Object.hashCode} method. * * @return A hash-code value for this virtual machine */ public abstract int hashCode ( ) ; /** * Tests this VirtualMachine for equality with another object. * * <p> If the given object is not a VirtualMachine then this * method returns <tt>false</tt>. For two VirtualMachines to * be considered equal requires that they both reference the same * provider, and their {@link VirtualMachineDescriptor#id() identifiers} are equal. </p> * * <p> This method satisfies the general contract of the {@link * java.lang.Object#equals(Object) Object.equals} method. </p> * * @param ob The object to which this object is to be compared * * @return <tt>true</tt> if, and only if, the given object is * a VirtualMachine that is equal to this * VirtualMachine. */ public abstract boolean equals ( Object ob ) ; /** * Returns the string representation of the <code>VirtualMachine</code>. */ public abstract String toString ( ) ; }
public abstract Properties getAgentProperties ( ) throws IOException ; /** * Returns a hash-code value for this VirtualMachine. The hash * code is based upon the VirtualMachine's components, and satifies * the general contract of the {@link java.lang.Object#hashCode() * Object.hashCode} method. * * @return A hash-code value for this virtual machine */ public abstract int hashCode ( ) ; /** * Tests this VirtualMachine for equality with another object. * * <p> If the given object is not a VirtualMachine then this * method returns <tt>false</tt>. For two VirtualMachines to * be considered equal requires that they both reference the same * provider, and their {@link VirtualMachineDescriptor#id() identifiers} are equal. </p> * * <p> This method satisfies the general contract of the {@link * java.lang.Object#equals(Object) Object.equals} method. </p> * * @param ob The object to which this object is to be compared * * @return <tt>true</tt> if, and only if, the given object is * a VirtualMachine that is equal to this * VirtualMachine. */ public abstract boolean equals ( Object ob ) ; /** * Returns the string representation of the <code>VirtualMachine</code>. */ public abstract String toString ( ) ; }
public abstract int hashCode ( ) ; /** * Tests this VirtualMachine for equality with another object. * * <p> If the given object is not a VirtualMachine then this * method returns <tt>false</tt>. For two VirtualMachines to * be considered equal requires that they both reference the same * provider, and their {@link VirtualMachineDescriptor#id() identifiers} are equal. </p> * * <p> This method satisfies the general contract of the {@link * java.lang.Object#equals(Object) Object.equals} method. </p> * * @param ob The object to which this object is to be compared * * @return <tt>true</tt> if, and only if, the given object is * a VirtualMachine that is equal to this * VirtualMachine. */ public abstract boolean equals ( Object ob ) ; /** * Returns the string representation of the <code>VirtualMachine</code>. */ public abstract String toString ( ) ; }
public abstract boolean equals ( Object ob ) ; /** * Returns the string representation of the <code>VirtualMachine</code>. */ public abstract String toString ( ) ; }
public abstract AttachProvider provider ( ) ; /** * Return the identifier component of this descriptor. * * @return The identifier component of this descriptor. */ public abstract String id ( ) ; /** * Return the <i>display name</i> component of this descriptor. * * @return The display name component of this descriptor. */ public abstract String displayName ( ) ; /** * Returns a hash-code value for this VirtualMachineDescriptor. The hash * code is based upon the descriptor's components, and satifies * the general contract of the {@link java.lang.Object#hashCode() * Object.hashCode} method. * * @return A hash-code value for this descriptor. */ public abstract int hashCode ( ) ; /** * Tests this VirtualMachineDescriptor for equality with another object. * * <p> If the given object is not a VirtualMachineDescriptor then this * method returns <tt>false</tt>. For two VirtualMachineDescriptors to * be considered equal requires that they both reference the same * provider, and their {@link #id() identifiers} are equal. </p> * * <p> This method satisfies the general contract of the {@link * java.lang.Object#equals(Object) Object.equals} method. </p> * * @param ob The object to which this object is to be compared * * @return <tt>true</tt> if, and only if, the given object is * a VirtualMachineDescriptor that is equal to this * VirtualMachineDescriptor. */ public abstract boolean equals ( Object ob ) ; /** * Returns the string representation of the <code>VirtualMachineDescriptor</code>. */ public abstract String toString ( ) ; }
public abstract String id ( ) ; /** * Return the <i>display name</i> component of this descriptor. * * @return The display name component of this descriptor. */ public abstract String displayName ( ) ; /** * Returns a hash-code value for this VirtualMachineDescriptor. The hash * code is based upon the descriptor's components, and satifies * the general contract of the {@link java.lang.Object#hashCode() * Object.hashCode} method. * * @return A hash-code value for this descriptor. */ public abstract int hashCode ( ) ; /** * Tests this VirtualMachineDescriptor for equality with another object. * * <p> If the given object is not a VirtualMachineDescriptor then this * method returns <tt>false</tt>. For two VirtualMachineDescriptors to * be considered equal requires that they both reference the same * provider, and their {@link #id() identifiers} are equal. </p> * * <p> This method satisfies the general contract of the {@link * java.lang.Object#equals(Object) Object.equals} method. </p> * * @param ob The object to which this object is to be compared * * @return <tt>true</tt> if, and only if, the given object is * a VirtualMachineDescriptor that is equal to this * VirtualMachineDescriptor. */ public abstract boolean equals ( Object ob ) ; /** * Returns the string representation of the <code>VirtualMachineDescriptor</code>. */ public abstract String toString ( ) ; }
public abstract String displayName ( ) ; /** * Returns a hash-code value for this VirtualMachineDescriptor. The hash * code is based upon the descriptor's components, and satifies * the general contract of the {@link java.lang.Object#hashCode() * Object.hashCode} method. * * @return A hash-code value for this descriptor. */ public abstract int hashCode ( ) ; /** * Tests this VirtualMachineDescriptor for equality with another object. * * <p> If the given object is not a VirtualMachineDescriptor then this * method returns <tt>false</tt>. For two VirtualMachineDescriptors to * be considered equal requires that they both reference the same * provider, and their {@link #id() identifiers} are equal. </p> * * <p> This method satisfies the general contract of the {@link * java.lang.Object#equals(Object) Object.equals} method. </p> * * @param ob The object to which this object is to be compared * * @return <tt>true</tt> if, and only if, the given object is * a VirtualMachineDescriptor that is equal to this * VirtualMachineDescriptor. */ public abstract boolean equals ( Object ob ) ; /** * Returns the string representation of the <code>VirtualMachineDescriptor</code>. */ public abstract String toString ( ) ; }
public abstract int hashCode ( ) ; /** * Tests this VirtualMachineDescriptor for equality with another object. * * <p> If the given object is not a VirtualMachineDescriptor then this * method returns <tt>false</tt>. For two VirtualMachineDescriptors to * be considered equal requires that they both reference the same * provider, and their {@link #id() identifiers} are equal. </p> * * <p> This method satisfies the general contract of the {@link * java.lang.Object#equals(Object) Object.equals} method. </p> * * @param ob The object to which this object is to be compared * * @return <tt>true</tt> if, and only if, the given object is * a VirtualMachineDescriptor that is equal to this * VirtualMachineDescriptor. */ public abstract boolean equals ( Object ob ) ; /** * Returns the string representation of the <code>VirtualMachineDescriptor</code>. */ public abstract String toString ( ) ; }
public abstract boolean equals ( Object ob ) ; /** * Returns the string representation of the <code>VirtualMachineDescriptor</code>. */ public abstract String toString ( ) ; }
public abstract VirtualMachine attachVirtualMachine ( VirtualMachineDescriptor vmd ) throws AttachNotSupportedException , IOException ; /** * Lists the Java virtual machines known to this provider. * * <p> This method returns a list of {@link * com.sun.tools.attach.VirtualMachineDescriptor} elements. Each * <code>VirtualMachineDescriptor</code> describes a Java virtual machine * to which this provider can <i>potentially</i> attach. There isn't any * guarantee that invoking {@link #attachVirtualMachine(VirtualMachineDescriptor) * attachVirtualMachine} on each descriptor in the list will succeed. * * @return The list of virtual machine descriptors which describe the * Java virtual machines known to this provider (may be empty). */ public abstract List < VirtualMachineDescriptor > listVirtualMachines ( ) ; /** * Returns a list of the installed attach providers. * * <p> An AttachProvider is installed on the platform if: * * <ul> * <li><p>It is installed in a JAR file that is visible to the defining * class loader of the AttachProvider type (usually, but not required * to be, the {@link java.lang.ClassLoader#getSystemClassLoader system * class loader}).</p></li> * * <li><p>The JAR file contains a provider configuration named * <tt>com.sun.tools.attach.spi.AttachProvider</tt> in the resource directory * <tt>META-INF/services</tt>. </p></li> * * <li><p>The provider configuration file lists the full-qualified class * name of the AttachProvider implementation. </p></li> * </ul> * * <p> The format of the provider configuration file is one fully-qualified * class name per line. Space and tab characters surrounding each class name, * as well as blank lines are ignored. The comment character is * <tt>'#'</tt> (<tt>0x23</tt>), and on each line all characters following * the first comment character are ignored. The file must be encoded in * UTF-8. </p> * * <p> AttachProvider implementations are loaded and instantiated * (using the zero-arg constructor) at the first invocation of this method. * The list returned by the first invocation of this method is the list * of providers. Subsequent invocations of this method return a list of the same * providers. The list is unmodifable.</p> * * @return A list of the installed attach providers. */ public static List < AttachProvider > providers ( ) { throw new UnsupportedOperationException ( " You should add tools.jar to classpath " ) ; } }
public abstract List < VirtualMachineDescriptor > listVirtualMachines ( ) ; /** * Returns a list of the installed attach providers. * * <p> An AttachProvider is installed on the platform if: * * <ul> * <li><p>It is installed in a JAR file that is visible to the defining * class loader of the AttachProvider type (usually, but not required * to be, the {@link java.lang.ClassLoader#getSystemClassLoader system * class loader}).</p></li> * * <li><p>The JAR file contains a provider configuration named * <tt>com.sun.tools.attach.spi.AttachProvider</tt> in the resource directory * <tt>META-INF/services</tt>. </p></li> * * <li><p>The provider configuration file lists the full-qualified class * name of the AttachProvider implementation. </p></li> * </ul> * * <p> The format of the provider configuration file is one fully-qualified * class name per line. Space and tab characters surrounding each class name, * as well as blank lines are ignored. The comment character is * <tt>'#'</tt> (<tt>0x23</tt>), and on each line all characters following * the first comment character are ignored. The file must be encoded in * UTF-8. </p> * * <p> AttachProvider implementations are loaded and instantiated * (using the zero-arg constructor) at the first invocation of this method. * The list returned by the first invocation of this method is the list * of providers. Subsequent invocations of this method return a list of the same * providers. The list is unmodifable.</p> * * @return A list of the installed attach providers. */ public static List < AttachProvider > providers ( ) { throw new UnsupportedOperationException ( " You should add tools.jar to classpath " ) ; } }
public static List < AttachProvider > providers ( ) { throw new UnsupportedOperationException ( " You should add tools.jar to classpath " ) ; }
public static void main ( String [ ] args ) { if ( REPORT_CPU ) { CpuUsageReporter . startReporter ( System . out , 15000 ) ; } long tenuredSize = Runtime . getRuntime ( ) . maxMemory ( ) ; // getting more accurate data for(MemoryPoolMXBean bean : ManagementFactory.getMemoryPoolMXBeans()) { if ("Tenured Gen".equals(bean.getName()) || "PS Old Gen".equals(bean.getName()) || "CMS Old Gen".equals(bean.getName())) { tenuredSize = bean.getUsage().getMax(); System.out.println("Exact tenured space size is " + tenuredSize); } } long limit = 0; if (args.length == 1) { limit = Long.parseLong(args[0]); System.out.println("Runlimit: " + limit + "secs"); limit = TimeUnit.SECONDS.toMillis(limit); } if (CMS_MODE) { HEADROOM = 0; } int count = (int) ((tenuredSize - (HEADROOM << 20)) / ENTRY_SIZE); if (CMS_MODE) { count /= 2; System.out.println("CMS mode is enabled"); } System.out.println("Total old space: " + (tenuredSize >> 20) + "M (-" + HEADROOM + "M)"); if (count < 0) { System.out.println("Heap size is too small, increase heap size or reduce headroom"); } System.out.println("Populating - " + count); maps = new Map[(count + 200000 -1) / 200000]; for(int i = 0; i != maps.length; ++i) { maps[i] = new HashMap<Integer, Object>(); } while(size() < count) { putRandom(count); if (CMS_MODE & random.nextInt(10) > 7) { removeRandom(count); } } int n = 0; int sz = 0; if (!DRY_MODE) { System.out.println("Processing ..."); } else { System.out.println("Processing ... (DRY MODE ENABLED)"); } GCSelfMonitor gcmonitor = new GCSelfMonitor(); // start count down here long startTime = System.currentTimeMillis(); while(true) { if (n % 100 == 0) { sz = size(); } ++n; if ((sz < 1.01 * count) && random.nextBoolean()) { if (DRY_MODE) { dryPutRandom(count); } else { putRandom(count); } } else { if (DRY_MODE) { dryRemoveRandom(count); } else { removeRandom(count); } } if (limit != 0 && (System.currentTimeMillis() > (startTime + limit))) { System.out.println("Finished"); break; } } gcmonitor.displayStats(); }
private static int size ( ) { int size = 0 ; for ( Map map : maps ) { size + = map . size ( ) ; } return size ; }
private static void putRandom ( int count ) { int key = random . nextInt ( 2 * count ) ; Object val = STRING_MODE ? new String ( STRING_TEMPLATE ) : new Integer ( random . nextInt ( ) ) ; maps [ key % maps . length ] . put ( key , val ) ; }
private static void dryPutRandom ( int count ) { int key = random . nextInt ( 2 * count ) ; Object val = STRING_MODE ? new String ( STRING_TEMPLATE ) : new Integer ( random . nextInt ( ) ) ; val . equals ( maps [ key % maps . length ] . get ( key ) ) ; }
private static void removeRandom ( int count ) { int key = random . nextInt ( 2 * count ) ; maps [ key % maps . length ] . remove ( key ) ; }
private static void dryRemoveRandom ( int count ) { int key = random . nextInt ( 2 * count ) ; maps [ key % maps . length ] . get ( key ) ; }
public static final String toTimestamp ( long millis ) { return String . format ( TIME_STAMP , millis ) ; }
public static final String toDatestamp ( long millis ) { return String . format ( DATE_STAMP , millis ) ; }
public static final String toFileDatestamp ( long millis ) { return String . format ( FILE_DATE_STAMP , millis ) ; }
public static final String currentDatestamp ( ) { return toDatestamp ( System . currentTimeMillis ( ) ) ; }
public static final String currentFileDatestamp ( ) { return toFileDatestamp ( System . currentTimeMillis ( ) ) ; }
public static void main ( String [ ] args ) { System . out . println ( " DATE_STAMP: " + String . format ( DATE_STAMP , System . currentTimeMillis ( ) ) ) ; System . out . println ( " FILE_DATE_STAMP: " + String . format ( FILE_DATE_STAMP , System . currentTimeMillis ( ) ) ) ; System . out . println ( " ZERO_LEAD_DECIMAL_6: " + String . format ( ZERO_LEAD_DECIMAL_6 , 1234 ) ) ; }
protected abstract List < GarbageCollectorMXBean > getGarbageCollectorMXBeans ( ) ; protected void initSnapshot ( ) { for ( GarbageCollectorMXBean gcbean : getGarbageCollectorMXBeans ( ) ) { CollectorTracker tracker = new CollectorTracker ( gcbean ) ; trackers . put ( gcbean . getName ( ) , tracker ) ; } } public void displayStats ( ) { for ( GarbageCollectorMXBean gcbean : getGarbageCollectorMXBeans ( ) ) { CollectorTracker tracker = trackers . get ( gcbean . getName ( ) ) ; if ( tracker ! = null ) { System . out . println ( tracker . calculateStats ( gcbean ) ) ; } } } protected static class CollectorTracker { private String name ; private long initialCount ; private long initialTime ; public CollectorTracker ( GarbageCollectorMXBean gcbean ) { this . name = gcbean . getName ( ) ; this . initialCount = gcbean . getCollectionCount ( ) ; this . initialTime = gcbean . getCollectionTime ( ) ; } public String calculateStats ( GarbageCollectorMXBean gcbean ) { long count = gcbean . getCollectionCount ( ) ; long time = gcbean . getCollectionTime ( ) ; while ( gcbean . getCollectionCount ( ) ! = count ) { count = gcbean . getCollectionCount ( ) ; time = gcbean . getCollectionTime ( ) ; } double avg = ( ( double ) ( time - initialTime ) ) / ( ( double ) ( count - initialCount ) ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( String . format ( " %s[ collections: %d | avg: %.4f secs | total: %.1f secs ] " , name , count - initialCount , avg / 1000 d , ( time - initialTime ) / 1000 d ) ) ; return builder . toString ( ) ; } } }
protected void initSnapshot ( ) { for ( GarbageCollectorMXBean gcbean : getGarbageCollectorMXBeans ( ) ) { CollectorTracker tracker = new CollectorTracker ( gcbean ) ;
public void displayStats ( ) { for ( GarbageCollectorMXBean gcbean : getGarbageCollectorMXBeans ( ) ) { CollectorTracker tracker = trackers . get ( gcbean . getName ( ) ) ;
public String calculateStats ( GarbageCollectorMXBean gcbean ) { long count = gcbean . getCollectionCount ( ) ; long time = gcbean . getCollectionTime ( ) ; while ( gcbean . getCollectionCount ( ) ! = count ) { count = gcbean . getCollectionCount ( ) ; time = gcbean . getCollectionTime ( ) ; } double avg = ( ( double ) ( time - initialTime ) ) / ( ( double ) ( count - initialCount ) ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( String . format ( " %s[ collections: %d | avg: %.4f secs | total: %.1f secs ] " , name , count - initialCount , avg / 1000 d , ( time - initialTime ) / 1000 d ) ) ; return builder . toString ( ) ; }
public static void startReporter ( ) { startReporter ( System . out , TimeUnit . SECONDS . toMillis ( 60 ) ) ; }
public static void startReporter ( PrintStream ps , long reportInterval ) { CpuUsageReporterDaemon reporter = new CpuUsageReporterDaemon ( ps , reportInterval ) ; Thread thread = new Thread ( reporter ) ; thread . setDaemon ( true ) ; thread . setName ( " CPU usage reporter " ) ; thread . start ( ) ; }
public void run ( ) { lastTimestamp = System . nanoTime ( ) ; lastProcessCpuTime = getProcessCpuTime ( ) ; while ( true ) {
private long getProcessCpuTime ( ) { return ( ( com . sun . management . OperatingSystemMXBean ) ManagementFactory . getOperatingSystemMXBean ( ) ) . getProcessCpuTime ( ) ; }
public static void main ( String [ ] args ) throws Exception { String pid = args [ 0 ] ; System . out . println ( " Attaching: " + pid ) ; VirtualMachine jvm = VirtualMachine . attach ( pid ) ; String addr = attachManagementAgent ( jvm ) ; System . out . println ( " JVM JMX uri: " + addr ) ; JMXServiceURL jmxurl = new JMXServiceURL ( addr ) ; JMXConnector conn = JMXConnectorFactory . connect ( jmxurl ) ; MBeanServerConnection mserver = conn . getMBeanServerConnection ( ) ; System . out . println ( " MBean server connected " ) ; MBeanGCMonitor rmon = new MBeanGCMonitor ( mserver ) ; MBeanGCMonitor pmon = new MBeanGCMonitor ( mserver ) ; final MBeanGCMonitor fmon = new MBeanGCMonitor ( mserver ) ; Thread freport = new Thread ( ) { @Override public void run ( ) { System . out . println ( " \ nTotal " ) ; System . out . println ( fmon . calculateStats ( ) ) ; } } ; Runtime . getRuntime ( ) . addShutdownHook ( freport ) ; long interval = 60000 ; long deadline = System . currentTimeMillis ( ) + interval ; System . out . println ( " Collecting GC stats ... " ) ; while ( true ) { while ( System . currentTimeMillis ( ) < deadline ) {
public void run ( ) { System . out . println ( " \ nTotal " ) ; System . out . println ( fmon . calculateStats ( ) ) ; }
private static String attachManagementAgent ( VirtualMachine vm ) throws Exception { Properties localProperties = vm . getAgentProperties ( ) ; if ( localProperties . containsKey ( " com.sun.management.jmxremote.localConnectorAddress " ) ) { return ( ( String ) localProperties . get ( " com.sun.management.jmxremote.localConnectorAddress " ) ) ; } String jhome = vm . getSystemProperties ( ) . getProperty ( " java.home " ) ; Object localObject = jhome + File . separator + " jre " + File . separator + " lib " + File . separator + " management-agent.jar " ; File localFile = new File ( ( String ) localObject ) ; if ( ! ( localFile . exists ( ) ) ) { localObject = jhome + File . separator + " lib " + File . separator + " management-agent.jar " ; localFile = new File ( ( String ) localObject ) ; if ( ! ( localFile . exists ( ) ) ) { throw new IOException ( " Management agent not found " ) ; } } localObject = localFile . getCanonicalPath ( ) ; try { vm . loadAgent ( ( String ) localObject , " com.sun.management.jmxremote " ) ; } catch ( Exception e ) { throw e ; } localProperties = vm . getAgentProperties ( ) ; return ( ( String ) localProperties . get ( " com.sun.management.jmxremote.localConnectorAddress " ) ) ; }
private List < GarbageCollectorMXBean > getGarbageCollectorMXBeans ( ) { return ManagementFactory . getGarbageCollectorMXBeans ( ) ; }
public static void main ( String [ ] args ) { System . gc ( ) ; for ( GarbageCollectorMXBean gcbean : ManagementFactory . getGarbageCollectorMXBeans ( ) ) { System . out . println ( gcbean . getName ( ) ) ;
public String report ( ) { dumpThreads ( ) ; StringBuilder sb = new StringBuilder ( ) ; long currentTime = System . nanoTime ( ) ; long timeSplit = currentTime - lastTimestamp ; long currentCpuTime = getProcessCpuTime ( ) ; Map < Long , ThreadNote > newNotes = new HashMap < Long , ThreadNote > ( ) ; Set < String > report = new TreeSet < String > ( ) ; BigInteger totalCpu = BigInteger . valueOf ( 0 ) ; BigInteger totalUser = BigInteger . valueOf ( 0 ) ; for ( long tid : getAllThreadIds ( ) ) { ThreadNote lastNote = notes . get ( tid ) ; ThreadNote newNote = new ThreadNote ( ) ; newNote . lastCpuTime = getThreadCpuTime ( tid ) ; newNote . lastUserTime = getThreadUserTime ( tid ) ; newNotes . put ( tid , newNote ) ; totalCpu = totalCpu . add ( BigInteger . valueOf ( newNote . lastCpuTime ) ) ; totalUser = totalUser . add ( BigInteger . valueOf ( newNote . lastUserTime ) ) ; if ( lastNote ! = null ) { double cpuT = ( ( double ) ( newNote . lastCpuTime - lastNote . lastCpuTime ) ) / timeSplit ; double userT = ( ( double ) ( newNote . lastUserTime - lastNote . lastUserTime ) ) / timeSplit ; StringBuffer buf = new StringBuffer ( ) ; buf . append ( String . format ( " [%06d] user=%.2f%% sys=%.2f%% - %s " , tid , 100 * userT , 100 * ( cpuT - userT ) , getThreadName ( tid ) ) ) ; report . add ( buf . toString ( ) ) ; } } if ( report . size ( ) > 0 ) { double processT = ( ( double ) ( currentCpuTime - lastProcessCpuTime ) ) / timeSplit ; double cpuT = ( ( double ) ( totalCpu . subtract ( lastCummulativeCpuTime ) . longValue ( ) ) ) / timeSplit ; double userT = ( ( double ) ( totalUser . subtract ( lastCummulativeUserTime ) . longValue ( ) ) ) / timeSplit ; sb . append ( Formats . toDatestamp ( System . currentTimeMillis ( ) ) ) ; sb . append ( String . format ( " CPU usage \ n process cpu=%.2f%% \ n application: cpu=%.2f%% (user=%.2f%% sys=%.2f%%) \ n other: cpu=%.2f%% \ n " , 100 * processT , 100 * cpuT , 100 * userT , 100 * ( cpuT - userT ) , 100 * ( processT - cpuT ) ) ) ; for ( String line : report ) { sb . append ( line ) . append ( '\n' ) ; } sb . append ( " \ n " ) ; } lastTimestamp = currentTime ; notes = newNotes ; lastCummulativeCpuTime = totalCpu ; lastCummulativeUserTime = totalUser ; lastProcessCpuTime = currentCpuTime ; return sb . toString ( ) ; }
private void dumpThreads ( ) { try { ObjectName bean = new ObjectName ( " java.lang:type=Threading " ) ;
private Object getThreadName ( long tid ) { try { CompositeData info = threadDump . get ( tid ) ;
private Collection < Long > getAllThreadIds ( ) { return threadDump . keySet ( ) ; }
private long getThreadCpuTime ( long tid ) { try { ObjectName bean = new ObjectName ( " java.lang:type=Threading " ) ;
private long getThreadUserTime ( long tid ) { try { ObjectName bean = new ObjectName ( " java.lang:type=Threading " ) ;
private long getProcessCpuTime ( ) { try { ObjectName bean = new ObjectName ( " java.lang:type=OperatingSystem " ) ;
private void initTrackers ( ) { try { for ( ObjectName name : connection . queryNames ( null , null ) ) {
public String calculateStats ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( CollectorTracker ct : trackers . values ( ) ) { if ( sb . length ( ) > 0 ) { sb . append ( '\n' ) ; } sb . append ( ct . calculateStats ( ) ) ; } return sb . toString ( ) ; }
public String reportCollection ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( CollectorTracker ct : trackers . values ( ) ) { String report = ct . reportCollection ( ) ; if ( report . length ( ) = = 0 ) { continue ; } if ( sb . length ( ) > 0 ) { sb . append ( '\n' ) ; } sb . append ( report ) ; } return sb . toString ( ) ; }
private String getName ( ) throws JMException , IOException { return ( String ) mserv . getAttribute ( mbean , " Name " ) ; }
private long getCollectionCount ( ) throws JMException , IOException { return ( Long ) mserv . getAttribute ( mbean , " CollectionCount " ) ; }
private long getCollectionTime ( ) throws JMException , IOException { return ( Long ) mserv . getAttribute ( mbean , " CollectionTime " ) ; }
private CompositeData getLastGcInfo ( ) throws JMException , IOException { return ( CompositeData ) mserv . getAttribute ( mbean , " LastGcInfo " ) ; }
public String reportCollection ( ) { try { long count = getCollectionCount ( ) ;
public String calculateStats ( ) { try { long count = getCollectionCount ( ) ;
public static void main ( String [ ] args ) throws Exception { long interval = 10000 ; String pid = args [ 0 ] ; if ( args . length > 1 ) { interval = Integer . parseInt ( args [ 1 ] ) * 1000 ; } System . out . println ( " Attaching: " + pid ) ; VirtualMachine jvm = VirtualMachine . attach ( pid ) ; String addr = attachManagementAgent ( jvm ) ; System . out . println ( " JVM JMX uri: " + addr ) ; JMXServiceURL jmxurl = new JMXServiceURL ( addr ) ; JMXConnector conn = JMXConnectorFactory . connect ( jmxurl ) ; MBeanServerConnection mserver = conn . getMBeanServerConnection ( ) ; System . out . println ( " MBean server connected " ) ; final MBeanCpuUsageReporter tmon = new MBeanCpuUsageReporter ( mserver ) ; long deadline = System . currentTimeMillis ( ) + interval ; tmon . report ( ) ; System . out . println ( " Monitoring threads ... " ) ; while ( true ) { while ( System . currentTimeMillis ( ) < deadline ) {
public static void main ( String [ ] args ) throws Exception { String pid = args [ 0 ] ; Util . addToolsToClasspath ( ) ; VirtualMachine jvm = Util . attachToPid ( pid ) ; MBeanServerConnection jmx = Util . attachJmx ( jvm ) ; JsonFactory jsonFactory = new JsonFactory ( ) ; JsonGenerator jg = jsonFactory . createJsonGenerator ( System . out ) ; jg . useDefaultPrettyPrinter ( ) ; jg . writeStartObject ( ) ; listBeans ( jg , jmx ) ; jg . writeEndObject ( ) ; jg . close ( ) ; System . out . println ( ) ; System . out . flush ( ) ; }
private static void listBeans ( JsonGenerator jg , MBeanServerConnection mBeanServer ) throws Exception { Set < ObjectName > names = null ; names = mBeanServer . queryNames ( null , null ) ; jg . writeArrayFieldStart ( " beans " ) ; Iterator < ObjectName > it = names . iterator ( ) ; while ( it . hasNext ( ) ) { ObjectName oname = it . next ( ) ; MBeanInfo minfo ; String code = " " ; minfo = mBeanServer . getMBeanInfo ( oname ) ; code = minfo . getClassName ( ) ; String prs = " " ; if ( " org.apache.commons.modeler.BaseModelMBean " . equals ( code ) ) { prs = " modelerType " ; code = ( String ) mBeanServer . getAttribute ( oname , prs ) ; } jg . writeStartObject ( ) ; jg . writeStringField ( " name " , oname . toString ( ) ) ; jg . writeStringField ( " modelerType " , code ) ; MBeanAttributeInfo attrs [ ] = minfo . getAttributes ( ) ; for ( int i = 0 ; i < attrs . length ; i + + ) { writeAttribute ( mBeanServer , jg , oname , attrs [ i ] ) ; } jg . writeEndObject ( ) ; } jg . writeEndArray ( ) ; }
private static void writeAttribute ( MBeanServerConnection mBeanServer , JsonGenerator jg , ObjectName oname , MBeanAttributeInfo attr ) throws IOException { if ( ! attr . isReadable ( ) ) { return ; } String attName = attr . getName ( ) ; if ( " modelerType " . equals ( attName ) ) { return ; } if ( attName . indexOf ( " = " ) > = 0 | | attName . indexOf ( " : " ) > = 0 | | attName . indexOf ( " " ) > = 0 ) { return ; } Object value = null ; try { value = mBeanServer . getAttribute ( oname , attName ) ; } catch ( AttributeNotFoundException e ) { //Ignored the attribute was not found, which should never happen because the bean //just told us that it has this attribute, but if this happens just don't output //the attribute. return; } catch (MBeanException e) { //The code inside the attribute getter threw an exception so log it, and // skip outputting the attribute error("getting attribute "+attName+" of "+oname+" threw an exception", e); return; } catch (RuntimeMBeanException e) { // The code inside the attribute getter threw an exception, so we skip // outputting the attribute. We will log the exception in certain cases, // but suppress the log message in others. See OPSAPS-5449 for more info. if (!(e.getCause() instanceof UnsupportedOperationException)) { error("getting attribute " + attName + " of " + oname + " threw " + "an exception", e); } return; } catch (RuntimeException e) { //For some reason even with an MBeanException available to them Runtime exceptions //can still find their way through, so treat them the same as MBeanException error("getting attribute "+attName+" of "+oname+" threw an exception", e); return; } catch (ReflectionException e) { //This happens when the code inside the JMX bean (setter?? from the java docs) //threw an exception, so log it and skip outputting the attribute error("getting attribute "+attName+" of "+oname+" threw an exception", e); return; } catch (InstanceNotFoundException e) { //Ignored the mbean itself was not found, which should never happen because we //just accessed it (perhaps something unregistered in-between) but if this //happens just don't output the attribute. return; } writeAttribute(jg, attName, value); }
private static void error ( String string , Throwable e ) { System . err . print ( string ) ; e . printStackTrace ( System . err ) ; }
private static void writeAttribute ( JsonGenerator jg , String attName , Object value ) throws IOException { jg . writeFieldName ( attName ) ; writeObject ( jg , value ) ; }
private static void writeObject ( JsonGenerator jg , Object value ) throws IOException { if ( value = = null ) { jg . writeNull ( ) ;
static void addToolsToClasspath ( ) { try { String javaHome = System . getProperty ( " java.home " ) ;
public static VirtualMachine attachToPid ( String pid ) throws Exception { System . out . println ( " Attaching: " + pid ) ; VirtualMachine jvm = VirtualMachine . attach ( pid ) ; return jvm ; }
public static MBeanServerConnection attachJmx ( VirtualMachine jvm ) throws Exception { String addr = attachManagementAgent ( jvm ) ; System . out . println ( " JVM JMX uri: " + addr ) ; JMXServiceURL jmxurl = new JMXServiceURL ( addr ) ; JMXConnector conn = JMXConnectorFactory . connect ( jmxurl ) ; MBeanServerConnection mserver = conn . getMBeanServerConnection ( ) ; return mserver ; }
private static String attachManagementAgent ( VirtualMachine vm ) throws Exception { Properties localProperties = vm . getAgentProperties ( ) ; if ( localProperties . containsKey ( " com.sun.management.jmxremote.localConnectorAddress " ) ) { return ( ( String ) localProperties . get ( " com.sun.management.jmxremote.localConnectorAddress " ) ) ; } String jhome = vm . getSystemProperties ( ) . getProperty ( " java.home " ) ; Object localObject = jhome + File . separator + " jre " + File . separator + " lib " + File . separator + " management-agent.jar " ; File localFile = new File ( ( String ) localObject ) ; if ( ! ( localFile . exists ( ) ) ) { localObject = jhome + File . separator + " lib " + File . separator + " management-agent.jar " ; localFile = new File ( ( String ) localObject ) ; if ( ! ( localFile . exists ( ) ) ) { throw new IOException ( " Management agent not found " ) ; } } localObject = localFile . getCanonicalPath ( ) ; try { vm . loadAgent ( ( String ) localObject , " com.sun.management.jmxremote " ) ; } catch ( Exception e ) { throw e ; } localProperties = vm . getAgentProperties ( ) ; return ( ( String ) localProperties . get ( " com.sun.management.jmxremote.localConnectorAddress " ) ) ; }
public static void main ( String [ ] args ) throws Exception { if ( args . length = = 0 ) { printUsageAndExit ( ) ; } String cmd = args [ 0 ] ; if ( " jmx " . equals ( cmd ) ) { JmxReporter . main ( sublist ( args , 1 ) ) ;
private static String [ ] sublist ( String [ ] args , int start ) { String [ ] ret = new String [ args . length - start ] ; for ( int i = 0 ; i < ret . length ; + + i ) { ret [ i ] = args [ start + i ] ; } return ret ; }
static void printUsageAndExit ( ) { System . err . println ( " Usage: " ) ; System . err . println ( " jmx <pid> " ) ; System . err . println ( " top <pid> " ) ; System . err . println ( " gc <pid> " ) ; System . err . println ( " ps " ) ; System . err . println ( " stack <pid> " ) ; System . exit ( 1 ) ; }
public void run ( ) throws Exception { Util . addToolsToClasspath ( ) ; for ( VirtualMachineDescriptor vm : VirtualMachine . list ( ) ) { System . out . print ( vm . id ( ) ) ;
public static void ensureToolsClasspath ( ) { // do nothing; try { VirtualMachine.class.toString();
private static void addToolsToClasspath ( ) { try { String javaHome = System . getProperty ( " java.home " ) ;
public static void main ( String [ ] args ) throws Exception { String pid = args [ 0 ] ; VirtualMachine jvm = AttachUtil . attachToPid ( pid ) ; MBeanServerConnection jmx = AttachUtil . attachJmx ( jvm ) ; JsonFactory jsonFactory = new JsonFactory ( ) ; JsonGenerator jg = jsonFactory . createJsonGenerator ( System . out ) ; jg . useDefaultPrettyPrinter ( ) ; jg . writeStartObject ( ) ; listBeans ( jg , jmx ) ; jg . writeEndObject ( ) ; jg . close ( ) ; System . out . println ( ) ; System . out . flush ( ) ; }
public void run ( ) throws Exception { for ( VirtualMachineDescriptor vm : VirtualMachine . list ( ) ) { System . out . print ( vm . id ( ) ) ;
public static MBeanServerConnection connection ( String connector ) throws IOException { MBeanServerConnection conn ; conn = connectByPID ( connector ) ; if ( conn ! = null ) { return conn ; } conn = connectBySocketAddress ( connector ) ; if ( conn ! = null ) { return conn ; } throw new IOException ( " Cannot connect to " + connector ) ; }
private static MBeanServerConnection connectByPID ( String connector ) throws IOException { try { int pid = Integer . parseInt ( connector ) ;
private static MBeanServerConnection connectBySocketAddress ( String connector ) throws IOException { Matcher matcher = SOCKET_ADDERSS . matcher ( connector ) ; if ( matcher . matches ( ) ) { try {
private static String attachManagementAgent ( VirtualMachine vm ) throws IOException , AgentLoadException , AgentInitializationException { Properties localProperties = vm . getAgentProperties ( ) ; if ( localProperties . containsKey ( " com.sun.management.jmxremote.localConnectorAddress " ) ) { return ( ( String ) localProperties . get ( " com.sun.management.jmxremote.localConnectorAddress " ) ) ; } String jhome = vm . getSystemProperties ( ) . getProperty ( " java.home " ) ; Object localObject = jhome + File . separator + " jre " + File . separator + " lib " + File . separator + " management-agent.jar " ; File localFile = new File ( ( String ) localObject ) ; if ( ! ( localFile . exists ( ) ) ) { localObject = jhome + File . separator + " lib " + File . separator + " management-agent.jar " ; localFile = new File ( ( String ) localObject ) ; if ( ! ( localFile . exists ( ) ) ) { throw new IOException ( " Management agent not found " ) ; } } localObject = localFile . getCanonicalPath ( ) ; vm . loadAgent ( ( String ) localObject , " com.sun.management.jmxremote " ) ; localProperties = vm . getAgentProperties ( ) ; return ( ( String ) localProperties . get ( " com.sun.management.jmxremote.localConnectorAddress " ) ) ; }
public void exec ( MBeanServerConnection connection , List < String > args ) ; }
public static void execMBeanCommand ( MBeanCommand cmd , List < String > args ) throws InvalidCommandLineException , IOException { try { String jxc = args . get ( 0 ) ;
public static void runMain ( String arg , String [ ] args ) throws Exception { String [ ] nargs = new String [ 1 + args . length ] ; nargs [ 0 ] = arg ; for ( int i = 0 ; i ! = args . length ; + + i ) { nargs [ i + 1 ] = args [ i ] ; } Tool . main ( nargs ) ; }
public String getCommand ( ) ; public String getDescription ( ) ; public void printUsage ( PrintStream out ) ; public void printHelp ( PrintStream out ) ; public void exec ( MBeanServerConnection connection , List < String > args ) ; }
public String getDescription ( ) ; public void printUsage ( PrintStream out ) ; public void printHelp ( PrintStream out ) ; public void exec ( MBeanServerConnection connection , List < String > args ) ; }
public void printUsage ( PrintStream out ) ; public void printHelp ( PrintStream out ) ; public void exec ( MBeanServerConnection connection , List < String > args ) ; }
public void printHelp ( PrintStream out ) ; public void exec ( MBeanServerConnection connection , List < String > args ) ; }
public String getDescription ( ) { return " Display memory and GC configurations " ; }
public void printUsage ( PrintStream out ) { } @Override public void printHelp ( PrintStream out ) { } @Override public void exec ( MBeanServerConnection connection , List < String > args ) { try { MemoryMXStruct membean = MemoryMXStruct . get ( connection ) ; Map < String , GarbageCollectorMXStruct > gcbeans = GarbageCollectorMXStruct . get ( connection ) ; Map < String , MemoryPoolMXStruct > mpbeans = MemoryPoolMXStruct . get ( connection ) ; System . out . println ( " \ nCollectors: " ) ; for ( GarbageCollectorMXStruct gc : gcbeans . values ( ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " " ) ; sb . append ( gc . getName ( ) ) ; sb . append ( " " ) . append ( Arrays . toString ( gc . getMemoryPoolNames ( ) ) ) ; System . out . println ( sb . toString ( ) ) ; } System . out . println ( " \ nMemory pools (heap): " ) ; for ( MemoryPoolMXStruct mp : mpbeans . values ( ) ) { if ( ! " HEAP " . equals ( mp . getType ( ) ) ) { continue ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( " " ) ; sb . append ( mp . getName ( ) ) ; sb . append ( " " ) . append ( mp . getUsage ( ) ) ; System . out . println ( sb . toString ( ) ) ; } System . out . println ( " \ nMemory pools (non heap): " ) ; for ( MemoryPoolMXStruct mp : mpbeans . values ( ) ) { if ( " HEAP " . equals ( mp . getType ( ) ) ) { continue ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( " " ) ; sb . append ( mp . getName ( ) ) ; sb . append ( " " ) . append ( mp . getType ( ) ) . append ( " " ) . append ( mp . getUsage ( ) ) ; System . out . println ( sb . toString ( ) ) ; } } catch ( Exception e ) { System . err . println ( " JMX error: " + e . toString ( ) ) ; } } public static void main ( String [ ] args ) throws InvalidCommandLineException , IOException { new HeapInfoCmd ( ) . exec ( ManagementFactory . getPlatformMBeanServer ( ) , Arrays . asList ( args ) ) ; } }
public void printHelp ( PrintStream out ) { } @Override public void exec ( MBeanServerConnection connection , List < String > args ) { try { MemoryMXStruct membean = MemoryMXStruct . get ( connection ) ; Map < String , GarbageCollectorMXStruct > gcbeans = GarbageCollectorMXStruct . get ( connection ) ; Map < String , MemoryPoolMXStruct > mpbeans = MemoryPoolMXStruct . get ( connection ) ; System . out . println ( " \ nCollectors: " ) ; for ( GarbageCollectorMXStruct gc : gcbeans . values ( ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " " ) ; sb . append ( gc . getName ( ) ) ; sb . append ( " " ) . append ( Arrays . toString ( gc . getMemoryPoolNames ( ) ) ) ; System . out . println ( sb . toString ( ) ) ; } System . out . println ( " \ nMemory pools (heap): " ) ; for ( MemoryPoolMXStruct mp : mpbeans . values ( ) ) { if ( ! " HEAP " . equals ( mp . getType ( ) ) ) { continue ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( " " ) ; sb . append ( mp . getName ( ) ) ; sb . append ( " " ) . append ( mp . getUsage ( ) ) ; System . out . println ( sb . toString ( ) ) ; } System . out . println ( " \ nMemory pools (non heap): " ) ; for ( MemoryPoolMXStruct mp : mpbeans . values ( ) ) { if ( " HEAP " . equals ( mp . getType ( ) ) ) { continue ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( " " ) ; sb . append ( mp . getName ( ) ) ; sb . append ( " " ) . append ( mp . getType ( ) ) . append ( " " ) . append ( mp . getUsage ( ) ) ; System . out . println ( sb . toString ( ) ) ; } } catch ( Exception e ) { System . err . println ( " JMX error: " + e . toString ( ) ) ; } } public static void main ( String [ ] args ) throws InvalidCommandLineException , IOException { new HeapInfoCmd ( ) . exec ( ManagementFactory . getPlatformMBeanServer ( ) , Arrays . asList ( args ) ) ; } }
public void exec ( MBeanServerConnection connection , List < String > args ) { try {
public static void main ( String [ ] args ) throws InvalidCommandLineException , IOException { new HeapInfoCmd ( ) . exec ( ManagementFactory . getPlatformMBeanServer ( ) , Arrays . asList ( args ) ) ; }
public static < V extends MXStruct > Map < String , V > collectBeans ( MBeanServerConnection conn , ObjectName pattern , V proto ) throws IOException , ReflectionException { Map < String , V > result = new LinkedHashMap < String , V > ( ) ; for ( ObjectName name : conn . queryNames ( pattern , null ) ) { StringBuffer sb = new StringBuffer ( ) ; for ( String key : pattern . getKeyPropertyList ( ) . keySet ( ) ) { String val = pattern . getKeyProperty ( key ) ; if ( " * " . equals ( val ) ) { if ( sb . length ( ) > 0 ) { sb . append ( ',' ) ; } sb . append ( name . getKeyProperty ( key ) ) ; } } V mstruct = proto . read ( conn , name ) ; result . put ( sb . toString ( ) , mstruct ) ; } return result ; }
public static ObjectName name ( String name ) { try { return new ObjectName ( name ) ;
private Map < String , AttrInfo > collectMeta ( ) { Map < String , AttrInfo > meta = new LinkedHashMap < String , MXStruct . AttrInfo > ( ) ; for ( Method m : getClass ( ) . getMethods ( ) ) { if ( m . isAnnotationPresent ( AttrName . class ) ) { AttrName an = m . getAnnotation ( AttrName . class ) ; AsObject ot = m . getAnnotation ( AsObject . class ) ; AsCollection ct = m . getAnnotation ( AsCollection . class ) ; AsMap mt = m . getAnnotation ( AsMap . class ) ; int ac = ( ot = = null ? 0 : 1 ) + ( ct = = null ? 0 : 1 ) + ( mt = = null ? 0 : 1 ) ; if ( ac > 1 ) { throw new IllegalArgumentException ( " You can specify only one \" As \" annotation for method " ) ; } AttrInfo ai = new AttrInfo ( ) ; ai . methodName = m . getName ( ) ; ai . attrName = an . value ( ) ; if ( ot ! = null ) { Class < ? > t = ot . value ( ) ; ai . converter = createConverter ( t ) ; } else if ( ct ! = null ) { Class < ? > t = ct . value ( ) ; ai . converter = new CollectionConverter ( createConverter ( t ) ) ; } else if ( mt ! = null ) { String key = mt . key ( ) ; String val = mt . val ( ) ; Class < ? > t = mt . type ( ) ; ai . converter = new MapConverter ( key , val , createConverter ( t ) ) ; } else if ( MXStruct . class . isAssignableFrom ( m . getReturnType ( ) ) ) { Class < ? > t = m . getReturnType ( ) ; ai . converter = createConverter ( t ) ; } meta . put ( ai . methodName , ai ) ; } } PrintTemplate pt = getClass ( ) . getAnnotation ( PrintTemplate . class ) ; if ( pt ! = null ) { printTemplate = pt . value ( ) ; } return meta ; }
private Converter createConverter ( Class < ? > t ) { if ( MXStruct . class . isAssignableFrom ( t ) ) { return new StructConverter ( t ) ;
public < V extends MXStruct > V read ( MBeanServerConnection conn , ObjectName name ) throws ReflectionException , IOException { try { MXStruct that ;
public < V extends MXStruct > V read ( CompositeData cdata ) { MXStruct that ; try { that = ( MXStruct ) clone ( ) ;
protected < V > V getMXAttr ( ) { StackTraceElement [ ] trace = Thread . currentThread ( ) . getStackTrace ( ) ; String methodName = trace [ 2 ] . getMethodName ( ) ; AttrInfo info = meta . get ( methodName ) ; if ( info = = null ) { throw new IllegalArgumentException ( " Method " + methodName + " is not annotated with MBean meta data " ) ; } Object val = data . get ( info . attrName ) ; if ( val ! = null & & info . converter ! = null ) { return ( V ) info . converter . convert ( val ) ;
public Object convert ( Object val ) { return val = = null ? null : proto . read ( ( CompositeData ) val ) ; }
public Object convert ( Object val ) { if ( val = = null ) { return null ;
private String normString ( String valueAttr ) { valueAttr = valueAttr . trim ( ) ; return ( valueAttr ! = null & & valueAttr . length ( ) > 1 ) ? valueAttr : null ; }
public String toString ( ) { if ( printTemplate ! = null & & printTemplate . length ( ) > 0 ) { VelocityContext ctx = new VelocityContext ( ) ;
public static Map < String , GarbageCollectorMXStruct > get ( MBeanServerConnection conn ) throws ReflectionException , IOException { return JmxHelper . collectBeans ( conn , PATTERN , PROTO ) ; }
public long getCollectionCount ( ) { return getMXAttr ( ) ; }
public long getCollectionTime ( ) { return getMXAttr ( ) ; }
public String [ ] getMemoryPoolNames ( ) { return getMXAttr ( ) ; }
public LastGcInfo getLastGcInfo ( ) { return getMXAttr ( ) ; }
public int getGcThreadCount ( ) { return getMXAttr ( ) ; }
public Map < String , MemUsage > getMemoryUsageBeforeGc ( ) { return getMXAttr ( ) ; }
public Map < String , MemUsage > getMemoryUsageAfterGc ( ) { return getMXAttr ( ) ; }
public static MemoryMXStruct get ( MBeanServerConnection conn ) throws ReflectionException , IOException { return PROTO . read ( conn , NAME ) ; }
public MemUsage getHeapMemoryUsage ( ) { return getMXAttr ( ) ; }
public MemUsage getNonHeapMemoryUsage ( ) { return getMXAttr ( ) ; }
public int getObjectPendingFinalizationCount ( ) { return getMXAttr ( ) ; }
public static Map < String , MemoryPoolMXStruct > get ( MBeanServerConnection conn ) throws ReflectionException , IOException { return JmxHelper . collectBeans ( conn , PATTERN , PROTO ) ; }
public String [ ] getMemoryManagerNames ( ) { return getMXAttr ( ) ; }
public void test_all_attrs ( ) throws ReflectionException , IOException { MemoryMXStruct membean = MemoryMXStruct . PROTO . read ( conn , MemoryMXStruct . NAME ) ; membean . getHeapMemoryUsage ( ) . getInit ( ) ; membean . getHeapMemoryUsage ( ) . getUsed ( ) ; membean . getHeapMemoryUsage ( ) . getCommitted ( ) ; membean . getHeapMemoryUsage ( ) . getMax ( ) ; membean . getNonHeapMemoryUsage ( ) . getInit ( ) ; membean . getNonHeapMemoryUsage ( ) . getUsed ( ) ; membean . getNonHeapMemoryUsage ( ) . getCommitted ( ) ; membean . getNonHeapMemoryUsage ( ) . getMax ( ) ; String heapUsage = membean . getHeapMemoryUsage ( ) . toString ( ) ; membean . getObjectPendingFinalizationCount ( ) ; membean . isVerbose ( ) ; }
public void test_gc_beans ( ) throws MalformedObjectNameException , NullPointerException , IOException , ReflectionException { Map < String , GarbageCollectorMXStruct > beans = JmxHelper . collectBeans ( conn , GarbageCollectorMXStruct . PATTERN , GarbageCollectorMXStruct . PROTO ) ; Assert . assertTrue ( beans . size ( ) > 0 ) ; for ( GarbageCollectorMXStruct bean : beans . values ( ) ) { bean . getName ( ) ;
public void test_memory_pool_beans ( ) throws MalformedObjectNameException , NullPointerException , IOException , ReflectionException { Map < String , MemoryPoolMXStruct > beans = JmxHelper . collectBeans ( conn , MemoryPoolMXStruct . PATTERN , MemoryPoolMXStruct . PROTO ) ; Assert . assertTrue ( beans . size ( ) > 0 ) ; for ( MemoryPoolMXStruct bean : beans . values ( ) ) { bean . getName ( ) ;
public static void main ( String [ ] args ) throws Exception { long interval = 10000 ; String pid = args [ 0 ] ; if ( args . length > 1 ) { interval = Integer . parseInt ( args [ 1 ] ) * 1000 ; } System . out . println ( " Attaching: " + pid ) ; VirtualMachine jvm = VirtualMachine . attach ( pid ) ; Properties prop = jvm . getAgentProperties ( ) ; for ( Object key : prop . keySet ( ) ) { System . out . println ( " " + key + " : " + prop . getProperty ( ( String ) key ) ) ; } String addr = attachManagementAgent ( jvm ) ; System . out . println ( " JVM JMX uri: " + addr ) ; JMXServiceURL jmxurl = new JMXServiceURL ( addr ) ; JMXConnector conn = JMXConnectorFactory . connect ( jmxurl ) ; MBeanServerConnection mserver = conn . getMBeanServerConnection ( ) ; System . out . println ( " MBean server connected " ) ; final MBeanCpuUsageReporter tmon = new MBeanCpuUsageReporter ( mserver ) ; long deadline = System . currentTimeMillis ( ) + interval ; tmon . report ( ) ; System . out . println ( " Monitoring threads ... " ) ; while ( true ) { while ( System . currentTimeMillis ( ) < deadline ) {
public static void main ( String [ ] args ) throws Exception { // BugSpotAgent agent = new BugSpotAgent(); // agent.attach(5296); // // System.out.println("Attached!"); // JMap.main(new String[]{"-histo:live", "5460"}); long start = System.nanoTime(); HotSpotVirtualMachine vm = (HotSpotVirtualMachine) AttachUtil.attachToPid("5460"); for(int i = 0; i != 1; ++i) { // InputStream is = vm.heapHisto("-all"); InputStream is = vm.printFlag("NewSize"); BufferedReader br = new BufferedReader(new InputStreamReader(is)); while(true) { String line = br.readLine(); if (line == null) { break; } System.out.println(line); } } System.out.println("100 dumps in " + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start) + "ms"); }
public static void main ( String [ ] argsArray ) { List < String > args = Arrays . asList ( argsArray ) ; try { if ( args . size ( ) = = 0 ) {
private static void runCommandAndExit ( Command cmd , List < String > args ) throws InvalidCommandLineException , IOException { if ( cmd instanceof MBeanCommand ) { CommandHelper . execMBeanCommand ( ( MBeanCommand ) cmd , args ) ; } else if ( cmd instanceof SimpleCommand ) { ( ( SimpleCommand ) cmd ) . exec ( args ) ; } System . exit ( 0 ) ; }
private static void printHelpAndExit ( List < String > args ) { for ( Command cmd : COMMANDS ) { if ( cmd . getCommand ( ) . equals ( args . get ( 0 ) ) ) { System . out . println ( cmd . getCommand ( ) + " - " + cmd . getDescription ( ) ) ; System . out . print ( " <JTOOL> " ) ; cmd . printUsage ( System . out ) ; cmd . printHelp ( System . out ) ; System . exit ( 1 ) ; } } System . err . println ( " Unknown command: " + args . get ( 0 ) ) ; printUsageAndExit ( ) ; }
static void printUsageAndExit ( ) { System . err . println ( " Usage: " ) ; for ( Command cmd : COMMANDS ) { System . err . println ( String . format ( " %-8s - %s " , cmd . getCommand ( ) , cmd . getDescription ( ) ) ) ; } System . exit ( 1 ) ; }
public String getCommand ( ) ; public String getDescription ( ) ; public void printUsage ( PrintStream out ) ; public void printHelp ( PrintStream out ) ; }
public String getDescription ( ) ; public void printUsage ( PrintStream out ) ; public void printHelp ( PrintStream out ) ; }
public void printUsage ( PrintStream out ) ; public void printHelp ( PrintStream out ) ; }
public String getDescription ( ) { return " Display memory and GC configuration summary " ; }
public void printUsage ( PrintStream out ) { out . println ( " meminfo [<pid>|<host:port>] " ) ; }
public void printHelp ( PrintStream out ) { } @Override public void exec ( MBeanServerConnection connection , List < String > args ) { try { // MemoryMXStruct membean = MemoryMXStruct.get(connection); Map<String, GarbageCollectorMXStruct> gcbeans = GarbageCollectorMXStruct.get(connection); Map<String, MemoryPoolMXStruct> mpbeans = MemoryPoolMXStruct.get(connection); System.out.println("\nCollectors:"); for(GarbageCollectorMXStruct gc: gcbeans.values()) { StringBuilder sb = new StringBuilder(); sb.append(" "); sb.append(gc.getName()); sb.append(" ").append(Arrays.toString(gc.getMemoryPoolNames())); System.out.println(sb.toString()); } System.out.println("\nMemory pools (heap):"); for(MemoryPoolMXStruct mp: mpbeans.values()) { if (!"HEAP".equals(mp.getType())) { continue; } StringBuilder sb = new StringBuilder(); sb.append(" "); sb.append(mp.getName()); sb.append(" ").append(mp.getUsage()); System.out.println(sb.toString()); } System.out.println("\nMemory pools (non heap):"); for(MemoryPoolMXStruct mp: mpbeans.values()) { if ("HEAP".equals(mp.getType())) { continue; } StringBuilder sb = new StringBuilder(); sb.append(" "); sb.append(mp.getName()); sb.append(" ") .append(mp.getType()).append(" ") .append(mp.getUsage()); System.out.println(sb.toString()); } } catch (Exception e) { System.err.println("JMX error: " + e.toString()); } } public static void main(String[] args) throws InvalidCommandLineException, IOException { new HeapInfoCmd().exec(ManagementFactory.getPlatformMBeanServer(), Arrays.asList(args)); } }
public String getDescription ( ) { return " List JVMs on local system " ; }
public void printUsage ( PrintStream out ) { out . println ( " ps " ) ; }
public void printHelp ( PrintStream out ) { } @Override public void exec ( List < String > args ) { for ( VirtualMachineDescriptor vm : VirtualMachine . list ( ) ) { System . out . print ( vm . id ( ) ) ; System . out . print ( " \ t " ) ; System . out . print ( vm . displayName ( ) ) ; System . out . print ( " \ n " ) ; } } public static void main ( String [ ] args ) { new ProcListCmd ( ) . exec ( null ) ; } }
public void exec ( List < String > args ) { for ( VirtualMachineDescriptor vm : VirtualMachine . list ( ) ) { System . out . print ( vm . id ( ) ) ;
public static void main ( String [ ] args ) { new ProcListCmd ( ) . exec ( null ) ; }
public static < V extends MXStruct > V parseComposite ( CompositeData cdata , V proto ) throws IOException , ReflectionException { return proto . read ( cdata ) ; }
public boolean isValid ( ) { return ( Boolean ) getMXAttr ( ) ; }
public long getCollectionCount ( ) { return ( Long ) getMXAttr ( ) ; }
public long getCollectionTime ( ) { return ( Long ) getMXAttr ( ) ; }
public int getGcThreadCount ( ) { return ( Integer ) getMXAttr ( ) ; }
public long getDuration ( ) { return ( Long ) getMXAttr ( ) ; }
public long getStartTime ( ) { return ( Long ) getMXAttr ( ) ; }
public long getEndTime ( ) { return ( Long ) getMXAttr ( ) ; }
public int getObjectPendingFinalizationCount ( ) { return ( Integer ) getMXAttr ( ) ; }
public boolean isVerbose ( ) { return ( Boolean ) getMXAttr ( ) ; }
public long getCommitted ( ) { return ( Long ) getMXAttr ( ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( Formats . toMemorySize ( getInit ( ) ) ) ; sb . append ( " / " ) . append ( Formats . toMemorySize ( getUsed ( ) ) ) ; sb . append ( " / " ) . append ( Formats . toMemorySize ( getCommitted ( ) ) ) ; if ( getMax ( ) > 0 ) { sb . append ( " / " ) . append ( Formats . toMemorySize ( getMax ( ) ) ) ; } else { sb . append ( " /NA " ) ; } return sb . toString ( ) ; }
public boolean isValid ( ) { return ( Boolean ) getMXAttr ( ) ; }
public static final String toMemorySize ( long n ) { if ( n < ( 10l < < 10 ) ) { return String . valueOf ( n ) ;
public static void main ( String [ ] args ) { System . out . println ( " DATE_STAMP: " + String . format ( DATE_STAMP , System . currentTimeMillis ( ) ) ) ; System . out . println ( " FILE_DATE_STAMP: " + String . format ( FILE_DATE_STAMP , System . currentTimeMillis ( ) ) ) ; System . out . println ( " ZERO_LEAD_DECIMAL_6: " + String . format ( ZERO_LEAD_DECIMAL_6 , 1234 ) ) ; System . out . println ( String . format ( " [%-6s] " , " x " ) ) ; }
public static void fail ( String . . . messages ) { throw new CommandAbortedError ( messages ) ; }
public void logError ( String line ) { System . err . println ( line ) ; }
public boolean start ( String [ ] args ) { try { JCommander parser = new JCommander ( this ) ; addCommands ( parser ) ; try { parser . parse ( args ) ; } catch ( Exception e ) { logError ( e . toString ( ) ) ; parser . usage ( ) ; fail ( ) ; } if ( help ) { String cmd = parser . getParsedCommand ( ) ; if ( cmd = = null ) { parser . usage ( ) ; } else { parser . usage ( cmd ) ; } } else { Runnable cmd = commands . get ( parser . getParsedCommand ( ) ) ; if ( cmd = = null ) { parser . usage ( ) ; fail ( ) ; } else { cmd . run ( ) ; } } if ( suppressSystemExit ) { return true ; } else { System . exit ( 0 ) ; } } catch ( CommandAbortedError error ) { for ( String m : error . messages ) { logError ( m ) ; } } catch ( Throwable e ) { e . printStackTrace ( ) ; } // abnormal termination if (suppressSystemExit) { return false;
private void addCommands ( JCommander parser ) { } @SuppressWarnings ( " serial " ) public static class CommandAbortedError extends Error { public String [ ] messages ; public CommandAbortedError ( String [ ] messages ) { super ( ) ; this . messages = messages ; } } }
public static void main ( String [ ] args ) { String [ ] cmd = new String [ args . length + 1 ] ; System . arraycopy ( args , 0 , cmd , 1 , args . length ) ; cmd [ 0 ] = " gc " ; SJK . main ( cmd ) ; }
public static void main ( String [ ] args ) { String [ ] cmd = new String [ args . length + 1 ] ; System . arraycopy ( args , 0 , cmd , 1 , args . length ) ; cmd [ 0 ] = " jps " ; SJK . main ( cmd ) ; }
public static Pattern translate ( String pattern , String separator ) { StringBuffer sb = new StringBuffer ( ) ; String es = escape ( separator ) ; // special starter Matcher ss = Pattern.compile("^([*][*][" + es + "]).*").matcher(pattern); if (ss.matches()) { pattern = pattern.substring(ss.group(1).length()); // make leading sep optional sb.append("(.*[" + es + "])?"); } // special trailer Matcher st = Pattern.compile(".*([" + es + "][*][*])$").matcher(pattern); boolean useSt = false; if (st.matches()) { pattern = pattern.substring(0, st.start(1)); useSt = true; } for(int i = 0; i != pattern.length(); ++i) { char c = pattern.charAt(i); if (c == '?') { sb.append("[^" + es + "]"); } else if (c == '*') { if (i + 1 < pattern.length() && pattern.charAt(i+1) == '*') { i++; // ** sb.append(".*"); } else { sb.append("[^" + es + "]*"); } } else { if (c == '$') { sb.append("\\$"); } else if (Character.isJavaIdentifierPart(c) || Character.isWhitespace(c)) { sb.append(c); } else { sb.append('\\').append(c); } } } if (useSt) { sb.append("([" + es + "].*)?"); } return Pattern.compile(sb.toString()); }
private static String escape ( String separator ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i ! = separator . length ( ) ; + + i ) { char c = separator . charAt ( i ) ; if ( " \\ []&- " . indexOf ( c ) > = 0 ) { sb . append ( '\\' ) . append ( c ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public MBeanServerConnection getMServer ( ) { if ( pid = = null & & sockAddr = = null ) { SJK . failAndPrintUsage ( " JVM porcess is not specified " ) ; } if ( pid ! = null & & sockAddr ! = null ) { SJK . failAndPrintUsage ( " You can specify eigther PID or JMX socket connection " ) ; } if ( pid ! = null ) { return AttachManager . getDetails ( pid ) . getMBeans ( ) ;
public boolean isDefined ( ) { return descFilter ! = null | | propFilters ! = null ; }
public void prepare ( ) { if ( descFilter ! = null ) { descPattern = GlobHelper . translate ( descFilter , " \ 0 " ) ; } if ( propFilters ! = null ) { propPatterns = new ArrayList < Pattern > ( ) ;
public boolean evaluate ( JavaProcessDetails proc ) { if ( descPattern ! = null ) { if ( ! descPattern . matcher ( proc . getDescription ( ) ) . matches ( ) ) { return false ; } } if ( propPatterns ! = null ) { List < String > props = new ArrayList < String > ( ) ; for ( Map . Entry < Object , Object > e : proc . getSystemProperties ( ) . entrySet ( ) ) { props . add ( e . getKey ( ) + " = " + e . getValue ( ) ) ; } filterLoop : for ( Pattern pp : propPatterns ) { for ( String p : props ) { if ( pp . matcher ( p ) . matches ( ) ) { continue filterLoop ; } } return false ; } } return true ; }
public boolean isDefined ( ) { return displayFields ! = null & & ! displayFields . isEmpty ( ) ; }
public String describe ( JavaProcessId jpid ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = true ; for ( String tag : displayFields ) { if ( ! first ) { sb . append ( '\t' ) ; } first = false ; if ( " PID " . equals ( tag ) ) { sb . append ( getPid ( jpid ) ) ; } else if ( " MAIN " . equals ( tag ) ) { sb . append ( getShortMain ( jpid ) ) ; } else if ( " FDQN_MAIN " . equals ( tag ) ) { sb . append ( getMain ( jpid ) ) ; } else if ( " ARGS " . equals ( tag ) ) { sb . append ( getArgs ( jpid ) ) ; } else if ( tag . startsWith ( " d " ) ) { sb . append ( getProp ( jpid , tag . substring ( 1 ) ) ) ; } else if ( tag . startsWith ( " D " ) ) { sb . append ( tag . substring ( 1 ) ) . append ( " = " ) ; sb . append ( getProp ( jpid , tag . substring ( 1 ) ) ) ; } else if ( tag . startsWith ( " X " ) ) { sb . append ( getFlag ( jpid , tag . substring ( 1 ) ) ) ; } else { sb . append ( " Unknown( " + tag + " ) " ) ; } } return sb . toString ( ) ; }
private String getProp ( JavaProcessId jpid , String propName ) { return ( String ) AttachManager . getDetails ( jpid ) . getSystemProperties ( ) . get ( propName ) ; }
private String getFlag ( JavaProcessId jpid , String flagName ) { return ( String ) AttachManager . getDetails ( jpid ) . getVmFlag ( flagName ) ; }
private String getArgs ( JavaProcessId jpid ) { String desc = jpid . getDescription ( ) ; int n = desc . indexOf ( ' ' ) ; if ( n > = 0 ) { desc = desc . substring ( n + 1 ) ; } return desc ; }
private String getMain ( JavaProcessId jpid ) { String desc = jpid . getDescription ( ) ; int n = desc . indexOf ( ' ' ) ; if ( n > = 0 ) { desc = desc . substring ( 0 , n ) ; } return desc ; }
private String getShortMain ( JavaProcessId jpid ) { String main = getMain ( jpid ) ; int n = main . lastIndexOf ( '.' ) ; if ( n > = 0 ) { main = main . substring ( n + 1 ) ; } return main ; }
private String getPid ( JavaProcessId jpid ) { return String . valueOf ( jpid . getPID ( ) ) ; }
public void sortByThreadName ( ) { comparators . add ( 0 , new ThreadNameComparator ( ) ) ; }
public void sortByUserCpu ( ) { comparators . add ( 0 , new UserTimeComparator ( ) ) ; }
public void sortBySysCpu ( ) { comparators . add ( 0 , new SysTimeComparator ( ) ) ; }
public void sortByTotalCpu ( ) { comparators . add ( 0 , new CpuTimeComparator ( ) ) ; }
public void setThreadFilter ( Pattern regEx ) { filter = regEx ; }
public String report ( ) { dumpThreads ( ) ; StringBuilder sb = new StringBuilder ( ) ; long currentTime = System . nanoTime ( ) ; long timeSplit = currentTime - lastTimestamp ; long currentCpuTime = getProcessCpuTime ( ) ; Map < Long , ThreadNote > newNotes = new HashMap < Long , ThreadNote > ( ) ; BigInteger totalCpu = BigInteger . valueOf ( 0 ) ; BigInteger totalUser = BigInteger . valueOf ( 0 ) ; List < ThreadLine > table = new ArrayList < ThreadLine > ( ) ; for ( long tid : getAllThreadIds ( ) ) { String threadName = getThreadName ( tid ) ; if ( filter ! = null & & ! filter . matcher ( threadName ) . matches ( ) ) { continue ; } ThreadNote lastNote = notes . get ( tid ) ; ThreadNote newNote = new ThreadNote ( ) ; newNote . lastCpuTime = getThreadCpuTime ( tid ) ; newNote . lastUserTime = getThreadUserTime ( tid ) ; newNotes . put ( tid , newNote ) ; totalCpu = totalCpu . add ( BigInteger . valueOf ( newNote . lastCpuTime ) ) ; totalUser = totalUser . add ( BigInteger . valueOf ( newNote . lastUserTime ) ) ; if ( lastNote ! = null ) { double cpuT = ( ( double ) ( newNote . lastCpuTime - lastNote . lastCpuTime ) ) / timeSplit ; double userT = ( ( double ) ( newNote . lastUserTime - lastNote . lastUserTime ) ) / timeSplit ; table . add ( new ThreadLine ( tid , 100 * userT , 100 * ( cpuT - userT ) , getThreadName ( tid ) ) ) ; } } if ( table . size ( ) > 0 ) { for ( Comparator < ThreadLine > cmp : comparators ) { Collections . sort ( table , cmp ) ; } if ( table . size ( ) > topLimit ) { table = table . subList ( 0 , topLimit ) ; } double processT = ( ( double ) ( currentCpuTime - lastProcessCpuTime ) ) / timeSplit ; double cpuT = ( ( double ) ( totalCpu . subtract ( lastCummulativeCpuTime ) . longValue ( ) ) ) / timeSplit ; double userT = ( ( double ) ( totalUser . subtract ( lastCummulativeUserTime ) . longValue ( ) ) ) / timeSplit ; sb . append ( Formats . toDatestamp ( System . currentTimeMillis ( ) ) ) ; sb . append ( String . format ( " CPU usage \ n process cpu=%.2f%% \ n application: cpu=%.2f%% (user=%.2f%% sys=%.2f%%) \ n other: cpu=%.2f%% \ n " , 100 * processT , 100 * cpuT , 100 * userT , 100 * ( cpuT - userT ) , 100 * ( processT - cpuT ) ) ) ; for ( ThreadLine line : table ) { sb . append ( line ) . append ( '\n' ) ; } sb . append ( " \ n " ) ; } lastTimestamp = currentTime ; notes = newNotes ; lastCummulativeCpuTime = totalCpu ; lastCummulativeUserTime = totalUser ; lastProcessCpuTime = currentCpuTime ; return sb . toString ( ) ; }
private String getThreadName ( long tid ) { try { CompositeData info = threadDump . get ( tid ) ;
private Collection < Long > getAllThreadIds ( ) { return new TreeSet < Long > ( threadDump . keySet ( ) ) ; }
public String toString ( ) { return String . format ( " [%06d] user=%5.2f%% sys=%5.2f%% - %s " , id , userT , ( sysT ) , name ) ; }
public int compare ( ThreadLine o1 , ThreadLine o2 ) { return Double . compare ( o2 . userT , o1 . userT ) ; }
public int compare ( ThreadLine o1 , ThreadLine o2 ) { return Double . compare ( o2 . userT + o2 . sysT , o1 . userT + o1 . userT ) ; }
public int compare ( ThreadLine o1 , ThreadLine o2 ) { return o1 . name . compareTo ( o2 . name ) ; }
public static void main ( String [ ] args ) { new SJK ( ) . start ( args ) ; }
public static void fail ( String . . . messages ) { throw new CommandAbortedError ( false , messages ) ; }
public static void failAndPrintUsage ( String . . . messages ) { throw new CommandAbortedError ( true , messages ) ; }
public void suppressSystemExit ( ) { suppressSystemExit = true ; }
public boolean start ( String [ ] args ) { JCommander parser = null ; try { parser = new JCommander ( this ) ; addCommands ( parser ) ; try { parser . parse ( args ) ; } catch ( Exception e ) { failAndPrintUsage ( e . toString ( ) ) ; } if ( help ) { String cmd = parser . getParsedCommand ( ) ; if ( cmd = = null ) { parser . usage ( ) ; } else { parser . usage ( cmd ) ; } } else { Runnable cmd = commands . get ( parser . getParsedCommand ( ) ) ; if ( cmd = = null ) { failAndPrintUsage ( ) ; } else { cmd . run ( ) ; } } if ( suppressSystemExit ) { return true ; } else { System . exit ( 0 ) ; } } catch ( CommandAbortedError error ) { for ( String m : error . messages ) { logError ( m ) ; } if ( error . printUsage & & parser ! = null ) { if ( parser . getParsedCommand ( ) ! = null ) { parser . usage ( parser . getParsedCommand ( ) ) ; } else { parser . usage ( ) ; } } } catch ( Throwable e ) { e . printStackTrace ( ) ; } // abnormal termination if (suppressSystemExit) { return false;
private void addCommands ( JCommander parser ) throws InstantiationException , IllegalAccessException { for ( Class < ? > c : findClasses ( getClass ( ) . getPackage ( ) . getName ( ) + " .cmd " ) ) { if ( CmdRef . class . isAssignableFrom ( c ) ) {
private List < Class < ? > > findClasses ( String packageName ) { List < Class < ? > > result = new ArrayList < Class < ? > > ( ) ; try { String path = packageName . replace ( '.' , '/' ) ;
static List < String > findFiles ( String path ) throws IOException { List < String > result = new ArrayList < String > ( ) ; ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; Enumeration < URL > en = cl . getResources ( path ) ; while ( en . hasMoreElements ( ) ) { URL u = en . nextElement ( ) ; listFiles ( result , u , path ) ; } return result ; }
static List < String > listFiles ( List < String > results , URL packageURL , String path ) throws IOException { if ( packageURL . getProtocol ( ) . equals ( " jar " ) ) { String jarFileName ; JarFile jf ; Enumeration < JarEntry > jarEntries ; String entryName ; // build jar file name, then loop through zipped entries jarFileName = URLDecoder.decode(packageURL.getFile(), "UTF-8"); jarFileName = jarFileName.substring(5,jarFileName.indexOf("!")); System.out.println(">"+jarFileName); jf = new JarFile(jarFileName); jarEntries = jf.entries(); while(jarEntries.hasMoreElements()){ entryName = jarEntries.nextElement().getName(); if(entryName.startsWith(path)){ results.add(entryName); } } // loop through files in classpath }else{ File dir = new File(packageURL.getFile()); String cp = dir.getCanonicalPath(); File root = dir; while(true) { if (cp.equals(new File(root, path).getCanonicalPath())) { break; } root = root.getParentFile(); } listFiles(results, root, dir); } return results; }
static void listFiles ( List < String > names , File root , File dir ) { String rootPath = root . getAbsolutePath ( ) ; if ( dir . exists ( ) & & dir . isDirectory ( ) ) { for ( File file : dir . listFiles ( ) ) {
public static long toMillis ( String rawStr ) { if ( rawStr = = null ) throw new NullPointerException ( " Null argument is not allowed " ) ; String str = rawStr . trim ( ) + " " ; Matcher matcher = MTI_PATTERN . matcher ( str ) ; if ( ! matcher . matches ( ) ) throw new IllegalArgumentException ( String . format ( " '%s' doesn't match duration pattern " , rawStr ) ) ; matcher = TI_PATTERN . matcher ( str ) ; BigInteger result = BigInteger . ZERO ; while ( matcher . find ( ) ) { String unitAlias = matcher . group ( TIME_UNIT_GROUP ) . toLowerCase ( ) ; TimeUnit timeUnit = timeUnitAlias . get ( unitAlias ) ; if ( timeUnit = = null ) { throw new IllegalArgumentException ( String . format ( " Unknown time unit alias '%s' in '%s' " , unitAlias , rawStr ) ) ; } long summand ; try { summand = Long . valueOf ( matcher . group ( DURATION_GROUP ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( " Number overflow for duration ' " + rawStr + " ' " , e ) ; } result = result . add ( BigInteger . valueOf ( timeUnit . toMillis ( summand ) ) ) ; } if ( result . compareTo ( LONG_MAX ) = = 1 ) throw new IllegalArgumentException ( " Number overflow for duration ' " + rawStr + " ' " ) ; return result . longValue ( ) ; }
public Long convert ( String value ) { return toMillis ( value ) ; }
public Runnable newCommand ( SJK host ) { return new GcRep ( host ) ; }
public void run ( ) { try { MBeanServerConnection mserver = conn . getMServer ( ) ;
public void run ( ) { System . out . println ( " \ nTotal " ) ; System . out . println ( fmon . calculateStats ( ) ) ; }
public Runnable newCommand ( SJK host ) { return new MxDump ( host ) ; }
public void run ( ) { try { MBeanServerConnection jmx = conn . getMServer ( ) ;
private static void listBeans ( JsonGenerator jg , MBeanServerConnection mBeanServer ) throws Exception { Set < ObjectName > names = null ; names = mBeanServer . queryNames ( null , null ) ; jg . writeArrayFieldStart ( " beans " ) ; Iterator < ObjectName > it = names . iterator ( ) ; while ( it . hasNext ( ) ) { ObjectName oname = it . next ( ) ; MBeanInfo minfo ; String code = " " ; minfo = mBeanServer . getMBeanInfo ( oname ) ; code = minfo . getClassName ( ) ; String prs = " " ; if ( " org.apache.commons.modeler.BaseModelMBean " . equals ( code ) ) { prs = " modelerType " ; code = ( String ) mBeanServer . getAttribute ( oname , prs ) ; } jg . writeStartObject ( ) ; jg . writeStringField ( " name " , oname . toString ( ) ) ; jg . writeStringField ( " modelerType " , code ) ; MBeanAttributeInfo attrs [ ] = minfo . getAttributes ( ) ; for ( int i = 0 ; i < attrs . length ; i + + ) { writeAttribute ( mBeanServer , jg , oname , attrs [ i ] ) ; } jg . writeEndObject ( ) ; } jg . writeEndArray ( ) ; }
private static void writeAttribute ( MBeanServerConnection mBeanServer , JsonGenerator jg , ObjectName oname , MBeanAttributeInfo attr ) throws IOException { if ( ! attr . isReadable ( ) ) { return ; } String attName = attr . getName ( ) ; if ( " modelerType " . equals ( attName ) ) { return ; } if ( attName . indexOf ( " = " ) > = 0 | | attName . indexOf ( " : " ) > = 0 | | attName . indexOf ( " " ) > = 0 ) { return ; } Object value = null ; try { value = mBeanServer . getAttribute ( oname , attName ) ; } catch ( AttributeNotFoundException e ) { //Ignored the attribute was not found, which should never happen because the bean //just told us that it has this attribute, but if this happens just don't output //the attribute. return; } catch (MBeanException e) { //The code inside the attribute getter threw an exception so log it, and // skip outputting the attribute error("getting attribute "+attName+" of "+oname+" threw an exception", e); return; } catch (RuntimeMBeanException e) { // The code inside the attribute getter threw an exception, so we skip // outputting the attribute. We will log the exception in certain cases, // but suppress the log message in others. See OPSAPS-5449 for more info. if (!(e.getCause() instanceof UnsupportedOperationException)) { error("getting attribute " + attName + " of " + oname + " threw " + "an exception", e); } return; } catch (RuntimeException e) { //For some reason even with an MBeanException available to them Runtime exceptions //can still find their way through, so treat them the same as MBeanException error("getting attribute "+attName+" of "+oname+" threw an exception", e); return; } catch (ReflectionException e) { //This happens when the code inside the JMX bean (setter?? from the java docs) //threw an exception, so log it and skip outputting the attribute error("getting attribute "+attName+" of "+oname+" threw an exception", e); return; } catch (InstanceNotFoundException e) { //Ignored the mbean itself was not found, which should never happen because we //just accessed it (perhaps something unregistered in-between) but if this //happens just don't output the attribute. return; } writeAttribute(jg, attName, value); }
private static void error ( String string , Throwable e ) { System . err . print ( string ) ; e . printStackTrace ( System . err ) ; }
private static void writeAttribute ( JsonGenerator jg , String attName , Object value ) throws IOException { jg . writeFieldName ( attName ) ; writeObject ( jg , value ) ; }
private static void writeObject ( JsonGenerator jg , Object value ) throws IOException { if ( value = = null ) { jg . writeNull ( ) ;
public Runnable newCommand ( SJK host ) { return new JPS ( host ) ; }
public void run ( ) { List < JavaProcessId > procList ; filter . prepare ( ) ; if ( filter . isDefined ( ) | | printer . isDefined ( ) ) { procList = AttachManager . listJavaProcesses ( filter ) ; } else { procList = AttachManager . listJavaProcesses ( ) ; } for ( JavaProcessId jpid : procList ) { if ( printer . isDefined ( ) ) {
public Runnable newCommand ( SJK host ) { return new TTop ( host ) ; }
public void run ( ) { try { MBeanServerConnection mserver = connInfo . getMServer ( ) ;
public static void main ( String [ ] args ) { String [ ] cmd = new String [ args . length + 1 ] ; System . arraycopy ( args , 0 , cmd , 1 , args . length ) ; cmd [ 0 ] = " ttop " ; SJK . main ( cmd ) ; }
public void jps_filter_by_prop ( ) { System . setProperty ( " my.prop " , " 123 " ) ; exec ( " jps " , " -pf " , " my.*=123 " ) ; }
public void jps_filter_by_desc ( ) { exec ( " jps " , " -df " , " *junit* " ) ; }
public void jps_print ( ) { exec ( " jps " , " -dp " , " PID " , " MAIN " , " Duser.dir " ) ; }
public void jps_print_flags ( ) { exec ( " jps " , " -dp " , " PID " , " MAIN " , " XMaxHeapSize " , " XBackgroundCompilation " ) ; }
public void ttop_self ( ) { exec ( " ttop " , " -p " , PID ) ; }
public void ttop_top_N_cpu ( ) { exec ( " ttop " , " -p " , " 8420 " , " -o " , " CPU " , " -n " , " 10 " ) ; }
public void ttop_top_N_filtered ( ) { exec ( " ttop " , " -p " , " 8420 " , " -f " , " *RMI* " , " -o " , " CPU " , " -n " , " 10 " ) ; }
public void mxdump_self ( ) { exec ( " mxdump " , " -p " , PID ) ; }
private void exec ( String . . . cmd ) { SJK sjk = new SJK ( ) ; sjk . suppressSystemExit ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " SJK " ) ; for ( String c : cmd ) { sb . append ( ' ' ) . append ( escape ( c ) ) ; } System . out . println ( sb ) ; Assert . assertTrue ( sjk . start ( cmd ) ) ; }
private Object escape ( String c ) { if ( c . split ( " \\ s " ) . length > 1 ) { return '\"' + c + '\"' ;
public static void main ( String [ ] args ) { String [ ] cmd = new String [ args . length + 1 ] ; System . arraycopy ( args , 0 , cmd , 1 , args . length ) ; cmd [ 0 ] = " hh " ; SJK . main ( cmd ) ; }
public static void main ( String [ ] args ) { // if (REPORT_CPU) { // CpuUsageReporter.startReporter(System.out, 15000); // } long tenuredSize = Runtime.getRuntime().maxMemory(); // getting more accurate data for(MemoryPoolMXBean bean : ManagementFactory.getMemoryPoolMXBeans()) { if ("Tenured Gen".equals(bean.getName()) || "PS Old Gen".equals(bean.getName()) || "CMS Old Gen".equals(bean.getName())) { tenuredSize = bean.getUsage().getMax(); System.out.println("Exact tenured space size is " + tenuredSize); } } long limit = 0; if (args.length == 1) { limit = Long.parseLong(args[0]); System.out.println("Runlimit: " + limit + "secs"); limit = TimeUnit.SECONDS.toMillis(limit); } if (CMS_MODE) { HEADROOM = 0; } int count = (int) ((tenuredSize - (HEADROOM << 20)) / ENTRY_SIZE); if (CMS_MODE) { count /= 2; System.out.println("CMS mode is enabled"); } System.out.println("Total old space: " + (tenuredSize >> 20) + "M (-" + HEADROOM + "M)"); if (count < 0) { System.out.println("Heap size is too small, increase heap size or reduce headroom"); } System.out.println("Populating - " + count); maps = new Map[(count + 200000 -1) / 200000]; for(int i = 0; i != maps.length; ++i) { maps[i] = new HashMap<Integer, Object>(); } while(size() < count) { putRandom(count); if (CMS_MODE & random.nextInt(10) > 7) { removeRandom(count); } } int n = 0; int sz = 0; if (!DRY_MODE) { System.out.println("Processing ..."); } else { System.out.println("Processing ... (DRY MODE ENABLED)"); } GCSelfMonitor gcmonitor = new GCSelfMonitor(); // start count down here long startTime = System.currentTimeMillis(); while(true) { if (n % 100 == 0) { sz = size(); } ++n; if ((sz < 1.01 * count) && random.nextBoolean()) { if (DRY_MODE) { dryPutRandom(count); } else { putRandom(count); } } else { if (DRY_MODE) { dryRemoveRandom(count); } else { removeRandom(count); } } if (limit != 0 && (System.currentTimeMillis() > (startTime + limit))) { System.out.println("Finished"); break; } } gcmonitor.displayStats(); }
public void hh_dead_N_self ( ) { exec ( " hh " , " -p " , PID , " --dead " , " -n " , " 20 " ) ; }
private String getShortMain ( JavaProcessId jpid ) { String main = getMain ( jpid ) ; if ( main . endsWith ( " .jar " ) ) { return main ; } int n = main . lastIndexOf ( '.' ) ; if ( n > = 0 ) { main = main . substring ( n + 1 ) ; } return main ; }
public static String toMemoryUnits ( double value ) { if ( value = = 0 ) { return " 0 " ; } if ( value < ( 10l < < 10 ) ) { String val = String . format ( " %.2f " , value ) . trim ( ) ;
public static String toSeconds ( double value ) { return String . format ( " %6.3fB " , value ) ; }
public void report ( String algoName , int eventsMissed , GcReport info ) ; interface GcReport { public long getId ( ) ; public boolean isYoungGC ( ) ; public boolean isConcurrentGC ( ) ; public long getCollectedSize ( ) ; public long getPromotedSize ( ) ; public long getTotalSizeBefore ( ) ; public long getTotalSizeAfter ( ) ; public Collection < String > getColletedPools ( ) ; public Collection < String > getAllCollectedPools ( ) ; public Collection < String > getAllMemoryPools ( ) ; public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getId ( ) ; public boolean isYoungGC ( ) ; public boolean isConcurrentGC ( ) ; public long getCollectedSize ( ) ; public long getPromotedSize ( ) ; public long getTotalSizeBefore ( ) ; public long getTotalSizeAfter ( ) ; public Collection < String > getColletedPools ( ) ; public Collection < String > getAllCollectedPools ( ) ; public Collection < String > getAllMemoryPools ( ) ; public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public boolean isYoungGC ( ) ; public boolean isConcurrentGC ( ) ; public long getCollectedSize ( ) ; public long getPromotedSize ( ) ; public long getTotalSizeBefore ( ) ; public long getTotalSizeAfter ( ) ; public Collection < String > getColletedPools ( ) ; public Collection < String > getAllCollectedPools ( ) ; public Collection < String > getAllMemoryPools ( ) ; public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public boolean isConcurrentGC ( ) ; public long getCollectedSize ( ) ; public long getPromotedSize ( ) ; public long getTotalSizeBefore ( ) ; public long getTotalSizeAfter ( ) ; public Collection < String > getColletedPools ( ) ; public Collection < String > getAllCollectedPools ( ) ; public Collection < String > getAllMemoryPools ( ) ; public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getCollectedSize ( ) ; public long getPromotedSize ( ) ; public long getTotalSizeBefore ( ) ; public long getTotalSizeAfter ( ) ; public Collection < String > getColletedPools ( ) ; public Collection < String > getAllCollectedPools ( ) ; public Collection < String > getAllMemoryPools ( ) ; public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getPromotedSize ( ) ; public long getTotalSizeBefore ( ) ; public long getTotalSizeAfter ( ) ; public Collection < String > getColletedPools ( ) ; public Collection < String > getAllCollectedPools ( ) ; public Collection < String > getAllMemoryPools ( ) ; public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getTotalSizeBefore ( ) ; public long getTotalSizeAfter ( ) ; public Collection < String > getColletedPools ( ) ; public Collection < String > getAllCollectedPools ( ) ; public Collection < String > getAllMemoryPools ( ) ; public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getTotalSizeAfter ( ) ; public Collection < String > getColletedPools ( ) ; public Collection < String > getAllCollectedPools ( ) ; public Collection < String > getAllMemoryPools ( ) ; public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public Collection < String > getColletedPools ( ) ; public Collection < String > getAllCollectedPools ( ) ; public Collection < String > getAllMemoryPools ( ) ; public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public Collection < String > getAllCollectedPools ( ) ; public Collection < String > getAllMemoryPools ( ) ; public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public Collection < String > getAllMemoryPools ( ) ; public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getSizeBefore ( String pool ) ; public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getSizeAfter ( String pool ) ; public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getSizeBefore ( Collection < String > pools ) ; public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getSizeAfter ( Collection < String > pools ) ; public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getTimeSincePreviousGC ( ) ; public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getDuration ( ) ; public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getJvmClockEndTime ( ) ; public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getJvmClockStartTime ( ) ; public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getWallClockEndTime ( ) ; public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public long getWallClockStartTime ( ) ; public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public Collection < String > getEdenPools ( ) ; public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public Collection < String > getSurvivourPools ( ) ; public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
public Collection < String > getOldSpacePools ( ) ; public Collection < String > getPermSpacePools ( ) ; } }
private List < String > getMemPools ( Map < PoolType , Collection < String > > types , PoolType type ) { List < String > pools ; if ( types . containsKey ( type ) ) { pools = new ArrayList < String > ( types . get ( type ) ) ; } else { pools = Collections . emptyList ( ) ; } return pools ; }
public void report ( ) { try { GcInfo lastGc = gc . getLastGcInfo ( ) ;
public long getWallClockStartTime ( ) { return processStartMs + gcInfo . getStartTime ( ) ; }
public long getWallClockEndTime ( ) { return processStartMs + gcInfo . getEndTime ( ) ; }
public long getJvmClockStartTime ( ) { return gcInfo . getStartTime ( ) ; }
public long getJvmClockEndTime ( ) { return gcInfo . getEndTime ( ) ; }
public long getDuration ( ) { return gcInfo . getDuration ( ) ; }
public long getTimeSincePreviousGC ( ) { return gcInterval ; }
public boolean isConcurrentGC ( ) { return isConcurent ; }
public long getCollectedSize ( ) { return getTotalSizeBefore ( ) - getTotalSizeAfter ( ) ; }
public long getPromotedSize ( ) { return getSizeAfter ( oldPools ) - getSizeBefore ( oldPools ) ; }
public long getTotalSizeBefore ( ) { return getSizeBefore ( allCollectedPools ) ; }
public long getTotalSizeAfter ( ) { return getSizeAfter ( allCollectedPools ) ; }
public Collection < String > getColletedPools ( ) { return Collections . unmodifiableCollection ( collectedPools ) ; }
public Collection < String > getAllCollectedPools ( ) { return Collections . unmodifiableCollection ( allCollectedPools ) ; }
public Collection < String > getAllMemoryPools ( ) { return Collections . unmodifiableCollection ( gcInfo . getMemoryUsageAfterGc ( ) . keySet ( ) ) ; }
public long getSizeBefore ( String pool ) { return gcInfo . getMemoryUsageBeforeGc ( ) . get ( pool ) . getUsed ( ) ; }
public long getSizeAfter ( String pool ) { return gcInfo . getMemoryUsageAfterGc ( ) . get ( pool ) . getUsed ( ) ; }
public long getSizeBefore ( Collection < String > pools ) { long total = 0 ; for ( String pool : pools ) { total + = getSizeBefore ( pool ) ; } return total ; }
public long getSizeAfter ( Collection < String > pools ) { long total = 0 ; for ( String pool : pools ) { total + = getSizeAfter ( pool ) ; } return total ; }
public Collection < String > getEdenPools ( ) { List < String > list = new ArrayList < String > ( edenPools ) ; list . retainAll ( gcInfo . getMemoryUsageAfterGc ( ) . keySet ( ) ) ; return list ; }
public Collection < String > getSurvivourPools ( ) { List < String > list = new ArrayList < String > ( survivourPools ) ; list . retainAll ( gcInfo . getMemoryUsageAfterGc ( ) . keySet ( ) ) ; return list ; }
public Collection < String > getOldSpacePools ( ) { List < String > list = new ArrayList < String > ( oldPools ) ; list . retainAll ( gcInfo . getMemoryUsageAfterGc ( ) . keySet ( ) ) ; return list ; }
public Collection < String > getPermSpacePools ( ) { List < String > list = new ArrayList < String > ( permPools ) ; list . retainAll ( gcInfo . getMemoryUsageAfterGc ( ) . keySet ( ) ) ; return list ; }
private static ObjectName name ( String name ) { try { return new ObjectName ( name ) ;
public static Collection < String > allCollectedPools ( MBeanServerConnection conn ) throws IOException { Set < String > pools = new LinkedHashSet < String > ( ) ; for ( ObjectName gcn : conn . queryNames ( COLLECTORS_PATTERN , null ) ) { GarbageCollectorMXBean gc = JMX . newMXBeanProxy ( conn , gcn , GarbageCollectorMXBean . class ) ; for ( String pool : gc . getMemoryPoolNames ( ) ) { pools . add ( pool ) ; } } return pools ; }
public static Map < PoolType , Collection < String > > classifyMemoryPools ( MBeanServerConnection conn ) throws IOException { RuntimeMXBean rtmx = JMX . newMXBeanProxy ( conn , RUNTIME_MXBEAN , RuntimeMXBean . class ) ; boolean jrockit = rtmx . getVmName ( ) . toUpperCase ( ) . contains ( " JROCKIT " ) ; Map < PoolType , Collection < String > > map = new HashMap < GcKnowledgeBase . PoolType , Collection < String > > ( ) ; for ( ObjectName gcn : conn . queryNames ( COLLECTORS_PATTERN , null ) ) { GarbageCollectorMXBean gc = JMX . newMXBeanProxy ( conn , gcn , GarbageCollectorMXBean . class ) ; String gcName = jrockit ? " JRockit " : gc . getName ( ) ; for ( String pool : gc . getMemoryPoolNames ( ) ) { PoolType type = classify ( gcName , pool ) ; if ( type ! = null ) { add ( map , type , pool ) ; } } } return map ; }
private static PoolType classify ( String gcName , String pool ) { for ( GcTypeMatcher m : GC_CATALOG ) { if ( m . gcName . equals ( gcName ) & & m . poolName . equals ( pool ) ) { return m . type ; } } return null ; }
private static void add ( Map < PoolType , Collection < String > > map , PoolType type , String name ) { if ( map . containsKey ( type ) ) { List < String > names = new ArrayList < String > ( ) ;
private static GcTypeMatcher eden ( String algo , String poolName ) { return new GcTypeMatcher ( algo , poolName , PoolType . EDEN ) ; }
private static GcTypeMatcher survivour ( String algo , String poolName ) { return new GcTypeMatcher ( algo , poolName , PoolType . SURVIVOR ) ; }
private static GcTypeMatcher tenured ( String algo , String poolName ) { return new GcTypeMatcher ( algo , poolName , PoolType . TENURED ) ; }
private static GcTypeMatcher permanent ( String algo , String poolName ) { return new GcTypeMatcher ( algo , poolName , PoolType . PERMANENT ) ; }
public static void logOff ( ) { LogManager . getLogManager ( ) . getLogger ( " " ) . setLevel ( Level . OFF ) ; }
public static void initCloud ( ) { ViProps . at ( cloud . node ( " ** " ) ) . setLocalType ( ) ; JvmProps . at ( cloud . node ( " ** " ) ) . addJvmArg ( " -Djava.util.logging.config.class= " + LogOff . class . getName ( ) ) ; }
public void classify_local ( ) throws IOException { dumpMemoryPools ( ) ; }
public void classify_serial_gc ( ) throws IOException { try { String gc = " -XX:+UseSerialGC " ;
public Void call ( ) throws Exception { dumpMemoryPools ( ) ; return null ; }
public void classify_par_new_gc ( ) throws IOException { try { String gc = " -XX:+UseParNewGC " ;
public void classify_ps_gc ( ) throws IOException { try { String gc = " |-XX:+UseParallelGC|-XX:-UseParallelOldGC " ;
public void classify_par_old_gc ( ) throws IOException { try { String gc = " -XX:+UseParallelOldGC " ;
public void classify_cms_def_new_gc ( ) throws IOException { try { String gc = " |-XX:+UseConcMarkSweepGC|-XX:-UseParNewGC " ;
public void classify_cms_par_new_gc ( ) throws IOException { try { String gc = " |-XX:+UseConcMarkSweepGC|-XX:+UseParNewGC " ;
public void classify_g1_gc ( ) throws IOException { try { String gc = " -XX:+UseG1GC " ;
public static void dumpMemoryPools ( ) throws IOException { Map < PoolType , Collection < String > > pools = GcKnowledgeBase . classifyMemoryPools ( ManagementFactory . getPlatformMBeanServer ( ) ) ; for ( PoolType pt : pools . keySet ( ) ) { System . out . println ( pt . toString ( ) + pools . get ( pt ) ) ;
public void run ( int seconds ) { long deadline = System . currentTimeMillis ( ) + TimeUnit . SECONDS . toMillis ( seconds ) ; while ( System . currentTimeMillis ( ) < deadline ) { for ( GcAdapter a : adapters ) {
public void addToAll ( GarbageCollectionSampler sampler ) throws MalformedObjectNameException , IOException { for ( ObjectName gc : ManagementFactory . getPlatformMBeanServer ( ) . queryNames ( GcKnowledgeBase . COLLECTORS_PATTERN , null ) ) { GcAdapter a = new GcAdapter ( ManagementFactory . getPlatformMBeanServer ( ) , gc , sampler ) ;
public void simple_report ( ) throws MalformedObjectNameException , IOException { addToAll ( new SimpleReporter ( ) ) ; run ( 20 ) ; }
public void report ( String algoName , int eventsMissed , GcReport info ) { if ( eventsMissed > 0 ) { System . out . println ( " Missed " + eventsMissed + " events for [ " + algoName + " ] " ) ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ " + algoName + " ] # " + info . getId ( ) ) . append ( ' ' ) ; reportSize ( info , sb , info . getAllMemoryPools ( ) ) ; sb . append ( '\n' ) ; sb . append ( " " ) ; Collection < String > eden = info . getEdenPools ( ) ; Collection < String > surv = info . getSurvivourPools ( ) ; Collection < String > old = info . getOldSpacePools ( ) ; Collection < String > perm = info . getPermSpacePools ( ) ; if ( ! eden . isEmpty ( ) ) { sb . append ( " EDEN[ " ) ; reportSize ( info , sb , eden ) ; sb . append ( " ] " ) ; } if ( ! surv . isEmpty ( ) ) { sb . append ( " SURVIVOUR[ " ) ; reportSize ( info , sb , surv ) ; sb . append ( " ] " ) ; } if ( ! old . isEmpty ( ) ) { sb . append ( " OLD[ " ) ; reportSize ( info , sb , old ) ; sb . append ( " ] " ) ; } if ( ! perm . isEmpty ( ) & & info . getSizeBefore ( perm ) ! = info . getSizeAfter ( perm ) ) { sb . append ( " PERM[ " ) ; reportSize ( info , sb , perm ) ; sb . append ( " ] " ) ; } sb . append ( '\n' ) ; System . out . print ( sb ) ; }
public void reportSize ( GcReport info , StringBuilder sb , Collection < String > pools ) { long delta = info . getSizeAfter ( pools ) - info . getSizeBefore ( pools ) ; sb . append ( FormatHelper . toMemoryUnits ( info . getSizeBefore ( pools ) ) ) . append ( 'B' ) ; if ( delta ! = 0 ) { sb . append ( " -> " )
public static PoolType classify ( String gcName , String pool ) { for ( GcTypeMatcher m : GC_CATALOG ) { if ( m . gcName . equals ( gcName ) & & m . poolName . equals ( pool ) ) { return m . type ; } } return null ; }
private int align ( int size , int al ) { return ( size + al - 1 ) & ( ~ ( al - 1 ) ) ; }
private long getOldSpaceUsed ( ) { long usage = oldMemPool . getUsage ( ) . getUsed ( ) ; if ( usage < 0 ) { return oldGcMBean . getLastGcInfo ( ) . getMemoryUsageAfterGc ( ) . get ( oldMemPool . getName ( ) ) . getUsed ( ) ;
private void calculateCount ( long tenuredSize ) { count = ( int ) ( ( tenuredSize - ( headRoom < < 20 ) ) / entrySize ) ; if ( concurentMode ) { count / = 2 ;
private void initMaps ( int entryCount ) { maps = new Map [ ( entryCount + 200000 - 1 ) / 200000 ] ; for ( int i = 0 ; i ! = maps . length ; + + i ) { maps [ i ] = new HashMap < Integer , Object > ( 250000 > > 8 ) ;
private void processMap ( boolean dry ) { boolean remove = size ( ) > 1.01 * count ; for ( int i = 0 ; i ! = 1000 ; + + i ) { if ( ( remove ) & & random . nextBoolean ( ) ) {
private void populateMap ( boolean concurentMode , int count ) { for ( int i = 0 ; i ! = 1000 ; + + i ) { putRandom ( count ) ;
private int size ( ) { int size = 0 ; for ( Map map : maps ) { size + = map . size ( ) ; } return size ; }
private Object newObject ( ) { switch ( mode ) { case STRING : return new String ( STRING_TEMPLATE ) ; case INT : return new Integer ( random . nextInt ( ) ) ; case LONG : return new Long ( random . nextInt ( ) ) ; case CONST : return this ; } return null ; }
private void putRandom ( int count ) { int key = random . nextInt ( 2 * count ) ; if ( Math . abs ( random . nextDouble ( ) ) < activeOverrideRate ) { Object val = newObject ( ) ;
private void dryPutRandom ( int count ) { int key = random . nextInt ( 2 * count ) ; Object val = newObject ( ) ; val . equals ( maps [ key % maps . length ] . get ( key ) ) ; }
private void removeRandom ( int count ) { int key = random . nextInt ( 2 * count ) ; maps [ key % maps . length ] . remove ( key ) ; }
private void dryRemoveRandom ( int count ) { int key = random . nextInt ( 2 * count ) ; maps [ key % maps . length ] . get ( key ) ; }
public void init ( ) { while ( true ) { long ygc = youngGcMBean . getCollectionCount ( ) ;
public void probe ( ) { while ( true ) { long ygc = youngGcMBean . getCollectionCount ( ) ;
public TestResult result ( ) { TestResult result = new TestResult ( ) ; result . totalSquareTime = squareTotal ; result . totalTime = totalTime ; result . youngGcCount = evenCount ; return result ; }
public String toString ( ) { double avg = ( ( double ) totalTime ) / youngGcCount ; double stdDev = Math . sqrt ( ( totalSquareTime / youngGcCount ) - ( avg * avg ) ) ; return String . format ( " %f [%f] ms " , avg , stdDev ) ; }
public void go ( ) throws IOException { YoungGCPauseBenchmark bench = new YoungGCPauseBenchmark ( ) ; bench . headRoom = 64 ; bench . printEvents = true ; TestResult result = bench . benchmark ( ) ; Assert . assertTrue ( result ! = null ) ; System . out . println ( result ) ; }
public void run ( ) { try { ObjectName q = null ;
private static void listBeans ( ObjectName query , JsonGenerator jg , MBeanServerConnection mBeanServer ) throws Exception { Set < ObjectName > names = null ; names = mBeanServer . queryNames ( query , null ) ; jg . writeArrayFieldStart ( " beans " ) ; Iterator < ObjectName > it = names . iterator ( ) ; while ( it . hasNext ( ) ) { ObjectName oname = it . next ( ) ; MBeanInfo minfo ; String code = " " ; minfo = mBeanServer . getMBeanInfo ( oname ) ; code = minfo . getClassName ( ) ; String prs = " " ; if ( " org.apache.commons.modeler.BaseModelMBean " . equals ( code ) ) { prs = " modelerType " ; code = ( String ) mBeanServer . getAttribute ( oname , prs ) ; } jg . writeStartObject ( ) ; jg . writeStringField ( " name " , oname . toString ( ) ) ; jg . writeStringField ( " modelerType " , code ) ; MBeanAttributeInfo attrs [ ] = minfo . getAttributes ( ) ; for ( int i = 0 ; i < attrs . length ; i + + ) { writeAttribute ( mBeanServer , jg , oname , attrs [ i ] ) ; } jg . writeEndObject ( ) ; } jg . writeEndArray ( ) ; }
public void mxdump_by_query ( ) { exec ( " mxdump " , " -p " , PID , " -q " , " java.lang:type=GarbageCollector,name=* " ) ; }
private MBeanServerConnection connectJmx ( String host , int port ) { try { final String uri = " service:jmx:rmi:///jndi/rmi:// " + host + " : " + port + " /jmxrmi " ; JMXServiceURL jmxurl = new JMXServiceURL ( uri ) ; JMXConnector conn = JMXConnectorFactory . connect ( jmxurl ) ; // TODO credentials MBeanServerConnection mserver = conn.getMBeanServerConnection(); return mserver; } catch (MalformedURLException e) { SJK.fail(e.toString()); } catch (IOException e) { SJK.fail(e.toString()); } return null; }
private String host ( String sockAddr ) { int c = sockAddr . indexOf ( ':' ) ; if ( c < = 0 ) { SJK . fail ( " Invalid socket address: " + sockAddr ) ; } return sockAddr . substring ( 0 , c ) ; }
private int port ( String sockAddr ) { int c = sockAddr . indexOf ( ':' ) ; if ( c < = 0 ) { SJK . fail ( " Invalid socket address: " + sockAddr ) ; } try { return Integer . valueOf ( sockAddr . substring ( c + 1 ) ) ;
public double getAverage ( ) { double avg = ( ( double ) totalTime ) / youngGcCount ; return avg ; }
public double getStdDev ( ) { double avg = ( ( double ) totalTime ) / youngGcCount ; double stdDev = Math . sqrt ( ( totalSquareTime / youngGcCount ) - ( avg * avg ) ) ; return stdDev ; }
private boolean getThreadingMBeanCapability ( String attrName ) { try { Object val = mserver . getAttribute ( THREADING_MBEAN , attrName ) ;
public void sortByAllocRate ( ) { comparators . add ( 0 , new AllocRateComparator ( ) ) ; }
private Object format ( ThreadLine line ) { if ( threadAllocatedMemoryEnabled ) { return String . format ( " [%06d] user=%5.2f%% sys=%5.2f%% alloc=%6sb/s - %s " , line . id , line . userT , ( line . sysT ) , Formats . toMemorySize ( ( long ) line . allocRate ) , line . name ) ;
private void dumpThreads ( ) { try { ObjectName bean = THREADING_MBEAN ;
private long getThreadCpuTime ( long tid ) { try { ObjectName bean = THREADING_MBEAN ;
private long getThreadUserTime ( long tid ) { try { ObjectName bean = THREADING_MBEAN ;
private long getThreadAllocatedBytes ( long tid ) { if ( threadAllocatedMemoryEnabled ) { try {
public int compare ( ThreadLine o1 , ThreadLine o2 ) { return Double . compare ( o2 . allocRate , o1 . allocRate ) ; }
public void ttop_top_N_cpu ( ) { exec ( " ttop " , " -p " , " 3380 " , " -o " , " CPU " , " -n " , " 10 " ) ; }
public void ttop_top_N_alloc ( ) { exec ( " ttop " , " -p " , " 3380 " , " -o " , " ALLOC " , " -n " , " 10 " ) ; }
public String describe ( ObjectName bean ) throws Exception { MBeanInfo mbinfo = mserver . getMBeanInfo ( bean ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( bean ) ; sb . append ( '\n' ) ; sb . append ( mbinfo . getClassName ( ) ) ; sb . append ( '\n' ) ; sb . append ( " - " + mbinfo . getDescription ( ) ) ; sb . append ( '\n' ) ; for ( MBeanAttributeInfo ai : mbinfo . getAttributes ( ) ) { sb . append ( " (A) " ) ; sb . append ( ai . getName ( ) ) . append ( " : " ) . append ( toPrintableType ( ai . getType ( ) ) ) . append ( " " ) ; if ( ! ai . isReadable ( ) ) { sb . append ( " - WRITEONLY " ) ; } else if ( ai . isWritable ( ) ) { sb . append ( " - WRITEABLE " ) ; } sb . append ( '\n' ) ; if ( ! ai . getName ( ) . equals ( ai . getDescription ( ) ) ) { sb . append ( " - " + ai . getDescription ( ) ) ; sb . append ( '\n' ) ; } } for ( MBeanOperationInfo oi : mbinfo . getOperations ( ) ) { sb . append ( " (O) " ) ; sb . append ( oi . getName ( ) ) . append ( " ( " ) ; for ( MBeanParameterInfo pi : oi . getSignature ( ) ) { String name = pi . getName ( ) ; String type = toPrintableType ( pi . getType ( ) ) ; sb . append ( type ) . append ( ' ' ) . append ( name ) . append ( " , " ) ; } if ( oi . getSignature ( ) . length > 0 ) { sb . setLength ( sb . length ( ) - 2 ) ; } sb . append ( " ) : " ) . append ( toPrintableType ( oi . getReturnType ( ) ) ) ; sb . append ( '\n' ) ; if ( ! oi . getName ( ) . equals ( oi . getDescription ( ) ) ) { sb . append ( " - " + oi . getDescription ( ) ) ; sb . append ( '\n' ) ; } } return sb . toString ( ) ; }
static String toPrintableType ( String type ) { if ( TYPE_MAP . containsKey ( type ) ) { return TYPE_MAP . get ( type ) ;
public void test_bean_describer ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; System . out . println ( helper . describe ( new ObjectName ( ManagementFactory . THREAD_MXBEAN_NAME ) ) ) ; }
public String get ( ObjectName bean , String attr ) throws Exception { MBeanInfo mbinfo = mserver . getMBeanInfo ( bean ) ; MBeanAttributeInfo ai = attrInfo ( mbinfo , attr ) ; if ( ai = = null ) { throw new IllegalArgumentException ( " No such attribute ' " + attr + " ' " ) ; } if ( ! ai . isReadable ( ) ) { throw new IllegalArgumentException ( " Attribute ' " + attr + " ' is write-only " ) ; } Object v = mserver . getAttribute ( bean , attr ) ; String type = ai . getType ( ) ; String text = format ( v , type ) ; return text ; }
public void set ( ObjectName bean , String attr , String value ) throws Exception { MBeanInfo mbinfo = mserver . getMBeanInfo ( bean ) ; MBeanAttributeInfo ai = attrInfo ( mbinfo , attr ) ; if ( ai = = null ) { throw new IllegalArgumentException ( " No such attribute ' " + attr + " ' " ) ; } if ( ! ai . isWritable ( ) ) { throw new IllegalArgumentException ( " Attribute ' " + attr + " ' is not writeable " ) ; } String type = ai . getType ( ) ; Object ov = convert ( value , type ) ; mserver . setAttribute ( bean , new Attribute ( attr , ov ) ) ; }
private String format ( Object v , String type ) { // if (v instanceof TabularData) { // // } // else if (v instanceof CompositeData) { // // } // else { return String.valueOf(v); // }
private String formatLine ( Object v , String type ) { return String . valueOf ( v ) ; }
private Object convert ( String value , String type ) { if ( type . equals ( " java.lang.String " ) ) { return value ; } if ( type . equals ( " boolean " ) ) { return Boolean . valueOf ( value ) ; } else if ( type . equals ( " byte " ) ) { return Byte . valueOf ( value ) ; } else if ( type . equals ( " short " ) ) { return Short . valueOf ( value ) ; } else if ( type . equals ( " char " ) ) { if ( value . length ( ) = = 1 ) { return value . charAt ( 0 ) ; } else { throw new IllegalArgumentException ( " Cannot convert ' " + value + " ' to " + type ) ; } } else if ( type . equals ( " int " ) ) { return Integer . valueOf ( value ) ; } else if ( type . equals ( " long " ) ) { return Long . valueOf ( value ) ; } else if ( type . equals ( " float " ) ) { return Float . valueOf ( value ) ; } else if ( type . equals ( " double " ) ) { return Double . valueOf ( value ) ; } else if ( type . startsWith ( " [ " ) ) { String [ ] elements = value . split ( " [,] " ) ; Object array = ARRAY_MAP . get ( type ) ; if ( array = = null ) { throw new IllegalArgumentException ( " Cannot convert ' " + value + " ' to " + type ) ; } array = Array . newInstance ( array . getClass ( ) . getComponentType ( ) , elements . length ) ; String etype = array . getClass ( ) . getComponentType ( ) . getName ( ) ; for ( int i = 0 ; i ! = elements . length ; + + i ) { Array . set ( array , i , convert ( elements [ i ] , etype ) ) ; } return array ; } throw new IllegalArgumentException ( " Cannot convert ' " + value + " ' to " + type ) ; }
private MBeanAttributeInfo attrInfo ( MBeanInfo mbinfo , String attr ) { for ( MBeanAttributeInfo ai : mbinfo . getAttributes ( ) ) { if ( ai . getName ( ) . equals ( attr ) ) { return ai ; } } return null ; }
public Runnable newCommand ( SJK host ) { return new MX ( host ) ; }
public void run ( ) { // TODO Auto-generated method stub } class CallCmd implements Runnable { @Parameter(names={"-mc", "--call"}, description="Invokes MBean method") boolean run; @Override public void run() { // TODO Auto-generated method stub } } class GetCmd implements Runnable { @Parameter(names={"-mg", "--get"}, description="Retrieves value of MBean attribute") boolean run; @Override public void run() { // TODO Auto-generated method stub } } class SetCmd implements Runnable { @Parameter(names={"-ms", "--set"}, description="Sets value for MBean attribute") boolean run; @Override public void run() { // TODO Auto-generated method stub } } class InfoCmd implements Runnable { @Parameter(names={"-mi", "--info"}, description="Display metadata for MBean") boolean run; @Override public void run() { // TODO Auto-generated method stub } } } }
public void run ( ) { // TODO Auto-generated method stub } } class GetCmd implements Runnable { @Parameter(names={"-mg", "--get"}, description="Retrieves value of MBean attribute") boolean run; @Override public void run() { // TODO Auto-generated method stub } } class SetCmd implements Runnable { @Parameter(names={"-ms", "--set"}, description="Sets value for MBean attribute") boolean run; @Override public void run() { // TODO Auto-generated method stub } } class InfoCmd implements Runnable { @Parameter(names={"-mi", "--info"}, description="Display metadata for MBean") boolean run; @Override public void run() { // TODO Auto-generated method stub } } } }
public void run ( ) { // TODO Auto-generated method stub } } class SetCmd implements Runnable { @Parameter(names={"-ms", "--set"}, description="Sets value for MBean attribute") boolean run; @Override public void run() { // TODO Auto-generated method stub } } class InfoCmd implements Runnable { @Parameter(names={"-mi", "--info"}, description="Display metadata for MBean") boolean run; @Override public void run() { // TODO Auto-generated method stub } } } }
public void run ( ) { // TODO Auto-generated method stub } } class InfoCmd implements Runnable { @Parameter(names={"-mi", "--info"}, description="Display metadata for MBean") boolean run; @Override public void run() { // TODO Auto-generated method stub } } } }
public void run ( ) { // TODO Auto-generated method stub } } } }
private ObjectName memoryMXBean ( ) throws MalformedObjectNameException { return new ObjectName ( ManagementFactory . MEMORY_MXBEAN_NAME ) ; }
private ObjectName osMXBean ( ) throws MalformedObjectNameException { return new ObjectName ( ManagementFactory . OPERATING_SYSTEM_MXBEAN_NAME ) ; }
private ObjectName threadMXBean ( ) throws MalformedObjectNameException { return new ObjectName ( ManagementFactory . THREAD_MXBEAN_NAME ) ; }
private ObjectName runtimeMXBean ( ) throws MalformedObjectNameException { return new ObjectName ( ManagementFactory . RUNTIME_MXBEAN_NAME ) ; }
private ObjectName managementMXBean ( ) throws MalformedObjectNameException { return new ObjectName ( " com.sun.management:type=HotSpotDiagnostic " ) ; }
public void test_thread_bean_describer ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; System . out . println ( helper . describe ( threadMXBean ( ) ) ) ; }
public void test_os_bean_describer ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; System . out . println ( helper . describe ( osMXBean ( ) ) ) ; }
public void test_memory_bean_describer ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; System . out . println ( helper . describe ( memoryMXBean ( ) ) ) ; }
public void test_runtime_bean_describer ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; System . out . println ( helper . describe ( runtimeMXBean ( ) ) ) ; }
public void test_management_bean_describer ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; System . out . println ( helper . describe ( managementMXBean ( ) ) ) ; }
public void test_bean_get_set ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; helper . set ( threadMXBean ( ) , " ThreadAllocatedMemoryEnabled " , " true " ) ; System . out . println ( " ThreadAllocatedMemoryEnabled: " + helper . get ( threadMXBean ( ) , " ThreadAllocatedMemoryEnabled " ) ) ; helper . set ( threadMXBean ( ) , " ThreadAllocatedMemoryEnabled " , " FALSE " ) ; System . out . println ( " ThreadAllocatedMemoryEnabled: " + helper . get ( threadMXBean ( ) , " ThreadAllocatedMemoryEnabled " ) ) ; }
public void test_bean_invalid_set ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; helper . set ( managementMXBean ( ) , " ThreadAllocatedMemoryEnabled " , " true " ) ; }
public void test_get_sys_props ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; System . out . println ( helper . get ( runtimeMXBean ( ) , " SystemProperties " ) ) ; }
public String invoke ( ObjectName bean , String operation , String . . . params ) throws InstanceNotFoundException , IntrospectionException , ReflectionException , IOException , MBeanException { MBeanInfo mbinfo = mserver . getMBeanInfo ( bean ) ; MBeanOperationInfo op = null ; for ( MBeanOperationInfo oi : mbinfo . getOperations ( ) ) { if ( oi . getName ( ) . equalsIgnoreCase ( operation ) & & oi . getSignature ( ) . length = = params . length ) { if ( op ! = null ) { throw new IllegalArgumentException ( " Ambigous " + operation + " / " + params . length + " operatition signature for " + bean ) ; } op = oi ; } } if ( op = = null ) { throw new IllegalArgumentException ( " Operation " + operation + " / " + params . length + " not found for " + bean ) ; } Object [ ] args = new Object [ params . length ] ; String [ ] sig = new String [ params . length ] ; for ( int i = 0 ; i ! = params . length ; + + i ) { args [ i ] = convert ( params [ i ] , op . getSignature ( ) [ i ] . getType ( ) ) ; sig [ i ] = op . getSignature ( ) [ i ] . getType ( ) ; } return format ( mserver . invoke ( bean , op . getName ( ) , args , sig ) , op . getReturnType ( ) ) ; }
private String format ( Object v , String type ) { if ( type . equals ( " void " ) ) { return null ;
private String formatTable ( List < String [ ] > content , int maxCell , boolean table ) { int [ ] width = new int [ content . get ( 0 ) . length ] ; for ( String [ ] row : content ) { for ( int i = 0 ; i ! = row . length ; + + i ) { width [ i ] = Math . min ( Math . max ( width [ i ] , row [ i ] . length ( ) ) , maxCell ) ; } } StringBuilder sb = new StringBuilder ( ) ; boolean header = table ; for ( String [ ] row : content ) { for ( int i = 0 ; i ! = width . length ; + + i ) { String cell = row [ i ] ; if ( cell . length ( ) > width [ i ] ) { cell = cell . substring ( 0 , width [ i ] - 3 ) + " ... " ; } sb . append ( cell ) ; for ( int s = 0 ; s ! = width [ i ] - cell . length ( ) ; + + s ) { sb . append ( ' ' ) ; } if ( table ) { sb . append ( '|' ) ; } } if ( table ) { sb . setLength ( sb . length ( ) - 1 ) ; } sb . append ( '\n' ) ; if ( header ) { header = false ; for ( int n : width ) { for ( int i = 0 ; i ! = n ; + + i ) { sb . append ( '-' ) ; } sb . append ( '+' ) ; } sb . setLength ( sb . length ( ) - 1 ) ; sb . append ( '\n' ) ; } } return sb . toString ( ) ; }
private String formatLine ( Object v , String type ) { if ( v instanceof TabularData ) { TabularData td = ( TabularData ) v ; StringBuilder sb = new StringBuilder ( ) ; for ( Object c : td . values ( ) ) { sb . append ( formatLine ( c , td . getTabularType ( ) . getRowType ( ) . getClassName ( ) ) ) ; sb . append ( " , " ) ; } if ( sb . length ( ) > 0 ) { sb . setLength ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; } if ( v instanceof CompositeData [ ] ) { CompositeData [ ] td = ( CompositeData [ ] ) v ;
private String [ ] formatRow ( CompositeData row , List < String > header ) { String [ ] text = new String [ header . size ( ) ] ; for ( int i = 0 ; i ! = text . length ; + + i ) { String attr = header . get ( i ) ; text [ i ] = formatLine ( row . get ( attr ) , row . getCompositeType ( ) . getType ( attr ) . getClassName ( ) ) ; } return text ; }
public void run ( ) { try { List < Runnable > action = new ArrayList < Runnable > ( ) ;
private ObjectName resolveSingleBean ( MBeanServerConnection conn ) throws Exception { ObjectName name = new ObjectName ( mbean ) ; Set < ObjectName > beans = conn . queryNames ( name , null ) ; if ( beans . isEmpty ( ) ) { SJK . fail ( " MBean not found: " + mbean ) ; } if ( beans . size ( ) > 1 ) { StringBuilder sb = new StringBuilder ( ) ; for ( ObjectName n : beans ) { sb . append ( '\n' ) . append ( n ) ; } SJK . fail ( " Ambigous MBean selection " + sb . toString ( ) ) ; } return beans . iterator ( ) . next ( ) ; }
public void run ( ) { try { if ( operation = = null ) {
public void run ( ) { try { if ( attrib = = null ) {
public void run ( ) { try { MBeanServerConnection conn = connInfo . getMServer ( ) ;
public void jps_filter_by_prop ( ) { System . setProperty ( " my.prop " , " 123 " ) ; exec ( " jps " , " -fp " , " my.*=123 " ) ; }
public void jps_filter_by_desc ( ) { exec ( " jps " , " -fd " , " *junit* " ) ; }
public void jps_print ( ) { exec ( " jps " , " -pd " , " PID " , " MAIN " , " Duser.dir " ) ; }
public void jps_print_flags ( ) { exec ( " jps " , " -pd " , " PID " , " MAIN " , " XMaxHeapSize " , " XBackgroundCompilation " ) ; }
public void mx_info ( ) { exec ( " mx " , " -p " , PID , " --info " , " --bean " , " *:type=HotSpotDiagnostic " ) ; }
public void mx_get_diagnostic_ops ( ) { exec ( " mx " , " -p " , PID , " --get " , " --bean " , " *:type=HotSpotDiagnostic " , " -f " , " DiagnosticOptions " ) ; }
public void mx_set_threading_alloc ( ) { exec ( " mx " , " -p " , PID , " --set " , " --bean " , " *:type=Threading " , " -f " , " ThreadAllocatedMemoryEnabled " , " -v " , " true " ) ; }
public void mx_get_thread_dump ( ) { exec ( " mx " , " -p " , PID , " --call " , " --bean " , " *:type=Threading " , " -op " , " dumpAllThreads " , " -a " , " true " , " true " ) ; }
public void mx_info_ambigous ( ) { fail ( " mx " , " -p " , PID , " --info " , " --bean " , " *:type=GarbageCollector,* " ) ; }
private void fail ( String . . . cmd ) { SJK sjk = new SJK ( ) ; sjk . suppressSystemExit ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " SJK " ) ; for ( String c : cmd ) { sb . append ( ' ' ) . append ( escape ( c ) ) ; } System . out . println ( sb ) ; Assert . assertFalse ( sjk . start ( cmd ) ) ; }
public void test_bean_get_set ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; helper . set ( threadMXBean ( ) , " ThreadCpuTimeEnabled " , " true " ) ; System . out . println ( " ThreadCpuTimeEnabled: " + helper . get ( threadMXBean ( ) , " ThreadAllocatedMemoryEnabled " ) ) ; helper . set ( threadMXBean ( ) , " ThreadCpuTimeEnabled " , " FALSE " ) ; System . out . println ( " ThreadCpuTimeEnabled: " + helper . get ( threadMXBean ( ) , " ThreadAllocatedMemoryEnabled " ) ) ; }
public void test_bean_invalid_set ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; helper . set ( managementMXBean ( ) , " ThreadCpuTimeEnabled " , " true " ) ; }
public void test_get_mem_heap ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; System . out . println ( helper . get ( memoryMXBean ( ) , " HeapMemoryUsage " ) ) ; }
public void test_get_thread_dump ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; System . out . println ( helper . invoke ( threadMXBean ( ) , " dumpAllThreads " , " true " , " true " ) ) ; }
public void test_find_deadlocked_threads ( ) throws Exception { MBeanHelper helper = new MBeanHelper ( ManagementFactory . getPlatformMBeanServer ( ) ) ; System . out . println ( helper . invoke ( threadMXBean ( ) , " findMonitorDeadlockedThreads " ) ) ; }
private MBeanServerConnection connectJmx ( String host , int port , Map < String , Object > props ) { try { final String uri = " service:jmx:rmi:///jndi/rmi:// " + host + " : " + port + " /jmxrmi " ; JMXServiceURL jmxurl = new JMXServiceURL ( uri ) ; JMXConnector conn = props = = null ? JMXConnectorFactory . connect ( jmxurl ) : JMXConnectorFactory . connect ( jmxurl , props ) ; // TODO credentials MBeanServerConnection mserver = conn.getMBeanServerConnection(); return mserver; } catch (MalformedURLException e) { SJK.fail(e.toString()); } catch (IOException e) { SJK.fail(e.toString()); } return null; }
public Runnable newCommand ( SJK host ) { return new Histo ( host ) ; }
static List < String > listFiles ( List < String > results , URL packageURL , String path ) throws IOException { if ( packageURL . getProtocol ( ) . equals ( " jar " ) ) { String jarFileName ; JarFile jf ; Enumeration < JarEntry > jarEntries ; String entryName ; // build jar file name, then loop through zipped entries jarFileName = URLDecoder.decode(packageURL.getFile(), "UTF-8"); jarFileName = jarFileName.substring(5,jarFileName.indexOf("!")); jf = new JarFile(jarFileName); jarEntries = jf.entries(); while(jarEntries.hasMoreElements()){ entryName = jarEntries.nextElement().getName(); if(entryName.startsWith(path)){ results.add(entryName); } } // loop through files in classpath }else{ File dir = new File(packageURL.getFile()); String cp = dir.getCanonicalPath(); File root = dir; while(true) { if (cp.equals(new File(root, path).getCanonicalPath())) { break; } root = root.getParentFile(); } listFiles(results, root, dir); } return results; }
public int compare ( ThreadLine o1 , ThreadLine o2 ) { return Double . compare ( o2 . userT + o2 . sysT , o1 . userT + o1 . sysT ) ; }
public String invoke ( ObjectName bean , String operation , String . . . params ) throws InstanceNotFoundException , IntrospectionException , ReflectionException , IOException , MBeanException { MBeanInfo mbinfo = mserver . getMBeanInfo ( bean ) ; MBeanOperationInfo op = null ; for ( MBeanOperationInfo oi : mbinfo . getOperations ( ) ) { if ( oi . getName ( ) . equalsIgnoreCase ( operation ) & & oi . getSignature ( ) . length = = params . length ) { if ( op ! = null ) { throw new IllegalArgumentException ( " Ambiguous " + operation + " / " + params . length + " operatition signature for " + bean ) ; } op = oi ; } } if ( op = = null ) { throw new IllegalArgumentException ( " Operation " + operation + " / " + params . length + " not found for " + bean ) ; } Object [ ] args = new Object [ params . length ] ; String [ ] sig = new String [ params . length ] ; for ( int i = 0 ; i ! = params . length ; + + i ) { args [ i ] = convert ( params [ i ] , op . getSignature ( ) [ i ] . getType ( ) ) ; sig [ i ] = op . getSignature ( ) [ i ] . getType ( ) ; } return format ( mserver . invoke ( bean , op . getName ( ) , args , sig ) , op . getReturnType ( ) ) ; }
private Set < ObjectName > resolveSingleBean ( MBeanServerConnection conn ) throws Exception { ObjectName name = new ObjectName ( mbean ) ; Set < ObjectName > beans = conn . queryNames ( name , null ) ; if ( beans . isEmpty ( ) ) { SJK . fail ( " MBean not found: " + mbean ) ; } if ( ! all & & beans . size ( ) > 1 ) { StringBuilder sb = new StringBuilder ( ) ; for ( ObjectName n : beans ) { sb . append ( '\n' ) . append ( n ) ; } SJK . fail ( " Ambiguous MBean selection. Use '-all' param for process all matched MBeans " + sb . toString ( ) ) ; } return beans ; }
public void ttop_top_N_cpu ( ) { exec ( " ttop " , " -p " , " 3380 " , " -o " , " CPU " , " -n " , " 10 " ) ; }
public void ttop_top_N_alloc ( ) { exec ( " ttop " , " -p " , " 3380 " , " -o " , " ALLOC " , " -n " , " 10 " ) ; }
public void mx_info_all ( ) { exec ( " mx " , " -p " , PID , " --info " , " -all " , " --bean " , " *:type=MemoryPool,* " ) ; }
public void mx_get_usage_threshold ( ) { exec ( " mx " , " -p " , PID , " --get " , " -all " , " --bean " , " *:type=MemoryPool,name=PS* " , " -f " , " CollectionUsageThreshold " ) ; }
public void mx_set_usage_threshold ( ) { exec ( " mx " , " -p " , PID , " --set " , " -all " , " --bean " , " *:type=MemoryPool,name=PS* " , " -f " , " CollectionUsageThreshold " , " -v " , " 1 " ) ; }
public void mx_get_resetPeakUsage_all ( ) { exec ( " mx " , " -p " , PID , " --call " , " -all " , " --bean " , " *:type=MemoryPool,* " , " -op " , " resetPeakUsage " ) ; }
public void mx_info_ambiguous ( ) { fail ( " mx " , " -p " , PID , " --info " , " --bean " , " *:type=GarbageCollector,* " ) ; }
public static boolean isProvider ( Key < ? > key ) { return key . getTypeLiteral ( ) . getRawType ( ) . equals ( Provider . class ) ; }
public static < T > TypeLiteral < T > getProvidedType ( TypeLiteral < ? extends Provider < ? extends T > > providerTypeLiteral , Errors errors ) throws ErrorsException { Type providerType = providerTypeLiteral . getType ( ) ; // If the Provider has no type parameter (raw Provider)... if (!(providerType instanceof ParameterizedType)) { throw errors.cannotInjectRawProvider().toException(); } Type entryType = ((ParameterizedType) providerType).getActualTypeArguments()[0]; return (TypeLiteral<T>) TypeLiteral.get(entryType); }
public static < T > Key < T > getProvidedKey ( Key < Provider < T > > key , Errors errors ) throws ErrorsException { TypeLiteral < T > providedType = getProvidedType ( key . getTypeLiteral ( ) , errors ) ; Key < T > providedKey ; if ( key . getAnnotation ( ) = = null ) { providedKey = ( Key < T > ) Key . get ( providedType ) ; } else { providedKey = ( Key < T > ) Key . get ( providedType , key . getAnnotation ( ) ) ; } return providedKey ; }
public static < T > Key < T > ensureProvidedKey ( Key < T > key , Errors errors ) { try { return isProvider ( key ) ? getProvidedKey ( ( Key < Provider < T > > ) key , errors ) : key ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } return null ; }
public static List < Key < ? > > getMethodKeys ( Method method , Errors errors ) { Annotation allParameterAnnotations [ ] [ ] = method . getParameterAnnotations ( ) ; List < Key < ? > > result = new ArrayList < Key < ? > > ( allParameterAnnotations . length ) ; Iterator < Annotation [ ] > annotationsIterator = Arrays . asList ( allParameterAnnotations ) . iterator ( ) ; TypeLiteral < ? > type = TypeLiteral . get ( method . getDeclaringClass ( ) ) ; for ( TypeLiteral < ? > parameterType : type . getParameterTypes ( method ) ) { try { Annotation [ ] parameterAnnotations = annotationsIterator . next ( ) ; result . add ( Annotations . getKey ( parameterType , method , parameterAnnotations , errors ) ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } return result ; }
public void evaluate ( ) throws Throwable { List < Throwable > errors = new ArrayList < Throwable > ( ) ; errors . clear ( ) ; try { prev . evaluate ( ) ; } catch ( Throwable e ) { errors . add ( e ) ; } finally { for ( Statement after : afters ) { try { after . evaluate ( ) ; } catch ( Throwable e ) { errors . add ( e ) ; } } } if ( ! errors . isEmpty ( ) ) { throw new MultipleFailureException ( errors ) ;
public void evaluate ( ) throws Throwable { for ( Statement before : befores ) { before . evaluate ( ) ; } next . evaluate ( ) ; }
public List < Binding < ? > > getBindingsToUseForParameters ( ) { return bindingsToUseForParameters ; }
public void evaluate ( ) throws Throwable { Method javaMethod = method . getMethod ( ) ; Errors errors = new Errors ( javaMethod ) ; List < Key < ? > > keys = GuiceUtils . getMethodKeys ( javaMethod , errors ) ; errors . throwConfigurationExceptionIfErrorsExist ( ) ; Iterator < Binding < ? > > bindingIter ; if ( InjectedFrameworkMethod . class . isAssignableFrom ( method . getClass ( ) ) ) { bindingIter = ( ( InjectedFrameworkMethod ) method ) . getBindingsToUseForParameters ( ) . iterator ( ) ; } else { bindingIter = new ArrayList < Binding < ? > > ( ) . iterator ( ) ; } List < Object > injectedParameters = new ArrayList < Object > ( ) ; for ( Key < ? > key : keys ) { if ( ! All . class . equals ( key . getAnnotationType ( ) ) ) { injectedParameters . add ( injector . getInstance ( key ) ) ; } else { if ( ! bindingIter . hasNext ( ) ) { throw new AssertionError ( " Expected more bindings to fill @All parameters. " ) ; } injectedParameters . add ( injector . getInstance ( bindingIter . next ( ) . getKey ( ) ) ) ; } } method . invokeExplosively ( test , injectedParameters . toArray ( ) ) ; }
protected void forceMock ( Class < ? > klass ) { forceMock . add ( klass ) ; }
private void addNeededKey ( Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded , Key < ? > keyNeeded ) { keysNeeded . add ( keyNeeded ) ; bindIfConcrete ( keysObserved , keyNeeded ) ; }
private void bindIfConcrete ( Set < Key < ? > > keysObserved , Key < ? > key ) { TypeLiteral < ? > parameter = key . getTypeLiteral ( ) ; Class < ? > rawType = parameter . getRawType ( ) ; if ( isInstantiable ( rawType ) & & ! shouldForceMock ( rawType ) & &
private boolean shouldForceMock ( Class < ? > klass ) { if ( dontForceMock . contains ( klass ) ) { return false ; } if ( forceMock . contains ( klass ) ) { return true ; } // The forceMock set contains all the base classes the user wants // to force mock, check id the specified klass is a subclass of one of these. // Update forceMock or dontForceMock based on the result to speed-up future look-ups. boolean result = false; for (Class<?> classToMock : forceMock) { if (classToMock.isAssignableFrom(klass)) { result = true; break; } } if (result) { forceMock.add(klass); } else { dontForceMock.add(klass); } return result; }
private boolean isInstantiable ( Class < ? > klass ) { return ! klass . isInterface ( ) & & ! Modifier . isAbstract ( klass . getModifiers ( ) ) ; }
protected < T > LinkedBindingBuilder < T > bind ( Key < T > key ) { return new SpyLinkedBindingBuilder < T > ( newBindingObserved ( key ) , super . bind ( key ) ) ; }
protected < T > AnnotatedBindingBuilder < T > bind ( TypeLiteral < T > typeLiteral ) { return new SpyAnnotatedBindingBuilder < T > ( newBindingObserved ( typeLiteral ) , super . bind ( typeLiteral ) ) ; }
protected < T > AnnotatedBindingBuilder < T > bind ( Class < T > clazz ) { return new SpyAnnotatedBindingBuilder < T > ( newBindingObserved ( clazz ) , super . bind ( clazz ) ) ; }
protected AnnotatedConstantBindingBuilder bindConstant ( ) { return new SpyAnnotatedConstantBindingBuilder ( newBindingObserved ( ) , super . bindConstant ( ) ) ; }
private BindingInfo newBindingObserved ( Key < ? > key ) { BindingInfo bindingInfo = new BindingInfo ( ) ; bindingInfo . abstractType = key . getTypeLiteral ( ) ; bindingInfo . annotation = key . getAnnotation ( ) ; bindingInfo . annotationClass = key . getAnnotationType ( ) ; bindingsObserved . add ( bindingInfo ) ; return bindingInfo ; }
private BindingInfo newBindingObserved ( TypeLiteral < ? > typeLiteral ) { BindingInfo bindingInfo = new BindingInfo ( ) ; bindingInfo . abstractType = typeLiteral ; bindingsObserved . add ( bindingInfo ) ; return bindingInfo ; }
private BindingInfo newBindingObserved ( Class < ? > clazz ) { BindingInfo bindingInfo = new BindingInfo ( ) ; bindingInfo . abstractType = TypeLiteral . get ( clazz ) ; bindingsObserved . add ( bindingInfo ) ; return bindingInfo ; }
private BindingInfo newBindingObserved ( ) { BindingInfo bindingInfo = new BindingInfo ( ) ; bindingsObserved . add ( bindingInfo ) ; return bindingInfo ; }
private < T > void addDependencies ( Key < T > key , Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded ) { TypeLiteral < T > type = key . getTypeLiteral ( ) ; if ( ! isInstantiable ( type . getRawType ( ) ) ) { return ; } addInjectionPointDependencies ( InjectionPoint . forConstructorOf ( type ) , keysObserved , keysNeeded ) ; Set < InjectionPoint > methodsAndFieldsInjectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; for ( InjectionPoint injectionPoint : methodsAndFieldsInjectionPoints ) { addInjectionPointDependencies ( injectionPoint , keysObserved , keysNeeded ) ;
private void addInjectionPointDependencies ( InjectionPoint injectionPoint , Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded ) { // Do not consider dependencies coming from optional injections if (injectionPoint.isOptional()) { return; } for (Dependency<?> dependency : injectionPoint.getDependencies()) { Key<?> key = dependency.getKey();
private void addKeyDependency ( Key < ? > key , Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded ) { Key < ? > newKey = key ; if ( Provider . class . isAssignableFrom ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { Type providedType = ( ( ParameterizedType ) key . getTypeLiteral ( ) . getType ( ) ) . getActualTypeArguments ( ) [ 0 ] ; if ( key . getAnnotation ( ) ! = null ) { newKey = Key . get ( providedType , key . getAnnotation ( ) ) ; } else if ( key . getAnnotationType ( ) ! = null ) { newKey = Key . get ( providedType , key . getAnnotationType ( ) ) ; } else { newKey = Key . get ( providedType ) ; } } bindIfConcrete ( keysObserved , newKey ) ; keysNeeded . add ( newKey ) ; }
public ScopedBindingBuilder to ( Class < ? extends T > type ) { bindingInfo . boundType = TypeLiteral . get ( type ) ; return delegate . to ( type ) ; }
public ScopedBindingBuilder to ( TypeLiteral < ? extends T > type ) { bindingInfo . boundType = type ; return delegate . to ( type ) ; }
public ScopedBindingBuilder to ( Key < ? extends T > key ) { bindingInfo . boundType = key . getTypeLiteral ( ) ; return delegate . to ( key ) ; }
public void toInstance ( T instance ) { // Binding to an instance, class cannot be injected bindingInfo.isBoundToInstance = true; delegate.toInstance(instance); }
public ScopedBindingBuilder toProvider ( Provider < ? extends T > provider ) { // Can't do better than use our own abstract type as a guess of the bound type // incidentally, this works great for spy providers bindingInfo.boundType = bindingInfo.abstractType; return delegate.toProvider(provider); }
public ScopedBindingBuilder toProvider ( Class < ? extends Provider < ? extends T > > providerClass ) { bindingInfo . boundType = TypeLiteral . get ( providerClass ) ; return delegate . toProvider ( providerClass ) ; }
public ScopedBindingBuilder toProvider ( Key < ? extends Provider < ? extends T > > key ) { Errors errors = new Errors ( ) ; try { bindingInfo . boundType = GuiceUtils . getProvidedType ( key . getTypeLiteral ( ) , errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } errors . throwConfigurationExceptionIfErrorsExist ( ) ; return delegate . toProvider ( key ) ; }
public void asEagerSingleton ( ) { delegate . asEagerSingleton ( ) ; }
public void in ( Class < ? extends Annotation > annotation ) { delegate . in ( annotation ) ; }
public void in ( Scope scope ) { delegate . in ( scope ) ; }
public LinkedBindingBuilder < T > annotatedWith ( Class < ? extends Annotation > annotationClass ) { bindingInfo . annotationClass = annotationClass ; return new SpyLinkedBindingBuilder < T > ( bindingInfo , delegate . annotatedWith ( annotationClass ) ) ; }
public LinkedBindingBuilder < T > annotatedWith ( Annotation annotation ) { bindingInfo . annotation = annotation ; return new SpyLinkedBindingBuilder < T > ( bindingInfo , delegate . annotatedWith ( annotation ) ) ; }
public ConstantBindingBuilder annotatedWith ( Class < ? extends Annotation > annotationClass ) { bindingInfo . annotationClass = annotationClass ; return new SpyConstantBindingBuilder ( bindingInfo , delegate . annotatedWith ( annotationClass ) ) ; }
public ConstantBindingBuilder annotatedWith ( Annotation annotation ) { bindingInfo . annotation = annotation ; return new SpyConstantBindingBuilder ( bindingInfo , delegate . annotatedWith ( annotation ) ) ; }
public void to ( String constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( constant . getClass ( ) ) ; }
public void to ( int constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Integer . class ) ; }
public void to ( long constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Long . class ) ; }
public void to ( boolean constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Boolean . class ) ; }
public void to ( double constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Double . class ) ; }
public void to ( float constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Float . class ) ; }
public void to ( short constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Short . class ) ; }
public void to ( char constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Character . class ) ; }
public void to ( Class < ? > constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( constant . getClass ( ) ) ; }
public < E extends Enum < E > > void to ( E constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( constant . getClass ( ) ) ; }
private void ensureInjector ( ) throws InstantiationException , IllegalAccessException { Class < ? > testClass = getTestClass ( ) . getJavaClass ( ) ; if ( injector ! = null ) { return ; } TestModule testModule = null ; for ( Class < ? > subclass : testClass . getClasses ( ) ) { if ( TestModule . class . isAssignableFrom ( subclass ) ) { assert testModule = = null : " More than one TestModule inner class found within test class \" " + testClass . getName ( ) + " \" . " ; testModule = ( TestModule ) subclass . newInstance ( ) ; } } if ( testModule = = null ) { if ( useAutomockingIfNoEnvironmentFound ) { testModule = new JukitoModule ( ) { @Override protected void configureTest ( ) { } } ; } else { testModule = new TestModule ( ) { @Override protected void configureTest ( ) { } } ; } } testModule . setTestClass ( testClass ) ; injector = Guice . createInjector ( testModule ) ; SpyProvider . setInjector ( testClass , injector ) ; }
public void run ( final RunNotifier notifier ) { // add listener that validates framework usage at the end of each test notifier.addListener(new FrameworkUsageValidator(notifier)); super.run(notifier); }
protected Object createTest ( ) throws Exception { TestScope . clear ( ) ; instantiateEagerTestSingletons ( ) ; return injector . getInstance ( getTestClass ( ) . getJavaClass ( ) ) ; }
protected Statement methodInvoker ( final FrameworkMethod method , final Object test ) { return new InjectedStatement ( method , test , injector ) ; }
protected Statement withBefores ( FrameworkMethod method , Object target , Statement statement ) { try { ensureInjector ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } List < FrameworkMethod > befores = getTestClass ( ) . getAnnotatedMethods ( Before . class ) ; return befores . isEmpty ( ) ? statement : new InjectedBeforeStatements ( statement , befores , target , injector ) ;
protected Statement withAfters ( FrameworkMethod method , Object target , Statement statement ) { try { ensureInjector ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } List < FrameworkMethod > afters = getTestClass ( ) . getAnnotatedMethods ( After . class ) ; return afters . isEmpty ( ) ? statement : new InjectedAfterStatements ( statement , afters , target , injector ) ;
protected List < FrameworkMethod > computeTestMethods ( ) { try { ensureInjector ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } List < FrameworkMethod > testMethods = getTestClass ( ) . getAnnotatedMethods ( Test . class ) ; List < FrameworkMethod > result = new ArrayList < FrameworkMethod > ( testMethods . size ( ) ) ; for ( FrameworkMethod method : testMethods ) { Method javaMethod = method . getMethod ( ) ; Errors errors = new Errors ( javaMethod ) ; List < Key < ? > > keys = GuiceUtils . getMethodKeys ( javaMethod , errors ) ; errors . throwConfigurationExceptionIfErrorsExist ( ) ; List < List < Binding < ? > > > bindingsToUseForParameters = new ArrayList < List < Binding < ? > > > ( ) ; for ( Key < ? > key : keys ) { if ( All . class . equals ( key . getAnnotationType ( ) ) ) { List < Binding < ? > > bindings = new ArrayList < Binding < ? > > ( ) ; for ( Binding < ? > binding : injector . findBindingsByType ( key . getTypeLiteral ( ) ) ) { bindings . add ( binding ) ; } bindingsToUseForParameters . add ( bindings ) ; } } // Add an injected method for every combination of binding addAllBindingAssignations(bindingsToUseForParameters, 0, new ArrayList<Binding<?>>(bindingsToUseForParameters.size()), javaMethod, result); } return result; }
private void addAllBindingAssignations ( List < List < Binding < ? > > > bindingsToUseForParameters , int index , List < Binding < ? > > currentAssignation , Method javaMethod , List < FrameworkMethod > result ) { if ( index > = bindingsToUseForParameters . size ( ) ) { List < Binding < ? > > assignation = new ArrayList < Binding < ? > > ( currentAssignation . size ( ) ) ; assignation . addAll ( currentAssignation ) ; result . add ( new InjectedFrameworkMethod ( javaMethod , assignation ) ) ; return ; } for ( Binding < ? > binding : bindingsToUseForParameters . get ( index ) ) { currentAssignation . add ( binding ) ;
private void instantiateEagerTestSingletons ( ) { DefaultBindingScopingVisitor < Boolean > isEagerTestScopeSingleton = new DefaultBindingScopingVisitor < Boolean > ( ) { public Boolean visitScope ( Scope scope ) { return scope = = TestScope . EAGER_SINGLETON ; } } ; for ( Binding < ? > binding : injector . getBindings ( ) . values ( ) ) { boolean instantiate = false ;
public Boolean visitScope ( Scope scope ) { return scope = = TestScope . EAGER_SINGLETON ; }
protected void validateInstanceMethods ( List < Throwable > errors ) { validatePublicVoidMethods ( After . class , false , errors ) ; validatePublicVoidMethods ( Before . class , false , errors ) ; validateTestMethods ( errors ) ; if ( computeTestMethods ( ) . size ( ) = = 0 ) { errors . add ( new Exception ( " No runnable methods " ) ) ;
protected void validateTestMethods ( List < Throwable > errors ) { validatePublicVoidMethods ( Test . class , false , errors ) ; }
protected void validatePublicVoidMethods ( Class < ? extends Annotation > annotation , boolean isStatic , List < Throwable > errors ) { List < FrameworkMethod > methods = getTestClass ( ) . getAnnotatedMethods ( annotation ) ; for ( FrameworkMethod eachTestMethod : methods ) { eachTestMethod . validatePublicVoid ( isStatic , errors ) ;
protected Injector getInjector ( ) { return injector ; }
public T get ( ) { List < Dependency < ? > > dependencies = injectionPoint . getDependencies ( ) ; Injector injector = testClassToInjector . get ( testClass ) ; Object [ ] constructorParameters = new Object [ dependencies . size ( ) ] ; for ( Dependency < ? > dependency : dependencies ) { constructorParameters [ dependency . getParameterIndex ( ) ] = injector . getInstance ( dependency . getKey ( ) ) ; } T instance ; try { instance = constructor . newInstance ( constructorParameters ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } injector . injectMembers ( instance ) ; return spy ( instance ) ; }
public static synchronized void setInjector ( Class < ? > testClass , Injector injector ) { testClassToInjector . put ( testClass , injector ) ; }
public void configure ( ) { bindScope ( TestSingleton . class , TestScope . SINGLETON ) ; bindScope ( TestEagerSingleton . class , TestScope . EAGER_SINGLETON ) ; configureTest ( ) ; }
public void setTestClass ( Class < ? > testClass ) { this . testClass = testClass ; }
protected < T > ScopedBindingBuilder bindMock ( Class < T > klass ) { return bind ( klass ) . toProvider ( new MockProvider < T > ( klass ) ) ; }
protected < T > ScopedBindingBuilder bindMock ( TypeLiteral < T > typeLiteral ) { return bind ( typeLiteral ) . toProvider ( new MockProvider < T > ( ( Class < T > ) typeLiteral . getRawType ( ) ) ) ; }
protected < T > ScopedBindingBuilder bindSpy ( Class < T > klass ) { return bind ( klass ) . toProvider ( createNewSpyProvider ( TypeLiteral . get ( klass ) ) ) ; }
protected < T > ScopedBindingBuilder bindSpy ( TypeLiteral < T > typeLiteral ) { return bind ( typeLiteral ) . toProvider ( createNewSpyProvider ( typeLiteral ) ) ; }
protected < T > ScopedBindingBuilder bindNamedMock ( Class < T > klass , String name ) { return bind ( klass ) . annotatedWith ( Names . named ( name ) ) . toProvider ( new MockProvider < T > ( klass ) ) ; }
protected < T > ScopedBindingBuilder bindNamedMock ( TypeLiteral < T > typeLiteral , String name ) { return bind ( typeLiteral ) . annotatedWith ( Names . named ( name ) ) . toProvider ( new MockProvider < T > ( ( Class < T > ) typeLiteral . getRawType ( ) ) ) ;
protected < T > ScopedBindingBuilder bindNamedSpy ( Class < T > klass , String name ) { return bind ( klass ) . annotatedWith ( Names . named ( name ) ) . toProvider ( createNewSpyProvider ( TypeLiteral . get ( klass ) ) ) ; }
protected < T > ScopedBindingBuilder bindNamedSpy ( TypeLiteral < T > typeLiteral , String name ) { return bind ( typeLiteral ) . annotatedWith ( Names . named ( name ) ) . toProvider ( createNewSpyProvider ( typeLiteral ) ) ; }
private < T > Provider < T > createNewSpyProvider ( TypeLiteral < T > typeLiteral ) { return new SpyProvider < T > ( testClass , typeLiteral ) ; }
protected < T , V extends T > void bindManyInstances ( Class < T > clazz , V . . . instances ) { for ( V instance : instances ) { bind ( clazz ) . annotatedWith ( UniqueAnnotations . create ( ) ) . toInstance ( instance ) ;
protected < T , V extends T > void bindManyInstances ( TypeLiteral < T > type , V . . . instances ) { for ( V instance : instances ) { bind ( type ) . annotatedWith ( UniqueAnnotations . create ( ) ) . toInstance ( instance ) ;
protected < T > void bindMany ( Class < T > clazz , Class < ? extends T > . . . boundClasses ) { for ( Class < ? extends T > boundClass : boundClasses ) { bind ( clazz ) . annotatedWith ( UniqueAnnotations . create ( ) ) . to ( boundClass ) . in ( TestScope . SINGLETON ) ;
protected < T , V extends T > void bindMany ( TypeLiteral < T > type , TypeLiteral < ? extends T > . . . boundTypes ) { for ( TypeLiteral < ? extends T > boundType : boundTypes ) { bind ( type ) . annotatedWith ( UniqueAnnotations . create ( ) ) . to ( boundType ) . in ( TestScope . SINGLETON ) ;
protected < T > LinkedBindingBuilder < T > bindNamed ( Class < T > klass , String name ) { return bind ( klass ) . annotatedWith ( Names . named ( name ) ) ; }
protected < T > LinkedBindingBuilder < T > bindNamed ( TypeLiteral < T > typeLiteral , String name ) { return bind ( typeLiteral ) . annotatedWith ( Names . named ( name ) ) ; }
public < T > Provider < T > scope ( final Key < T > key , final Provider < T > unscoped ) { return new Provider < T > ( ) { @SuppressWarnings ( " unchecked " )
public T get ( ) { Object o = backingMap . get ( key ) ; if ( o = = null ) { o = unscoped . get ( ) ; backingMap . put ( key , o ) ; } return ( T ) o ; }
public static void clear ( ) { SINGLETON . clear ( ) ; EAGER_SINGLETON . clear ( ) ; }
protected void configureTest ( ) { bindManyInstances ( String . class , " A " , " B " ) ; bindManyInstances ( TestDataInstance . class , new TestDataInstance ( " A " ) , new TestDataInstance ( " B " ) ) ; bindMany ( TestData . class , TestDataA . class , TestDataB . class ) ; }
String getData ( ) ; } static class TestDataA implements TestData { public String getData ( ) { return " A " ; } } static class TestDataB implements TestData { public String getData ( ) { return " B " ; } } static class TestDataInstance { private final String data ; public TestDataInstance ( String data ) { this . data = data ; } public String getData ( ) { return data ; } } /** * This class keeps track of what happens in all the tests run in this * class. It's used to make sure all expected tests are called. */ private static class Bookkeeper { static List < String > stringsProcessed = new ArrayList < String > ( ) ; static List < String > dataProcessed = new ArrayList < String > ( ) ; static List < String > dataInstanceProcessed = new ArrayList < String > ( ) ; } @Test public void testAllWithInstance ( @All String string1 , @All String string2 ) { Bookkeeper . stringsProcessed . add ( string1 + string2 ) ; } @Test public void testAllWithClass ( @All TestData data1 , @All TestData data2 ) { Bookkeeper . dataProcessed . add ( data1 . getData ( ) + data2 . getData ( ) ) ; } @Test public void testAllWithClassInstance ( @All TestDataInstance data1 , @All TestDataInstance data2 ) { Bookkeeper . dataInstanceProcessed . add ( data1 . getData ( ) + data2 . getData ( ) ) ; } @AfterClass public static void checkBookkeeper ( ) { assertTrue ( Bookkeeper . stringsProcessed . contains ( " AA " ) ) ; assertTrue ( Bookkeeper . stringsProcessed . contains ( " AB " ) ) ; assertTrue ( Bookkeeper . stringsProcessed . contains ( " BA " ) ) ; assertTrue ( Bookkeeper . stringsProcessed . contains ( " BB " ) ) ; assertEquals ( 4 , Bookkeeper . stringsProcessed . size ( ) ) ; assertTrue ( Bookkeeper . dataProcessed . contains ( " AA " ) ) ; assertTrue ( Bookkeeper . dataProcessed . contains ( " AB " ) ) ; assertTrue ( Bookkeeper . dataProcessed . contains ( " BA " ) ) ; assertTrue ( Bookkeeper . dataProcessed . contains ( " BB " ) ) ; assertEquals ( 4 , Bookkeeper . dataProcessed . size ( ) ) ; assertTrue ( Bookkeeper . dataInstanceProcessed . contains ( " AA " ) ) ; assertTrue ( Bookkeeper . dataInstanceProcessed . contains ( " AB " ) ) ; assertTrue ( Bookkeeper . dataInstanceProcessed . contains ( " BA " ) ) ; assertTrue ( Bookkeeper . dataInstanceProcessed . contains ( " BB " ) ) ; assertEquals ( 4 , Bookkeeper . dataInstanceProcessed . size ( ) ) ; } }
public void testAllWithInstance ( @All String string1 , @All String string2 ) { Bookkeeper . stringsProcessed . add ( string1 + string2 ) ; }
public void testAllWithClass ( @All TestData data1 , @All TestData data2 ) { Bookkeeper . dataProcessed . add ( data1 . getData ( ) + data2 . getData ( ) ) ; }
public void testAllWithClassInstance ( @All TestDataInstance data1 , @All TestDataInstance data2 ) { Bookkeeper . dataInstanceProcessed . add ( data1 . getData ( ) + data2 . getData ( ) ) ; }
public static void checkBookkeeper ( ) { assertTrue ( Bookkeeper . stringsProcessed . contains ( " AA " ) ) ; assertTrue ( Bookkeeper . stringsProcessed . contains ( " AB " ) ) ; assertTrue ( Bookkeeper . stringsProcessed . contains ( " BA " ) ) ; assertTrue ( Bookkeeper . stringsProcessed . contains ( " BB " ) ) ; assertEquals ( 4 , Bookkeeper . stringsProcessed . size ( ) ) ; assertTrue ( Bookkeeper . dataProcessed . contains ( " AA " ) ) ; assertTrue ( Bookkeeper . dataProcessed . contains ( " AB " ) ) ; assertTrue ( Bookkeeper . dataProcessed . contains ( " BA " ) ) ; assertTrue ( Bookkeeper . dataProcessed . contains ( " BB " ) ) ; assertEquals ( 4 , Bookkeeper . dataProcessed . size ( ) ) ; assertTrue ( Bookkeeper . dataInstanceProcessed . contains ( " AA " ) ) ; assertTrue ( Bookkeeper . dataInstanceProcessed . contains ( " AB " ) ) ; assertTrue ( Bookkeeper . dataInstanceProcessed . contains ( " BA " ) ) ; assertTrue ( Bookkeeper . dataInstanceProcessed . contains ( " BB " ) ) ; assertEquals ( 4 , Bookkeeper . dataInstanceProcessed . size ( ) ) ; }
protected void configureTest ( ) { bindSpy ( SimpleClass . class ) . in ( TestScope . SINGLETON ) ; }
String test ( ) ; } interface CompositionMockB { String test ( ) ; } static class SimpleClass { private CompositionMockA mockA ; @Inject CompositionMockB mockB ; @Inject SimpleClass ( CompositionMockA mockA ) { this . mockA = mockA ; } String callTestMethodOnMock ( ) { mockA . test ( ) ; mockB . test ( ) ; return " Default string " ; } } @Inject CompositionMockA mockA ; @Inject CompositionMockA mockB ; @Test public void testStubbingSpiedInstance ( SimpleClass simpleClass ) { // GIVEN doReturn("Mocked string").when(simpleClass).callTestMethodOnMock(); // WHEN String result = simpleClass.callTestMethodOnMock(); // THEN assertEquals("Mocked string", result); verify(mockA, never()).test(); verify(mockB, never()).test(); } @Test public void testNotStubbingSpiedInstance(SimpleClass simpleClass) { // WHEN String result = simpleClass.callTestMethodOnMock(); // THEN verify(mockA).test(); verify(mockB).test(); assertEquals("Default string", result); } }
String test ( ) ; } static class SimpleClass { private CompositionMockA mockA ; @Inject CompositionMockB mockB ; @Inject SimpleClass ( CompositionMockA mockA ) { this . mockA = mockA ; } String callTestMethodOnMock ( ) { mockA . test ( ) ; mockB . test ( ) ; return " Default string " ; } } @Inject CompositionMockA mockA ; @Inject CompositionMockA mockB ; @Test public void testStubbingSpiedInstance ( SimpleClass simpleClass ) { // GIVEN doReturn("Mocked string").when(simpleClass).callTestMethodOnMock(); // WHEN String result = simpleClass.callTestMethodOnMock(); // THEN assertEquals("Mocked string", result); verify(mockA, never()).test(); verify(mockB, never()).test(); } @Test public void testNotStubbingSpiedInstance(SimpleClass simpleClass) { // WHEN String result = simpleClass.callTestMethodOnMock(); // THEN verify(mockA).test(); verify(mockB).test(); assertEquals("Default string", result); } }
String callTestMethodOnMock ( ) { mockA . test ( ) ; mockB . test ( ) ; return " Default string " ; }
public void testStubbingSpiedInstance ( SimpleClass simpleClass ) { // GIVEN doReturn("Mocked string").when(simpleClass).callTestMethodOnMock(); // WHEN String result = simpleClass.callTestMethodOnMock(); // THEN assertEquals("Mocked string", result); verify(mockA, never()).test(); verify(mockB, never()).test(); }
public void testNotStubbingSpiedInstance ( SimpleClass simpleClass ) { // WHEN String result = simpleClass.callTestMethodOnMock(); // THEN verify(mockA).test(); verify(mockB).test(); assertEquals("Default string", result); }
protected void configureTest ( ) { forceMock ( Base1 . class ) ; forceMock ( Child21 . class ) ; forceMock ( Child311 . class ) ; }
interface Base1 { int t1 ( ) ; } static class Child11 implements Base1 { public int t1 ( ) { return 11 ; } } static class Child111 extends Child11 { public int t1 ( ) { return 111 ; } } static class Child12 implements Base1 { public int t1 ( ) { return 12 ; } } interface Base2 { int t2 ( ) ; } static class Child21 implements Base2 { public int t2 ( ) { return 21 ; } } static class Child211 extends Child21 { public int t2 ( ) { return 211 ; } } static class Child22 implements Base2 { public int t2 ( ) { return 22 ; } } interface Base3 { int t3 ( ) ; } static class Child31 implements Base3 { public int t3 ( ) { return 31 ; } } static class Child311 extends Child31 { public int t3 ( ) { return 311 ; } } @Test public void injectForceMock ( Base1 base1 , Child11 child11 , Child111 child111 , Child12 child12 , Base2 base2 , Child21 child21 , Child211 child211 , Child22 child22 , Base3 base3 , Child31 child31 , Child311 child311 ) { verify ( base1 , never ( ) ) . t1 ( ) ; verify ( child11 , never ( ) ) . t1 ( ) ; verify ( child111 , never ( ) ) . t1 ( ) ; verify ( child12 , never ( ) ) . t1 ( ) ; verify ( base2 , never ( ) ) . t2 ( ) ; verify ( child21 , never ( ) ) . t2 ( ) ; verify ( child211 , never ( ) ) . t2 ( ) ; assertEquals ( 22 , child22 . t2 ( ) ) ; verify ( base3 , never ( ) ) . t3 ( ) ; assertEquals ( 31 , child31 . t3 ( ) ) ; verify ( child311 , never ( ) ) . t3 ( ) ; } }
static class Child11 implements Base1 { public int t1 ( ) { return 11 ; } } static class Child111 extends Child11 { public int t1 ( ) { return 111 ; } }
static class Child111 extends Child11 { public int t1 ( ) { return 111 ; } } static class Child12 implements Base1 { public int t1 ( ) { return 12 ; } }
static class Child12 implements Base1 { public int t1 ( ) { return 12 ; } }
interface Base2 { int t2 ( ) ; } static class Child21 implements Base2 { public int t2 ( ) { return 21 ; } } static class Child211 extends Child21 { public int t2 ( ) { return 211 ; } } static class Child22 implements Base2 { public int t2 ( ) { return 22 ; } } interface Base3 { int t3 ( ) ; } static class Child31 implements Base3 { public int t3 ( ) { return 31 ; } } static class Child311 extends Child31 { public int t3 ( ) { return 311 ; } } @Test public void injectForceMock ( Base1 base1 , Child11 child11 , Child111 child111 , Child12 child12 , Base2 base2 , Child21 child21 , Child211 child211 , Child22 child22 , Base3 base3 , Child31 child31 , Child311 child311 ) { verify ( base1 , never ( ) ) . t1 ( ) ; verify ( child11 , never ( ) ) . t1 ( ) ; verify ( child111 , never ( ) ) . t1 ( ) ; verify ( child12 , never ( ) ) . t1 ( ) ; verify ( base2 , never ( ) ) . t2 ( ) ; verify ( child21 , never ( ) ) . t2 ( ) ; verify ( child211 , never ( ) ) . t2 ( ) ; assertEquals ( 22 , child22 . t2 ( ) ) ; verify ( base3 , never ( ) ) . t3 ( ) ; assertEquals ( 31 , child31 . t3 ( ) ) ; verify ( child311 , never ( ) ) . t3 ( ) ; } }
static class Child21 implements Base2 { public int t2 ( ) { return 21 ; } } static class Child211 extends Child21 { public int t2 ( ) { return 211 ; } }
static class Child211 extends Child21 { public int t2 ( ) { return 211 ; } } static class Child22 implements Base2 { public int t2 ( ) { return 22 ; } }
static class Child22 implements Base2 { public int t2 ( ) { return 22 ; } }
interface Base3 { int t3 ( ) ; } static class Child31 implements Base3 { public int t3 ( ) { return 31 ; } } static class Child311 extends Child31 { public int t3 ( ) { return 311 ; } } @Test public void injectForceMock ( Base1 base1 , Child11 child11 , Child111 child111 , Child12 child12 , Base2 base2 , Child21 child21 , Child211 child211 , Child22 child22 , Base3 base3 , Child31 child31 , Child311 child311 ) { verify ( base1 , never ( ) ) . t1 ( ) ; verify ( child11 , never ( ) ) . t1 ( ) ; verify ( child111 , never ( ) ) . t1 ( ) ; verify ( child12 , never ( ) ) . t1 ( ) ; verify ( base2 , never ( ) ) . t2 ( ) ; verify ( child21 , never ( ) ) . t2 ( ) ; verify ( child211 , never ( ) ) . t2 ( ) ; assertEquals ( 22 , child22 . t2 ( ) ) ; verify ( base3 , never ( ) ) . t3 ( ) ; assertEquals ( 31 , child31 . t3 ( ) ) ; verify ( child311 , never ( ) ) . t3 ( ) ; } }
static class Child31 implements Base3 { public int t3 ( ) { return 31 ; } } static class Child311 extends Child31 { public int t3 ( ) { return 311 ; } }
static class Child311 extends Child31 { public int t3 ( ) { return 311 ; } }
public void injectForceMock ( Base1 base1 , Child11 child11 , Child111 child111 , Child12 child12 , Base2 base2 , Child21 child21 , Child211 child211 , Child22 child22 , Base3 base3 , Child31 child31 , Child311 child311 ) { verify ( base1 , never ( ) ) . t1 ( ) ; verify ( child11 , never ( ) ) . t1 ( ) ; verify ( child111 , never ( ) ) . t1 ( ) ; verify ( child12 , never ( ) ) . t1 ( ) ; verify ( base2 , never ( ) ) . t2 ( ) ; verify ( child21 , never ( ) ) . t2 ( ) ; verify ( child211 , never ( ) ) . t2 ( ) ; assertEquals ( 22 , child22 . t2 ( ) ) ; verify ( base3 , never ( ) ) . t3 ( ) ; assertEquals ( 31 , child31 . t3 ( ) ) ; verify ( child311 , never ( ) ) . t3 ( ) ; }
protected void configureTest ( ) { bindConstant ( ) . annotatedWith ( OneHundred . class ) . to ( 100 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 200 " ) ) . to ( 200 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE1 " ) ) . to ( MyEnum . VALUE1 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE2 " ) ) . to ( MyEnum . VALUE2 ) ; bind ( Key . get ( TestClass . class , Value3 . class ) ) . toInstance ( new TestClass ( MyEnum . VALUE3 ) ) ; bind ( Key . get ( TestClass . class , Names . named ( " VALUE2 " ) ) ) . to ( TestClass . class ) . in ( TestScope . SINGLETON ) ; }
public void testConstantInjection ( @OneHundred Integer oneHundred , @Named ( " 200 " ) Integer twoHundred , @Named ( " VALUE1 " ) MyEnum value1 ) { assertEquals ( 100 , ( int ) oneHundred ) ; assertEquals ( 200 , ( int ) twoHundred ) ; assertEquals ( MyEnum . VALUE1 , value1 ) ; }
public void testInjectBoundWithKeys ( @Value3 TestClass testClassValue3 , @Named ( " VALUE2 " ) TestClass testClassValue2 ) { assertEquals ( MyEnum . VALUE3 , testClassValue3 . value ) ; assertEquals ( MyEnum . VALUE2 , testClassValue2 . value ) ; }
void mockSingletonMethod ( ) ; } interface DummyInterface { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent1 { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent2 { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent3 { String getDummyValue ( ) ; } static class DummyClassUsedOnlyInParent1 { } static class DummyClassUsedOnlyInParent2 { } static class DummyClassUsedOnlyInParent3 { } @Inject protected Provider < DummyInterface > dummyProvider ; @Inject protected MockSingletonDefinedInParent mockSingletonDefinedInParent ; /** * This class keeps track of what happens in all the tests run in this * class and its child. It's used to make sure all expected tests are called. */ protected static class Bookkeeper { static boolean parentTestShouldRunExecuted ; } @Test public void parentTestShouldRun ( ) { Bookkeeper . parentTestShouldRunExecuted = true ; } @Test public void interfaceBoundInChildIsInjectedInParent ( ) { assertEquals ( " DummyValue " , dummyProvider . get ( ) . getDummyValue ( ) ) ; } @Test public void interfaceBoundInChildIsInjectedInParentTestMethod ( DummyInterface dummyInterface ) { assertEquals ( " DummyValue " , dummyInterface . getDummyValue ( ) ) ; } @Test public void interfaceUsedInParentTestMethodShouldBeMockedAsTestSingleton ( Provider < DummyInterfaceUsedOnlyInParent1 > provider ) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Test public void concreteClassUsedInParentTestMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent1> provider) { assertSame(provider.get(), provider.get()); } @Before public void interfaceUsedInParentBeforeMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent2> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Before public void concreteClassUsedInParentBeforeMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent2> provider) { assertSame(provider.get(), provider.get()); } @After public void interfaceUsedInParentAfterMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent3> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @After public void concreteClassUsedInParentAfterMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent3> provider) { assertSame(provider.get(), provider.get()); } }
String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent1 { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent2 { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent3 { String getDummyValue ( ) ; } static class DummyClassUsedOnlyInParent1 { } static class DummyClassUsedOnlyInParent2 { } static class DummyClassUsedOnlyInParent3 { } @Inject protected Provider < DummyInterface > dummyProvider ; @Inject protected MockSingletonDefinedInParent mockSingletonDefinedInParent ; /** * This class keeps track of what happens in all the tests run in this * class and its child. It's used to make sure all expected tests are called. */ protected static class Bookkeeper { static boolean parentTestShouldRunExecuted ; } @Test public void parentTestShouldRun ( ) { Bookkeeper . parentTestShouldRunExecuted = true ; } @Test public void interfaceBoundInChildIsInjectedInParent ( ) { assertEquals ( " DummyValue " , dummyProvider . get ( ) . getDummyValue ( ) ) ; } @Test public void interfaceBoundInChildIsInjectedInParentTestMethod ( DummyInterface dummyInterface ) { assertEquals ( " DummyValue " , dummyInterface . getDummyValue ( ) ) ; } @Test public void interfaceUsedInParentTestMethodShouldBeMockedAsTestSingleton ( Provider < DummyInterfaceUsedOnlyInParent1 > provider ) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Test public void concreteClassUsedInParentTestMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent1> provider) { assertSame(provider.get(), provider.get()); } @Before public void interfaceUsedInParentBeforeMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent2> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Before public void concreteClassUsedInParentBeforeMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent2> provider) { assertSame(provider.get(), provider.get()); } @After public void interfaceUsedInParentAfterMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent3> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @After public void concreteClassUsedInParentAfterMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent3> provider) { assertSame(provider.get(), provider.get()); } }
String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent2 { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent3 { String getDummyValue ( ) ; } static class DummyClassUsedOnlyInParent1 { } static class DummyClassUsedOnlyInParent2 { } static class DummyClassUsedOnlyInParent3 { } @Inject protected Provider < DummyInterface > dummyProvider ; @Inject protected MockSingletonDefinedInParent mockSingletonDefinedInParent ; /** * This class keeps track of what happens in all the tests run in this * class and its child. It's used to make sure all expected tests are called. */ protected static class Bookkeeper { static boolean parentTestShouldRunExecuted ; } @Test public void parentTestShouldRun ( ) { Bookkeeper . parentTestShouldRunExecuted = true ; } @Test public void interfaceBoundInChildIsInjectedInParent ( ) { assertEquals ( " DummyValue " , dummyProvider . get ( ) . getDummyValue ( ) ) ; } @Test public void interfaceBoundInChildIsInjectedInParentTestMethod ( DummyInterface dummyInterface ) { assertEquals ( " DummyValue " , dummyInterface . getDummyValue ( ) ) ; } @Test public void interfaceUsedInParentTestMethodShouldBeMockedAsTestSingleton ( Provider < DummyInterfaceUsedOnlyInParent1 > provider ) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Test public void concreteClassUsedInParentTestMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent1> provider) { assertSame(provider.get(), provider.get()); } @Before public void interfaceUsedInParentBeforeMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent2> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Before public void concreteClassUsedInParentBeforeMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent2> provider) { assertSame(provider.get(), provider.get()); } @After public void interfaceUsedInParentAfterMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent3> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @After public void concreteClassUsedInParentAfterMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent3> provider) { assertSame(provider.get(), provider.get()); } }
String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent3 { String getDummyValue ( ) ; } static class DummyClassUsedOnlyInParent1 { } static class DummyClassUsedOnlyInParent2 { } static class DummyClassUsedOnlyInParent3 { } @Inject protected Provider < DummyInterface > dummyProvider ; @Inject protected MockSingletonDefinedInParent mockSingletonDefinedInParent ; /** * This class keeps track of what happens in all the tests run in this * class and its child. It's used to make sure all expected tests are called. */ protected static class Bookkeeper { static boolean parentTestShouldRunExecuted ; } @Test public void parentTestShouldRun ( ) { Bookkeeper . parentTestShouldRunExecuted = true ; } @Test public void interfaceBoundInChildIsInjectedInParent ( ) { assertEquals ( " DummyValue " , dummyProvider . get ( ) . getDummyValue ( ) ) ; } @Test public void interfaceBoundInChildIsInjectedInParentTestMethod ( DummyInterface dummyInterface ) { assertEquals ( " DummyValue " , dummyInterface . getDummyValue ( ) ) ; } @Test public void interfaceUsedInParentTestMethodShouldBeMockedAsTestSingleton ( Provider < DummyInterfaceUsedOnlyInParent1 > provider ) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Test public void concreteClassUsedInParentTestMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent1> provider) { assertSame(provider.get(), provider.get()); } @Before public void interfaceUsedInParentBeforeMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent2> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Before public void concreteClassUsedInParentBeforeMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent2> provider) { assertSame(provider.get(), provider.get()); } @After public void interfaceUsedInParentAfterMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent3> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @After public void concreteClassUsedInParentAfterMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent3> provider) { assertSame(provider.get(), provider.get()); } }
String getDummyValue ( ) ; } static class DummyClassUsedOnlyInParent1 { } static class DummyClassUsedOnlyInParent2 { } static class DummyClassUsedOnlyInParent3 { } @Inject protected Provider < DummyInterface > dummyProvider ; @Inject protected MockSingletonDefinedInParent mockSingletonDefinedInParent ; /** * This class keeps track of what happens in all the tests run in this * class and its child. It's used to make sure all expected tests are called. */ protected static class Bookkeeper { static boolean parentTestShouldRunExecuted ; } @Test public void parentTestShouldRun ( ) { Bookkeeper . parentTestShouldRunExecuted = true ; } @Test public void interfaceBoundInChildIsInjectedInParent ( ) { assertEquals ( " DummyValue " , dummyProvider . get ( ) . getDummyValue ( ) ) ; } @Test public void interfaceBoundInChildIsInjectedInParentTestMethod ( DummyInterface dummyInterface ) { assertEquals ( " DummyValue " , dummyInterface . getDummyValue ( ) ) ; } @Test public void interfaceUsedInParentTestMethodShouldBeMockedAsTestSingleton ( Provider < DummyInterfaceUsedOnlyInParent1 > provider ) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Test public void concreteClassUsedInParentTestMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent1> provider) { assertSame(provider.get(), provider.get()); } @Before public void interfaceUsedInParentBeforeMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent2> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Before public void concreteClassUsedInParentBeforeMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent2> provider) { assertSame(provider.get(), provider.get()); } @After public void interfaceUsedInParentAfterMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent3> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @After public void concreteClassUsedInParentAfterMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent3> provider) { assertSame(provider.get(), provider.get()); } }
public void parentTestShouldRun ( ) { Bookkeeper . parentTestShouldRunExecuted = true ; }
public void interfaceBoundInChildIsInjectedInParent ( ) { assertEquals ( " DummyValue " , dummyProvider . get ( ) . getDummyValue ( ) ) ; }
public void interfaceBoundInChildIsInjectedInParentTestMethod ( DummyInterface dummyInterface ) { assertEquals ( " DummyValue " , dummyInterface . getDummyValue ( ) ) ; }
public void interfaceUsedInParentTestMethodShouldBeMockedAsTestSingleton ( Provider < DummyInterfaceUsedOnlyInParent1 > provider ) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); }
public void concreteClassUsedInParentTestMethodShouldBeBoundAsTestSingleton ( Provider < DummyClassUsedOnlyInParent1 > provider ) { assertSame ( provider . get ( ) , provider . get ( ) ) ; }
public void interfaceUsedInParentBeforeMethodShouldBeMockedAsTestSingleton ( Provider < DummyInterfaceUsedOnlyInParent2 > provider ) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); }
public void concreteClassUsedInParentBeforeMethodShouldBeBoundAsTestSingleton ( Provider < DummyClassUsedOnlyInParent2 > provider ) { assertSame ( provider . get ( ) , provider . get ( ) ) ; }
public void interfaceUsedInParentAfterMethodShouldBeMockedAsTestSingleton ( Provider < DummyInterfaceUsedOnlyInParent3 > provider ) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); }
public void concreteClassUsedInParentAfterMethodShouldBeBoundAsTestSingleton ( Provider < DummyClassUsedOnlyInParent3 > provider ) { assertSame ( provider . get ( ) , provider . get ( ) ) ; }
protected void configureTest ( ) { bind ( DummyInterface . class ) . to ( MyDummyClass . class ) . in ( TestScope . SINGLETON ) ; }
public String getDummyValue ( ) { return " DummyValue " ; }
public void mockSingletonDefinedInParentShouldBeBoundAsAMock ( ) { verify ( mockSingletonDefinedInParent , never ( ) ) . mockSingletonMethod ( ) ; }
public void singletonDefinedInParentShouldBeBound ( SingletonDefinedInParent singletonDefinedInParent ) { assertEquals ( " SingletonDefinedInParentValue " , singletonDefinedInParent . getValue ( ) ) ; }
public static void checkBookkeeper ( ) { assertTrue ( Bookkeeper . parentTestShouldRunExecuted ) ; }
protected void configureTest ( ) { bindNamedMock ( Mock . class , " singleton " ) . in ( TestScope . SINGLETON ) ; bindNamedMock ( Mock . class , " nonsingleton " ) ; bindNamed ( Instance . class , " singleton " ) . to ( Instance . class ) . in ( TestScope . SINGLETON ) ; bindNamed ( Instance . class , " nonsingleton " ) . to ( Instance . class ) ; bindNamed ( Parent . class , " providerInstance " ) . toProvider ( new ParentProviderA ( ) ) ; bindNamed ( Parent . class , " providerClass " ) . toProvider ( ParentProviderB . class ) ; }
String getValue ( ) ; } static class ChildA implements Parent { public String getValue ( ) { return " childA " ; } } interface MockInChildB { } interface MockInProviderB { void test ( ) ; } static class ChildB implements Parent { @Inject MockInChildB mockB ; public String getValue ( ) { return " childB " ; } } static class ParentProviderA implements Provider < Parent > { @Override public Parent get ( ) { return new ChildA ( ) ; } } static class ParentProviderB implements Provider < Parent > { private final Provider < ChildB > childBProvider ; @Inject ParentProviderB ( Provider < ChildB > childBProvider , Provider < MockInProviderB > myMock ) { this . childBProvider = childBProvider ; // These calls should succeed myMock.get().test(); verify(myMock.get()).test(); } @Override public Parent get() { return childBProvider.get(); } } @Test public void mockSingletonProviderShouldReturnTheSameInstance( @Named("singleton") Provider<Mock> provider) { assertSame(provider.get(), provider.get()); } @Test public void mockNonSingletonProviderShouldNotReturnTheSameInstance( @Named("nonsingleton") Provider<Mock> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void singletonClassShouldReturnTheSameInstance( @Named("singleton") Provider<Instance> provider) { assertSame(provider.get(), provider.get()); } @Test public void nonSingletonClassShouldNotReturnTheSameInstance( @Named("nonsingleton") Provider<Instance> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void bindingToProviderInstanceShouldWorkAndInject( @Named("nonsingleton") Provider<Mock> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void shouldInjectProviderBoundWithInstance( @Named("providerInstance") Parent parentProvidedFromProviderInstance) { } @Test public void shouldInjectProviderBoundWithClass( @Named("providerClass") Parent parentProvidedFromProviderInstance) { } }
public String getValue ( ) { return " childA " ; }
void test ( ) ; } static class ChildB implements Parent { @Inject MockInChildB mockB ; public String getValue ( ) { return " childB " ; } } static class ParentProviderA implements Provider < Parent > { @Override public Parent get ( ) { return new ChildA ( ) ; } } static class ParentProviderB implements Provider < Parent > { private final Provider < ChildB > childBProvider ; @Inject ParentProviderB ( Provider < ChildB > childBProvider , Provider < MockInProviderB > myMock ) { this . childBProvider = childBProvider ; // These calls should succeed myMock.get().test(); verify(myMock.get()).test(); } @Override public Parent get() { return childBProvider.get(); } } @Test public void mockSingletonProviderShouldReturnTheSameInstance( @Named("singleton") Provider<Mock> provider) { assertSame(provider.get(), provider.get()); } @Test public void mockNonSingletonProviderShouldNotReturnTheSameInstance( @Named("nonsingleton") Provider<Mock> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void singletonClassShouldReturnTheSameInstance( @Named("singleton") Provider<Instance> provider) { assertSame(provider.get(), provider.get()); } @Test public void nonSingletonClassShouldNotReturnTheSameInstance( @Named("nonsingleton") Provider<Instance> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void bindingToProviderInstanceShouldWorkAndInject( @Named("nonsingleton") Provider<Mock> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void shouldInjectProviderBoundWithInstance( @Named("providerInstance") Parent parentProvidedFromProviderInstance) { } @Test public void shouldInjectProviderBoundWithClass( @Named("providerClass") Parent parentProvidedFromProviderInstance) { } }
public String getValue ( ) { return " childB " ; }
public Parent get ( ) { return childBProvider . get ( ) ; }
public void mockSingletonProviderShouldReturnTheSameInstance ( @Named ( " singleton " ) Provider < Mock > provider ) { assertSame ( provider . get ( ) , provider . get ( ) ) ; }
public void mockNonSingletonProviderShouldNotReturnTheSameInstance ( @Named ( " nonsingleton " ) Provider < Mock > provider ) { assertNotSame ( provider . get ( ) , provider . get ( ) ) ; }
public void singletonClassShouldReturnTheSameInstance ( @Named ( " singleton " ) Provider < Instance > provider ) { assertSame ( provider . get ( ) , provider . get ( ) ) ; }
public void nonSingletonClassShouldNotReturnTheSameInstance ( @Named ( " nonsingleton " ) Provider < Instance > provider ) { assertNotSame ( provider . get ( ) , provider . get ( ) ) ; }
public void bindingToProviderInstanceShouldWorkAndInject ( @Named ( " nonsingleton " ) Provider < Mock > provider ) { assertNotSame ( provider . get ( ) , provider . get ( ) ) ; }
public void shouldInjectProviderBoundWithInstance ( @Named ( " providerInstance " ) Parent parentProvidedFromProviderInstance ) { } @Test public void shouldInjectProviderBoundWithClass ( @Named ( " providerClass " ) Parent parentProvidedFromProviderInstance ) { } }
public void shouldInjectProviderBoundWithClass ( @Named ( " providerClass " ) Parent parentProvidedFromProviderInstance ) { } }
public void register ( ) { registrationCount + + ; }
public void onlyEagerSingletonShouldBeRegistered ( ) { assertEquals ( 1 , registry . registrationCount ) ; }
public void bothSingletonsShouldBeRegistered ( MyTestSingleton myTestSingleton ) { assertEquals ( 2 , registry . registrationCount ) ; }
public static void verifyNumberOfInstantiations ( ) { assertEquals ( 2 , Bookkeeper . numberOfTimesEagerSingletonIsInstantiated ) ; assertEquals ( 1 , Bookkeeper . numberOfTimesSingletonIsInstantiated ) ; }
protected void configureTest ( ) { bindConstant ( ) . annotatedWith ( OneHundred . class ) . to ( 100 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 200 " ) ) . to ( 200 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE1 " ) ) . to ( MyEnum . VALUE1 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE2 " ) ) . to ( MyEnum . VALUE2 ) ; bind ( Key . get ( TestClass . class , Value3 . class ) ) . toInstance ( new TestClass ( MyEnum . VALUE3 ) ) ; bind ( Key . get ( TestClass . class , Names . named ( " VALUE2 " ) ) ) . to ( TestClass . class ) . in ( TestScope . SINGLETON ) ; bind ( new TypeLiteral < ParameterizedTestClass < Integer > > ( ) { } ) . in ( TestScope . SINGLETON ) ; bind ( new TypeLiteral < ParameterizedTestClass < Double > > ( ) { } ) . to ( ParameterizedTestClassDouble . class ) . in ( TestScope . SINGLETON ) ; }
public void setValue ( @Named ( " 200 " ) Integer value ) { this . value = value ; }
int getValue ( ) ; } static class TestClassWithOptionalInjection { private int value ; @Inject public TestClassWithOptionalInjection ( @OneHundred Integer value ) { this . value = value ; } @Inject ( optional = true ) public void setValue ( NonBoundInterface obj ) { value = obj . getValue ( ) ; // Should never be called, NonBoundInterface should not be mocked } } @Test public void testConstantInjection( @OneHundred Integer oneHundred, @Named("200") Integer twoHundred, @Named("VALUE1") MyEnum value1) { assertEquals(100, (int) oneHundred); assertEquals(200, (int) twoHundred); assertEquals(MyEnum.VALUE1, value1); } @Test public void testInjectBoundWithKeys( @Value3 TestClass testClassValue3, @Named("VALUE2") TestClass testClassValue2) { assertEquals(MyEnum.VALUE3, testClassValue3.value); assertEquals(MyEnum.VALUE2, testClassValue2.value); } @Test public void testParameterizedInjection1( ParameterizedTestClass<Integer> testClass) { assertEquals(200, (int) testClass.value); } @Test public void testParameterizedInjection2( ParameterizedTestClass<Double> testClass) { assertEquals(10.0, (double) testClass.value, 0.0000001); } @Test public void testMethodInjection( TestClassWithMethodInjection testClass) { assertEquals(200, testClass.value); } @Test public void testOptionalInjection( TestClassWithOptionalInjection testClass) { assertEquals(100, testClass.value); } }
public void setValue ( NonBoundInterface obj ) { value = obj . getValue ( ) ; // Should never be called, NonBoundInterface should not be mocked }
public void testParameterizedInjection1 ( ParameterizedTestClass < Integer > testClass ) { assertEquals ( 200 , ( int ) testClass . value ) ; }
public void testParameterizedInjection2 ( ParameterizedTestClass < Double > testClass ) { assertEquals ( 10.0 , ( double ) testClass . value , 0.0000001 ) ; }
public void testMethodInjection ( TestClassWithMethodInjection testClass ) { assertEquals ( 200 , testClass . value ) ; }
public void testOptionalInjection ( TestClassWithOptionalInjection testClass ) { assertEquals ( 100 , testClass . value ) ; }
void dummy ( ) ; } @Inject Registry registry ; @Test public void onlyEagerSingletonShouldBeRegistered ( ) { assertEquals ( 1 , registry . registrationCount ) ; } @Test public void bothSingletonsShouldBeRegistered ( MyTestSingleton myTestSingleton ) { assertEquals ( 2 , registry . registrationCount ) ; } @Test public void injectionOfMockShouldBeADifferentObject1 ( MyTestMockSingleton myTestMockSingleton ) { myTestMockSingleton . dummy ( ) ; verify ( myTestMockSingleton ) . dummy ( ) ; } @Test public void injectionOfMockShouldBeADifferentObject2 ( MyTestMockSingleton myTestMockSingleton ) { myTestMockSingleton . dummy ( ) ; verify ( myTestMockSingleton ) . dummy ( ) ; } @AfterClass public static void verifyNumberOfInstantiations ( ) { assertEquals ( 4 , Bookkeeper . numberOfTimesEagerSingletonIsInstantiated ) ; assertEquals ( 1 , Bookkeeper . numberOfTimesSingletonIsInstantiated ) ; } }
public void injectionOfMockShouldBeADifferentObject1 ( MyTestMockSingleton myTestMockSingleton ) { myTestMockSingleton . dummy ( ) ; verify ( myTestMockSingleton ) . dummy ( ) ; }
public void injectionOfMockShouldBeADifferentObject2 ( MyTestMockSingleton myTestMockSingleton ) { myTestMockSingleton . dummy ( ) ; verify ( myTestMockSingleton ) . dummy ( ) ; }
public static void verifyNumberOfInstantiations ( ) { assertEquals ( 4 , Bookkeeper . numberOfTimesEagerSingletonIsInstantiated ) ; assertEquals ( 1 , Bookkeeper . numberOfTimesSingletonIsInstantiated ) ; }
public void to ( Class < ? > constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Class . class ) ; }
protected void configureTest ( ) { bindConstant ( ) . annotatedWith ( OneHundred . class ) . to ( 100 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 200 " ) ) . to ( 200 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " HelloWorld " ) ) . to ( " Hello World! " ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 500L " ) ) . to ( 500L ) ; bindConstant ( ) . annotatedWith ( Names . named ( " true " ) ) . to ( true ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 3.1415 " ) ) . to ( 3.1415 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 2.718f " ) ) . to ( 2.718f ) ; bindConstant ( ) . annotatedWith ( Names . named ( " short8 " ) ) . to ( ( short ) 8 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 'a' " ) ) . to ( 'a' ) ; bindConstant ( ) . annotatedWith ( Names . named ( " IntegerClass " ) ) . to ( Integer . class ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE1 " ) ) . to ( MyEnum . VALUE1 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE2 " ) ) . to ( MyEnum . VALUE2 ) ; bind ( MyInteger . class ) . annotatedWith ( OneHundred . class ) . toInstance ( new MyIntegerImpl ( 100 ) ) ; bind ( MyInteger . class ) . annotatedWith ( Names . named ( " 200 " ) ) . toInstance ( new MyIntegerImpl ( 200 ) ) ; bind ( Key . get ( TestClass . class , Value3 . class ) ) . toInstance ( new TestClass ( MyEnum . VALUE3 ) ) ; bind ( Key . get ( TestClass . class , Names . named ( " VALUE2 " ) ) ) . to ( TestClass . class ) . in ( TestScope . SINGLETON ) ; bind ( new TypeLiteral < ParameterizedTestClass < Integer > > ( ) { } ) . in ( TestScope . SINGLETON ) ; bind ( new TypeLiteral < ParameterizedTestClass < Double > > ( ) { } ) . to ( ParameterizedTestClassDouble . class ) . in ( TestScope . SINGLETON ) ; }
int getValue ( ) ; } static class TestClassWithOptionalInjection { private int value ; @Inject public TestClassWithOptionalInjection ( @OneHundred Integer value ) { this . value = value ; } @Inject ( optional = true ) public void setValue ( NonBoundInterface obj ) { value = obj . getValue ( ) ; // Should never be called, NonBoundInterface should not be mocked } } @Test public void testConstantInjection( @OneHundred Integer oneHundred, @Named("200") Integer twoHundred, @Named("HelloWorld") String helloWorld, @Named("500L") long fiveHundred, @Named("3.1415") double pi, @Named("2.718f") float e, @Named("short8") short eight, @Named("'a'") char a, @SuppressWarnings("rawtypes") @Named("IntegerClass") Class integerClass, @Named("VALUE1") MyEnum value1) { assertEquals(100, (int) oneHundred); assertEquals(200, (int) twoHundred); assertEquals("Hello World!", helloWorld); assertEquals(500L, fiveHundred); assertEquals(3.1415, pi, 0.0000001); assertEquals(2.718f, e, 0.00001); assertEquals(8, eight); assertEquals('a', a); assertEquals(Integer.class, integerClass); assertEquals(MyEnum.VALUE1, value1); } @Test public void testInjectBoundWithKeys( @Value3 TestClass testClassValue3, @Named("VALUE2") TestClass testClassValue2, @OneHundred MyInteger testMyInteger100, @Named("200") MyInteger testMyInteger200) { assertEquals(MyEnum.VALUE3, testClassValue3.value); assertEquals(MyEnum.VALUE2, testClassValue2.value); assertEquals(100, testMyInteger100.getValue()); assertEquals(200, testMyInteger200.getValue()); } @Test public void testParameterizedInjection1( ParameterizedTestClass<Integer> testClass) { assertEquals(200, (int) testClass.value); } @Test public void testParameterizedInjection2( ParameterizedTestClass<Double> testClass) { assertEquals(10.0, (double) testClass.value, 0.0000001); } @Test public void testMethodInjection( TestClassWithMethodInjection testClass) { assertEquals(200, testClass.value); } @Test public void testOptionalInjection( TestClassWithOptionalInjection testClass) { assertEquals(100, testClass.value); } }
public void testConstantInjection ( @OneHundred Integer oneHundred , @Named ( " 200 " ) Integer twoHundred , @Named ( " HelloWorld " ) String helloWorld , @Named ( " 500L " ) long fiveHundred , @Named ( " 3.1415 " ) double pi , @Named ( " 2.718f " ) float e , @Named ( " short8 " ) short eight , @Named ( " 'a' " ) char a , @SuppressWarnings ( " rawtypes " ) @Named ( " IntegerClass " ) Class integerClass , @Named ( " VALUE1 " ) MyEnum value1 ) { assertEquals ( 100 , ( int ) oneHundred ) ; assertEquals ( 200 , ( int ) twoHundred ) ; assertEquals ( " Hello World! " , helloWorld ) ; assertEquals ( 500L , fiveHundred ) ; assertEquals ( 3.1415 , pi , 0.0000001 ) ; assertEquals ( 2.718f , e , 0.00001 ) ; assertEquals ( 8 , eight ) ; assertEquals ( 'a' , a ) ; assertEquals ( Integer . class , integerClass ) ; assertEquals ( MyEnum . VALUE1 , value1 ) ; }
public void testInjectBoundWithKeys ( @Value3 TestClass testClassValue3 , @Named ( " VALUE2 " ) TestClass testClassValue2 , @OneHundred MyInteger testMyInteger100 , @Named ( " 200 " ) MyInteger testMyInteger200 ) { assertEquals ( MyEnum . VALUE3 , testClassValue3 . value ) ; assertEquals ( MyEnum . VALUE2 , testClassValue2 . value ) ; assertEquals ( 100 , testMyInteger100 . getValue ( ) ) ; assertEquals ( 200 , testMyInteger200 . getValue ( ) ) ; }
public static < T > TypeLiteral < T > getProvidedType ( TypeLiteral < ? extends Provider < ? extends T > > initialProviderTypeLiteral , Errors errors ) throws ErrorsException { TypeLiteral < ? extends Provider < ? extends T > > providerTypeLiteral = initialProviderTypeLiteral ; while ( providerTypeLiteral . getRawType ( ) ! = Provider . class ) { providerTypeLiteral = ( TypeLiteral < ? extends Provider < ? extends T > > ) providerTypeLiteral . getSupertype ( Provider . class ) ; } Type providerType = providerTypeLiteral . getType ( ) ; // If the Provider has no type parameter (raw Provider)... if (!(providerType instanceof ParameterizedType)) { throw errors.cannotInjectRawProvider().toException(); } Type entryType = ((ParameterizedType) providerType).getActualTypeArguments()[0]; return (TypeLiteral<T>) TypeLiteral.get(entryType); }
public void configure ( ) { bindScopes ( ) ; configureTest ( ) ; }
protected void bindScopes ( ) { bindScope ( TestSingleton . class , TestScope . SINGLETON ) ; bindScope ( TestEagerSingleton . class , TestScope . EAGER_SINGLETON ) ; }
protected void configureTest ( ) { bindConstant ( ) . annotatedWith ( OneHundred . class ) . to ( 100 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 200 " ) ) . to ( 200 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " HelloWorld " ) ) . to ( " Hello World! " ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 500L " ) ) . to ( 500L ) ; bindConstant ( ) . annotatedWith ( Names . named ( " true " ) ) . to ( true ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 3.1415 " ) ) . to ( 3.1415 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 2.718f " ) ) . to ( 2.718f ) ; bindConstant ( ) . annotatedWith ( Names . named ( " short8 " ) ) . to ( ( short ) 8 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 'a' " ) ) . to ( 'a' ) ; bindConstant ( ) . annotatedWith ( Names . named ( " IntegerClass " ) ) . to ( Integer . class ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE1 " ) ) . to ( MyEnum . VALUE1 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE2 " ) ) . to ( MyEnum . VALUE2 ) ; bind ( MyInteger . class ) . annotatedWith ( OneHundred . class ) . toInstance ( new MyIntegerImpl ( 100 ) ) ; bind ( MyInteger . class ) . annotatedWith ( Names . named ( " 200 " ) ) . toInstance ( new MyIntegerImpl ( 200 ) ) ; bind ( Key . get ( TestClass . class , Value3 . class ) ) . toInstance ( new TestClass ( MyEnum . VALUE3 ) ) ; bind ( Key . get ( TestClass . class , Names . named ( " VALUE2 " ) ) ) . to ( TestClass . class ) . in ( TestSingleton . class ) ; bind ( new TypeLiteral < ParameterizedTestClass < Integer > > ( ) { } ) . in ( TestScope . SINGLETON ) ; bind ( new TypeLiteral < ParameterizedTestClass < Double > > ( ) { } ) . to ( ParameterizedTestClassDouble . class ) . in ( TestScope . SINGLETON ) ; }
protected void configureTest ( ) { bindNamedMock ( Mock . class , " singleton " ) . in ( TestScope . SINGLETON ) ; bindNamedMock ( Mock . class , " nonsingleton " ) ; bindNamed ( Instance . class , " singleton " ) . to ( Instance . class ) . in ( TestSingleton . class ) ; bindNamed ( Instance . class , " nonsingleton " ) . to ( Instance . class ) ; bindNamed ( Parent . class , " providerInstance " ) . toProvider ( new ParentProviderA ( ) ) . in ( TestSingleton . class ) ; bindNamed ( Parent . class , " providerClass " ) . toProvider ( ParentProviderB . class ) . in ( TestSingleton . class ) ; bindNamed ( Parent . class , " providerKey " ) . toProvider ( Key . get ( ParentProviderA . class ) ) . in ( TestSingleton . class ) ; }
String getValue ( ) ; } static class ChildA implements Parent { public String getValue ( ) { return " childA " ; } } interface MockInChildB { } interface MockInProviderB { void test ( ) ; } static class ChildB implements Parent { @Inject MockInChildB mockB ; public String getValue ( ) { return " childB " ; } } abstract static class ParentProviderABase implements Provider < Parent > { } static class ParentProviderA extends ParentProviderABase { @Override public Parent get ( ) { return new ChildA ( ) ; } } static class ParentProviderB implements Provider < Parent > { private final Provider < ChildB > childBProvider ; @Inject ParentProviderB ( Provider < ChildB > childBProvider , Provider < MockInProviderB > myMock ) { this . childBProvider = childBProvider ; // These calls should succeed myMock.get().test(); verify(myMock.get()).test(); } @Override public Parent get() { return childBProvider.get(); } } @Test public void mockSingletonProviderShouldReturnTheSameInstance( @Named("singleton") Provider<Mock> provider) { assertSame(provider.get(), provider.get()); } @Test public void mockNonSingletonProviderShouldNotReturnTheSameInstance( @Named("nonsingleton") Provider<Mock> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void singletonClassShouldReturnTheSameInstance( @Named("singleton") Provider<Instance> provider) { assertSame(provider.get(), provider.get()); } @Test public void nonSingletonClassShouldNotReturnTheSameInstance( @Named("nonsingleton") Provider<Instance> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void bindingToProviderInstanceShouldWorkAndInject( @Named("nonsingleton") Provider<Mock> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void shouldInjectProviderBoundWithInstance( @Named("providerInstance") Parent parentProvidedFromProviderInstance) { assertEquals(parentProvidedFromProviderInstance.getClass(), ChildA.class); } @Test public void shouldInjectProviderBoundWithClass( @Named("providerClass") Parent parentProvidedFromProviderClass) { assertEquals(parentProvidedFromProviderClass.getClass(), ChildB.class); } @Test public void shouldInjectProviderBoundWithKey( @Named("providerKey") Parent parentProvidedFromProviderKey) { assertEquals(parentProvidedFromProviderKey.getClass(), ChildA.class); } }
void test ( ) ; } static class ChildB implements Parent { @Inject MockInChildB mockB ; public String getValue ( ) { return " childB " ; } } abstract static class ParentProviderABase implements Provider < Parent > { } static class ParentProviderA extends ParentProviderABase { @Override public Parent get ( ) { return new ChildA ( ) ; } } static class ParentProviderB implements Provider < Parent > { private final Provider < ChildB > childBProvider ; @Inject ParentProviderB ( Provider < ChildB > childBProvider , Provider < MockInProviderB > myMock ) { this . childBProvider = childBProvider ; // These calls should succeed myMock.get().test(); verify(myMock.get()).test(); } @Override public Parent get() { return childBProvider.get(); } } @Test public void mockSingletonProviderShouldReturnTheSameInstance( @Named("singleton") Provider<Mock> provider) { assertSame(provider.get(), provider.get()); } @Test public void mockNonSingletonProviderShouldNotReturnTheSameInstance( @Named("nonsingleton") Provider<Mock> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void singletonClassShouldReturnTheSameInstance( @Named("singleton") Provider<Instance> provider) { assertSame(provider.get(), provider.get()); } @Test public void nonSingletonClassShouldNotReturnTheSameInstance( @Named("nonsingleton") Provider<Instance> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void bindingToProviderInstanceShouldWorkAndInject( @Named("nonsingleton") Provider<Mock> provider) { assertNotSame(provider.get(), provider.get()); } @Test public void shouldInjectProviderBoundWithInstance( @Named("providerInstance") Parent parentProvidedFromProviderInstance) { assertEquals(parentProvidedFromProviderInstance.getClass(), ChildA.class); } @Test public void shouldInjectProviderBoundWithClass( @Named("providerClass") Parent parentProvidedFromProviderClass) { assertEquals(parentProvidedFromProviderClass.getClass(), ChildB.class); } @Test public void shouldInjectProviderBoundWithKey( @Named("providerKey") Parent parentProvidedFromProviderKey) { assertEquals(parentProvidedFromProviderKey.getClass(), ChildA.class); } }
public void shouldInjectProviderBoundWithInstance ( @Named ( " providerInstance " ) Parent parentProvidedFromProviderInstance ) { assertEquals ( parentProvidedFromProviderInstance . getClass ( ) , ChildA . class ) ; }
public void shouldInjectProviderBoundWithClass ( @Named ( " providerClass " ) Parent parentProvidedFromProviderClass ) { assertEquals ( parentProvidedFromProviderClass . getClass ( ) , ChildB . class ) ; }
public void shouldInjectProviderBoundWithKey ( @Named ( " providerKey " ) Parent parentProvidedFromProviderKey ) { assertEquals ( parentProvidedFromProviderKey . getClass ( ) , ChildA . class ) ; }
protected void configureTest ( ) { bind ( MyEagerSingleton . class ) . asEagerSingleton ( ) ; }
void dummy ( ) ; } @Inject Registry registry ; @Test public void onlyEagerSingletonShouldBeRegistered ( ) { assertEquals ( 1 , registry . registrationCount ) ; } @Test public void bothSingletonsShouldBeRegistered ( MyTestSingleton myTestSingleton ) { assertEquals ( 2 , registry . registrationCount ) ; } @Test public void injectionOfMockShouldBeADifferentObject1 ( MyTestMockSingleton myTestMockSingleton ) { myTestMockSingleton . dummy ( ) ; verify ( myTestMockSingleton ) . dummy ( ) ; } @Test public void injectionOfMockShouldBeADifferentObject2 ( MyTestMockSingleton myTestMockSingleton ) { myTestMockSingleton . dummy ( ) ; verify ( myTestMockSingleton ) . dummy ( ) ; } @AfterClass public static void verifyNumberOfInstantiations ( ) { assertEquals ( 4 , Bookkeeper . numberOfTimesTestEagerSingletonIsInstantiated ) ; assertEquals ( 1 , Bookkeeper . numberOfTimesTestSingletonIsInstantiated ) ; assertEquals ( 1 , Bookkeeper . numberOfTimesEagerSingletonIsInstantiated ) ; } }
public static void verifyNumberOfInstantiations ( ) { assertEquals ( 4 , Bookkeeper . numberOfTimesTestEagerSingletonIsInstantiated ) ; assertEquals ( 1 , Bookkeeper . numberOfTimesTestSingletonIsInstantiated ) ; assertEquals ( 1 , Bookkeeper . numberOfTimesEagerSingletonIsInstantiated ) ; }
void mockSingletonMethod ( ) ; } interface DummyInterface { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent1 { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent2 { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent3 { String getDummyValue ( ) ; } static class DummyClassUsedOnlyInParent1 { } static class DummyClassUsedOnlyInParent2 { } static class DummyClassUsedOnlyInParent3 { } @Inject protected Provider < DummyInterface > dummyProvider ; @Inject protected MockSingletonDefinedInParent mockSingletonDefinedInParent ; // This keeps track that the parent test was executed. static boolean parentTestShouldRunExecuted; @Test public void parentTestShouldRun() { parentTestShouldRunExecuted = true; } @Test public void interfaceBoundInChildIsInjectedInParent() { assertEquals("DummyValue", dummyProvider.get().getDummyValue()); } @Test public void interfaceBoundInChildIsInjectedInParentTestMethod( DummyInterface dummyInterface) { assertEquals("DummyValue", dummyInterface.getDummyValue()); } @Test public void interfaceUsedInParentTestMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent1> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Test public void concreteClassUsedInParentTestMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent1> provider) { assertSame(provider.get(), provider.get()); } @Before public void interfaceUsedInParentBeforeMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent2> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Before public void concreteClassUsedInParentBeforeMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent2> provider) { assertSame(provider.get(), provider.get()); } @After public void interfaceUsedInParentAfterMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent3> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @After public void concreteClassUsedInParentAfterMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent3> provider) { assertSame(provider.get(), provider.get()); } }
String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent1 { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent2 { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent3 { String getDummyValue ( ) ; } static class DummyClassUsedOnlyInParent1 { } static class DummyClassUsedOnlyInParent2 { } static class DummyClassUsedOnlyInParent3 { } @Inject protected Provider < DummyInterface > dummyProvider ; @Inject protected MockSingletonDefinedInParent mockSingletonDefinedInParent ; // This keeps track that the parent test was executed. static boolean parentTestShouldRunExecuted; @Test public void parentTestShouldRun() { parentTestShouldRunExecuted = true; } @Test public void interfaceBoundInChildIsInjectedInParent() { assertEquals("DummyValue", dummyProvider.get().getDummyValue()); } @Test public void interfaceBoundInChildIsInjectedInParentTestMethod( DummyInterface dummyInterface) { assertEquals("DummyValue", dummyInterface.getDummyValue()); } @Test public void interfaceUsedInParentTestMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent1> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Test public void concreteClassUsedInParentTestMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent1> provider) { assertSame(provider.get(), provider.get()); } @Before public void interfaceUsedInParentBeforeMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent2> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Before public void concreteClassUsedInParentBeforeMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent2> provider) { assertSame(provider.get(), provider.get()); } @After public void interfaceUsedInParentAfterMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent3> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @After public void concreteClassUsedInParentAfterMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent3> provider) { assertSame(provider.get(), provider.get()); } }
String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent2 { String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent3 { String getDummyValue ( ) ; } static class DummyClassUsedOnlyInParent1 { } static class DummyClassUsedOnlyInParent2 { } static class DummyClassUsedOnlyInParent3 { } @Inject protected Provider < DummyInterface > dummyProvider ; @Inject protected MockSingletonDefinedInParent mockSingletonDefinedInParent ; // This keeps track that the parent test was executed. static boolean parentTestShouldRunExecuted; @Test public void parentTestShouldRun() { parentTestShouldRunExecuted = true; } @Test public void interfaceBoundInChildIsInjectedInParent() { assertEquals("DummyValue", dummyProvider.get().getDummyValue()); } @Test public void interfaceBoundInChildIsInjectedInParentTestMethod( DummyInterface dummyInterface) { assertEquals("DummyValue", dummyInterface.getDummyValue()); } @Test public void interfaceUsedInParentTestMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent1> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Test public void concreteClassUsedInParentTestMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent1> provider) { assertSame(provider.get(), provider.get()); } @Before public void interfaceUsedInParentBeforeMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent2> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Before public void concreteClassUsedInParentBeforeMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent2> provider) { assertSame(provider.get(), provider.get()); } @After public void interfaceUsedInParentAfterMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent3> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @After public void concreteClassUsedInParentAfterMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent3> provider) { assertSame(provider.get(), provider.get()); } }
String getDummyValue ( ) ; } interface DummyInterfaceUsedOnlyInParent3 { String getDummyValue ( ) ; } static class DummyClassUsedOnlyInParent1 { } static class DummyClassUsedOnlyInParent2 { } static class DummyClassUsedOnlyInParent3 { } @Inject protected Provider < DummyInterface > dummyProvider ; @Inject protected MockSingletonDefinedInParent mockSingletonDefinedInParent ; // This keeps track that the parent test was executed. static boolean parentTestShouldRunExecuted; @Test public void parentTestShouldRun() { parentTestShouldRunExecuted = true; } @Test public void interfaceBoundInChildIsInjectedInParent() { assertEquals("DummyValue", dummyProvider.get().getDummyValue()); } @Test public void interfaceBoundInChildIsInjectedInParentTestMethod( DummyInterface dummyInterface) { assertEquals("DummyValue", dummyInterface.getDummyValue()); } @Test public void interfaceUsedInParentTestMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent1> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Test public void concreteClassUsedInParentTestMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent1> provider) { assertSame(provider.get(), provider.get()); } @Before public void interfaceUsedInParentBeforeMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent2> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Before public void concreteClassUsedInParentBeforeMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent2> provider) { assertSame(provider.get(), provider.get()); } @After public void interfaceUsedInParentAfterMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent3> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @After public void concreteClassUsedInParentAfterMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent3> provider) { assertSame(provider.get(), provider.get()); } }
String getDummyValue ( ) ; } static class DummyClassUsedOnlyInParent1 { } static class DummyClassUsedOnlyInParent2 { } static class DummyClassUsedOnlyInParent3 { } @Inject protected Provider < DummyInterface > dummyProvider ; @Inject protected MockSingletonDefinedInParent mockSingletonDefinedInParent ; // This keeps track that the parent test was executed. static boolean parentTestShouldRunExecuted; @Test public void parentTestShouldRun() { parentTestShouldRunExecuted = true; } @Test public void interfaceBoundInChildIsInjectedInParent() { assertEquals("DummyValue", dummyProvider.get().getDummyValue()); } @Test public void interfaceBoundInChildIsInjectedInParentTestMethod( DummyInterface dummyInterface) { assertEquals("DummyValue", dummyInterface.getDummyValue()); } @Test public void interfaceUsedInParentTestMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent1> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Test public void concreteClassUsedInParentTestMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent1> provider) { assertSame(provider.get(), provider.get()); } @Before public void interfaceUsedInParentBeforeMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent2> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @Before public void concreteClassUsedInParentBeforeMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent2> provider) { assertSame(provider.get(), provider.get()); } @After public void interfaceUsedInParentAfterMethodShouldBeMockedAsTestSingleton( Provider<DummyInterfaceUsedOnlyInParent3> provider) { // Following should not crash verify(provider.get(), never()).getDummyValue(); assertSame(provider.get(), provider.get()); } @After public void concreteClassUsedInParentAfterMethodShouldBeBoundAsTestSingleton( Provider<DummyClassUsedOnlyInParent3> provider) { assertSame(provider.get(), provider.get()); } }
public void parentTestShouldRun ( ) { parentTestShouldRunExecuted = true ; }
public void toInstance ( T instance ) { // Binding to an instance, class cannot be injected bindingInfo.isBoundToInstanceOrMock = true; delegate.toInstance(instance); }
public ScopedBindingBuilder toProvider ( Provider < ? extends T > provider ) { if ( SpyProvider . class . isAssignableFrom ( provider . getClass ( ) ) ) { // For a SpyProvider, consider all the dependencies of the class spied upon bindingInfo.boundType = bindingInfo.abstractType; } else { bindingInfo.isBoundToInstanceOrMock = true; } return delegate.toProvider(provider); }
public ScopedBindingBuilder toProvider ( Key < ? extends Provider < ? extends T > > key ) { bindingInfo . boundType = key . getTypeLiteral ( ) ; return delegate . toProvider ( key ) ; }
protected void configureTest ( ) { bindConstant ( ) . annotatedWith ( OneHundred . class ) . to ( 100 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 200 " ) ) . to ( 200 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " HelloWorld " ) ) . to ( " Hello World! " ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 500L " ) ) . to ( 500L ) ; bindConstant ( ) . annotatedWith ( Names . named ( " true " ) ) . to ( true ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 3.1415 " ) ) . to ( 3.1415 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 2.718f " ) ) . to ( 2.718f ) ; bindConstant ( ) . annotatedWith ( Names . named ( " short8 " ) ) . to ( ( short ) 8 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 'a' " ) ) . to ( 'a' ) ; bindConstant ( ) . annotatedWith ( Names . named ( " IntegerClass " ) ) . to ( Integer . class ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE1 " ) ) . to ( MyEnum . VALUE1 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE2 " ) ) . to ( MyEnum . VALUE2 ) ; bind ( MyInteger . class ) . annotatedWith ( OneHundred . class ) . toInstance ( new MyIntegerImpl ( 100 ) ) ; bind ( MyInteger . class ) . annotatedWith ( Names . named ( " 200 " ) ) . toInstance ( new MyIntegerImpl ( 200 ) ) ; bind ( Key . get ( TestClass . class , Value3 . class ) ) . toInstance ( new TestClass ( MyEnum . VALUE3 ) ) ; bind ( Key . get ( TestClass . class , Names . named ( " VALUE2 " ) ) ) . to ( TestClass . class ) . in ( TestSingleton . class ) ; bind ( new TypeLiteral < ParameterizedTestClass < Integer > > ( ) { } ) . in ( TestScope . SINGLETON ) ; bind ( new TypeLiteral < ParameterizedTestClass < Double > > ( ) { } ) . to ( ParameterizedTestClassDouble . class ) . in ( TestScope . SINGLETON ) ; bindNamedMock ( ClassWithUninstanciableDependency3 . class , " UninstanciableDependency3a " ) ; bind ( ClassWithUninstanciableDependency3 . class ) . annotatedWith ( Names . named ( " UninstanciableDependency3b " ) ) . toProvider ( MyMockProvider3b . class ) ; bind ( ClassWithUninstanciableDependency3 . class ) . annotatedWith ( Names . named ( " UninstanciableDependency3c " ) ) . toProvider ( Key . get ( MyMockProvider3c . class ) ) ; }
public void testInjectingMockShouldNotInstantiateDependencies1 ( ClassWithUninstanciableDependency1 testClass ) { verify ( testClass , never ( ) ) . getValue ( ) ; }
public void testInjectingMockShouldNotInstantiateDependencies2 ( ClassWithUninstanciableDependency2 testClass ) { verify ( testClass , never ( ) ) . getValue ( ) ; }
public void testInjectingMockShouldNotInstantiateDependencies3a ( @Named ( " UninstanciableDependency3a " ) ClassWithUninstanciableDependency3 testClass ) { verify ( testClass , never ( ) ) . getValue ( ) ; }
public void testInjectingMockShouldNotInstantiateDependencies3b ( @Named ( " UninstanciableDependency3b " ) ClassWithUninstanciableDependency3 testClass ) { verify ( testClass , never ( ) ) . getValue ( ) ; }
public void testInjectingMockShouldNotInstantiateDependencies3c ( @Named ( " UninstanciableDependency3c " ) ClassWithUninstanciableDependency3 testClass ) { verify ( testClass , never ( ) ) . getValue ( ) ; }
protected void configureTest ( ) { bindNamedMock ( Mock . class , " singleton " ) . in ( TestScope . SINGLETON ) ; bindNamedMock ( Mock . class , " nonsingleton " ) ; bindNamed ( Instance . class , " singleton " ) . to ( Instance . class ) . in ( TestSingleton . class ) ; bindNamed ( Instance . class , " nonsingleton " ) . to ( Instance . class ) ; bindNamed ( Parent . class , " providerInstance " ) . toProvider ( new ParentProviderA ( ) ) . in ( TestSingleton . class ) ; bindNamed ( Parent . class , " providerClass " ) . toProvider ( ParentProviderB . class ) . in ( TestSingleton . class ) ; bindNamed ( Parent . class , " providerKey " ) . toProvider ( Key . get ( ParentProviderA . class ) ) . in ( TestSingleton . class ) ; bindNamedMock ( UninstanciableClass . class , " cannotInstantiate1 " ) . in ( TestScope . SINGLETON ) ; bind ( UninstanciableClass . class ) . annotatedWith ( Names . named ( " cannotInstantiate2 " ) ) . toProvider ( MyMockProvider2 . class ) ; bind ( UninstanciableClass . class ) . annotatedWith ( Names . named ( " cannotInstantiate3 " ) ) . toProvider ( Key . get ( MyMockProvider3 . class ) ) ; bind ( ClassWithMockedDependency1 . class ) . annotatedWith ( Names . named ( " MockedDependency1 " ) ) . toProvider ( MyProvider1 . class ) ; bind ( ClassWithMockedDependency2 . class ) . annotatedWith ( Names . named ( " MockedDependency2 " ) ) . toProvider ( Key . get ( MyProvider2 . class ) ) ; }
public DependencyShouldBeMocked1 getDependency ( ) { return dependency ; }
public ClassWithMockedDependency1 get ( ) { return provider . get ( ) ; }
public DependencyShouldBeMocked2 getDependency ( ) { return dependency ; }
public ClassWithMockedDependency2 get ( ) { return provider . get ( ) ; }
public void shouldInjectProviderOfClassWithPrivateConstructor1 ( @Named ( " cannotInstantiate1 " ) UninstanciableClass classWithPrivateConstructor ) { verify ( classWithPrivateConstructor , never ( ) ) . getValue ( ) ; }
public void shouldInjectProviderOfClassWithPrivateConstructor2 ( @Named ( " cannotInstantiate2 " ) UninstanciableClass classWithPrivateConstructor ) { verify ( classWithPrivateConstructor , never ( ) ) . getValue ( ) ; }
public void shouldInjectProviderOfClassWithPrivateConstructor3 ( @Named ( " cannotInstantiate3 " ) UninstanciableClass classWithPrivateConstructor ) { verify ( classWithPrivateConstructor , never ( ) ) . getValue ( ) ; }
public void testInjectingProviderShouldInstantiateDependencies1 ( @Named ( " MockedDependency1 " ) ClassWithMockedDependency1 testClass ) { verify ( testClass . getDependency ( ) , never ( ) ) . getValue ( ) ; }
public void testInjectingProviderShouldInstantiateDependencies2 ( @Named ( " MockedDependency2 " ) ClassWithMockedDependency2 testClass ) { verify ( testClass . getDependency ( ) , never ( ) ) . getValue ( ) ; }
private void ensureInjector ( ) throws InstantiationException , IllegalAccessException { Class < ? > testClass = getTestClass ( ) . getJavaClass ( ) ; if ( injector ! = null ) { return ; } TestModule testModule = null ; for ( Class < ? > subclass : testClass . getDeclaredClasses ( ) ) { if ( TestModule . class . isAssignableFrom ( subclass ) ) { assert testModule = = null : " More than one TestModule inner class found within test class \" " + testClass . getName ( ) + " \" . " ; testModule = ( TestModule ) subclass . newInstance ( ) ; } } if ( testModule = = null ) { if ( useAutomockingIfNoEnvironmentFound ) { testModule = new JukitoModule ( ) { @Override protected void configureTest ( ) { } } ; } else { testModule = new TestModule ( ) { @Override protected void configureTest ( ) { } } ; } } testModule . setTestClass ( testClass ) ; injector = Guice . createInjector ( testModule ) ; SpyProvider . setInjector ( testClass , injector ) ; }
private void ensureInjector ( ) throws InstantiationException , IllegalAccessException { Class < ? > testClass = getTestClass ( ) . getJavaClass ( ) ; if ( injector ! = null ) { return ; } TestModule testModule = null ; for ( Class < ? > subclass : testClass . getDeclaredClasses ( ) ) { if ( TestModule . class . isAssignableFrom ( subclass ) ) { assert testModule = = null : " More than one TestModule inner class found within test class \" " + testClass . getName ( ) + " \" . " ; testModule = ( TestModule ) subclass . newInstance ( ) ; } } if ( testModule = = null ) { if ( useAutomockingIfNoEnvironmentFound ) { testModule = new JukitoModule ( ) { @Override protected void configureTest ( ) { } } ; } else { testModule = new TestModule ( ) { @Override protected void configureTest ( ) { } } ; } } testModule . setTestClass ( testClass ) ; injector = Guice . createInjector ( testModule ) ; }
public T get ( ) { List < Dependency < ? > > dependencies = injectionPoint . getDependencies ( ) ; Object [ ] constructorParameters = new Object [ dependencies . size ( ) ] ; for ( Dependency < ? > dependency : dependencies ) { constructorParameters [ dependency . getParameterIndex ( ) ] = injector . getInstance ( dependency . getKey ( ) ) ; } T instance ; try { instance = constructor . newInstance ( constructorParameters ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } injector . injectMembers ( instance ) ; return spy ( instance ) ; }
private < T > Provider < T > createNewSpyProvider ( TypeLiteral < T > typeLiteral ) { return new SpyProvider < T > ( typeLiteral ) ; }
private boolean isCoreGuiceType ( Class < ? > klass ) { return TypeLiteral . class . isAssignableFrom ( klass ) | | Injector . class . isAssignableFrom ( klass ) ; }
public Class < ? super U > getInjectedType ( ) { return injectedType ; }
public void testInjectingClassInjectedWithTypeLiteralShouldWork ( TestGenericClassInjectedWithTypeLiteral < String > testClass ) { assertEquals ( String . class , testClass . getInjectedType ( ) ) ; }
public void testInjectingTypeLiteralShouldWork ( TypeLiteral < Integer > typeLiteral ) { assertEquals ( Integer . class , typeLiteral . getRawType ( ) ) ; }
public void testInjectingInjectorShouldWork ( Injector injector ) { } }
protected void configureTest ( ) { bind ( Payment . class ) . to ( RealPayment1 . class ) ; bind ( PaymentFactory1 . class ) . toProvider ( FactoryProvider . newFactory ( PaymentFactory1 . class , Payment . class ) ) ; bind ( PaymentFactory2 . class ) . toProvider ( FactoryProvider . newFactory ( PaymentFactory2 . class , Payment . class ) ) ;
RealPayment1 create ( Amount amount ) ; } interface PaymentFactory2 { RealPayment1 create ( String amount ) ; } interface Payment { } interface Amount { } static class RealPayment1 implements Payment { @Inject public RealPayment1 ( @Assisted Amount amount ) { } } static class RealPayment2 implements Payment { @Inject public RealPayment2 ( @Assisted String amount ) { } } // SUT @Inject PaymentFactory1 paymentFactory1; @Inject PaymentFactory2 paymentFactory2; @Test public void shouldntFailToLoad() { assert true; } }
RealPayment1 create ( String amount ) ; } interface Payment { } interface Amount { } static class RealPayment1 implements Payment { @Inject public RealPayment1 ( @Assisted Amount amount ) { } } static class RealPayment2 implements Payment { @Inject public RealPayment2 ( @Assisted String amount ) { } } // SUT @Inject PaymentFactory1 paymentFactory1; @Inject PaymentFactory2 paymentFactory2; @Test public void shouldntFailToLoad() { assert true; } }
public static boolean isFactory ( Class < ? > klass ) { return FactoryProvider2 . class . isAssignableFrom ( klass ) ; }
public static < T > TypeLiteral < T > getProvidedType ( Provider < T > factoryProvider ) { FactoryProvider2 < ? > factoryProviderConcrete = ( FactoryProvider2 < ? > ) factoryProvider ; // TODO: Found no way to access the private variable producedType. It is needed in order // to identify the dependencies that may need to be mocked. try { Field field = factoryProviderConcrete.getClass().getDeclaredField("producedType");
private boolean isAssistedInjection ( Key < ? > key ) { return key . getAnnotationType ( ) ! = null & & Assisted . class . isAssignableFrom ( key . getAnnotationType ( ) ) ; }
private boolean shouldForceMock ( Class < ? > klass ) { if ( dontForceMock . contains ( klass ) ) { return false ; } if ( forceMock . contains ( klass ) ) { return true ; } // The forceMock set contains all the base classes the user wants // to force mock, check id the specified klass is a subclass of one of these. // Update forceMock or dontForceMock based on the result to speed-up future look-ups. boolean result = false; for (Class<?> classToMock : forceMock) { if (classToMock.isAssignableFrom(klass)) { result = true; break; } } if (result) { forceMock.add(klass); } else { dontForceMock.add(klass); } return result; }
private < T > void addDependencies ( Key < T > key , Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded ) { TypeLiteral < T > type = key . getTypeLiteral ( ) ; if ( ! isInstantiable ( type . getRawType ( ) ) ) { return ; } addInjectionPointDependencies ( InjectionPoint . forConstructorOf ( type ) , keysObserved , keysNeeded ) ; Set < InjectionPoint > methodsAndFieldsInjectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; for ( InjectionPoint injectionPoint : methodsAndFieldsInjectionPoints ) { addInjectionPointDependencies ( injectionPoint , keysObserved , keysNeeded ) ;
public ScopedBindingBuilder toProvider ( Provider < ? extends T > provider ) { Class < ? > providerClass = provider . getClass ( ) ; if ( SpyProvider . class . isAssignableFrom ( providerClass ) ) { // For a SpyProvider, consider all the dependencies of the class spied upon bindingInfo.boundType = bindingInfo.abstractType; } else if (AssistedInjectHelper.isFactory(providerClass)) { // For an assisted factory, consider all the dependencies of the class generated upon bindingInfo.boundType = AssistedInjectHelper.getProvidedType(provider); } else { bindingInfo.isBoundToInstanceOrMock = true; } return delegate.toProvider(provider); }
protected void configureTest ( ) { bindConstant ( ) . annotatedWith ( Names . named ( " moneySymbol " ) ) . to ( " $ " ) ; bindNamed ( PaymentFactory . class , " factory1 " ) . toProvider ( FactoryProvider . newFactory ( PaymentFactory . class , RealPayment1 . class ) ) ; bindNamed ( PaymentFactory . class , " factory2 " ) . toProvider ( FactoryProvider . newFactory ( PaymentFactory . class , RealPayment2 . class ) ) ; bind ( PaymentAmountFactory . class ) . toProvider ( FactoryProvider . newFactory ( PaymentAmountFactory . class , RealPaymentAmount . class ) ) ; bind ( Amount . class ) . toInstance ( new Amount ( ) { public String toString ( ) {
public String toString ( ) { return " An amount of 10.00 dollars. " ; }
public String getPayment ( ) { return Integer . toString ( amount ) + " .00 " + moneySymbol ; }
public String getPayment ( ) { return Integer . toString ( amount ) + " dollars " ; }
boolean shouldAlwaysHideAmounts ( ) ; } // Class InjectedClass should be bound automatically as TestSingleton // because it is a dependency of RealPaymentAmount static class InjectedClass { } static class RealPaymentAmount implements Payment { private final Configuration configuration; private final InjectedClass injectedClass; private final Amount amount; @Inject public RealPaymentAmount(Configuration configuration, InjectedClass injectedClass, @Assisted Amount amount) { this.configuration = configuration; this.injectedClass = injectedClass; this.amount = amount; } @Override public String getPayment() { if (configuration.shouldAlwaysHideAmounts()) { return "xxxxxxx"; } return amount.toString(); } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((injectedClass == null) ? 0 : injectedClass.hashCode()); return result; } /* Checks only injectedClass, to ensure injectedClass is a singleton. */ @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } RealPaymentAmount other = (RealPaymentAmount) obj; if (injectedClass == null) { if (other.injectedClass != null) { return false; } } else if (!injectedClass.equals(other.injectedClass)) { return false; } return true; } } @Inject @Named("factory1") PaymentFactory factory1; @Test public void shouldInjectFactoryInClass() { // WHEN Payment payment = factory1.create(20); // THEN assertEquals("20.00$", payment.getPayment()); } @Test public void shouldInjectFactoryAsParameter(@Named("factory2") PaymentFactory factory2) { // WHEN Payment payment = factory2.create(30); // THEN assertEquals("30 dollars", payment.getPayment()); } @Test public void shouldInjectFactoryWithInterfacesAsParameter( PaymentAmountFactory factoryString, Amount amount) { // WHEN Payment payment = factoryString.create(amount); // THEN assertEquals("An amount of 10.00 dollars.", payment.getPayment()); } @Test public void shouldInjectFactoryWithTestSingletonAsParameter( PaymentAmountFactory factoryString, Amount amount) { // WHEN Payment payment1 = factoryString.create(amount); Payment payment2 = factoryString.create(amount); // THEN assertEquals(payment1, payment2); } }
public String getPayment ( ) { if ( configuration . shouldAlwaysHideAmounts ( ) ) { return " xxxxxxx " ; } return amount . toString ( ) ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( injectedClass = = null ) ? 0 : injectedClass . hashCode ( ) ) ; return result ; }
public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null ) { return false ; } if ( getClass ( ) ! = obj . getClass ( ) ) { return false ; } RealPaymentAmount other = ( RealPaymentAmount ) obj ; if ( injectedClass = = null ) { if ( other . injectedClass ! = null ) { return false ; } } else if ( ! injectedClass . equals ( other . injectedClass ) ) { return false ; } return true ; }
public void shouldInjectFactoryInClass ( ) { // WHEN Payment payment = factory1.create(20); // THEN assertEquals("20.00$", payment.getPayment()); }
public void shouldInjectFactoryAsParameter ( @Named ( " factory2 " ) PaymentFactory factory2 ) { // WHEN Payment payment = factory2.create(30); // THEN assertEquals("30 dollars", payment.getPayment()); }
public void shouldInjectFactoryWithInterfacesAsParameter ( PaymentAmountFactory factoryString , Amount amount ) { // WHEN Payment payment = factoryString.create(amount); // THEN assertEquals("An amount of 10.00 dollars.", payment.getPayment()); }
public void shouldInjectFactoryWithTestSingletonAsParameter ( PaymentAmountFactory factoryString , Amount amount ) { // WHEN Payment payment1 = factoryString.create(amount); Payment payment2 = factoryString.create(amount); // THEN assertEquals(payment1, payment2); }
private boolean isCoreGuiceType ( Class < ? > klass ) { return TypeLiteral . class . isAssignableFrom ( klass ) | | Injector . class . isAssignableFrom ( klass ) | |
protected void configureTest ( ) { bindConstant ( ) . annotatedWith ( OneHundred . class ) . to ( 100 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 200 " ) ) . to ( 200 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " HelloWorld " ) ) . to ( " Hello World! " ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 500L " ) ) . to ( 500L ) ; bindConstant ( ) . annotatedWith ( Names . named ( " true " ) ) . to ( true ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 3.1415 " ) ) . to ( 3.1415 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 2.718f " ) ) . to ( 2.718f ) ; bindConstant ( ) . annotatedWith ( Names . named ( " short8 " ) ) . to ( ( short ) 8 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 'a' " ) ) . to ( 'a' ) ; bindConstant ( ) . annotatedWith ( Names . named ( " IntegerClass " ) ) . to ( Integer . class ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE1 " ) ) . to ( MyEnum . VALUE1 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE2 " ) ) . to ( MyEnum . VALUE2 ) ; bind ( MyInteger . class ) . annotatedWith ( OneHundred . class ) . toInstance ( new MyIntegerImpl ( 100 ) ) ; bind ( MyInteger . class ) . annotatedWith ( Names . named ( " 200 " ) ) . toInstance ( new MyIntegerImpl ( 200 ) ) ; bind ( Key . get ( TestClass . class , Value3 . class ) ) . toInstance ( new TestClass ( MyEnum . VALUE3 ) ) ; bind ( Key . get ( TestClass . class , Names . named ( " VALUE2 " ) ) ) . to ( TestClass . class ) . in ( TestSingleton . class ) ; bind ( new TypeLiteral < ParameterizedTestClass < Integer > > ( ) { } ) . in ( TestScope . SINGLETON ) ; bind ( new TypeLiteral < ParameterizedTestClass < Double > > ( ) { } ) . to ( ParameterizedTestClassDouble . class ) . in ( TestScope . SINGLETON ) ; bindNamedMock ( ClassWithUninstanciableDependency3 . class , " UninstanciableDependency3a " ) ; bind ( ClassWithUninstanciableDependency3 . class ) . annotatedWith ( Names . named ( " UninstanciableDependency3b " ) ) . toProvider ( MyMockProvider3b . class ) ; bind ( ClassWithUninstanciableDependency3 . class ) . annotatedWith ( Names . named ( " UninstanciableDependency3c " ) ) . toProvider ( Key . get ( MyMockProvider3c . class ) ) ; bindMock ( Logger . class ) ; }
public void testInjectingInjectorShouldWork ( Injector injector ) { } @Test public void testInjectingLoggerShouldWork ( Logger logger ) { } @Test public void testInjectingStageShouldWork ( Stage stage ) { } @Test public void testInjectingMembersInjectorShouldWork ( MembersInjector < TestClass > memberInjector ) { } }
public void testInjectingLoggerShouldWork ( Logger logger ) { } @Test public void testInjectingStageShouldWork ( Stage stage ) { } @Test public void testInjectingMembersInjectorShouldWork ( MembersInjector < TestClass > memberInjector ) { } }
public void testInjectingStageShouldWork ( Stage stage ) { } @Test public void testInjectingMembersInjectorShouldWork ( MembersInjector < TestClass > memberInjector ) { } }
public void testInjectingMembersInjectorShouldWork ( MembersInjector < TestClass > memberInjector ) { } }
protected void configureTest ( ) { bindConstant ( ) . annotatedWith ( OneHundred . class ) . to ( 100 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 200 " ) ) . to ( 200 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " HelloWorld " ) ) . to ( " Hello World! " ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 500L " ) ) . to ( 500L ) ; bindConstant ( ) . annotatedWith ( Names . named ( " true " ) ) . to ( true ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 3.1415 " ) ) . to ( 3.1415 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 2.718f " ) ) . to ( 2.718f ) ; bindConstant ( ) . annotatedWith ( Names . named ( " short8 " ) ) . to ( ( short ) 8 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " 'a' " ) ) . to ( 'a' ) ; bindConstant ( ) . annotatedWith ( Names . named ( " IntegerClass " ) ) . to ( Integer . class ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE1 " ) ) . to ( MyEnum . VALUE1 ) ; bindConstant ( ) . annotatedWith ( Names . named ( " VALUE2 " ) ) . to ( MyEnum . VALUE2 ) ; bind ( MyInteger . class ) . annotatedWith ( OneHundred . class ) . toInstance ( new MyIntegerImpl ( 100 ) ) ; bind ( MyInteger . class ) . annotatedWith ( Names . named ( " 200 " ) ) . toInstance ( new MyIntegerImpl ( 200 ) ) ; bind ( Key . get ( TestClass . class , Value3 . class ) ) . toInstance ( new TestClass ( MyEnum . VALUE3 ) ) ; bind ( Key . get ( TestClass . class , Names . named ( " VALUE2 " ) ) ) . to ( TestClass . class ) . in ( TestSingleton . class ) ; bind ( new TypeLiteral < ParameterizedTestClass < Integer > > ( ) { } ) . in ( TestScope . SINGLETON ) ; bind ( new TypeLiteral < ParameterizedTestClass < Double > > ( ) { } ) . to ( ParameterizedTestClassDouble . class ) . in ( TestScope . SINGLETON ) ; bindNamedMock ( ClassWithUninstanciableDependency3 . class , " UninstanciableDependency3a " ) ; bind ( ClassWithUninstanciableDependency3 . class ) . annotatedWith ( Names . named ( " UninstanciableDependency3b " ) ) . toProvider ( MyMockProvider3b . class ) ; bind ( ClassWithUninstanciableDependency3 . class ) . annotatedWith ( Names . named ( " UninstanciableDependency3c " ) ) . toProvider ( Key . get ( MyMockProvider3c . class ) ) ; // TODO: Try to bind a mock logger once Issue 9 is solved.
protected void forceMock ( Class < ? > klass ) { forceMock . add ( klass ) ; }
private void addNeededKey ( Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded , Key < ? > keyNeeded ) { keysNeeded . add ( keyNeeded ) ; bindIfConcrete ( keysObserved , keyNeeded ) ; }
private void bindIfConcrete ( Set < Key < ? > > keysObserved , Key < ? > key ) { TypeLiteral < ? > parameter = key . getTypeLiteral ( ) ; Class < ? > rawType = parameter . getRawType ( ) ; if ( isInstantiable ( rawType ) & & ! shouldForceMock ( rawType ) & & ! isCoreGuiceType ( rawType ) & & ! isAssistedInjection ( key )
private boolean isAssistedInjection ( Key < ? > key ) { return key . getAnnotationType ( ) ! = null & & Assisted . class . isAssignableFrom ( key . getAnnotationType ( ) ) ;
private boolean shouldForceMock ( Class < ? > klass ) { if ( dontForceMock . contains ( klass ) ) { return false ; } if ( forceMock . contains ( klass ) ) { return true ; } // The forceMock set contains all the base classes the user wants // to force mock, check id the specified klass is a subclass of one of // these. // Update forceMock or dontForceMock based on the result to speed-up // future look-ups. boolean result = false; for (Class<?> classToMock : forceMock) { if (classToMock.isAssignableFrom(klass)) { result = true; break; } } if (result) { forceMock.add(klass); } else { dontForceMock.add(klass); } return result; }
private boolean isInstantiable ( Class < ? > klass ) { return ! klass . isInterface ( ) & & ! Modifier . isAbstract ( klass . getModifiers ( ) ) ;
private boolean isCoreGuiceType ( Class < ? > klass ) { return TypeLiteral . class . isAssignableFrom ( klass ) | | Injector . class . isAssignableFrom ( klass )
protected < T > LinkedBindingBuilder < T > bind ( Key < T > key ) { return new SpyLinkedBindingBuilder < T > ( newBindingObserved ( key ) , super . bind ( key ) ) ;
protected < T > AnnotatedBindingBuilder < T > bind ( TypeLiteral < T > typeLiteral ) { return new SpyAnnotatedBindingBuilder < T > ( newBindingObserved ( typeLiteral ) , super . bind ( typeLiteral ) ) ;
protected < T > AnnotatedBindingBuilder < T > bind ( Class < T > clazz ) { return new SpyAnnotatedBindingBuilder < T > ( newBindingObserved ( clazz ) , super . bind ( clazz ) ) ;
protected AnnotatedConstantBindingBuilder bindConstant ( ) { return new SpyAnnotatedConstantBindingBuilder ( newBindingObserved ( ) , super . bindConstant ( ) ) ;
private BindingInfo newBindingObserved ( Key < ? > key ) { BindingInfo bindingInfo = new BindingInfo ( ) ; bindingInfo . abstractType = key . getTypeLiteral ( ) ; bindingInfo . annotation = key . getAnnotation ( ) ; bindingInfo . annotationClass = key . getAnnotationType ( ) ; bindingsObserved . add ( bindingInfo ) ; return bindingInfo ; }
private BindingInfo newBindingObserved ( TypeLiteral < ? > typeLiteral ) { BindingInfo bindingInfo = new BindingInfo ( ) ; bindingInfo . abstractType = typeLiteral ; bindingsObserved . add ( bindingInfo ) ; return bindingInfo ; }
private BindingInfo newBindingObserved ( Class < ? > clazz ) { BindingInfo bindingInfo = new BindingInfo ( ) ; bindingInfo . abstractType = TypeLiteral . get ( clazz ) ; bindingsObserved . add ( bindingInfo ) ; return bindingInfo ; }
private BindingInfo newBindingObserved ( ) { BindingInfo bindingInfo = new BindingInfo ( ) ; bindingsObserved . add ( bindingInfo ) ; return bindingInfo ; }
private < T > void addDependencies ( Key < T > key , Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded ) { TypeLiteral < T > type = key . getTypeLiteral ( ) ; if ( ! isInstantiable ( type . getRawType ( ) ) ) { return ; } addInjectionPointDependencies ( InjectionPoint . forConstructorOf ( type ) , keysObserved , keysNeeded ) ; Set < InjectionPoint > methodsAndFieldsInjectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; for ( InjectionPoint injectionPoint : methodsAndFieldsInjectionPoints ) { addInjectionPointDependencies ( injectionPoint , keysObserved ,
private void addInjectionPointDependencies ( InjectionPoint injectionPoint , Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded ) { // Do not consider dependencies coming from optional injections if (injectionPoint.isOptional()) { return; } for (Dependency<?> dependency : injectionPoint.getDependencies()) { Key<?> key = dependency.getKey();
private void addKeyDependency ( Key < ? > key , Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded ) { Key < ? > newKey = key ; if ( Provider . class . isAssignableFrom ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { Type providedType = ( ( ParameterizedType ) key . getTypeLiteral ( ) . getType ( ) ) . getActualTypeArguments ( ) [ 0 ] ; if ( key . getAnnotation ( ) ! = null ) { newKey = Key . get ( providedType , key . getAnnotation ( ) ) ; } else if ( key . getAnnotationType ( ) ! = null ) { newKey = Key . get ( providedType , key . getAnnotationType ( ) ) ; } else { newKey = Key . get ( providedType ) ; } } bindIfConcrete ( keysObserved , newKey ) ; keysNeeded . add ( newKey ) ; }
public ScopedBindingBuilder to ( Class < ? extends T > type ) { bindingInfo . boundType = TypeLiteral . get ( type ) ; return delegate . to ( type ) ; }
public ScopedBindingBuilder to ( TypeLiteral < ? extends T > type ) { bindingInfo . boundType = type ; return delegate . to ( type ) ; }
public ScopedBindingBuilder to ( Key < ? extends T > key ) { bindingInfo . boundType = key . getTypeLiteral ( ) ; return delegate . to ( key ) ; }
public void toInstance ( T instance ) { // Binding to an instance, class cannot be injected bindingInfo.isBoundToInstanceOrMock = true; delegate.toInstance(instance); }
public ScopedBindingBuilder toProvider ( Provider < ? extends T > provider ) { Class < ? > providerClass = provider . getClass ( ) ; if ( SpyProvider . class . isAssignableFrom ( providerClass ) ) { // For a SpyProvider, consider all the dependencies of the class // spied upon bindingInfo.boundType = bindingInfo.abstractType; } else if (AssistedInjectHelper.isFactory(providerClass)) { // For an assisted factory, consider all the dependencies of the // class generated upon bindingInfo.boundType = AssistedInjectHelper .getProvidedType(provider); } else { bindingInfo.isBoundToInstanceOrMock = true; } return delegate.toProvider(provider); }
public ScopedBindingBuilder toProvider ( Class < ? extends Provider < ? extends T > > providerClass ) { bindingInfo . boundType = TypeLiteral . get ( providerClass ) ; return delegate . toProvider ( providerClass ) ; }
public ScopedBindingBuilder toProvider ( Key < ? extends Provider < ? extends T > > key ) { bindingInfo . boundType = key . getTypeLiteral ( ) ; return delegate . toProvider ( key ) ; }
public void asEagerSingleton ( ) { delegate . asEagerSingleton ( ) ; }
public void in ( Class < ? extends Annotation > annotation ) { delegate . in ( annotation ) ; }
public LinkedBindingBuilder < T > annotatedWith ( Class < ? extends Annotation > annotationClass ) { bindingInfo . annotationClass = annotationClass ; return new SpyLinkedBindingBuilder < T > ( bindingInfo , delegate . annotatedWith ( annotationClass ) ) ;
public LinkedBindingBuilder < T > annotatedWith ( Annotation annotation ) { bindingInfo . annotation = annotation ; return new SpyLinkedBindingBuilder < T > ( bindingInfo , delegate . annotatedWith ( annotation ) ) ;
public ConstantBindingBuilder annotatedWith ( Class < ? extends Annotation > annotationClass ) { bindingInfo . annotationClass = annotationClass ; return new SpyConstantBindingBuilder ( bindingInfo , delegate . annotatedWith ( annotationClass ) ) ;
public ConstantBindingBuilder annotatedWith ( Annotation annotation ) { bindingInfo . annotation = annotation ; return new SpyConstantBindingBuilder ( bindingInfo , delegate . annotatedWith ( annotation ) ) ;
public void to ( String constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( constant . getClass ( ) ) ; }
public void to ( int constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Integer . class ) ; }
public void to ( long constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Long . class ) ; }
public void to ( boolean constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Boolean . class ) ; }
public void to ( double constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Double . class ) ; }
public void to ( float constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Float . class ) ; }
public void to ( short constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Short . class ) ; }
public void to ( char constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Character . class ) ; }
public void to ( Class < ? > constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( Class . class ) ; }
public < E extends Enum < E > > void to ( E constant ) { delegate . to ( constant ) ; bindingInfo . abstractType = TypeLiteral . get ( constant . getClass ( ) ) ; }
private void bindIfConcrete ( Set < Key < ? > > keysObserved , Key < ? > key ) { TypeLiteral < ? > parameter = key . getTypeLiteral ( ) ; Class < ? > rawType = parameter . getRawType ( ) ; if ( isInstantiable ( rawType ) & & ! shouldForceMock ( rawType ) & & ! isCoreGuiceType ( rawType ) & & ! isAssistedInjection ( key )
private boolean isAssistedInjection ( Key < ? > key ) { return key . getAnnotationType ( ) ! = null & & Assisted . class . isAssignableFrom ( key . getAnnotationType ( ) ) ;
private boolean shouldForceMock ( Class < ? > klass ) { if ( dontForceMock . contains ( klass ) ) { return false ; } if ( forceMock . contains ( klass ) ) { return true ; } // The forceMock set contains all the base classes the user wants // to force mock, check id the specified klass is a subclass of one of // these. // Update forceMock or dontForceMock based on the result to speed-up // future look-ups. boolean result = false; for (Class<?> classToMock : forceMock) { if (classToMock.isAssignableFrom(klass)) { result = true; break; } } if (result) { forceMock.add(klass); } else { dontForceMock.add(klass); } return result; }
private boolean isCoreGuiceType ( Class < ? > klass ) { return TypeLiteral . class . isAssignableFrom ( klass ) | | Injector . class . isAssignableFrom ( klass )
protected < T > LinkedBindingBuilder < T > bind ( Key < T > key ) { return new SpyLinkedBindingBuilder < T > ( newBindingObserved ( key ) , super . bind ( key ) ) ;
protected < T > AnnotatedBindingBuilder < T > bind ( TypeLiteral < T > typeLiteral ) { return new SpyAnnotatedBindingBuilder < T > ( newBindingObserved ( typeLiteral ) , super . bind ( typeLiteral ) ) ;
protected < T > AnnotatedBindingBuilder < T > bind ( Class < T > clazz ) { return new SpyAnnotatedBindingBuilder < T > ( newBindingObserved ( clazz ) , super . bind ( clazz ) ) ;
protected AnnotatedConstantBindingBuilder bindConstant ( ) { return new SpyAnnotatedConstantBindingBuilder ( newBindingObserved ( ) , super . bindConstant ( ) ) ;
private < T > void addDependencies ( Key < T > key , Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded ) { TypeLiteral < T > type = key . getTypeLiteral ( ) ; if ( ! isInstantiable ( type . getRawType ( ) ) ) { return ; } addInjectionPointDependencies ( InjectionPoint . forConstructorOf ( type ) , keysObserved , keysNeeded ) ; Set < InjectionPoint > methodsAndFieldsInjectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; for ( InjectionPoint injectionPoint : methodsAndFieldsInjectionPoints ) { addInjectionPointDependencies ( injectionPoint , keysObserved , keysNeeded ) ;
private void addInjectionPointDependencies ( InjectionPoint injectionPoint , Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded ) { // Do not consider dependencies coming from optional injections if (injectionPoint.isOptional()) { return; } for (Dependency<?> dependency : injectionPoint.getDependencies()) { Key<?> key = dependency.getKey();
private void addKeyDependency ( Key < ? > key , Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded ) { Key < ? > newKey = key ; if ( Provider . class . isAssignableFrom ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { Type providedType = ( ( ParameterizedType ) key . getTypeLiteral ( ) . getType ( ) ) . getActualTypeArguments ( ) [ 0 ] ; if ( key . getAnnotation ( ) ! = null ) { newKey = Key . get ( providedType , key . getAnnotation ( ) ) ; } else if ( key . getAnnotationType ( ) ! = null ) { newKey = Key . get ( providedType , key . getAnnotationType ( ) ) ; } else { newKey = Key . get ( providedType ) ; } } bindIfConcrete ( keysObserved , newKey ) ; keysNeeded . add ( newKey ) ; }
public ScopedBindingBuilder toProvider ( Provider < ? extends T > provider ) { Class < ? > providerClass = provider . getClass ( ) ; if ( SpyProvider . class . isAssignableFrom ( providerClass ) ) { // For a SpyProvider, consider all the dependencies of the class // spied upon bindingInfo.boundType = bindingInfo.abstractType; } else if (AssistedInjectHelper.isFactory(providerClass)) { // For an assisted factory, consider all the dependencies of the // class generated upon bindingInfo.boundType = AssistedInjectHelper.getProvidedType(provider); } else { bindingInfo.isBoundToInstanceOrMock = true; } return delegate.toProvider(provider); }
public void in ( Scope scope ) { delegate . in ( scope ) ; }
public LinkedBindingBuilder < T > annotatedWith ( Class < ? extends Annotation > annotationClass ) { bindingInfo . annotationClass = annotationClass ; return new SpyLinkedBindingBuilder < T > ( bindingInfo , delegate . annotatedWith ( annotationClass ) ) ;
public LinkedBindingBuilder < T > annotatedWith ( Annotation annotation ) { bindingInfo . annotation = annotation ; return new SpyLinkedBindingBuilder < T > ( bindingInfo , delegate . annotatedWith ( annotation ) ) ;
public ConstantBindingBuilder annotatedWith ( Class < ? extends Annotation > annotationClass ) { bindingInfo . annotationClass = annotationClass ; return new SpyConstantBindingBuilder ( bindingInfo , delegate . annotatedWith ( annotationClass ) ) ;
public ConstantBindingBuilder annotatedWith ( Annotation annotation ) { bindingInfo . annotation = annotation ; return new SpyConstantBindingBuilder ( bindingInfo , delegate . annotatedWith ( annotation ) ) ;
public void collectBindings ( ) { GuiceElementVisitor visitor = new GuiceElementVisitor ( ) ; visitor . visitElements ( Elements . getElements ( module ) ) ;
public List < BindingInfo > getBindingsObserved ( ) { return bindingsObserved ; }
private void visitElements ( List < Element > elements ) { for ( Element element : elements ) { element . acceptVisitor ( this ) ;
public < T > Void visit ( com . google . inject . Binding < T > command ) { GuiceBindingVisitor < T > bindingVisitor = new GuiceBindingVisitor < T > ( ) ; command . acceptTargetVisitor ( bindingVisitor ) ; return null ; }
public Void visit ( Message message ) { messages . add ( message ) ; return null ; }
public Void visit ( ProviderBinding < ? extends T > providerBinding ) { BindingInfo binding = new BindingInfo ( ) ; binding . key = providerBinding . getKey ( ) ; binding . boundKey = providerBinding . getProvidedKey ( ) ; bindingsObserved . add ( binding ) ; return null ; }
public Void visit ( ProviderKeyBinding < ? extends T > providerKeyBinding ) { BindingInfo binding = new BindingInfo ( ) ; binding . key = providerKeyBinding . getKey ( ) ; binding . boundKey = providerKeyBinding . getProviderKey ( ) ; bindingsObserved . add ( binding ) ; return null ; }
public Void visit ( ProviderInstanceBinding < ? extends T > providerInstanceBinding ) { BindingInfo binding = new BindingInfo ( ) ; binding . key = providerInstanceBinding . getKey ( ) ; binding . boundInstance = providerInstanceBinding . getProviderInstance ( ) ; bindingsObserved . add ( binding ) ; return null ; }
public Void visit ( InstanceBinding < ? extends T > instanceBinding ) { BindingInfo binding = new BindingInfo ( ) ; binding . key = instanceBinding . getKey ( ) ; binding . boundInstance = instanceBinding . getInstance ( ) ; bindingsObserved . add ( binding ) ; return null ; }
public Void visit ( ConvertedConstantBinding < ? extends T > constantBinding ) { BindingInfo binding = new BindingInfo ( ) ; binding . key = constantBinding . getKey ( ) ; binding . boundInstance = constantBinding . getValue ( ) ; bindingsObserved . add ( binding ) ; return null ; }
public Void visit ( UntargettedBinding < ? extends T > untargettedBinding ) { BindingInfo binding = new BindingInfo ( ) ; binding . key = untargettedBinding . getKey ( ) ; binding . boundKey = untargettedBinding . getKey ( ) ; bindingsObserved . add ( binding ) ; return null ; }
public Void visit ( LinkedKeyBinding < ? extends T > linkedKeyBinding ) { BindingInfo binding = new BindingInfo ( ) ; binding . key = linkedKeyBinding . getKey ( ) ; binding . boundKey = linkedKeyBinding . getLinkedKey ( ) ; bindingsObserved . add ( binding ) ; return null ; }
public void setBindingsObserved ( List < BindingInfo > bindingsObserved ) { this . bindingsObserved = bindingsObserved ; }
private void addNeededKey ( Set < Key < ? > > keysObserved , Set < Key < ? > > keysNeeded , Key < ? > keyNeeded , boolean asTestSingleton ) { keysNeeded . add ( keyNeeded ) ; bindIfConcrete ( keysObserved , keyNeeded , asTestSingleton ) ; }
private void bindIfConcrete ( Set < Key < ? > > keysObserved , Key < ? > key , boolean asTestSingleton ) { TypeLiteral < ? > parameter = key . getTypeLiteral ( ) ; Class < ? > rawType = parameter . getRawType ( ) ; if ( isInstantiable ( rawType ) & & ! shouldForceMock ( rawType ) & & ! isCoreGuiceType ( rawType ) & & ! isAssistedInjection ( key )
public static void main ( String [ ] args ) { System . out . println ( " Hello World! " ) ; }
public static Test suite ( ) { return new TestSuite ( AppTest . class ) ; }
public void testApp ( ) { assertTrue ( true ) ; }
public String getName ( ) { return name ; }
public String getAlpha2 ( ) { return name ( ) ; }
public String getAlpha3 ( ) { return alpha3 ; }
public static CountryCode getByCode ( String code ) { if ( code = = null ) { return null ; } switch ( code . length ( ) ) {
private static CountryCode getByAlpha2Code ( String code ) { try {
private static CountryCode getByAlpha3Code ( String code ) { return alpha3Map . get ( code ) ; }
public static CountryCode getByCode ( final String code ) { if ( code = = null ) { return null ; } switch ( code . length ( ) ) {
private static CountryCode getByAlpha2Code ( final String code ) { try {
private static CountryCode getByAlpha3Code ( final String code ) { return alpha3Map . get ( code ) ; }
private static Iban valueOf ( String value ) { return null ; }
public boolean equals ( Object obj ) { if ( obj instanceof Integer ) { return value . equals ( ( ( Iban ) obj ) . toString ( ) ) ; } return false ; }
public int hashCode ( ) { return value . hashCode ( ) ; }
private void resolve ( String propertyFileName ) throws IOException { InputStream is = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( propertyFileName ) ; properties = new Properties ( ) ; properties . load ( is ) ; }
public String getProperty ( String key ) { return properties . getProperty ( key ) ; }
public int getIntProperty ( String key ) throws NumberFormatException { String value = properties . getProperty ( key ) ; return Integer . parseInt ( value ) ; }
public String [ ] getProperties ( String key ) { String value = properties . getProperty ( key ) ; return value . split ( " [,] " ) ; }
public String getProperty ( String key ) ; public int getIntProperty ( String key ) throws NumberFormatException ; public String [ ] getProperties ( String key ) ; }
public int getIntProperty ( String key ) throws NumberFormatException ; public String [ ] getProperties ( String key ) ; }
public void testGetProperty ( ) throws Exception { } @Test public void testGetIntProperty ( ) throws Exception { } @Test public void testGetProperties ( ) throws Exception { } }
public void testGetIntProperty ( ) throws Exception { } @Test public void testGetProperties ( ) throws Exception { } }
public void testGetProperties ( ) throws Exception { } }
public String getAlpha2 ( ) { return name ( ) ; }
public String getAlpha3 ( ) { return alpha3 ; }
public static CountryCode getByCode ( final String code ) { if ( code = = null ) { return null ; } switch ( code . length ( ) ) { case 2 :
private static CountryCode getByAlpha2Code ( final String code ) { try { return Enum . valueOf ( CountryCode . class , code ) ;
private static CountryCode getByAlpha3Code ( final String code ) { return alpha3Map . get ( code ) ; }
public String getStructure ( CountryCode countryCode ) { return null ; }
public void getByCodeWithAlpha2CodeShouldReturnCountry ( ) { for ( CountryCode code : CountryCode . values ( ) ) { CountryCode newCode = CountryCode . getByCode ( code . getAlpha2 ( ) ) ;
public void getByCodeWithAlpha3CodeShouldReturnCountryCode ( ) { for ( CountryCode code : CountryCode . values ( ) ) { CountryCode newCode = CountryCode . getByCode ( code . getAlpha3 ( ) ) ;
public void getByCodeWithNullCodeShouldReturnNull ( ) { CountryCode code = CountryCode . getByCode ( null ) ; assertThat ( code , is ( nullValue ( ) ) ) ; }
public void getByCodeWith4DigitCodeShouldReturnNull ( ) { CountryCode code = CountryCode . getByCode ( " XXXX " ) ; assertThat ( code , is ( nullValue ( ) ) ) ; }
public void getByCodeWithWrongAlpha2CodeShouldReturnNull ( ) { CountryCode code = CountryCode . getByCode ( " XX " ) ; assertThat ( code , is ( nullValue ( ) ) ) ; }
public void getByCodeWithWrongAlpha3CodeShouldReturnNull ( ) { CountryCode code = CountryCode . getByCode ( " XXX " ) ; assertThat ( code , is ( nullValue ( ) ) ) ; }
public void getNameWithDECodeShouldReturnGermany ( ) { assertThat ( " Germany " , is ( equalTo ( CountryCode . DE . getName ( ) ) ) ) ; }
public void getAlpha2WithDECodeShouldReturnGermany ( ) { assertThat ( " DE " , is ( equalTo ( CountryCode . DE . getAlpha2 ( ) ) ) ) ; }
public void getAlpha3WithDECodeShouldReturnGermany ( ) { assertThat ( " DEU " , is ( equalTo ( CountryCode . DE . getAlpha3 ( ) ) ) ) ; }
IbanStructure getStructure ( CountryCode countryCode ) ; }
public static IbanStructure valueOf ( String structure ) throws IllegalArgumentException { // TODO add parsing logic return new IbanStructure(); }
public IbanStructure getStructure ( CountryCode countryCode ) { String key = countryCode . getAlpha2 ( ) . toLowerCase ( ) + IBAN_STRUCTURE_SUFFIX ; String structure = propertyResolver . getProperty ( key ) ; return IbanStructure . valueOf ( structure ) ; }
String getProperty ( String key ) ; int getIntProperty ( String key ) throws NumberFormatException ; String [ ] getProperties ( String key ) ; }
int getIntProperty ( String key ) throws NumberFormatException ; String [ ] getProperties ( String key ) ; }
public void getByCodeWithLowerCaseAlpha2CodeShouldReturnCountry ( ) { for ( CountryCode code : CountryCode . values ( ) ) { CountryCode newCode = CountryCode . getByCode ( code . getAlpha2 ( ) . toLowerCase ( ) ) ;
public void getByCodeWithUpperCaseAlpha2CodeShouldReturnCountry ( ) { for ( CountryCode code : CountryCode . values ( ) ) { CountryCode newCode = CountryCode . getByCode ( code . getAlpha2 ( ) . toUpperCase ( ) ) ;
public void getByCodeWithLowerCaseAlpha3CodeShouldReturnCountry ( ) { for ( CountryCode code : CountryCode . values ( ) ) { CountryCode newCode = CountryCode . getByCode ( code . getAlpha3 ( ) . toLowerCase ( ) ) ;
public void getByCodeWithUpperCaseAlpha3CodeShouldReturnCountry ( ) { for ( CountryCode code : CountryCode . values ( ) ) { CountryCode newCode = CountryCode . getByCode ( code . getAlpha3 ( ) . toUpperCase ( ) ) ;
public void getNameWithDECodeShouldReturnGermany ( ) { assertThat ( CountryCode . DE . getName ( ) , is ( equalTo ( " Germany " ) ) ) ; }
public void getAlpha2WithDECodeShouldReturnGermany ( ) { assertThat ( CountryCode . DE . getAlpha2 ( ) , is ( equalTo ( " DE " ) ) ) ; }
public void getAlpha3WithDECodeShouldReturnGermany ( ) { assertThat ( CountryCode . DE . getAlpha3 ( ) , is ( equalTo ( " DEU " ) ) ) ; }
public static IbanStructure valueOf ( final String structure ) throws IllegalArgumentException { return parseStructure ( structure ) ; }
public boolean hasEntry ( final IbanStructureEntry . EntryType entryType ) { return entries . containsKey ( entryType ) ; }
public Collection < IbanStructureEntry > getEntries ( ) { return entries . values ( ) ; }
public IbanStructureEntry getEntry ( final IbanStructureEntry . EntryType entryType ) { return entries . get ( entryType ) ; }
private static IbanStructure parseStructure ( final String structure ) throws IllegalArgumentException { Map < IbanStructureEntry . EntryType , IbanStructureEntry > entries = new HashMap < IbanStructureEntry . EntryType , IbanStructureEntry > ( ) ; try { String [ ] entriesStr = structure . split ( " " ) ; for ( String entryStr : entriesStr ) { IbanStructureEntry entry = parseStructureEntry ( entryStr ) ; entries . put ( entry . getEntryType ( ) , entry ) ; } } catch ( Exception e ) { throw new IllegalArgumentException ( " Invalid IBAN Structure is passed: " + structure , e ) ; } return new IbanStructure ( entries ) ; }
private static IbanStructureEntry parseStructureEntry ( final String entry ) { String [ ] parts = entry . split ( " ! " ) ; IbanStructureEntry . EntryCharacterType characterType = parseCharacterType ( parts [ 1 ] ) ; IbanStructureEntry . EntryType entryType = parseEntryType ( parts [ 0 ] ) ; int length = parseEntryLength ( parts [ 0 ] ) ; return new IbanStructureEntry ( entryType , characterType , length ) ; }
private static IbanStructureEntry . EntryCharacterType parseCharacterType ( final String type ) { return IbanStructureEntry . EntryCharacterType . valueOf ( type ) ; }
private static IbanStructureEntry . EntryType parseEntryType ( final String entry ) { String structureEntryStr = entry . substring ( entry . length ( ) - 1 ) ; return IbanStructureEntry . EntryType . valueOf ( structureEntryStr ) ; }
private static int parseEntryLength ( final String entry ) { String lengthStr = entry . substring ( 0 , entry . length ( ) - 1 ) ; return Integer . valueOf ( lengthStr ) ; }
public EntryType getEntryType ( ) { return entryType ; }
public EntryCharacterType getCharacterType ( ) { return characterType ; }
private static IbanStructure parseStructure ( final String structure ) throws IllegalArgumentException { Map < IbanStructureEntry . EntryType , IbanStructureEntry > entries = new HashMap < IbanStructureEntry . EntryType , IbanStructureEntry > ( ) ; try { String [ ] entriesStr = structure . split ( " " ) ; for ( String entryStr : entriesStr ) { IbanStructureEntry entry = parseStructureEntry ( entryStr ) ; entries . put ( entry . getEntryType ( ) , entry ) ; } } catch ( Exception e ) { throw new IllegalArgumentException ( " Invalid IBAN Structure is passed: " + structure , e ) ; } return new IbanStructure ( entries , structure ) ; }
public String toString ( ) { return " IbanStructure{ " + " rawStructure=' " + rawStructure + '\'' +
public static Properties loadProperties ( String path ) throws IOException { Properties properties = new Properties ( ) ; InputStream is = PropertiesLoaderUtils . class . getClassLoader ( ) . getResourceAsStream ( path ) ; try { properties . load ( is ) ; } finally { is . close ( ) ; } return properties ;
static CheckDigit calculateCheckDigit ( String iban ) { int modResult = calculateMod ( iban ) ; int checkDigitIntValue = ( 98 - modResult ) ; String checkDigit = Integer . toString ( checkDigitIntValue ) ; return new CheckDigit ( checkDigitIntValue > 9 ? checkDigit : " 0 " + checkDigit ) ; }
private static int calculateMod ( String iban ) { String reformattedIban = iban . substring ( 4 ) + iban . substring ( 0 , 4 ) ; long total = 0 ; for ( int i = 0 ; i < reformattedIban . length ( ) ; i + + ) { int numericValue = Character . getNumericValue ( reformattedIban . charAt ( i ) ) ; if ( numericValue < 0 | | numericValue > 35 ) { throw new IllegalArgumentException ( " Invalid Character[ " + i + " ] = ' " + numericValue + " ' " ) ; } total = ( numericValue > 9 ? total * 100 : total * 10 ) + numericValue ; if ( total > MAX ) { total = ( total % MOD ) ; } } return ( int ) ( total % MOD ) ; }
public String toString ( ) { return " Bban{ " + " value=' " + value + '\'' +
public String toString ( ) { return " OwnerAccountType{ " + " value=' " + value + '\'' +
public String toString ( ) { return " AccountNumber{ " + " value=' " + value + '\'' +
public String toString ( ) { return " AccountType{ " + " value=' " + value + '\'' +
public String toString ( ) { return " BankCode{ " + " value=' " + value + '\'' +
public String toString ( ) { return " BranchCode{ " + " value=' " + value + '\'' +
public String toString ( ) { return " CheckDigit{ " + " value=' " + value + '\'' +
public boolean equals ( Object obj ) { if ( obj instanceof Iban ) { return value . equals ( ( ( Iban ) obj ) . value ) ; } return false ; }
public String toString ( ) { return " NationalCheckDigit{ " + " value=' " + value + '\'' +
private static IbanStructure parseStructure ( final String structure ) throws IllegalArgumentException { Map < IbanStructureEntry . EntryType , IbanStructureEntry > entries = new HashMap < IbanStructureEntry . EntryType , IbanStructureEntry > ( ) ; try { String [ ] entriesStr = structure . split ( ENTRY_SPLITTER ) ; for ( String entryStr : entriesStr ) { IbanStructureEntry entry = parseStructureEntry ( entryStr ) ; entries . put ( entry . getEntryType ( ) , entry ) ; } } catch ( Exception e ) { throw new IllegalArgumentException ( " Invalid IBAN Structure is passed: " + structure , e ) ; } return new IbanStructure ( entries , structure ) ; }
private static IbanStructureEntry parseStructureEntry ( final String entry ) { String [ ] parts = entry . split ( CHARACTER_TYPE_SPLITTER ) ; IbanStructureEntry . EntryCharacterType characterType = parseCharacterType ( parts [ 1 ] ) ; String entryDefaultValue = null ; if ( hasDefaultValue ( parts [ 0 ] ) ) { String [ ] valueParts = parts [ 0 ] . split ( DEFAULT_VALUE_SPLITTER ) ; entryDefaultValue = parts [ 1 ] ; parts [ 0 ] = valueParts [ 0 ] ; } IbanStructureEntry . EntryType entryType = parseEntryType ( parts [ 0 ] ) ; int length = parseEntryLength ( parts [ 0 ] ) ; return new IbanStructureEntry ( entryType , characterType , length , entryDefaultValue ) ; }
private static boolean hasDefaultValue ( final String entry ) { return entry . contains ( DEFAULT_VALUE_SPLITTER ) ; }
public String getDefaultValue ( ) { return defaultValue ; }
public boolean hasDefaultValue ( ) { return defaultValue ! = null ; }
public String toString ( ) { return " TODO " ; }
public Builder bankCode ( String bankCode ) { this . bankCode = bankCode ; return this ; }
public Builder branchCode ( String branchCode ) { this . branchCode = branchCode ; return this ; }
public Builder nationalCheckDigit ( String nationalCheckDigit ) { this . nationalCheckDigit = nationalCheckDigit ; return this ; }
public Builder accountType ( String accountType ) { this . accountType = accountType ; return this ; }
public Builder ownerAccountType ( String ownerAccountType ) { this . ownerAccountType = ownerAccountType ; return this ; }
public Builder accountNumber ( String accountNumber ) { this . accountNumber = accountNumber ; return this ; }
public Bban build ( ) { return new Bban ( this ) ; }
public Iban generate ( String accountNumber ) throws IllegalStateException { if ( configuration = = null ) { configure ( ) ; } IbanStructure structure = configuration . getStructure ( coutryCode ) ; Bban bban = constructBban ( structure ) ; String checkDigit = IbanUtil . calculateCheckDigit ( new Iban ( coutryCode , DEFAULT_CHECK_DIGIT , bban ) ) ; return new Iban ( coutryCode , checkDigit , bban ) ; }
private Bban constructBban ( IbanStructure structure ) { return null ; //To change body of created methods use File | Settings | File Templates. }
private String constructIbanString ( IbanStructure structure , String checkDigit ) { // TODO implement return "testtodo"; }
public void setCountryCode ( CountryCode countryCode ) { this . coutryCode = countryCode ; }
public void setBankCode ( String bankCode ) { this . bankCode = bankCode ; }
protected void setConfiguration ( IbanConfiguration configuration ) { this . configuration = configuration ; }
private void configure ( ) throws IllegalStateException { Properties properties = null ; try { properties = PropertiesLoaderUtils . loadProperties ( DEFAULT_PROPERTIES_FILE ) ; } catch ( IOException e ) { throw new IllegalStateException ( " Can not configure IbanGenerator " , e ) ; } configuration = new PropertyBasedIbanConfiguration ( properties ) ; }
public static void main ( String [ ] args ) { DefaultIbanGenerator generator = new DefaultIbanGenerator ( ) ; generator . setCountryCode ( CountryCode . AT ) ; generator . setBankCode ( " 19043 " ) ; Iban iban = generator . generate ( " 00234573201 " ) ; System . out . println ( iban ) ; }
public CountryCode getCountryCode ( ) { return countryCode ; }
public String getCheckDigit ( ) { return checkDigit ; }
public String toString ( ) { return new StringBuilder ( ) . append ( countryCode . name ( ) )
static String calculateCheckDigit ( Iban iban ) { return calculateCheckDigit ( iban . toString ( ) ) ; }
private static String calculateCheckDigit ( String iban ) { int modResult = calculateMod ( iban ) ; int checkDigitIntValue = ( 98 - modResult ) ; String checkDigit = Integer . toString ( checkDigitIntValue ) ; return checkDigitIntValue > 9 ? checkDigit : " 0 " + checkDigit ; }
public String format ( CountryCode countryCode ) { StringBuilder sb = new StringBuilder ( ) ; IbanStructure structure = IbanStructureCache . getStructure ( countryCode ) ; for ( IbanStructureEntry entry : structure . getBbanEntries ( ) ) { switch ( entry . getEntryType ( ) ) { case k : break ; case b : sb . append ( bankCode ) ; break ; case s : sb . append ( branchCode ) ; break ; case c : sb . append ( accountNumber ) ; break ; case x : sb . append ( nationalCheckDigit ) ; break ; case t : sb . append ( accountType ) ; break ; case n : sb . append ( ownerAccountType ) ; break ; } } return sb . toString ( ) ; }
public static Iban valueOf ( ) throws IbanFormatException { return null ; }
public static void main ( String [ ] args ) { Bban bban = new Bban . Builder ( ) . bankCode ( " 19043 " ) . accountNumber ( " 00234573201 " ) . build ( ) ; Iban iban = new Iban ( CountryCode . AT , bban ) ; System . out . println ( iban ) ; bban = new Bban . Builder ( ) . bankCode ( " 0002 " ) . branchCode ( " 0123 " ) . accountNumber ( " 12345678901 " ) . nationalCheckDigit ( " 54 " ) . build ( ) ; iban = new Iban ( CountryCode . PT , bban ) ; System . out . println ( iban ) ; }
public static String calculateCheckDigit ( Iban iban ) { return calculateCheckDigit ( iban . getCountryCode ( ) , iban . getBban ( ) ) ; }
public static String calculateCheckDigit ( CountryCode countryCode , Bban bban ) { StringBuilder sb = new StringBuilder ( ) . append ( countryCode . name ( ) ) . append ( DEFAULT_CHECK_DIGIT ) . append ( bban . format ( countryCode ) ) ; return calculateCheckDigit ( sb . toString ( ) ) ; }
public boolean hasEntry ( final IbanStructureEntry . EntryType entryType ) { return entries . containsKey ( entryType . name ( ) ) ; }
public List < IbanStructureEntry > getEntries ( ) { return Collections . unmodifiableList ( new LinkedList < IbanStructureEntry > ( entries . values ( ) ) ) ; }
public Collection < IbanStructureEntry > getBbanEntries ( ) { LinkedList < IbanStructureEntry > tmpEntries = new LinkedList < IbanStructureEntry > ( entries . values ( ) ) ; return Collections . unmodifiableList ( tmpEntries . subList ( 1 , tmpEntries . size ( ) ) ) ; }
public IbanStructureEntry getEntry ( final IbanStructureEntry . EntryType entryType ) { return entries . get ( entryType . name ( ) ) ; }
public String getEntryDefaultValue ( final IbanStructureEntry . EntryType entryType ) { return entries . get ( entryType . name ( ) ) . getDefaultValue ( ) ; }
private static IbanStructure parseStructure ( final String structure ) throws IllegalArgumentException { Map < String , IbanStructureEntry > entries = new LinkedHashMap < String , IbanStructureEntry > ( ) ; try { String [ ] entriesStr = structure . split ( ENTRY_SPLITTER ) ; for ( String entryStr : entriesStr ) { IbanStructureEntry entry = parseStructureEntry ( entryStr ) ; entries . put ( entry . getEntryType ( ) . name ( ) , entry ) ; } } catch ( Exception e ) { throw new IllegalArgumentException ( " Invalid IBAN Structure is passed: " + structure , e ) ; } return new IbanStructure ( entries , structure ) ; }
private static IbanConfiguration doConfigure ( ) throws IllegalStateException { Properties properties = null ; try { properties = PropertiesLoaderUtils . loadProperties ( DEFAULT_PROPERTIES_FILE ) ; } catch ( IOException e ) { throw new IllegalStateException ( " Can not find configuration file " , e ) ; } return new PropertyBasedIbanConfiguration ( properties ) ; }
public static IbanStructure getStructure ( CountryCode countryCode ) { return configuration . getStructure ( countryCode ) ; }
public String toString ( ) { return " Bban{ " + " bankCode=' " + bankCode + '\'' +
public static Iban valueOf ( ) throws IbanFormatException { // TODO implement return null; }
private static IbanConfiguration doConfigure ( ) throws IllegalStateException { Properties properties = null ; try { properties = PropertiesLoaderUtils . loadProperties ( DEFAULT_PROPERTIES_FILE ) ; } catch ( IOException e ) { throw new IllegalStateException ( " Can not find configuration file " , e ) ; } return new IbanConfiguration ( properties ) ; }
static Properties loadProperties ( String path ) throws IOException { Properties properties = new Properties ( ) ; InputStream is = PropertiesLoaderUtils . class . getClassLoader ( ) . getResourceAsStream ( path ) ; try { properties . load ( is ) ; } finally { is . close ( ) ; } return properties ;
public String format ( CountryCode countryCode ) { IbanStructure structure = IbanStructureCache . getStructure ( countryCode . getAlpha2 ( ) ) ; return format ( structure ) ; }
protected String format ( IbanStructure structure ) { StringBuilder sb = new StringBuilder ( ) ; for ( IbanStructureEntry entry : structure . getBbanEntries ( ) ) { switch ( entry . getEntryType ( ) ) { case k : break ; case b : sb . append ( bankCode ) ; break ; case s : sb . append ( branchCode ) ; break ; case c : sb . append ( accountNumber ) ; break ; case x : sb . append ( nationalCheckDigit ) ; break ; case t : sb . append ( accountType ) ; break ; case n : sb . append ( ownerAccountType ) ; break ; } } return sb . toString ( ) ; }
public IbanStructure getStructure ( String countryCode ) { String key = countryCode . toLowerCase ( ) + IBAN_STRUCTURE_SUFFIX ; String structure = propertyResolver . getProperty ( key ) ; return IbanStructure . valueOf ( structure ) ; }
public static IbanStructure getStructure ( String countryCode ) { return configuration . getStructure ( countryCode ) ; }
private static IbanConfiguration doConfigure ( ) throws IllegalStateException { Properties properties = null ; try { properties = PropertiesLoaderUtil . loadProperties ( DEFAULT_PROPERTIES_FILE ) ; } catch ( IOException e ) { throw new IllegalStateException ( " Can not find configuration file " , e ) ; } return new IbanConfiguration ( properties ) ; }
static Properties loadProperties ( String path ) throws IOException { Properties properties = new Properties ( ) ; InputStream is = PropertiesLoaderUtil . class . getClassLoader ( ) . getResourceAsStream ( path ) ; try { properties . load ( is ) ; } finally { is . close ( ) ; } return properties ;
protected String format ( IbanStructure structure ) { StringBuilder sb = new StringBuilder ( ) ; for ( IbanStructureEntry entry : structure . getBbanEntries ( ) ) { switch ( entry . getEntryType ( ) ) { case k : break ; case b : sb . append ( bankCode ) ; break ; case s : sb . append ( branchCode ) ; break ; case c : sb . append ( accountNumber ) ; break ; case x : sb . append ( nationalCheckDigit ) ; break ; case t : sb . append ( accountType ) ; break ; case n : sb . append ( ownerAccountType ) ; break ; case i : sb . append ( identificationNumber ) ; break ; } } return sb . toString ( ) ; }
public Builder identificationNumber ( String identificationNumber ) { this . identificationNumber = identificationNumber ; return this ; }
public static void main ( String [ ] args ) { Bban bban = new Bban . Builder ( ) . bankCode ( " 19043 " ) . accountNumber ( " 00234573201 " ) . build ( ) ; Iban iban = new Iban ( CountryCode . AT , bban ) ; System . out . println ( iban ) ; bban = new Bban . Builder ( ) . bankCode ( " 0002 " ) . branchCode ( " 0123 " ) . accountNumber ( " 12345678901 " ) . nationalCheckDigit ( " 54 " ) . build ( ) ; iban = new Iban ( CountryCode . PT , bban ) ; System . out . println ( iban ) ; bban = new Bban . Builder ( ) . bankCode ( " 0159 " ) . branchCode ( " 26 " ) . accountNumber ( " 007654 " ) . identificationNumber ( " 5510730339 " ) . build ( ) ; iban = new Iban ( CountryCode . IS , bban ) ; System . out . println ( iban ) ; }
public void ibanConstructionWithSupportedCountriesShouldReturnIban ( ) { Iban iban = new Iban ( countryCode , bban ) ; assertThat ( iban . toString ( ) , is ( equalTo ( expectedIbanString ) ) ) ; }
public static Collection < Object [ ] > ibanParameters ( ) { return Arrays . asList ( new Object [ ] [ ] { { CountryCode . AL , new Bban . Builder ( )
public static String calculateCheckDigit ( CountryCode countryCode , Bban bban ) { return calculateCheckDigit ( countryCode , bban . format ( countryCode ) ) ; }
public static String calculateCheckDigit ( CountryCode countryCode , String bban ) { StringBuilder sb = new StringBuilder ( ) . append ( countryCode . name ( ) ) . append ( DEFAULT_CHECK_DIGIT ) . append ( bban ) ; return calculateCheckDigit ( sb . toString ( ) ) ; }
public static String calculateCheckDigit ( String iban ) { String reformattedIban = removeCheckDigit ( iban ) ; int modResult = calculateMod ( reformattedIban ) ; int checkDigitIntValue = ( 98 - modResult ) ; String checkDigit = Integer . toString ( checkDigitIntValue ) ; return checkDigitIntValue > 9 ? checkDigit : " 0 " + checkDigit ; }
protected static String removeCheckDigit ( String iban ) { return iban . substring ( 0 , 2 ) + DEFAULT_CHECK_DIGIT + iban . substring ( 4 ) ; }
public static Collection < Object [ ] > ibanParameters ( ) { return TestDataHelper . getIbanData ( ) ; }
public void checkDigitCalculationWithCountryCodeAndBbanShouldReturnCheckDigit ( ) { String checkDigit = IbanUtil . calculateCheckDigit ( countryCode , bban ) ; assertThat ( checkDigit , is ( equalTo ( expectedIbanString . substring ( 2 , 4 ) ) ) ) ; }
public static Collection < Object [ ] > ibanParameters ( ) { return TestDataHelper . getIbanData ( ) ; }
public void checkDigitCalculationWithInvalidBbanShouldThrowException ( ) { IbanUtil . calculateCheckDigit ( CountryCode . AT , " 0159260+076545510730339 " ) ; }
public static Collection < Object [ ] > getIbanData ( ) { return Arrays . asList ( new Object [ ] [ ] { { CountryCode . AL , new Bban . Builder ( )
public void checkDigitCalculationWithNonNumericBbanShouldThrowException ( ) { IbanUtil . calculateCheckDigit ( CountryCode . AT , " 0159260 " + invalidCharacter + " 076545510730339 " ) ; }
public static Collection < Character [ ] > invalidCharacters ( ) { return Arrays . asList ( new Character [ ] [ ] { { '\u216C' } , { '+' } } ) ;
public String format ( final CountryCode countryCode ) { IbanStructure structure = IbanStructureCache . getStructure ( countryCode . getAlpha2 ( ) ) ; return format ( structure ) ; }
protected String format ( final IbanStructure structure ) { StringBuilder sb = new StringBuilder ( ) ; for ( IbanStructureEntry entry : structure . getBbanEntries ( ) ) { switch ( entry . getEntryType ( ) ) { case k : break ; case b : sb . append ( bankCode ) ; break ; case s : sb . append ( branchCode ) ; break ; case c : sb . append ( accountNumber ) ; break ; case x : sb . append ( nationalCheckDigit ) ; break ; case t : sb . append ( accountType ) ; break ; case n : sb . append ( ownerAccountType ) ; break ; case i : sb . append ( identificationNumber ) ; break ; } } return sb . toString ( ) ; }
public Builder bankCode ( final String bankCode ) { this . bankCode = bankCode ; return this ; }
public Builder branchCode ( final String branchCode ) { this . branchCode = branchCode ; return this ; }
public Builder nationalCheckDigit ( final String nationalCheckDigit ) { this . nationalCheckDigit = nationalCheckDigit ; return this ; }
public Builder accountType ( final String accountType ) { this . accountType = accountType ; return this ; }
public Builder ownerAccountType ( final String ownerAccountType ) { this . ownerAccountType = ownerAccountType ; return this ; }
public Builder accountNumber ( final String accountNumber ) { this . accountNumber = accountNumber ; return this ; }
public Builder identificationNumber ( final String identificationNumber ) { this . identificationNumber = identificationNumber ; return this ; }
public static String calculateCheckDigit ( final CountryCode countryCode , final Bban bban ) { return calculateCheckDigit ( countryCode , bban . format ( countryCode ) ) ; }
public static String calculateCheckDigit ( final CountryCode countryCode , final String bban ) { StringBuilder sb = new StringBuilder ( ) . append ( countryCode . name ( ) ) . append ( DEFAULT_CHECK_DIGIT ) . append ( bban ) ; return calculateCheckDigit ( sb . toString ( ) ) ; }
public static String calculateCheckDigit ( final String iban ) { String reformattedIban = removeCheckDigit ( iban ) ; int modResult = calculateMod ( reformattedIban ) ; int checkDigitIntValue = ( 98 - modResult ) ; String checkDigit = Integer . toString ( checkDigitIntValue ) ; return checkDigitIntValue > 9 ? checkDigit : " 0 " + checkDigit ; }
private static String removeCheckDigit ( final String iban ) { return iban . substring ( 0 , 2 ) + DEFAULT_CHECK_DIGIT + iban . substring ( 4 ) ; }
private static int calculateMod ( final String iban ) { String reformattedIban = iban . substring ( 4 ) + iban . substring ( 0 , 4 ) ; long total = 0 ; for ( int i = 0 ; i < reformattedIban . length ( ) ; i + + ) { int numericValue = Character . getNumericValue ( reformattedIban . charAt ( i ) ) ; if ( numericValue < 0 | | numericValue > 35 ) { throw new IllegalArgumentException ( " Invalid Character[ " + i + " ] = ' " + numericValue + " ' " ) ; } total = ( numericValue > 9 ? total * 100 : total * 10 ) + numericValue ; if ( total > MAX ) { total = ( total % MOD ) ; } } return ( int ) ( total % MOD ) ; }
private String format ( final IbanStructure structure ) { StringBuilder sb = new StringBuilder ( ) ; for ( IbanStructureEntry entry : structure . getBbanEntries ( ) ) { switch ( entry . getEntryType ( ) ) { case k : break ; case b : sb . append ( bankCode ) ; break ; case s : sb . append ( branchCode ) ; break ; case c : sb . append ( accountNumber ) ; break ; case x : sb . append ( nationalCheckDigit ) ; break ; case t : sb . append ( accountType ) ; break ; case n : sb . append ( ownerAccountType ) ; break ; case i : sb . append ( identificationNumber ) ; break ; } } return sb . toString ( ) ; }
public String getBankCode ( ) { return bankCode ; }
public String getBranchCode ( ) { return branchCode ; }
public String getNationalCheckDigit ( ) { return nationalCheckDigit ; }
public String getAccountType ( ) { return accountType ; }
public String getAccountNumber ( ) { return accountNumber ; }
public String getOwnerAccountType ( ) { return ownerAccountType ; }
public String getIdentificationNumber ( ) { return identificationNumber ; }
public String getAccountNumber ( ) { return bban . getAccountNumber ( ) ; }
public String getBankCode ( ) { return bban . getBankCode ( ) ; }
public String getBranchCode ( ) { return bban . getBranchCode ( ) ; }
public String getNationalCheckDigit ( ) { return bban . getNationalCheckDigit ( ) ; }
public String getAccountType ( ) { return bban . getAccountType ( ) ; }
public String getOwnerAccountType ( ) { return bban . getOwnerAccountType ( ) ; }
public String getIdentificationNumber ( ) { return bban . getIdentificationNumber ( ) ; }
public Builder countryCode ( final CountryCode countryCode ) { this . countryCode = countryCode ; return this ; }
public Builder bankCode ( final String bankCode ) { bbanBuilder . bankCode ( bankCode ) ; return this ; }
public Builder branchCode ( final String branchCode ) { bbanBuilder . branchCode ( branchCode ) ; return this ; }
public Builder accountNumber ( final String accountNumber ) { bbanBuilder . accountNumber ( accountNumber ) ; return this ; }
public Builder nationalCheckDigit ( final String nationalCheckDigit ) { bbanBuilder . nationalCheckDigit ( nationalCheckDigit ) ; return this ; }
public Builder accountType ( final String accountType ) { bbanBuilder . accountType ( accountType ) ; return this ; }
public Builder ownerAccountType ( final String ownerAccountType ) { bbanBuilder . ownerAccountType ( ownerAccountType ) ; return this ; }
public Builder identificationNumber ( final String identificationNumber ) { bbanBuilder . identificationNumber ( identificationNumber ) ; return this ; }
public Iban build ( ) { return new Iban ( this ) ; }
private Bban buildBban ( ) { return bbanBuilder . build ( ) ; }
public void ibanConstructionWithSupportedCountriesShouldReturnIban ( ) { assertThat ( iban . toString ( ) , is ( equalTo ( expectedIbanString ) ) ) ; }
public void checkDigitCalculationWithCountryCodeAndBbanShouldReturnCheckDigit ( ) { String checkDigit = IbanUtil . calculateCheckDigit ( iban . getCountryCode ( ) , iban . getBban ( ) ) ; assertThat ( checkDigit , is ( equalTo ( expectedIbanString . substring ( 2 , 4 ) ) ) ) ; }
public static Collection < Object [ ] > getIbanData ( ) { return Arrays . asList ( new Object [ ] [ ] { { new Iban . Builder ( )
protected static Iban valueOf ( ) throws IbanFormatException { // TODO implement return null; }
public Iban build ( ) throws IbanFormatException { return new Iban ( this ) ; }
protected static String calculateCheckDigit ( final CountryCode countryCode , final Bban bban ) { return calculateCheckDigit ( countryCode , bban . format ( countryCode ) ) ; }
protected static String calculateCheckDigit ( final CountryCode countryCode , final String bban ) { StringBuilder sb = new StringBuilder ( ) . append ( countryCode . name ( ) ) . append ( DEFAULT_CHECK_DIGIT ) . append ( bban ) ; return calculateCheckDigit ( sb . toString ( ) ) ; }
protected String format ( final CountryCode countryCode ) { IbanStructure structure = IbanStructureCache . getStructure ( countryCode . getAlpha2 ( ) ) ; return format ( structure ) ; }
protected String getBankCode ( ) { return bankCode ; }
protected String getBranchCode ( ) { return branchCode ; }
protected String getNationalCheckDigit ( ) { return nationalCheckDigit ; }
protected String getAccountType ( ) { return accountType ; }
protected String getAccountNumber ( ) { return accountNumber ; }
protected String getOwnerAccountType ( ) { return ownerAccountType ; }
protected String getIdentificationNumber ( ) { return identificationNumber ; }
private static Iban valueOf ( ) throws IbanFormatException { // TODO implement return null; }
private static int calculateMod ( final String iban ) { String reformattedIban = iban . substring ( 4 ) + iban . substring ( 0 , 4 ) ; long total = 0 ; for ( int i = 0 ; i < reformattedIban . length ( ) ; i + + ) { int numericValue = Character . getNumericValue ( reformattedIban . charAt ( i ) ) ; if ( numericValue < 0 | | numericValue > 35 ) { throw new IllegalArgumentException ( " Invalid Character[ " + i + " ] = ' " + numericValue + " ' " ) ; } total = ( numericValue > 9 ? total * 100 : total * 10 ) + numericValue ; if ( total > MAX ) { total = ( total % MOD ) ; } } return ( int ) ( total % MOD ) ; }
private static Iban valueOf ( String iban ) throws IbanFormatException { CountryCode countryCode = CountryCode . getByCode ( iban . substring ( 0 , 2 ) ) ; String checkDigit = iban . substring ( 2 , 4 ) ; // Bban bban = Bban.valueOf(iban.substring); // return new Iban(countryCode, checkDigit, bban); return null; }
public String format ( final CountryCode countryCode ) { IbanStructure structure = IbanStructureResolver . getStructure ( countryCode . getAlpha2 ( ) ) ; return format ( structure ) ; }
private static Iban valueOf ( final String iban ) throws IbanFormatException { CountryCode countryCode = CountryCode . getByCode ( iban . substring ( 0 , 2 ) ) ; String checkDigit = iban . substring ( 2 , 4 ) ; // Bban bban = Bban.valueOf(iban.substring); // return new Iban(countryCode, checkDigit, bban); return null; }
private static IbanStructure parseStructure ( final String structure ) throws IllegalArgumentException { // it's important to have linked hash map to keep insertion order Map<String, IbanStructureEntry> entries = new LinkedHashMap<String, IbanStructureEntry>(); try { String[] entriesStr = structure.split(ENTRY_SPLITTER); for (String entryStr : entriesStr) { IbanStructureEntry entry = parseStructureEntry(entryStr); entries.put(entry.getEntryType().name(), entry); } } catch (Exception e) { throw new IllegalArgumentException("Invalid IBAN Structure is passed: " + structure, e); } return new IbanStructure(entries, structure); }
public static IbanStructure getStructure ( final String countryCode ) { String key = countryCode . toLowerCase ( ) + IBAN_STRUCTURE_SUFFIX ; String structure = propertyResolver . getProperty ( key ) ; return IbanStructure . valueOf ( structure ) ; }
private static PropertyResolver configurePropertyResolver ( ) throws IllegalStateException { Properties properties = null ; try { properties = PropertiesLoaderUtil . loadProperties ( DEFAULT_PROPERTIES_FILE ) ; } catch ( IOException e ) { throw new IllegalStateException ( " Can not find configuration file " , e ) ; } return new PropertyResolver ( properties ) ; }
String getProperty ( final String key ) { return properties . getProperty ( key ) ; }
int getIntProperty ( final String key ) throws NumberFormatException { String value = properties . getProperty ( key ) ; return Integer . parseInt ( value ) ; }
String [ ] getProperties ( final String key ) { String value = properties . getProperty ( key ) ; return value . split ( " [,] " ) ; }
private static Iban valueOf ( final String iban ) throws IbanFormatException { CountryCode countryCode = CountryCode . getByCode ( iban . substring ( 0 , 2 ) ) ; String checkDigit = iban . substring ( 2 , 4 ) ; // return new Iban(countryCode, checkDigit, bban); return null; }
protected String format ( ) { IbanStructure structure = IbanStructureResolver . getStructure ( countryCode . getAlpha2 ( ) ) ; return format ( structure ) ; }
protected static String calculateCheckDigit ( final Iban iban ) { return calculateCheckDigit ( iban . toString ( ) ) ; }
private static String removeCheckDigit ( final String iban ) { return iban . substring ( 0 , 2 ) + Iban . DEFAULT_CHECK_DIGIT + iban . substring ( 4 ) ; }
public void checkDigitCalculationWithCountryCodeAndBbanShouldReturnCheckDigit ( ) { String checkDigit = IbanUtil . calculateCheckDigit ( iban ) ; assertThat ( checkDigit , is ( equalTo ( expectedIbanString . substring ( 2 , 4 ) ) ) ) ; }
public void checkDigitCalculationWithNonNumericBbanShouldThrowException ( ) { IbanUtil . calculateCheckDigit ( " AT000159260 " + invalidCharacter + " 076545510730339 " ) ; }
private String format ( ) { StringBuilder sb = new StringBuilder ( countryCode . getAlpha2 ( ) ) ; for ( IbanStructureEntry entry : structure . getEntries ( ) ) { switch ( entry . getEntryType ( ) ) { case k : sb . append ( checkDigit ) ; break ; case b : sb . append ( bankCode ) ; break ; case s : sb . append ( branchCode ) ; break ; case c : sb . append ( accountNumber ) ; break ; case x : sb . append ( nationalCheckDigit ) ; break ; case t : sb . append ( accountType ) ; break ; case n : sb . append ( ownerAccountType ) ; break ; case i : sb . append ( identificationNumber ) ; break ; } } return sb . toString ( ) ; }
private void validateLength ( ) { } @Override public String toString ( ) { return format ( ) ; } /** * Iban Builder Class */ public final static class Builder { private CountryCode countryCode ; private String bankCode ; private String branchCode ; private String nationalCheckDigit ; private String accountType ; private String accountNumber ; private String ownerAccountType ; private String identificationNumber ; public Builder ( ) { } public Builder countryCode ( final CountryCode countryCode ) { this . countryCode = countryCode ; return this ; } public Builder bankCode ( final String bankCode ) { this . bankCode = bankCode ; return this ; } public Builder branchCode ( final String branchCode ) { this . branchCode = branchCode ; return this ; } public Builder accountNumber ( final String accountNumber ) { this . accountNumber = accountNumber ; return this ; } public Builder nationalCheckDigit ( final String nationalCheckDigit ) { this . nationalCheckDigit = nationalCheckDigit ; return this ; } public Builder accountType ( final String accountType ) { this . accountType = accountType ; return this ; } public Builder ownerAccountType ( final String ownerAccountType ) { this . ownerAccountType = ownerAccountType ; return this ; } public Builder identificationNumber ( final String identificationNumber ) { this . identificationNumber = identificationNumber ; return this ; } /** * Builds new iban instance. * * @return new iban instance. * @throws IbanFormatException, IllegalArgumentException if values are not parsable by Iban Specification * <a href="http://en.wikipedia.org/wiki/ISO_13616">ISO_13616</a> */ public Iban build ( ) throws IbanFormatException , IllegalArgumentException { Assert . notNull ( countryCode , " countryCode is required; it cannot be null " ) ; Assert . notNull ( bankCode , " bankCode is required; it cannot be null " ) ; Assert . notNull ( accountNumber , " accountNumber is required; it cannot be null " ) ; // iban instance with default check digit Iban iban = new Iban(this); // replace default check digit with calculated check digit iban.checkDigit = IbanUtil.calculateCheckDigit(iban); // validate iban IbanUtil.validate(iban); return iban; } } }
public String toString ( ) { return format ( ) ; }
public Iban build ( ) throws IbanFormatException , IllegalArgumentException { Assert . notNull ( countryCode , " countryCode is required; it cannot be null " ) ; Assert . notNull ( bankCode , " bankCode is required; it cannot be null " ) ; Assert . notNull ( accountNumber , " accountNumber is required; it cannot be null " ) ; // iban instance with default check digit Iban iban = new Iban(this); // replace default check digit with calculated check digit iban.checkDigit = IbanUtil.calculateCheckDigit(iban); // validate iban IbanUtil.validate(iban); return iban; }
public static void validate ( Iban iban ) throws IbanFormatException { IbanStructure structure = IbanStructureResolver . getStructure ( iban . getCountryCode ( ) . getAlpha2 ( ) ) ; int expectedLength = structure . getIbanLength ( ) ; int realLength = iban . toString ( ) . length ( ) ; if ( expectedLength ! = realLength ) { throw new IbanFormatException ( " [ " + iban + " ] length is " +
protected static void validate ( String iban ) throws IbanFormatException { // TODO use valueOf } protected static String calculateCheckDigit(final Iban iban) { return calculateCheckDigit(iban.toString()); } /** * Returns an iban with default check digit. * * @param iban The iban * @return The iban without the check digit */ private static String removeCheckDigit(final String iban) { return iban.substring(0, 2) + Iban.DEFAULT_CHECK_DIGIT + iban.substring(4); } /** * Calculates * <a href="http://en.wikipedia.org/wiki/ISO_13616#Modulo_operation_on_IBAN">Iban Modulo</a>. * * @param iban String value * @return modulo 97 */ private static int calculateMod(final String iban) { String reformattedIban = iban.substring(4) + iban.substring(0, 4); long total = 0; for (int i = 0; i < reformattedIban.length(); i++) { int numericValue = Character.getNumericValue(reformattedIban.charAt(i)); if (numericValue < 0 || numericValue > 35) { throw new IllegalArgumentException("Invalid Character[" + i + "] = '" + numericValue + "'"); } total = (numericValue > 9 ? total * 100 : total * 10) + numericValue; if (total > MAX) { total = (total % MOD); } } return (int) (total % MOD); } }
public static void notNull ( Object object , String message ) throws IllegalArgumentException { if ( object = = null ) { throw new IllegalArgumentException ( message ) ;
public int getIbanLength ( ) { int length = COUNTRY_CODE_LENGTH ; for ( IbanStructureEntry entry : entries . values ( ) ) { length + = entry . getLength ( ) ; } return length ; }
public static void validate ( final Iban iban ) throws IbanFormatException { IbanStructure structure = IbanStructureResolver . getStructure ( iban . getCountryCode ( ) . getAlpha2 ( ) ) ; int expectedLength = structure . getIbanLength ( ) ; int realLength = iban . toString ( ) . length ( ) ; if ( expectedLength ! = realLength ) { throw new IbanFormatException ( " [ " + iban + " ] length is " +
public static void notNull ( final Object object , final String message ) throws IllegalArgumentException { if ( object = = null ) { throw new IllegalArgumentException ( message ) ;
public Iban build ( ) throws IbanFormatException , IllegalArgumentException , UnsupportedCountryException { Assert . notNull ( countryCode , " countryCode is required; it cannot be null " ) ; Assert . notNull ( bankCode , " bankCode is required; it cannot be null " ) ; Assert . notNull ( accountNumber , " accountNumber is required; it cannot be null " ) ; // iban instance with default check digit Iban iban = new Iban(this); // replace default check digit with calculated check digit iban.checkDigit = IbanUtil.calculateCheckDigit(iban); // validate iban IbanUtil.validate(iban); return iban; }
public Iban build ( ) throws IbanFormatException , IllegalArgumentException , UnsupportedCountryException { // null checks Assert.notNull(countryCode, "countryCode is required; it cannot be null"); Assert.notNull(bankCode, "bankCode is required; it cannot be null"); Assert.notNull(accountNumber, "accountNumber is required; it cannot be null"); // throw exception if country is not supported try { structure = IbanStructureResolver.getStructure(countryCode.getAlpha2()); } catch (IllegalArgumentException e) { throw new UnsupportedCountryException(e); } // iban instance with default check digit Iban iban = new Iban(this); // replace default check digit with calculated check digit iban.checkDigit = IbanUtil.calculateCheckDigit(iban); // validate iban IbanUtil.validate(iban); return iban; }
public static IbanStructure valueOf ( final String structure ) throws IllegalStateException { return parseStructure ( structure ) ; }
private static IbanStructure parseStructure ( final String structure ) throws IllegalStateException { // it's important to have linked hash map to keep insertion order Map<String, IbanStructureEntry> entries = new LinkedHashMap<String, IbanStructureEntry>(); try { String[] entriesStr = structure.split(ENTRY_SPLITTER); for (String entryStr : entriesStr) { IbanStructureEntry entry = parseStructureEntry(entryStr); entries.put(entry.getEntryType().name(), entry); } } catch (Exception e) { throw new IllegalStateException("Invalid IBAN Structure: " + structure, e); } return new IbanStructure(entries, structure); }
public static IbanStructure getStructure ( final String countryCode ) { String key = countryCode . toLowerCase ( ) + IBAN_STRUCTURE_SUFFIX ; String structure = propertyResolver . getProperty ( key ) ; Assert . notNull ( structure , " Structure is not defined for specified country. " ) ; return IbanStructure . valueOf ( structure ) ; }
public void ibanConstructionWithSupportedCountriesShouldReturnIban ( ) { assertThat ( iban . toString ( ) , is ( equalTo ( expectedIbanString ) ) ) ; }
public static Collection < Object [ ] > ibanParameters ( ) { return TestDataHelper . getIbanData ( ) ; }
public void ibanConstructionWithNonSupportedCountryShouldThrowException ( ) { new Iban . Builder ( ) . countryCode ( CountryCode . AM )
public void ibanConstructionWithoutCountryShouldThrowException ( ) { new Iban . Builder ( ) . bankCode ( " 0001 " )
public void ibanConstructionWithoutBankCodeShouldThrowException ( ) { new Iban . Builder ( ) . countryCode ( CountryCode . AM )
public void ibanConstructionWithoutAccountNumberShouldThrowException ( ) { new Iban . Builder ( ) . countryCode ( CountryCode . AM )
public static void validate ( final Iban iban ) throws IbanFormatException { validate ( iban . toString ( ) ) ; }
public static void validate ( String iban ) throws IbanFormatException { IbanStructure structure = getIbanStructure ( iban ) ; try { validateIbanLength ( iban , structure ) ;
private static IbanStructure getIbanStructure ( String iban ) { String countryCode = iban . substring ( 0 , 2 ) ; return IbanStructureResolver . getStructure ( countryCode ) ; }
private static void validateIbanLength ( String iban , IbanStructure structure ) { int expectedLength = structure . getIbanLength ( ) ; int realLength = iban . length ( ) ; if ( expectedLength ! = realLength ) { throw new IbanFormatException ( " [ " + iban + " ] length is " +
private static void validateIbanEntries ( String iban , IbanStructure structure ) { int ibanEntryOffset = 2 ; List < IbanStructureEntry > entries = structure . getEntries ( ) ; for ( IbanStructureEntry entry : entries ) { int entryLength = entry . getLength ( ) ;
public static void isTrue ( boolean expression , String message ) { if ( ! expression ) { throw new IllegalArgumentException ( message ) ;
public static void hasLength ( String text , int length , String message ) { Assert . notNull ( text , message ) ; if ( text . length ( ) ! = length ) { throw new IllegalArgumentException ( message ) ;
public void ibanConstructionWithInvalidCharacterShouldThrowException ( ) { new Iban . Builder ( ) . countryCode ( CountryCode . AT )
public void ibanConstructionWithShortBankCodeShouldThrowException ( ) { new Iban . Builder ( ) . countryCode ( CountryCode . AT )
public Iban build ( ) throws IbanFormatException , IllegalArgumentException , UnsupportedCountryException { // null checks Assert.notNull(countryCode, "countryCode is required; it cannot be null"); Assert.notNull(bankCode, "bankCode is required; it cannot be null"); Assert.notNull(accountNumber, "accountNumber is required; it cannot be null"); // throw exception if country is not supported try { structure = IbanStructureResolver.getStructure(countryCode.getAlpha2()); } catch (IllegalArgumentException e) { throw new UnsupportedCountryException(e); } // iban instance with default check digit Iban iban = new Iban(this); // replace default check digit with calculated check digit iban.checkDigit = IbanUtil.calculateCheckDigit(iban); // validate iban IbanUtil.validate(iban); // pre-genrate and cache iban string value iban.value = iban.format(); return iban; }
public void ibansWithSameDataShouldBeEqual ( ) { Iban iban1 = new Iban . Builder ( ) . countryCode ( CountryCode . AT ) . bankCode ( " 1904 " ) . accountNumber ( " 102345732012 " ) . build ( ) ; Iban iban2 = new Iban . Builder ( ) . countryCode ( CountryCode . AT ) . bankCode ( " 1904 " ) . accountNumber ( " 102345732012 " ) . build ( ) ; assertThat ( iban1 , is ( equalTo ( iban2 ) ) ) ; }
public void ibansWithSameDataShouldHaveSameHashCode ( ) { Iban iban1 = new Iban . Builder ( ) . countryCode ( CountryCode . AT ) . bankCode ( " 1904 " ) . accountNumber ( " 102345732012 " ) . build ( ) ; Iban iban2 = new Iban . Builder ( ) . countryCode ( CountryCode . AT ) . bankCode ( " 1904 " ) . accountNumber ( " 102345732012 " ) . build ( ) ; assertThat ( iban1 . hashCode ( ) , is ( equalTo ( iban2 . hashCode ( ) ) ) ) ; }
public static void validate ( String iban ) throws IbanFormatException { // FIXME -> PERF: optimize performance of this method -> 100 ms IbanStructure structure = getIbanStructure(iban); try { validateIbanLength(iban, structure);
public void ibanConstruction ( ) { for ( int i = 0 ; i < LOOPS_COUNT ; i + + ) { Iban iban = new Iban . Builder ( )
private String getBban ( ) { return formatBban ( ) ; }
private String format ( ) { StringBuilder sb = new StringBuilder ( countryCode . getAlpha2 ( ) ) ; sb . append ( checkDigit ) ; sb . append ( formatBban ( ) ) ; return sb . toString ( ) ; }
private String formatBban ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( BbanStructureEntry entry : bbanStructure . getEntries ( ) ) { switch ( entry . getEntryType ( ) ) { case b : sb . append ( bankCode ) ; break ; case s : sb . append ( branchCode ) ; break ; case c : sb . append ( accountNumber ) ; break ; case x : sb . append ( nationalCheckDigit ) ; break ; case t : sb . append ( accountType ) ; break ; case n : sb . append ( ownerAccountType ) ; break ; case i : sb . append ( identificationNumber ) ; break ; } } return sb . toString ( ) ; }
public Iban build ( ) throws IbanFormatException , IllegalArgumentException , UnsupportedCountryException { // null checks Assert.notNull(countryCode, "countryCode is required; it cannot be null"); Assert.notNull(bankCode, "bankCode is required; it cannot be null"); Assert.notNull(accountNumber, "accountNumber is required; it cannot be null"); bbanStructure = BbanStructure.forCountry(countryCode); if(bbanStructure == null) { throw new UnsupportedCountryException(); } // iban instance with default check digit Iban iban = new Iban(this); // replace default check digit with calculated check digit iban.checkDigit = IbanUtil.calculateCheckDigit(iban); // pre-genrate and cache iban string value iban.value = iban.format(); // validate iban IbanUtil.validate(iban.value); return iban; }
public static void validate ( String iban ) throws IbanFormatException { BbanStructure structure = getBbanStructure ( iban ) ; if ( structure = = null ) { throw new UnsupportedCountryException ( ) ; } try { validateIbanLength ( iban , structure ) ;
private static BbanStructure getBbanStructure ( String iban ) { String countryCode = iban . substring ( 0 , 2 ) ; return BbanStructure . forCountry ( CountryCode . valueOf ( countryCode ) ) ; }
private static void validateIbanLength ( String iban , BbanStructure structure ) { int bbanLength = structure . getBbanLength ( ) ; int ibanLength = iban . length ( ) ; if ( bbanLength ! = ibanLength - 4 ) { throw new IbanFormatException ( " [ " + iban + " ] length is " +
private static void validateIbanEntries ( String iban , BbanStructure structure ) { int ibanEntryOffset = 4 ; for ( BbanStructureEntry entry : structure . getEntries ( ) ) { int entryLength = entry . getLength ( ) ;
public static BbanStructure forCountry ( CountryCode countryCode ) { return structures . get ( countryCode ) ; }
public BbanStructureEntry [ ] getEntries ( ) { return entries ; }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; Document doc = new Document(dataDir + "TestFile.doc"); insertWatermarkText(doc, "CONFIDENTIAL"); doc.save(dataDir + "TestFile Out.doc"); }
private static void insertWatermarkText ( Document doc , String watermarkText ) throws Exception { // Create a watermark shape. This will be a WordArt shape. // You are free to try other shape types as watermarks. Shape watermark = new Shape(doc, ShapeType.TEXT_PLAIN_TEXT); // Set up the text of the watermark. watermark.getTextPath().setText(watermarkText); watermark.getTextPath().setFontFamily("Arial"); watermark.setWidth(500); watermark.setHeight(100); // Text will be directed from the bottom-left to the top-right corner. watermark.setRotation(-40); // Remove the following two lines if you need a solid black text. watermark.getFill().setColor(Color.GRAY); // Try LightGray to get more Word-style watermark watermark.setStrokeColor(Color.GRAY); // Try LightGray to get more Word-style watermark // Place the watermark in the page center. watermark.setRelativeHorizontalPosition(RelativeHorizontalPosition.PAGE); watermark.setRelativeVerticalPosition(RelativeVerticalPosition.PAGE); watermark.setWrapType(WrapType.NONE); watermark.setVerticalAlignment(VerticalAlignment.CENTER); watermark.setHorizontalAlignment(HorizontalAlignment.CENTER); // Create a new paragraph and append the watermark to this paragraph. Paragraph watermarkPara = new Paragraph(doc); watermarkPara.appendChild(watermark); // Insert the watermark into all headers of each document section. for (Section sect : doc.getSections()) {
private static void insertWatermarkIntoHeader ( Paragraph watermarkPara , Section sect , int headerType ) throws Exception { HeaderFooter header = sect . getHeadersFooters ( ) . getByHeaderFooterType ( headerType ) ; if ( header = = null ) { // There is no header of the specified type in the current section, create it. header = new HeaderFooter(sect.getDocument(), headerType); sect.getHeadersFooters().add(header); } // Insert a clone of the watermark into the header. header.appendChild(watermarkPara.deepClone(true)); }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); gDataDir = new File(exeDir.resolve("../../Data")) + File.separator; // Run each of the sample code snippets. appendDocument_SimpleAppendDocument(); appendDocument_KeepSourceFormatting(); appendDocument_UseDestinationStyles(); appendDocument_JoinContinuous(); appendDocument_JoinNewPage(); appendDocument_RestartPageNumbering(); appendDocument_LinkHeadersFooters(); appendDocument_UnlinkHeadersFooters(); appendDocument_RemoveSourceHeadersFooters(); appendDocument_DifferentPageSetup(); appendDocument_ConvertNumPageFields(); appendDocument_ListUseDestinationStyles(); appendDocument_ListKeepSourceFormatting(); appendDocument_KeepSourceTogether(); appendDocument_BaseDocument(); appendDocument_UpdatePageLayout(); }
public static void appendDocument_SimpleAppendDocument ( ) throws Exception { Document dstDoc = new Document ( gDataDir + " TestFile.Destination.doc " ) ; Document srcDoc = new Document ( gDataDir + " TestFile.Source.doc " ) ; //ExStart //ExId:AppendDocument_SimpleAppend //ExSummary:Shows how to append a document to the end of another document using no additional options. // Append the source document to the destination document using no extra options. dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); //ExEnd dstDoc.save(gDataDir + "TestFile.SimpleAppendDocument Out.docx"); }
public static void appendDocument_KeepSourceFormatting ( ) throws Exception { //ExStart //ExId:AppendDocument_KeepSourceFormatting //ExSummary:Shows how to append a document to another document while keeping the original formatting. // Load the documents to join. Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc"); Document srcDoc = new Document(gDataDir + "TestFile.Source.doc"); // Keep the formatting from the source document when appending it to the destination document. dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); // Save the joined document to disk. dstDoc.save(gDataDir + "TestFile.KeepSourceFormatting Out.docx"); //ExEnd
public static void appendDocument_UseDestinationStyles ( ) throws Exception { //ExStart //ExId:AppendDocument_UseDestinationStyles //ExSummary:Shows how to append a document to another document using the formatting of the destination document. // Load the documents to join. Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc"); Document srcDoc = new Document(gDataDir + "TestFile.Source.doc"); // Append the source document using the styles of the destination document. dstDoc.appendDocument(srcDoc, ImportFormatMode.USE_DESTINATION_STYLES); // Save the joined document to disk. dstDoc.save(gDataDir + "TestFile.UseDestinationStyles Out.doc"); //ExEnd
public static void appendDocument_JoinContinuous ( ) throws Exception { //ExStart //ExId:AppendDocument_JoinContinuous //ExSummary:Shows how to append a document to another document so the content flows continuously. Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc"); Document srcDoc = new Document(gDataDir + "TestFile.Source.doc"); // Make the document appear straight after the destination documents content. srcDoc.getFirstSection().getPageSetup().setSectionStart(SectionStart.CONTINUOUS); // Append the source document using the original styles found in the source document. dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); dstDoc.save(gDataDir + "TestFile.JoinContinuous Out.doc"); //ExEnd
public static void appendDocument_JoinNewPage ( ) throws Exception { //ExStart //ExId:AppendDocument_JoinNewPage //ExSummary:Shows how to append a document to another document so it starts on a new page. Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc"); Document srcDoc = new Document(gDataDir + "TestFile.Source.doc"); // Set the appended document to start on a new page. srcDoc.getFirstSection().getPageSetup().setSectionStart(SectionStart.NEW_PAGE); // Append the source document using the original styles found in the source document. dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); dstDoc.save(gDataDir + "TestFile.JoinNewPage Out.doc"); //ExEnd
public static void appendDocument_RestartPageNumbering ( ) throws Exception { //ExStart //ExId:AppendDocument_RestartPageNumbering //ExSummary:Shows how to append a document to another document with page numbering restarted. Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc"); Document srcDoc = new Document(gDataDir + "TestFile.Source.doc"); // Set the appended document to appear on the next page. srcDoc.getFirstSection().getPageSetup().setSectionStart(SectionStart.NEW_PAGE); // Restart the page numbering for the document to be appended. srcDoc.getFirstSection().getPageSetup().setRestartPageNumbering(true); dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); dstDoc.save(gDataDir + "TestFile.RestartPageNumbering Out.doc"); //ExEnd
public static void appendDocument_LinkHeadersFooters ( ) throws Exception { //ExStart //ExFor:HeaderFooterCollection.LinkToPrevious(Boolean) //ExId:AppendDocument_LinkHeadersFooters //ExSummary:Shows how to append a document to another document and continue headers and footers from the destination document. Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc"); Document srcDoc = new Document(gDataDir + "TestFile.Source.doc"); // Set the appended document to appear on a new page. srcDoc.getFirstSection().getPageSetup().setSectionStart(SectionStart.NEW_PAGE); // Link the headers and footers in the source document to the previous section. // This will override any headers or footers already found in the source document. srcDoc.getFirstSection().getHeadersFooters().linkToPrevious(true); dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); dstDoc.save(gDataDir + "TestFile.LinkHeadersFooters Out.doc"); //ExEnd
public static void appendDocument_UnlinkHeadersFooters ( ) throws Exception { //ExStart //ExId:AppendDocument_UnlinkHeadersFooters //ExSummary:Shows how to append a document to another document so headers and footers do not continue from the destination document. Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc"); Document srcDoc = new Document(gDataDir + "TestFile.Source.doc"); // Even a document with no headers or footers can still have the LinkToPrevious setting set to true. // Unlink the headers and footers in the source document to stop this from continuing the headers and footers // from the destination document. srcDoc.getFirstSection().getHeadersFooters().linkToPrevious(false); dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); dstDoc.save(gDataDir + "TestFile.UnlinkHeadersFooters Out.doc"); //ExEnd
public static void appendDocument_RemoveSourceHeadersFooters ( ) throws Exception { //ExStart //ExId:AppendDocument_RemoveSourceHeadersFooters //ExSummary:Shows how to remove headers and footers from a document before appending it to another document. Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc"); Document srcDoc = new Document(gDataDir + "TestFile.Source.doc"); // Remove the headers and footers from each of the sections in the source document. for (Section section : srcDoc.getSections()) { section.clearHeadersFooters(); } // Even after the headers and footers are cleared from the source document, the "LinkToPrevious" setting // for HeadersFooters can still be set. This will cause the headers and footers to continue from the destination // document. This should set to false to avoid this behaviour. srcDoc.getFirstSection().getHeadersFooters().linkToPrevious(false); dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); dstDoc.save(gDataDir + "TestFile.RemoveSourceHeadersFooters Out.doc"); //ExEnd
public static void appendDocument_DifferentPageSetup ( ) throws Exception { //ExStart //ExId:AppendDocument_DifferentPageSetup //ExSummary:Shows how to append a document to another document continuously which has different page settings. Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc"); Document srcDoc = new Document(gDataDir + "TestFile.SourcePageSetup.doc"); // Set the source document to continue straight after the end of the destination document. // If some page setup settings are different then this may not work and the source document will appear // on a new page. srcDoc.getFirstSection().getPageSetup().setSectionStart(SectionStart.CONTINUOUS); // To ensure this does not happen when the source document has different page setup settings make sure the // settings are identical between the last section of the destination document. // If there are further continuous sections that follow on in the source document then this will need to be // repeated for those sections as well. srcDoc.getFirstSection().getPageSetup().setPageWidth(dstDoc.getLastSection().getPageSetup().getPageWidth()); srcDoc.getFirstSection().getPageSetup().setPageHeight(dstDoc.getLastSection().getPageSetup().getPageHeight()); srcDoc.getFirstSection().getPageSetup().setOrientation(dstDoc.getLastSection().getPageSetup().getOrientation()); dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); dstDoc.save(gDataDir + "TestFile.DifferentPageSetup Out.doc"); //ExEnd
public static void appendDocument_ConvertNumPageFields ( ) throws Exception { Document dstDoc = new Document ( gDataDir + " TestFile.Destination.doc " ) ; Document srcDoc = new Document ( gDataDir + " TestFile.Source.doc " ) ; // Restart the page numbering on the start of the source document. srcDoc.getFirstSection().getPageSetup().setRestartPageNumbering(true); srcDoc.getFirstSection().getPageSetup().setPageStartingNumber(1); // Append the source document to the end of the destination document. dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); // After joining the documents the NUMPAGE fields will now display the total number of pages which // is undesired behaviour. Call this method to fix them by replacing them with PAGEREF fields. convertNumPageFieldsToPageRef(dstDoc); // This needs to be called in order to update the new fields with page numbers. dstDoc.updatePageLayout(); dstDoc.save(gDataDir + "TestFile.ConvertNumPageFields Out.doc"); }
public static void convertNumPageFieldsToPageRef ( Document doc ) throws Exception { // This is the prefix for each bookmark which signals where page numbering restarts. // The underscore "_" at the start inserts this bookmark as hidden in MS Word. final String BOOKMARK_PREFIX = "_SubDocumentEnd"; // Field name of the NUMPAGES field. final String NUM_PAGES_FIELD_NAME = "NUMPAGES"; // Field name of the PAGEREF field. final String PAGE_REF_FIELD_NAME = "PAGEREF"; // Create a new DocumentBuilder which is used to insert the bookmarks and replacement fields. DocumentBuilder builder = new DocumentBuilder(doc); // Defines the number of page restarts that have been encountered and therefore the number of "sub" documents // found within this document. int subDocumentCount = 0; // Iterate through all sections in the document. for (Section section : doc.getSections()) {
public static void appendDocument_ListUseDestinationStyles ( ) throws Exception { //ExStart //ExId:AppendDocument_ListUseDestinationStyles //ExSummary:Shows how to append a document using destination styles and preventing any list numberings from continuing on. Document dstDoc = new Document(gDataDir + "TestFile.DestinationList.doc"); Document srcDoc = new Document(gDataDir + "TestFile.SourceList.doc"); // Set the source document to continue straight after the end of the destination document. srcDoc.getFirstSection().getPageSetup().setSectionStart(SectionStart.CONTINUOUS); // Keep track of the lists that are created. HashMap newLists = new HashMap(); // Iterate through all paragraphs in the document. for (Paragraph para : (Iterable<Paragraph>) srcDoc.getChildNodes(NodeType.PARAGRAPH, true)) { if (para.isListItem()) { int listId = para.getListFormat().getList().getListId(); // Check if the destination document contains a list with this ID already. If it does then this may // cause the two lists to run together. Create a copy of the list in the source document instead. if (dstDoc.getLists().getListByListId(listId) != null) { List currentList; // A newly copied list already exists for this ID, retrieve the stored list and use it on // the current paragraph. if (newLists.containsKey(listId)) { currentList = (List)newLists.get(listId); } else { // Add a copy of this list to the document and store it for later reference. currentList = srcDoc.getLists().addCopy(para.getListFormat().getList()); newLists.put(listId, currentList); } // Set the list of this paragraph to the copied list. para.getListFormat().setList(currentList); } } } // Append the source document to end of the destination document. dstDoc.appendDocument(srcDoc, ImportFormatMode.USE_DESTINATION_STYLES); // Save the combined document to disk. dstDoc.save(gDataDir + "TestFile.ListUseDestinationStyles Out.docx"); //ExEnd
public static void appendDocument_ListKeepSourceFormatting ( ) throws Exception { //ExStart //ExId:AppendDocument_ListKeepSourceFormatting //ExSummary:Shows how to append a document to another document containing lists retaining source formatting. Document dstDoc = new Document(gDataDir + "TestFile.DestinationList.doc"); Document srcDoc = new Document(gDataDir + "TestFile.SourceList.doc"); // Append the content of the document so it flows continuously. srcDoc.getFirstSection().getPageSetup().setSectionStart(SectionStart.CONTINUOUS); dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); dstDoc.save(gDataDir + "TestFile.ListKeepSourceFormatting Out.doc"); //ExEnd
public static void appendDocument_KeepSourceTogether ( ) throws Exception { //ExStart //ExFor:ParagraphFormat.KeepWithNext //ExId:AppendDocument_KeepSourceTogether //ExSummary:Shows how to append a document to another document while keeping the content from splitting across two pages. Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc"); Document srcDoc = new Document(gDataDir + "TestFile.Source.doc"); // Set the source document to appear straight after the destination document's content. srcDoc.getFirstSection().getPageSetup().setSectionStart(SectionStart.CONTINUOUS); // Iterate through all sections in the source document. for(Paragraph para : (Iterable<Paragraph>) srcDoc.getChildNodes(NodeType.PARAGRAPH, true)) { para.getParagraphFormat().setKeepWithNext(true); } dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); dstDoc.save(gDataDir + "TestDcc.KeepSourceTogether Out.doc"); //ExEnd
public static void appendDocument_BaseDocument ( ) throws Exception { //ExStart //ExId:AppendDocument_BaseDocument //ExSummary:Shows how to remove all content from a document before using it as a base to append documents to. // Use a blank document as the destination document. Document dstDoc = new Document(); Document srcDoc = new Document(gDataDir + "TestFile.Source.doc"); // The destination document is not actually empty which often causes a blank page to appear before the appended document // This is due to the base document having an empty section and the new document being started on the next page. // Remove all content from the destination document before appending. dstDoc.removeAllChildren(); dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); dstDoc.save(gDataDir + "TestFile.BaseDocument Out.doc"); //ExEnd
public static void appendDocument_UpdatePageLayout ( ) throws Exception { //ExStart //ExId:AppendDocument_UpdatePageLayout //ExSummary:Shows how to rebuild the document layout after appending further content. Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc"); Document srcDoc = new Document(gDataDir + "TestFile.Source.doc"); // If the destination document is rendered to PDF, image etc or UpdatePageLayout is called before the source document // is appended then any changes made after will not be reflected in the rendered output. dstDoc.updatePageLayout(); // Join the documents. dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); // For the changes to be updated to rendered output, UpdatePageLayout must be called again. // If not called again the appended document will not appear in the output of the next rendering. dstDoc.updatePageLayout(); // Save the joined document to PDF. dstDoc.save(gDataDir + "TestFile.UpdatePageLayout Out.pdf"); //ExEnd
private static String getFieldCode ( FieldStart fieldStart ) throws Exception { StringBuilder builder = new StringBuilder ( ) ; for ( Node node = fieldStart ; node ! = null & & node . getNodeType ( ) ! = NodeType . FIELD_SEPARATOR & & node . getNodeType ( ) ! = NodeType . FIELD_END ; node = node . nextPreOrder ( node . getDocument ( ) ) ) { // Use text only of Run nodes to avoid duplication. if (node.getNodeType() == NodeType.RUN) builder.append(node.getText()); } return builder.toString(); }
private static void removeField ( FieldStart fieldStart ) throws Exception { Node currentNode = fieldStart ; boolean isRemoving = true ; while ( currentNode ! = null & & isRemoving ) {
public void appendDocument ( Document dstDoc , Document srcDoc , int mode ) throws Exception { // Loop through all sections in the source document. // Section nodes are immediate children of the Document node so we can just enumerate the Document. for (Node srcNode : srcDoc) {
public static void prependDocumentMain ( ) throws Exception { Document dstDoc = new Document ( gDataDir + " TestFile.Destination.doc " ) ; Document srcDoc = new Document ( gDataDir + " TestFile.Source.doc " ) ; // Append the source document to the destination document. This causes the result to have line spacing problems. dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); // Instead prepend the content of the destination document to the start of the source document. // This results in the same joined document but with no line spacing issues. prependDocument(srcDoc, dstDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); }
public static void prependDocument ( Document dstDoc , Document srcDoc , int mode ) throws Exception { // Loop through all sections in the source document. // Section nodes are immediate children of the Document node so we can just enumerate the Document. ArrayList sections = (ArrayList)Arrays.asList(srcDoc.getSections().toArray()); // Reverse the order of the sections so they are prepended to start of the destination document in the correct order. Collections.reverse(sections); for (Section srcSection : (Iterable<Section>) sections) {
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; //ExStart //ExId:CustomHandleRegionsMain //ExSummary:Shows how to handle unmerged regions after mail merge with user defined code. // Open the document. Document doc = new Document(dataDir + "TestFile.doc"); // Create a data source which contains empty DataTables with no data. // This will result in some regions that are merged and some that remain after executing mail merge. DataSet data = getDataSource(); // Set the RemoveEmptyRegions to false as we want to handle the unmerged regions manually. doc.getMailMerge().setRemoveEmptyRegions(false); // Execute mail merge. Some regions will be merged with data, others left unmerged. doc.getMailMerge().executeWithRegions(data); // The regions which contained data now would of been merged. Any regions which had no data and were // not merged will still remain in the document. Document mergedDoc = doc.deepClone(); //ExSkip // Apply logic to each empty region left in the document using the logic set out in the handler. // The handler class must implement the IFieldMergingCallback interface. executeCustomLogicOnEmptyRegions(doc, new EmptyRegionsHandler()); // Save the output document to disk. doc.save(dataDir + "TestFile.CustomLogicEmptyRegions1 Out.doc"); //ExEnd // Reload the original merged document. doc = mergedDoc.deepClone(); // Apply different logic to empty regions this time. executeCustomLogicOnEmptyRegions(doc, new EmptyRegionsHandler_MergeTable()); doc.save(dataDir + "TestFile.CustomLogicEmptyRegions2 Out.doc"); // Reload the original merged document. doc = mergedDoc.deepClone(); //ExStart //ExId:HandleContactDetailsRegion //ExSummary:Shows how to specify only the ContactDetails region to be handled through the handler class. // Only handle the ContactDetails region in our handler. ArrayList regions = new ArrayList(); regions.add("ContactDetails"); executeCustomLogicOnEmptyRegions(doc, new EmptyRegionsHandler(), regions); //ExEnd doc.save(dataDir + "TestFile.CustomLogicEmptyRegions3 Out.doc"); }
private static DataSet createDataSourceFromDocumentRegions ( Document doc , ArrayList regionsList ) throws Exception { final String TABLE_START_MARKER = " TableStart: " ; DataSet dataSet = new DataSet ( ) ; String tableName = null ; for ( String fieldName : doc . getMailMerge ( ) . getFieldNames ( ) ) { if ( fieldName . contains ( TABLE_START_MARKER ) ) { tableName = fieldName . substring ( TABLE_START_MARKER . length ( ) ) ; } else if ( tableName ! = null ) { // Only add the table as a new DataTable if it doesn't already exists in the DataSet. if (dataSet.getTables().get(tableName) == null) { ResultSet resultSet = createCachedRowSet(new String[] {fieldName}); // We only need to add the first field for the handler to be called for the fields in the region. if (regionsList == null || regionsList.contains(tableName)) { addRow(resultSet, new String[] {"FirstField"}); } dataSet.getTables().add(new DataTable(resultSet, tableName)); } tableName = null; } } return dataSet; }
public static void executeCustomLogicOnEmptyRegions ( Document doc , IFieldMergingCallback handler ) throws Exception { executeCustomLogicOnEmptyRegions ( doc , handler , null ) ; // Pass null to handle all regions found in the document. }
public static void executeCustomLogicOnEmptyRegions ( Document doc , IFieldMergingCallback handler , ArrayList regionsList ) throws Exception { // Certain regions can be skipped from applying logic to by not adding the table name inside the CreateEmptyDataSource method. // Set this property to true so any regions which are not handled by the user's logic are removed automatically. doc.getMailMerge().setRemoveEmptyRegions(true); // Set the user's handler which is called for each unmerged region. doc.getMailMerge().setFieldMergingCallback(handler); // Execute mail merge using the dummy dataset. The dummy data source contains the table names of // each unmerged region in the document (excluding ones that the user may have specified to be skipped). This will allow the handler // to be called for each field in the unmerged regions. doc.getMailMerge().executeWithRegions(createDataSourceFromDocumentRegions(doc, regionsList)); }
private static ResultSet createCachedRowSet ( String [ ] columnNames ) throws Exception { RowSetMetaDataImpl metaData = new RowSetMetaDataImpl ( ) ; metaData . setColumnCount ( columnNames . length ) ; for ( int i = 0 ; i < columnNames . length ; i + + ) { metaData . setColumnName ( i + 1 , columnNames [ i ] ) ; metaData . setColumnType ( i + 1 , java . sql . Types . VARCHAR ) ; } CachedRowSetImpl rowSet = new CachedRowSetImpl ( ) ; rowSet . setMetaData ( metaData ) ; return rowSet ; }
private static void addRow ( ResultSet resultSet , String [ ] values ) throws Exception { resultSet . moveToInsertRow ( ) ; for ( int i = 0 ; i < values . length ; i + + ) resultSet . updateString ( i + 1 , values [ i ] ) ; resultSet . insertRow ( ) ; // This "dance" is needed to add rows to the end of the result set properly. // If I do something else then rows are either added at the front or the result // set throws an exception about a deleted row during mail merge. resultSet.moveToCurrentRow(); resultSet.last(); }
public void fieldMerging ( FieldMergingArgs args ) throws Exception { // Change the text of each field of the ContactDetails region individually. if ("ContactDetails".equals(args.getTableName())) { // Set the text of the field based off the field name. if ("Name".equals(args.getFieldName())) args.setText("(No details found)"); else if ("Number".equals(args.getFieldName())) args.setText("(N/A)"); } // Remove the entire table of the Suppliers region. Also check if the previous paragraph // before the table is a heading paragraph and if so remove that too. if ("Suppliers".equals(args.getTableName())) {
private boolean isHeadingParagraph ( Paragraph para ) throws Exception { return ( para . getParagraphFormat ( ) . getStyleIdentifier ( ) > = StyleIdentifier . HEADING_1 & & para . getParagraphFormat ( ) . getStyleIdentifier ( ) < = StyleIdentifier . HEADING_9 ) ; }
public void fieldMerging ( FieldMergingArgs args ) throws Exception { //ExStart //ExId:ContactDetailsCodeVariation //ExSummary:Shows how to replace an empty region with a message and remove extra paragraphs. // Store the parent paragraph of the current field for easy access. Paragraph parentParagraph = args.getField().getStart().getParentParagraph(); // Define the logic to be used when the ContactDetails region is encountered. // The region is removed and replaced with a single line of text stating that there are no records. if ("ContactDetails".equals(args.getTableName())) { // Called for the first field encountered in a region. This can be used to execute logic on the first field // in the region without needing to hard code the field name. Often the base logic is applied to the first field and // different logic for other fields. The rest of the fields in the region will have a null FieldValue. if ("FirstField".equals((String)args.getFieldValue())) { // Remove the "Name:" tag from the start of the paragraph parentParagraph.getRange().replace("Name:", "", false, false); // Set the text of the first field to display a message stating that there are no records. args.setText("No records to display"); } else { // We have already inserted our message in the paragraph belonging to the first field. The other paragraphs in the region // will still remain so we want to remove these. A check is added to ensure that the paragraph has not already been removed. // which may happen if more than one field is included in a paragraph. if (parentParagraph.getParentNode() != null) parentParagraph.remove(); } } //ExEnd //ExStart //ExFor:Cell.IsFirstCell //ExId:SuppliersCodeVariation //ExSummary:Shows how to merge all the parent cells of an empty region and display a message within the table. // Replace the empty region in the table with a "no records" message and merge all cells into one. if ("Suppliers".equals(args.getTableName())) {
public void imageFieldMerging ( ImageFieldMergingArgs args ) throws Exception { // Do Nothing } } /** * Returns the data used to merge the TestFile document. * This dataset purposely contains only rows for the StoreDetails region and only a select few for the child region. * The other DataTables are left empty so they will not be merged. */ private static DataSet getDataSource() throws Exception { // Create empty disconnected Java result sets. ResultSet storeDetailsResultSet = createCachedRowSet(new String[]{"ID", "Name", "Address", "City", "Country"}); ResultSet contactDetailsResultSet = createCachedRowSet(new String[]{"ID", "Name", "Number"}); ResultSet suppliersResultSet = createCachedRowSet(new String[] {"ID", "CompanyName", "ContactName"}); // Create new Aspose.Words DataSet and DataTable objects to be used for mail merge. DataSet data = new DataSet(); DataTable storeDetails = new DataTable(storeDetailsResultSet, "StoreDetails"); DataTable contactDetails = new DataTable(contactDetailsResultSet, "ContactDetails"); DataTable suppliers = new DataTable(suppliersResultSet, "Suppliers"); // Add the data to the tables. addRow(storeDetailsResultSet, new String[] {"0", "Hungry Coyote Import Store", "2732 Baker Blvd", "Eugene", "USA"}); addRow(storeDetailsResultSet, new String[] {"1", "Great Lakes Food Market", "City Center Plaza, 516 Main St.", "San Francisco", "USA"}); // Add data to the child table only for the first record. addRow(contactDetailsResultSet, new String[] {"0", "Thomas Hardy", "(206) 555-9857 ext 237"}); addRow(contactDetailsResultSet, new String[] {"0", "Elizabeth Brown", "(206) 555-9857 ext 764"}); // Include the tables in the DataSet. data.getTables().add(storeDetails); data.getTables().add(contactDetails); data.getTables().add(suppliers); // Setup the relation between the parent table (StoreDetails) and the child table (ContactDetails). data.getRelations().add(new DataRelation( null, "StoreDetails", "ContactDetails", new String[] {"ID"}, new String[] {"ID"})); return data; } }
private static DataSet getDataSource ( ) throws Exception { // Create empty disconnected Java result sets. ResultSet storeDetailsResultSet = createCachedRowSet(new String[]{"ID", "Name", "Address", "City", "Country"}); ResultSet contactDetailsResultSet = createCachedRowSet(new String[]{"ID", "Name", "Number"}); ResultSet suppliersResultSet = createCachedRowSet(new String[] {"ID", "CompanyName", "ContactName"}); // Create new Aspose.Words DataSet and DataTable objects to be used for mail merge. DataSet data = new DataSet(); DataTable storeDetails = new DataTable(storeDetailsResultSet, "StoreDetails"); DataTable contactDetails = new DataTable(contactDetailsResultSet, "ContactDetails"); DataTable suppliers = new DataTable(suppliersResultSet, "Suppliers"); // Add the data to the tables. addRow(storeDetailsResultSet, new String[] {"0", "Hungry Coyote Import Store", "2732 Baker Blvd", "Eugene", "USA"}); addRow(storeDetailsResultSet, new String[] {"1", "Great Lakes Food Market", "City Center Plaza, 516 Main St.", "San Francisco", "USA"}); // Add data to the child table only for the first record. addRow(contactDetailsResultSet, new String[] {"0", "Thomas Hardy", "(206) 555-9857 ext 237"}); addRow(contactDetailsResultSet, new String[] {"0", "Elizabeth Brown", "(206) 555-9857 ext 764"}); // Include the tables in the DataSet. data.getTables().add(storeDetails); data.getTables().add(contactDetails); data.getTables().add(suppliers); // Setup the relation between the parent table (StoreDetails) and the child table (ContactDetails). data.getRelations().add(new DataRelation( null, "StoreDetails", "ContactDetails", new String[] {"ID"}, new String[] {"ID"})); return data; }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; // Demonstrate autofitting a table to the window. autoFitTableToWindow(dataDir); // Demonstrate autofitting a table to its contents. autoFitTableToContents(dataDir); // Demonstrate autofitting a table to fixed column widths. autoFitTableToFixedColumnWidths(dataDir); }
public static void autoFitTableToWindow ( String dataDir ) throws Exception { //ExStart //ExFor:Table.AutoFit //ExFor:AutoFitBehavior //ExId:FitTableToPageWidth //ExSummary:Autofits a table to fit the page width. // Open the document Document doc = new Document(dataDir + "TestFile.doc"); Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // Autofit the first table to the page width. table.autoFit(AutoFitBehavior.AUTO_FIT_TO_WINDOW); // Save the document to disk. doc.save(dataDir + "TestFile.AutoFitToWindow Out.doc"); //ExEnd assert(doc.getFirstSection().getBody().getTables().get(0).getPreferredWidth().getType() == PreferredWidthType.PERCENT) : "PreferredWidth type is not percent"; assert(doc.getFirstSection().getBody().getTables().get(0).getPreferredWidth().getValue() == 100) : "PreferredWidth value is different than 100";
public static void autoFitTableToContents ( String dataDir ) throws Exception { //ExStart //ExFor:Table.AutoFit //ExFor:AutoFitBehavior //ExId:FitTableToContents //ExSummary:Autofits a table in the document to its contents. // Open the document Document doc = new Document(dataDir + "TestFile.doc"); Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // Auto fit the table to the cell contents table.autoFit(AutoFitBehavior.AUTO_FIT_TO_CONTENTS); // Save the document to disk. doc.save(dataDir + "TestFile.AutoFitToContents Out.doc"); //ExEnd assert(doc.getFirstSection().getBody().getTables().get(0).getPreferredWidth().getType() == PreferredWidthType.AUTO) : "PreferredWidth type is not auto"; assert(doc.getFirstSection().getBody().getTables().get(0).getFirstRow().getFirstCell().getCellFormat().getPreferredWidth().getType() == PreferredWidthType.AUTO) : "PrefferedWidth on cell is not auto"; assert(doc.getFirstSection().getBody().getTables().get(0).getFirstRow().getFirstCell().getCellFormat().getPreferredWidth().getValue() == 0) : "PreferredWidth value is not 0"; }
public static void autoFitTableToFixedColumnWidths ( String dataDir ) throws Exception { //ExStart //ExFor:Table.AutoFit //ExFor:AutoFitBehavior //ExId:DisableAutoFitAndUseFixedWidths //ExSummary:Disables autofitting and enables fixed widths for the specified table. // Open the document Document doc = new Document(dataDir + "TestFile.doc"); Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // Disable autofitting on this table. table.autoFit(AutoFitBehavior.FIXED_COLUMN_WIDTHS); // Save the document to disk. doc.save(dataDir + "TestFile.FixedWidth Out.doc"); //ExEnd assert(doc.getFirstSection().getBody().getTables().get(0).getPreferredWidth().getType() == PreferredWidthType.AUTO) : "PreferredWidth type is not auto"; assert(doc.getFirstSection().getBody().getTables().get(0).getPreferredWidth().getValue() == 0) : "PreferredWidth value is not 0"; assert(doc.getFirstSection().getBody().getTables().get(0).getFirstRow().getFirstCell().getCellFormat().getWidth() == 69.2) : "Cell width is not correct."; }
public static void main ( String [ ] args ) throws Exception { // The sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; String supportedDir = dataDir + "OutSupported" + File.separator; String unknownDir = dataDir + "OutUnknown" + File.separator; String encryptedDir = dataDir + "OutEncrypted" + File.separator; String pre97Dir = dataDir + "OutPre97" + File.separator; //ExStart //ExId:CheckFormat_Folder //ExSummary:Get the list of all files in the dataDir folder. File[] fileList = new java.io.File(dataDir).listFiles(); //ExEnd //ExStart //ExFor:FileFormatInfo //ExFor:FileFormatUtil //ExFor:FileFormatUtil.DetectFileFormat(String) //ExFor:LoadFormat //ExId:CheckFormat_Main //ExSummary:Check each file in the folder and move it to the appropriate subfolder. // Loop through all found files. for (File file : fileList) {
private static void fileCopy ( String sourceFileName , String destinationFileName ) throws Exception { File sourceFile = new File ( sourceFileName ) ; File destinationFile = new File ( destinationFileName ) ; File directoryFile = new File ( destinationFile . getParent ( ) ) ; if ( ! directoryFile . exists ( ) ) directoryFile . mkdir ( ) ; FileInputStream fis = null ; FileOutputStream fos = null ; try {
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; String srcFileName = dataDir + "Test.docx"; System.out.println(MessageFormat.format("Loading {0}. Size {1}.", srcFileName, getFileSize(srcFileName))); Document doc = new Document(srcFileName); // 220ppi Print - said to be excellent on most printers and screens. // 150ppi Screen - said to be good for web pages and projectors. // 96ppi Email - said to be good for minimal document size and sharing. final int desiredPpi = 150; // In Java this seems to be a good compression / quality setting. final int jpegQuality = 90; // Resample images to desired ppi and save. int count = Resampler.resample(doc, desiredPpi, jpegQuality); System.out.println(MessageFormat.format("Resampled {0} images.", count)); if (count != 1) System.out.println("We expected to have only 1 image resampled in this test document!"); String dstFileName = srcFileName + ".Resampled Out.docx"; doc.save(dstFileName); System.out.println(MessageFormat.format("Saving {0}. Size {1}.", dstFileName, getFileSize(dstFileName))); // Verify that the first image was compressed by checking the new Ppi. doc = new Document(dstFileName); DrawingML shape = (DrawingML)doc.getChild(NodeType.DRAWING_ML, 0, true); double imagePpi = shape.getImageData().getImageSize().getWidthPixels() / ConvertUtil.pointToInch(shape.getSize().getX()); assert (imagePpi < 150) : "Image was not resampled successfully."; }
public static int getFileSize ( String fileName ) throws Exception { File file = new File ( fileName ) ; return ( int ) file . length ( ) ; }
public static int resample ( Document doc , int desiredPpi , int jpegQuality ) throws Exception { int count = 0 ; // Convert VML shapes. for (Shape vmlShape : (Iterable<Shape>) doc.getChildNodes(NodeType.SHAPE, true, false)) { // It is important to use this method to correctly get the picture shape size in points even if the picture is inside a group shape. Point2D.Float shapeSizeInPoints = vmlShape.getSizeInPoints(); if (resampleCore(vmlShape.getImageData(), shapeSizeInPoints, desiredPpi, jpegQuality)) count++; } // Convert DrawingML shapes. for (DrawingML dmlShape : (Iterable<DrawingML>) doc.getChildNodes(NodeType.DRAWING_ML, true, false)) { // In MS Word the size of a DrawingML shape is always in points at the moment. Point2D.Float shapeSizeInPoints = dmlShape.getSize(); if (resampleCore(dmlShape.getImageData(), shapeSizeInPoints, desiredPpi, jpegQuality)) count++; } return count; }
private static int getResampledImageType ( int srcImageType ) { // In general, we want to preserve the image color model, but some things need to be taken care of. switch (srcImageType) {
public static void main ( String [ ] args ) throws Exception { URI exeDir = Program . class . getResource ( " " ) . toURI ( ) ; String dataDir = new File ( exeDir . resolve ( " ../../Data " ) ) + File . separator ; // Load the source document. Document srcDoc = new Document(dataDir + "Template.doc"); // This is the bookmark whose content we want to copy. Bookmark srcBookmark = srcDoc.getRange().getBookmarks().get("ntf010145060"); // We will be adding to this document. Document dstDoc = new Document(); // Let's say we will be appending to the end of the body of the last section. CompositeNode dstNode = dstDoc.getLastSection().getBody(); // It is a good idea to use this import context object because multiple nodes are being imported. // If you import multiple times without a single context, it will result in many styles created. NodeImporter importer = new NodeImporter(srcDoc, dstDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); // Do it once. appendBookmarkedText(importer, srcBookmark, dstNode); // Do it one more time for fun. appendBookmarkedText(importer, srcBookmark, dstNode); // Save the finished document. dstDoc.save(dataDir + "Template Out.doc"); }
private static void appendBookmarkedText ( NodeImporter importer , Bookmark srcBookmark , CompositeNode dstNode ) throws Exception { // This is the paragraph that contains the beginning of the bookmark. Paragraph startPara = (Paragraph)srcBookmark.getBookmarkStart().getParentNode(); // This is the paragraph that contains the end of the bookmark. Paragraph endPara = (Paragraph)srcBookmark.getBookmarkEnd().getParentNode(); if ((startPara == null) || (endPara == null)) throw new IllegalStateException("Parent of the bookmark start or end is not a paragraph, cannot handle this scenario yet."); // Limit ourselves to a reasonably simple scenario. if (startPara.getParentNode() != endPara.getParentNode()) throw new IllegalStateException("Start and end paragraphs have different parents, cannot handle this scenario yet."); // We want to copy all paragraphs from the start paragraph up to (and including) the end paragraph, // therefore the node at which we stop is one after the end paragraph. Node endNode = endPara.getNextSibling(); // This is the loop to go through all paragraph-level nodes in the bookmark. for (Node curNode = startPara; curNode != endNode; curNode = curNode.getNextSibling()) {
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; String dbName = dataDir + "DocDB.mdb"; final String FILE_NAME = "TestFile.doc"; // Create a connection to the database. createConnection(dbName); // Open the document. Document doc = new Document(dataDir + FILE_NAME); //ExStart //ExId:DocumentInDB_Main //ExSummary:Stores the document to a database, then reads the same document back again, and finally deletes the record containing the document from the database. // Store the document to the database. storeToDatabase(doc); // Read the document from the database and store the file to disk. Document dbDoc = readFromDatabase(FILE_NAME); // Save the retrieved document to disk. String newFileName = new File(FILE_NAME).getName() + " from DB" + FILE_NAME.substring(FILE_NAME.lastIndexOf(".")); dbDoc.save(dataDir + newFileName); // Delete the document from the database. deleteFromDatabase(FILE_NAME); //ExEnd
public static void storeToDatabase ( Document doc ) throws Exception { // Save the document to a OutputStream object. ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); doc.save(outputStream, SaveFormat.DOC); // Get the filename from the document. String fileName = new File(doc.getOriginalFileName()).getName(); // Create the SQL command. String commandString = "INSERT INTO Documents (FileName, FileContent) VALUES(?, ?)"; // Prepare the statement to store the data into the database. PreparedStatement statement = mConnection.prepareStatement(commandString); // Add the parameter value for FileName. statement.setString(1, fileName); // Add the parameter value for FileContent. statement.setBinaryStream(2, new ByteArrayInputStream(outputStream.toByteArray()), outputStream.size()); // Execute and commit the changes. statement.execute(); mConnection.commit(); }
public static Document readFromDatabase ( String fileName ) throws Exception { // Create the SQL command. String commandString = "SELECT * FROM Documents WHERE FileName='" + fileName + "'"; // Retrieve the results from the database. ResultSet resultSet = executeQuery(commandString); // Check there was a matching record found from the database and throw an exception if no record was found. if(!resultSet.isBeforeFirst()) throw new IllegalArgumentException(MessageFormat.format("Could not find any record matching the document \"{0}\" in the database.", fileName)); // Move to the first record. resultSet.next(); // The document is stored in byte form in the FileContent column. // Retrieve these bytes of the first matching record to a new buffer. byte[] buffer = resultSet.getBytes("FileContent"); // Wrap the bytes from the buffer into a new ByteArrayInputStream object. ByteArrayInputStream newStream = new ByteArrayInputStream(buffer); // Read the document from the input stream. Document doc = new Document(newStream); // Return the retrieved document. return doc;
public static void deleteFromDatabase ( String fileName ) throws Exception { // Create the SQL command. String commandString = "DELETE * FROM Documents WHERE FileName='" + fileName + "'"; // Execute the command. createStatement().executeUpdate(commandString); }
public static void createConnection ( String dataBasePath ) throws Exception { // Load a DB driver that is used by the demos Class.forName("sun.jdbc.odbc.JdbcOdbcDriver"); // The path to the database on the disk. File dataBase = new File(dataBasePath); // Compose connection string. String connectionString = "jdbc:odbc:DRIVER={Microsoft Access Driver (*.mdb)};" + "DBQ=" + dataBase + ";UID=Admin"; // Create a connection to the database. mConnection = DriverManager.getConnection(connectionString); }
protected static ResultSet executeQuery ( String query ) throws Exception { return createStatement ( ) . executeQuery ( query ) ; }
public static Statement createStatement ( ) throws Exception { return mConnection . createStatement ( ResultSet . TYPE_SCROLL_INSENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; }
public void setPrinterAttributes ( PrintRequestAttributeSet attributes ) { // Store the printer attributes for use with the page dialog. mAttributeSet = attributes; // Extract the page range from the printer attributes if that property is present. findPageRangeFromAttributes(attributes); }
public void init ( ) { // Setup the main window setContentPane(contentPane); pack(); setTitle("Print preview"); // Center the dialog in the center of the page. setLocationRelativeTo(null); // Add zoom options. populateZoomComboBox(); // Pageable print classes already have page formatting applied so disable page setup button. if(mPageableDoc != null) pageSetupButton.setEnabled(false); // Make the page number centered horizontally. SimpleAttributeSet aSet = new SimpleAttributeSet(); StyleConstants.setFontFamily(aSet, "Arial"); StyleConstants.setAlignment(aSet, StyleConstants.ALIGN_CENTER); pageNumberTextBox.setParagraphAttributes(aSet, true); // Setup the appropriate handlers. printButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { onPrint(); } }); pageSetupButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { onPageSetup(); } }); zoomComboBox.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { onZoomChanged(); } }); firstPageButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { onFirstPageSelected(); } }); previousPageButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { onPreviousPageSelected(); } }); lastPageButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { onLastPageSelected(); } }); nextPageButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { onNextPageSelected(); } }); closeButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { closeWindow(); } }); setDefaultCloseOperation(DO_NOTHING_ON_CLOSE); addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) { closeWindow(); } }); contentPane.registerKeyboardAction(new ActionListener() { public void actionPerformed(ActionEvent e) {
public void actionPerformed ( ActionEvent e ) { onPrint ( ) ; }
public void actionPerformed ( ActionEvent e ) { onPageSetup ( ) ; }
public void actionPerformed ( ActionEvent e ) { onZoomChanged ( ) ; }
public void actionPerformed ( ActionEvent e ) { onFirstPageSelected ( ) ; }
public void actionPerformed ( ActionEvent e ) { onPreviousPageSelected ( ) ; }
public void actionPerformed ( ActionEvent e ) { onLastPageSelected ( ) ; }
public void actionPerformed ( ActionEvent e ) { onNextPageSelected ( ) ; }
public void actionPerformed ( ActionEvent e ) { closeWindow ( ) ; }
public void windowClosing ( WindowEvent e ) { closeWindow ( ) ; }
public boolean display ( ) { // Activate the window. setVisible(true); // Render the current page. setPageToDisplay(mCurrentPage); // This causes the JFrame to act like modal. We want to use a JFrame in this way and not JDialog so // we can have a taskbar icon for this window. while(mIsOpened) {} // Return whether the user pressed print or close. return mPrintSelected; }
private int renderImageAndDisplay ( ) { // Set the progress bar to loading. progressBar.setVisible(true); progressBar.setIndeterminate(true); BufferedImage img = null; Graphics2D g; // The zoom factor currently selected. double zoomModifier = getCurrentZoomModifier(); // Clear the current image. imageLabel.setIcon(null); int result; // Find the format of the current page from either the current pageable or printable object we are printing with. PageFormat format = mPageableDoc != null ? mPageableDoc.getPageFormat(mCurrentPage - 1) : mPageFormat; try { img = new BufferedImage((int)(format.getWidth() * zoomModifier), (int)(format.getHeight() * zoomModifier), BufferedImage.TYPE_INT_RGB); g = img.createGraphics(); // Fill the background white and add a black border. g.setColor(Color.WHITE); g.fillRect(0, 0, img.getWidth(), img.getHeight()); g.setColor(Color.BLACK); g.drawRect(0, 0, img.getWidth() - 1, img.getHeight() - 1); // Scale based on zoom factor. g.scale(zoomModifier, zoomModifier); // We must re-size the image label so scrolling works properly. imageLabel.setPreferredSize(new Dimension(img.getWidth(), img.getHeight())); imageLabel.setMinimumSize(new Dimension(img.getWidth(), img.getHeight())); imageLabel.setMaximumSize(new Dimension(img.getWidth(), img.getHeight())); // Call the pageable or printable class to render the specified page onto our image object. if(mPageableDoc != null) result = mPageableDoc.getPrintable(mCurrentPage - 1).print(g, format, mCurrentPage - 1); else result = mPrintableDoc.print(g, format, mCurrentPage - 1); } catch(Exception e) { // We'll end up here if there is a problem with rendering or we have gone past the valid page range. // Display a blank page and return the result so we know we have gone past the last page. return Printable.NO_SUCH_PAGE; } finally { // Hide the progress bar. progressBar.setVisible(false); } // Display the rendered page. imageLabel.setIcon(new ImageIcon( img )); return result; }
private void findPageRangeFromAttributes ( PrintRequestAttributeSet attributes ) { if ( attributes . containsKey ( PageRanges . class ) ) {
private void setPageToDisplay ( int page ) { mCurrentPage = page ; updateCurrentPage ( ) ; }
private void populateZoomComboBox ( ) { zoomComboBox . addItem ( " 10% " ) ; zoomComboBox . addItem ( " 25% " ) ; zoomComboBox . addItem ( " 50% " ) ; zoomComboBox . addItem ( " 75% " ) ; zoomComboBox . addItem ( " 100% " ) ; zoomComboBox . addItem ( " 150% " ) ; zoomComboBox . addItem ( " 200% " ) ; zoomComboBox . setSelectedIndex ( 4 ) ; mPreviousZoomIndex = zoomComboBox . getSelectedIndex ( ) ; }
private double getCurrentZoomModifier ( ) { String zoomLevel = ( ( String ) zoomComboBox . getSelectedItem ( ) ) . replace ( " % " , " " ) ; // Percent increase of the original image to make the page displayed at 100%. double hundredPercent = 1.5; // Zoom level percent as a decimal. double zoomValue = Double.parseDouble(zoomLevel) / 100; return hundredPercent * zoomValue; }
private void updateCurrentPage ( ) { // If we don't know the total pages in the document then we also won't know the final page count in the document // until we try to render outside the valid index. Until then allow the user to move forward no matter the current // page index. if(knowsDocumentPages()) { if(mCurrentPage > mTotalPages) return; } // Can't move past the first page. if(mCurrentPage < mStartPage) return; int result = renderImageAndDisplay(); // If the rendering of the previous page resulted in "NO_SUCH_PAGE" then // we must have found the last page in the document. The appropriate page numbers // needs to be updated. if(result == Printable.NO_SUCH_PAGE) { // If this occurs at the very start of the document preview then the intial starting page // must be out of bounds. Default to page one instead. if(mCurrentPage == mStartPage) { mCurrentPage = 1; mStartPage = 1; } else { mCurrentPage--; // If the next page document button was pressed and there's no futher pages to render then // we must have found the end page of the document. mTotalPages = mCurrentPage; mDocumentPages = mCurrentPage; } // Render the previous page which is the last page in the document. renderImageAndDisplay(); } pageNumberTextBox.setText(String.valueOf((mCurrentPage - mStartPage) + 1)); updateArrowButtons(); }
private void updateArrowButtons ( ) { if ( mCurrentPage > mStartPage ) { firstPageButton . setEnabled ( true ) ; previousPageButton . setEnabled ( true ) ; } else { firstPageButton . setEnabled ( false ) ; previousPageButton . setEnabled ( false ) ; } if ( knowsDocumentPages ( ) ) {
private boolean knowsDocumentPages ( ) { return mDocumentPages > 0 ; }
private void closeWindow ( ) { setVisible ( false ) ; mIsOpened = false ; dispose ( ) ; }
private void onPageSetup ( ) { // Retrieve the new page format from either the attributes if specified otherwise the previous page formatting. if(mAttributeSet != null) mPageFormat = mPrintJob.pageDialog(mAttributeSet); else mPageFormat = mPrintJob.pageDialog(mPageFormat); // Print using the new page format. mPrintJob.setPrintable(mPrintableDoc, mPageFormat); // Update the preview of the new settings. updateCurrentPage(); }
private void onPrint ( ) { mPrintSelected = true ; closeWindow ( ) ; }
private void onZoomChanged ( ) { if ( mPreviousZoomIndex ! = zoomComboBox . getSelectedIndex ( ) ) {
private void onFirstPageSelected ( ) { setPageToDisplay ( mStartPage ) ; }
private void onNextPageSelected ( ) { setPageToDisplay ( mCurrentPage + 1 ) ; }
private void onLastPageSelected ( ) { setPageToDisplay ( mTotalPages ) ; }
private void onPreviousPageSelected ( ) { setPageToDisplay ( mCurrentPage - 1 ) ; }
private void createUIComponents ( ) { previousPageButton = new BasicArrowButton ( BasicArrowButton . WEST ) ; nextPageButton = new BasicArrowButton ( BasicArrowButton . EAST ) ; firstPageButton = new DoubleArrowButton ( BasicArrowButton . WEST ) ; lastPageButton = new DoubleArrowButton ( BasicArrowButton . EAST ) ; }
public void paintTriangle ( Graphics g , int x , int y , int size , int direction , boolean isEnabled ) { super . paintTriangle ( g , x - ( size / 2 ) , y , size , mArrowType , isEnabled ) ; super . paintTriangle ( g , x + ( size / 2 ) , y , size , mArrowType , isEnabled ) ; }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; // Open the document. Document doc = new Document(dataDir + "TestFile.doc"); //ExStart //ExId:DocumentPreviewAndPrint_PrintDialog_Creation //ExSummary:Creates the print dialog. PrinterJob pj = PrinterJob.getPrinterJob(); // Initialize the Print Dialog with the number of pages in the document. PrintRequestAttributeSet attributes = new HashPrintRequestAttributeSet(); attributes.add(new PageRanges(1, doc.getPageCount())); //ExEnd //ExStart //ExId:DocumentPreviewAndPrint_PrintDialog_Check_Result //ExSummary:Check if the user accepted the print and proceed to preview the document. // Proceed with print preview only if the user accepts the print dialog. if (!pj.printDialog(attributes)) return; //ExEnd //ExStart //ExId:DocumentPreviewAndPrint_AsposeWordsPrintDocument_Creation //ExSummary:Creates a special Aspose.Words implementation of the Java Pageable interface. // This object is responsible for rendering our document for use with the Java Print API. AsposeWordsPrintDocument awPrintDoc = new AsposeWordsPrintDocument(doc); // Pass our document as pageable to the printer job. pj.setPageable(awPrintDoc); //ExEnd //ExStart //ExId:DocumentPreviewAndPrint_ActivePrintPreviewDialog_Creation //ExSummary:Creates a custom Print Preview dialog which accepts a Printable or Pageable object and displays a preview of the document. // Create an instance of the print preview dialog and pass the print dialog and our document. // Note that AsposeWordsPrintDocument implements both the Pageable and Printable interfaces. If the pageable constructor for PrintPreviewDialog // is used then the formatting of each page is taken from the document. If the printable constructor is used then Page Setup dialog becomes enabled // and the desired page setting for all pages can be chosen there instead. PrintPreviewDialog previewDlg = new PrintPreviewDialog(awPrintDoc); // Pass the desired page range attributes to the print preview dialog. previewDlg.setPrinterAttributes(attributes); // Proceed with printing if the user accepts the print preview. if(previewDlg.display()) pj.print(attributes);
public void setUp ( ) throws Exception { setUnlimitedLicense ( ) ; }
static void setUnlimitedLicense ( ) throws Exception { if ( new File ( TEST_LICENSE_FILE_NAME ) . exists ( ) ) {
static void removeLicense ( ) throws Exception { License license = new License ( ) ; license . setLicense ( " " ) ; }
static URI getAssemblyDir ( ) throws Exception { return G_ASSEMBLY_DIR ; }
static String getMyDir ( ) throws Exception { return G_MY_DIR ; }
static String getDatabaseDir ( ) throws Exception { return G_DATABASE_DIR ; }
static java . sql . ResultSet createCachedRowSet ( String [ ] columnNames ) throws Exception { RowSetMetaDataImpl metaData = new RowSetMetaDataImpl ( ) ; metaData . setColumnCount ( columnNames . length ) ; for ( int i = 0 ; i < columnNames . length ; i + + ) { metaData . setColumnName ( i + 1 , columnNames [ i ] ) ; metaData . setColumnType ( i + 1 , java . sql . Types . VARCHAR ) ; } com . sun . rowset . CachedRowSetImpl rowSet = new com . sun . rowset . CachedRowSetImpl ( ) ; rowSet . setMetaData ( metaData ) ; return rowSet ; }
static void addRow ( java . sql . ResultSet resultSet , String [ ] values ) throws Exception { resultSet . moveToInsertRow ( ) ; for ( int i = 0 ; i < values . length ; i + + ) resultSet . updateString ( i + 1 , values [ i ] ) ; resultSet . insertRow ( ) ; // This "dance" is needed to add rows to the end of the result set properly. // If I do something else then rows are either added at the front or the result // set throws an exception about a deleted row during mail merge. resultSet.moveToCurrentRow(); resultSet.last(); }
public void bookmarkNameAndText ( ) throws Exception { //ExStart //ExFor:Bookmark //ExFor:Bookmark.Name //ExFor:Bookmark.Text //ExFor:Range.Bookmarks //ExId:BookmarksGetNameSetText //ExSummary:Shows how to get or set bookmark name and text. Document doc = new Document(getMyDir() + "Bookmark.doc"); // Use the indexer of the Bookmarks collection to obtain the desired bookmark. Bookmark bookmark = doc.getRange().getBookmarks().get("MyBookmark"); // Get the name and text of the bookmark. String name = bookmark.getName(); String text = bookmark.getText(); // Set the name and text of the bookmark. bookmark.setName("RenamedBookmark"); bookmark.setText("This is a new bookmarked text."); //ExEnd Assert.assertEquals(name, "MyBookmark"); Assert.assertEquals(text, "This is a bookmarked text."); }
public void bookmarkRemove ( ) throws Exception { //ExStart //ExFor:Bookmark.Remove //ExSummary:Shows how to remove a particular bookmark from a document. Document doc = new Document(getMyDir() + "Bookmark.doc"); // Use the indexer of the Bookmarks collection to obtain the desired bookmark. Bookmark bookmark = doc.getRange().getBookmarks().get("MyBookmark"); // Remove the bookmark. The bookmarked text is not deleted. bookmark.remove(); //ExEnd Assert.assertEquals(doc.getRange().getBookmarks().getCount(), 0); }
public void ClearBookmarks ( ) throws Exception { //ExStart //ExFor:BookmarkCollection.Clear //ExSummary:Shows how to remove all bookmarks from a document. Document doc = new Document(getMyDir() + "Bookmark.doc"); doc.getRange().getBookmarks().clear(); //ExEnd // Verify that the bookmarks were removed from the document. Assert.assertEquals(doc.getRange().getBookmarks().getCount(), 0); }
public void accessBookmarks ( ) throws Exception { //ExStart //ExFor:BookmarkCollection //ExFor:BookmarkCollection.Item(Int32) //ExFor:BookmarkCollection.Item(String) //ExId:BookmarksAccess //ExSummary:Shows how to obtain bookmarks from a bookmark collection. Document doc = new Document(getMyDir() + "Bookmarks.doc"); // By index. Bookmark bookmark1 = doc.getRange().getBookmarks().get(0); // By name. Bookmark bookmark2 = doc.getRange().getBookmarks().get("Bookmark2"); //ExEnd
public void bookmarkCollectionRemove ( ) throws Exception { //ExStart //ExFor:BookmarkCollection.Remove(Bookmark) //ExFor:BookmarkCollection.Remove(String) //ExFor:BookmarkCollection.RemoveAt //ExSummary:Demonstrates different methods of removing bookmarks from a document. Document doc = new Document(getMyDir() + "Bookmarks.doc"); // Remove a particular bookmark from the document. Bookmark bookmark = doc.getRange().getBookmarks().get(0); doc.getRange().getBookmarks().remove(bookmark); // Remove a bookmark by specified name. doc.getRange().getBookmarks().remove("Bookmark2"); // Remove a bookmark at the specified index. doc.getRange().getBookmarks().removeAt(0); //ExEnd Assert.assertEquals(doc.getRange().getBookmarks().getCount(), 0); }
public void bookmarksInsertBookmark ( ) throws Exception { //ExStart //ExId:BookmarksInsertBookmark //ExSummary:Shows how to create a new bookmark. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.startBookmark("MyBookmark"); builder.writeln("Text inside a bookmark."); builder.endBookmark("MyBookmark"); //ExEnd
public void GetBookmarkCount ( ) throws Exception { //ExStart //ExFor:BookmarkCollection.Count //ExSummary:Shows how to count the number of bookmarks in a document. Document doc = new Document(getMyDir() + "Bookmark.doc"); int count = doc.getRange().getBookmarks().getCount(); //ExEnd Assert.assertEquals(count, 1); }
public void fontBorder ( ) throws Exception { //ExStart //ExFor:Border //ExFor:Border.Color //ExFor:Border.LineWidth //ExFor:Border.LineStyle //ExFor:Font.Border //ExFor:LineStyle //ExFor:Font //ExFor:DocumentBuilder.Font //ExFor:DocumentBuilder.Write //ExSummary:Inserts a string surrounded by a border into a document. DocumentBuilder builder = new DocumentBuilder(); builder.getFont().getBorder().setColor(Color.GREEN); builder.getFont().getBorder().setLineWidth(2.5); builder.getFont().getBorder().setLineStyle(LineStyle.DASH_DOT_STROKER); builder.write("run of text in a green border"); //ExEnd
public void paragraphTopBorder ( ) throws Exception { //ExStart //ExFor:BorderCollection //ExFor:Border //ExFor:BorderType //ExFor:DocumentBuilder.ParagraphFormat //ExFor:DocumentBuilder.Writeln(String) //ExSummary:Inserts a paragraph with a top border. DocumentBuilder builder = new DocumentBuilder(); Border topBorder = builder.getParagraphFormat().getBorders().getByBorderType(BorderType.TOP); topBorder.setColor(Color.RED); topBorder.setLineStyle(LineStyle.DASH_SMALL_GAP); topBorder.setLineWidth(4); builder.writeln("Hello World!"); //ExEnd
public void verticalMerge ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertCell //ExFor:DocumentBuilder.EndRow //ExFor:CellMerge //ExFor:CellFormat.VerticalMerge //ExId:VerticalMerge //ExSummary:Creates a table with two columns with cells merged vertically in the first column. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.insertCell(); builder.getCellFormat().setVerticalMerge(CellMerge.FIRST); builder.write("Text in merged cells."); builder.insertCell(); builder.getCellFormat().setVerticalMerge(CellMerge.NONE); builder.write("Text in one cell"); builder.endRow(); builder.insertCell(); // This cell is vertically merged to the cell above and should be empty. builder.getCellFormat().setVerticalMerge(CellMerge.PREVIOUS); builder.insertCell(); builder.getCellFormat().setVerticalMerge(CellMerge.NONE); builder.write("Text in another cell"); builder.endRow(); //ExEnd
public void horizontalMerge ( ) throws Exception { //ExStart //ExFor:CellMerge //ExFor:CellFormat.HorizontalMerge //ExId:HorizontalMerge //ExSummary:Creates a table with two rows with cells in the first row horizontally merged. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.insertCell(); builder.getCellFormat().setHorizontalMerge(CellMerge.FIRST); builder.write("Text in merged cells."); builder.insertCell(); // This cell is merged to the previous and should be empty. builder.getCellFormat().setHorizontalMerge(CellMerge.PREVIOUS); builder.endRow(); builder.insertCell(); builder.getCellFormat().setHorizontalMerge(CellMerge.NONE); builder.write("Text in one cell."); builder.insertCell(); builder.write("Text in another cell."); builder.endRow(); //ExEnd
public void acceptAllRevisions ( ) throws Exception { //ExStart //ExFor:Document.AcceptAllRevisions //ExId:AcceptAllRevisions //ExSummary:Shows how to accept all tracking changes in the document. Document doc = new Document(getMyDir() + "Document.doc"); doc.acceptAllRevisions(); //ExEnd
private static void copyFile ( File srcFile , File dstFile ) throws IOException { FileInputStream srcStream = null ; FileOutputStream dstStream = null ; try {
public void licenseFromFileNoPath ( ) throws Exception { // Copy a license to the bin folder so the examples can execute. // The directory must be specified one level up because the class file will be in a subfolder according // to the package name, but the licensing code looks at the "root" folder of the jar only. File dstFile = new File(ExDocument.class.getResource("").toURI().resolve("../Aspose.Words.Java.lic")); copyFile(new File(TEST_LICENSE_FILE_NAME), dstFile); //ExStart //ExFor:License //ExFor:License.#ctor //ExFor:License.SetLicense(String) //ExId:LicenseFromFileNoPath //ExSummary:In this example Aspose.Words will attempt to find the license file in folders that contain the JARs of your application. License license = new License(); license.setLicense("Aspose.Words.Java.lic"); //ExEnd // Cleanup by removing the license. license.setLicense(""); dstFile.delete(); }
public void licenseFromStream ( ) throws Exception { InputStream myStream = new FileInputStream ( TEST_LICENSE_FILE_NAME ) ; try {
public void documentCtor ( ) throws Exception { //ExStart //ExId:DocumentCtor //ExSummary:Shows how to create a blank document. Note the blank document contains one section and one paragraph. Document doc = new Document(); //ExEnd
public void openFromFile ( ) throws Exception { //ExStart //ExFor:Document.#ctor(String) //ExId:OpenFromFile //ExSummary:Opens a document from a file. // Open a document. The file is opened read only and only for the duration of the constructor. Document doc = new Document(getMyDir() + "Document.doc"); //ExEnd //ExStart //ExFor:Document.Save(String) //ExId:SaveToFile //ExSummary:Saves a document to a file. doc.save(getMyDir() + "Document.OpenFromFile Out.doc"); //ExEnd
public void openAndSaveToFile ( ) throws Exception { //ExStart //ExId:OpenAndSaveToFile //ExSummary:Opens a document from a file and saves it to a different format Document doc = new Document(getMyDir() + "Document.doc"); doc.save(getMyDir() + "Document Out.html"); //ExEnd
public void loadEncryptedFromStream ( ) throws Exception { //ExStart //ExFor:Document.#ctor(Stream,LoadOptions) //ExSummary:Loads a Microsoft Word document encrypted with a password from a stream. InputStream stream = new FileInputStream(getMyDir() + "Document.LoadEncrypted.doc"); Document doc = new Document(stream, new LoadOptions("qwerty")); stream.close(); //ExEnd
public void openDocumentFromWeb ( ) throws Exception { //ExStart //ExFor:Document.#ctor(Stream) //ExSummary:Retrieves a document from a URL and saves it to disk in a different format. // This is the URL pointing to where to find the document. URL url = new URL("http://www.aspose.com/demos/.net-components/aspose.words/csharp/general/Common/Documents/DinnerInvitationDemo.doc"); // The easiest way to load our document from the internet is make use of the URLConnection class. URLConnection webClient = url.openConnection(); // Download the bytes from the location referenced by the URL. InputStream inputStream = webClient.getInputStream(); // Convert the input stream to a byte array. int pos; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while ((pos = inputStream.read()) != -1) bos.write(pos); byte[] dataBytes = bos.toByteArray(); // Wrap the bytes representing the document in memory into a stream object. ByteArrayInputStream byteStream = new ByteArrayInputStream(dataBytes); // Load this memory stream into a new Aspose.Words Document. // The file format of the passed data is inferred from the content of the bytes itself. // You can load any document format supported by Aspose.Words in the same way. Document doc = new Document(byteStream); // Convert the document to any format supported by Aspose.Words. doc.save(getMyDir() + "Document.OpenFromWeb Out.docx"); //ExEnd
public void insertHtmlFromWebPage ( ) throws Exception { //ExStart //ExFor:Document.#ctor(Stream, LoadOptions) //ExFor:LoadOptions.#ctor(LoadFormat, String, String) //ExFor:LoadFormat //ExSummary:Shows how to insert the HTML contents from a web page into a new document. // The url of the page to load URL url = new URL("http://www.aspose.com/"); // The easiest way to load our document from the internet is make use of the URLConnection class. URLConnection webClient = url.openConnection(); // Download the bytes from the location referenced by the URL. InputStream inputStream = webClient.getInputStream(); // Convert the input stream to a byte array. int pos; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while ((pos = inputStream.read()) != -1) bos.write(pos); byte[] dataBytes = bos.toByteArray(); // Wrap the bytes representing the document in memory into a stream object. ByteArrayInputStream byteStream = new ByteArrayInputStream(dataBytes); // The baseUri property should be set to ensure any relative img paths are retrieved correctly. LoadOptions options = new LoadOptions(LoadFormat.HTML, "", url.getPath()); // Load the HTML document from stream and pass the LoadOptions object. Document doc = new Document(byteStream, options); // Save the document to disk. // The extension of the filename can be changed to save the document into other formats. e.g PDF, DOCX, ODT, RTF. doc.save(getMyDir() + "Document.HtmlPageFromWebpage Out.doc"); //ExEnd
public void openFromStreamWithBaseUri ( ) throws Exception { //ExStart //ExFor:Document.#ctor(Stream,LoadOptions) //ExFor:LoadOptions //ExFor:LoadOptions.BaseUri //ExId:DocumentCtor_LoadOptions //ExSummary:Opens an HTML document with images from a stream using a base URI. // We are opening this HTML file: // <html> // <body> // <p>Simple file.</p> // <p><img src="Aspose.Words.gif" width="80" height="60"></p> // </body> // </html> String fileName = getMyDir() + "Document.OpenFromStreamWithBaseUri.html"; // Open the stream. InputStream stream = new FileInputStream(fileName); // Open the document. Note the Document constructor detects HTML format automatically. // Pass the URI of the base folder so any images with relative URIs in the HTML document can be found. LoadOptions loadOptions = new LoadOptions(); loadOptions.setBaseUri(getMyDir()); Document doc = new Document(stream, loadOptions); // You can close the stream now, it is no longer needed because the document is in memory. stream.close(); // Save in the DOC format. doc.save(getMyDir() + "Document.OpenFromStreamWithBaseUri Out.doc"); //ExEnd // Lets make sure the image was imported successfully into a Shape node. // Get the first shape node in the document. Shape shape = (Shape)doc.getChild(NodeType.SHAPE, 0, true); // Verify some properties of the image. Assert.assertTrue(shape.isImage()); Assert.assertNotNull(shape.getImageData().getImageBytes()); Assert.assertEquals(ConvertUtil.pointToPixel(shape.getWidth()), 80.0); Assert.assertEquals(ConvertUtil.pointToPixel(shape.getHeight()), 60.0); }
public void openFromStream ( ) throws Exception { //ExStart //ExFor:Document.#ctor(Stream) //ExId:OpenFromStream //ExSummary:Opens a document from a stream. // Open the stream. Read only access is enough for Aspose.Words to load a document. InputStream stream = new FileInputStream(getMyDir() + "Document.doc"); // Load the entire document into memory. Document doc = new Document(stream); // You can close the stream now, it is no longer needed because the document is in memory. stream.close(); // ... do something with the document //ExEnd Assert.assertEquals(doc.getText(), "Hello World!\f"); }
public void loadFormat ( ) throws Exception { //ExStart //ExFor:Document.#ctor(String,LoadOptions) //ExFor:LoadFormat //ExSummary:Explicitly loads a document as HTML without automatic file format detection. LoadOptions loadOptions = new LoadOptions(); loadOptions.setLoadFormat(com.aspose.words.LoadFormat.HTML); Document doc = new Document(getMyDir() + "Document.LoadFormat.html", loadOptions); //ExEnd
public void changeFieldUpdateCultureSource ( ) throws Exception { // We will test this functionality creating a document with two fields with date formatting // field where the set language is different than the current culture, e.g German. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Insert content with German locale. builder.getFont().setLocaleId(1031); builder.insertField("MERGEFIELD Date1 \\@ \"dddd, d MMMM yyyy\""); builder.write(" - "); builder.insertField("MERGEFIELD Date2 \\@ \"dddd, d MMMM yyyy\""); // Make sure that English culture is set then execute mail merge using current culture for // date formatting. Locale currentLocale = Locale.getDefault(); Locale.setDefault(new Locale("en", "US")); doc.getMailMerge().execute(new String[] { "Date1" }, new Object[] { new SimpleDateFormat("yyyy/MM/DD").parse("2011/01/01") }); //ExStart //ExFor:Document.FieldOptions //ExFor:FieldOptions //ExFor:FieldOptions.FieldUpdateCultureSource //ExFor:FieldUpdateCultureSource //ExId:ChangeFieldUpdateCultureSource //ExSummary:Shows how to specify where the locale for date formatting during field update and mail merge is chosen from. // Set the culture used during field update to the culture used by the field. doc.getFieldOptions().setFieldUpdateCultureSource(FieldUpdateCultureSource.FIELD_CODE); doc.getMailMerge().execute(new String[] { "Date2" }, new Object[] { new SimpleDateFormat("yyyy/MM/DD").parse("2011/01/01") }); //ExEnd // Verify the field update behaviour is correct. Currently this isn't working properly for different locales // so the test is disabled for now. Assert.assertEquals(doc.getRange().getText().trim(), "Saturday, 1 January 2011 - Samstag, 1 Januar 2011"); // Restore the original culture. Locale.setDefault(currentLocale); }
public void loadEncryptedFromFile ( ) throws Exception { //ExStart //ExFor:Document.#ctor(String,LoadOptions) //ExFor:LoadOptions.#ctor(String) //ExFor:LoadOptions //ExId:OpenEncrypted //ExSummary:Loads a Microsoft Word document encrypted with a password. Document doc = new Document(getMyDir() + "Document.LoadEncrypted.doc", new LoadOptions("qwerty")); //ExEnd
public void convertToHtml ( ) throws Exception { //ExStart //ExFor:Document.Save(String,SaveFormat) //ExFor:SaveFormat //ExSummary:Converts from DOC to HTML format. Document doc = new Document(getMyDir() + "Document.doc"); doc.save(getMyDir() + "Document.ConvertToHtml Out.html", SaveFormat.HTML); //ExEnd
public void convertToMhtml ( ) throws Exception { //ExStart //ExFor:Document.Save(String) //ExSummary:Converts from DOC to MHTML format. Document doc = new Document(getMyDir() + "Document.doc"); doc.save(getMyDir() + "Document.ConvertToMhtml Out.mht"); //ExEnd
public void convertToTxt ( ) throws Exception { //ExStart //ExId:ExtractContentSaveAsText //ExSummary:Shows how to save a document in TXT format. Document doc = new Document(getMyDir() + "Document.doc"); doc.save(getMyDir() + "Document.ConvertToTxt Out.txt"); //ExEnd
public void doc2PdfSave ( ) throws Exception { //ExStart //ExFor:Document //ExFor:Document.Save(String) //ExId:Doc2PdfSave //ExSummary:Converts a whole document from DOC to PDF using default options. Document doc = new Document(getMyDir() + "Document.doc"); doc.save(getMyDir() + "Document.Doc2PdfSave Out.pdf"); //ExEnd
public void saveToStream ( ) throws Exception { //ExStart //ExFor:Document.Save(Stream,SaveFormat) //ExId:SaveToStream //ExSummary:Shows how to save a document to a stream. Document doc = new Document(getMyDir() + "Document.doc"); ByteArrayOutputStream dstStream = new ByteArrayOutputStream(); doc.save(dstStream, SaveFormat.DOCX); // In you want to read the result into a Document object again, in Java you need to get the // data bytes and wrap into an input stream. ByteArrayInputStream srcStream = new ByteArrayInputStream(dstStream.toByteArray()); //ExEnd
public void saveHtmlPrettyFormat ( ) throws Exception { //ExStart //ExFor:SaveOptions.PrettyFormat //ExSummary:Shows how to pass an option to export HTML tags in a well spaced, human readable format. Document doc = new Document(getMyDir() + "Document.doc"); HtmlSaveOptions htmlOptions = new HtmlSaveOptions(SaveFormat.HTML); // Enabling the PrettyFormat setting will export HTML in an indented format that is easy to read. // If this is setting is false (by default) then the HTML tags will be exported in condensed form with no indentation. htmlOptions.setPrettyFormat(true); doc.save(getMyDir() + "Document.PrettyFormat Out.html", htmlOptions); //ExEnd
public void saveHtmlWithOptions ( ) throws Exception { //ExStart //ExFor:HtmlSaveOptions //ExFor:HtmlSaveOptions.ExportTextInputFormFieldAsText //ExFor:HtmlSaveOptions.ImagesFolder //ExId:SaveWithOptions //ExSummary:Shows how to set save options before saving a document to HTML. Document doc = new Document(getMyDir() + "Rendering.doc"); // This is the directory we want the exported images to be saved to. File imagesDir = new File(getMyDir(), "Images"); // The folder specified needs to exist and should be empty. if(imagesDir.exists()) imagesDir.delete(); imagesDir.mkdir(); // Set an option to export form fields as plain text, not as HTML input elements. HtmlSaveOptions options = new HtmlSaveOptions(SaveFormat.HTML); options.setExportTextInputFormFieldAsText(true); options.setImagesFolder(imagesDir.getPath()); doc.save(getMyDir() + "Document.SaveWithOptions Out.html", options); //ExEnd // Verify the images were saved to the correct location. Assert.assertTrue(new File(getMyDir() + "Document.SaveWithOptions Out.html").exists()); Assert.assertEquals(imagesDir.list().length, 9); }
public void saveHtmlExportFontsCaller ( ) throws Exception { saveHtmlExportFonts ( ) ; }
public void saveHtmlExportFonts ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Document.doc " ) ; // Set the option to export font resources. HtmlSaveOptions options = new HtmlSaveOptions(SaveFormat.MHTML); options.setExportFontResources(true); // Create and pass the object which implements the handler methods. options.setFontSavingCallback(new HandleFontSaving()); doc.save(getMyDir() + "Document.SaveWithFontsExport Out.html", options); }
public void fontSaving ( FontSavingArgs args ) throws Exception { // You can implement logic here to rename fonts, save to file etc. For this example just print some details about the current font being handled. System.out.println(MessageFormat.format("Font Name = {0}, Font Filename = {1}", args.getFontFamilyName(), args.getFontFileName())); }
public void saveHtmlExportImagesCaller ( ) throws Exception { saveHtmlExportImages ( ) ; }
public void saveHtmlExportImages ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Document.doc " ) ; // Create and pass the object which implements the handler methods. HtmlSaveOptions options = new HtmlSaveOptions(SaveFormat.HTML); options.setImageSavingCallback(new HandleImageSaving()); doc.save(getMyDir() + "Document.SaveWithCustomImagesExport Out.html", options); }
public void imageSaving ( ImageSavingArgs e ) throws Exception { // Change any images in the document being exported with the extension of "jpeg" to "jpg". if (e.getImageFileName().endsWith(".jpeg")) e.setImageFileName(e.getImageFileName().replace(".jpeg", ".jpg"));
public void testNodeChangingInDocumentCaller ( ) throws Exception { testNodeChangingInDocument ( ) ; }
public void testNodeChangingInDocument ( ) throws Exception { // Create a blank document object Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Set up and pass the object which implements the handler methods. doc.setNodeChangingCallback(new HandleNodeChanging_FontChanger()); // Insert sample HTML content builder.insertHtml("<p>Hello World</p>"); doc.save(getMyDir() + "Document.FontChanger Out.doc"); // Check that the inserted content has the correct formatting Run run = (Run)doc.getChild(NodeType.RUN, 0, true); Assert.assertEquals(run.getFont().getSize(), 24.0); Assert.assertEquals(run.getFont().getName(), "Arial"); }
public void nodeInserted ( NodeChangingArgs args ) throws Exception { // Change the font of inserted text contained in the Run nodes. if (args.getNode().getNodeType() == NodeType.RUN) {
public void detectFileFormat ( ) throws Exception { //ExStart //ExFor:FileFormatUtil.DetectFileFormat(String) //ExFor:FileFormatInfo //ExFor:FileFormatInfo.LoadFormat //ExFor:FileFormatInfo.IsEncrypted //ExFor:FileFormatInfo.HasDigitalSignature //ExId:DetectFileFormat //ExSummary:Shows how to use the FileFormatUtil class to detect the document format and other features of the document. FileFormatInfo info = FileFormatUtil.detectFileFormat(getMyDir() + "Document.doc"); System.out.println("The document format is: " + FileFormatUtil.loadFormatToExtension(info.getLoadFormat())); System.out.println("Document is encrypted: " + info.isEncrypted()); System.out.println("Document has a digital signature: " + info.hasDigitalSignature()); //ExEnd
public void detectFileFormat_EnumConversions ( ) throws Exception { //ExStart //ExFor:FileFormatUtil.DetectFileFormat(Stream) //ExFor:FileFormatUtil.LoadFormatToExtension(LoadFormat) //ExFor:FileFormatUtil.ExtensionToSaveFormat(String) //ExFor:FileFormatUtil.SaveFormatToExtension(SaveFormat) //ExFor:FileFormatUtil.LoadFormatToSaveFormat(LoadFormat) //ExFor:Document.OriginalFileName //ExFor:FileFormatInfo.LoadFormat //ExSummary:Shows how to use the FileFormatUtil methods to detect the format of a document without any extension and save it with the correct file extension. // Load the document without a file extension into a stream and use the DetectFileFormat method to detect it's format. These are both times where you might need extract the file format as it's not visible FileInputStream docStream = new FileInputStream(getMyDir() + "Document.FileWithoutExtension"); // The file format of this document is actually ".doc" FileFormatInfo info = FileFormatUtil.detectFileFormat(docStream); // Retrieve the LoadFormat of the document. int loadFormat = info.getLoadFormat(); // Let's show the different methods of converting LoadFormat enumerations to SaveFormat enumerations. // // Method #1 // Convert the LoadFormat to a string first for working with. The string will include the leading dot infront of the extension. String fileExtension = FileFormatUtil.loadFormatToExtension(loadFormat); // Now convert this extension into the corresponding SaveFormat enumeration int saveFormat = FileFormatUtil.extensionToSaveFormat(fileExtension); // Method #2 // Convert the LoadFormat enumeration directly to the SaveFormat enumeration. saveFormat = FileFormatUtil.loadFormatToSaveFormat(loadFormat); // Load a document from the stream. // Note that in Java we cannot reuse the same InputStream instance that was used for file format detection because InputStream is not seekable. docStream = new FileInputStream(getMyDir() + "Document.FileWithoutExtension"); // The file format of this document is actually ".doc" Document doc = new Document(docStream); // Save the document with the original file name, " Out" and the document's file extension. doc.save(getMyDir() + "Document.WithFileExtension Out" + FileFormatUtil.saveFormatToExtension(saveFormat)); //ExEnd Assert.assertEquals(FileFormatUtil.saveFormatToExtension(saveFormat), ".doc"); }
public void detectFileFormat_SaveFormatToLoadFormat ( ) throws Exception { //ExStart //ExFor:FileFormatUtil.SaveFormatToLoadFormat(SaveFormat) //ExSummary:Shows how to use the FileFormatUtil class and to convert a SaveFormat enumeration into the corresponding LoadFormat enumeration. // Define the SaveFormat enumeration to convert. int saveFormat = SaveFormat.HTML; // Convert the SaveFormat enumeration to LoadFormat enumeration. int loadFormat = FileFormatUtil.saveFormatToLoadFormat(saveFormat); System.out.println("The converted LoadFormat is: " + FileFormatUtil.loadFormatToExtension(loadFormat)); //ExEnd Assert.assertEquals(FileFormatUtil.saveFormatToExtension(saveFormat), ".html"); Assert.assertEquals(FileFormatUtil.loadFormatToExtension(loadFormat), ".html"); }
public void appendDocument ( ) throws Exception { //ExStart //ExFor:Document.AppendDocument(Document, ImportFormatMode) //ExSummary:Shows how to append a document to the end of another document. // The document that the content will be appended to. Document dstDoc = new Document(getMyDir() + "Document.doc"); // The document to append. Document srcDoc = new Document(getMyDir() + "DocumentBuilder.doc"); // Append the source document to the destination document. // Pass format mode to retain the original formatting of the source document when importing it. dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); // Save the document. dstDoc.save(getMyDir() + "Document.AppendDocument Out.doc"); //ExEnd
public void detectDocumentSignatures ( ) throws Exception { //ExStart //ExFor:FileFormatUtil.DetectFileFormat(String) //ExFor:FileFormatInfo.HasDigitalSignature //ExId:DetectDocumentSignatures //ExSummary:Shows how to check a document for digital signatures before loading it into a Document object. // The path to the document which is to be processed. String filePath = getMyDir() + "Document.Signed.docx"; FileFormatInfo info = FileFormatUtil.detectFileFormat(filePath); if (info.hasDigitalSignature()) {
public void appendAllDocumentsInFolder ( ) throws Exception { // Delete the file that was created by the previous run as I don't want to append it again. new File(getMyDir() + "Document.AppendDocumentsFromFolder Out.doc").delete(); //ExStart //ExFor:Document.AppendDocument(Document, ImportFormatMode) //ExSummary:Shows how to use the AppendDocument method to combine all the documents in a folder to the end of a template document. // Lets start with a simple template and append all the documents in a folder to this document. Document baseDoc = new Document(); // Add some content to the template. DocumentBuilder builder = new DocumentBuilder(baseDoc); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.HEADING_1); builder.writeln("Template Document"); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.NORMAL); builder.writeln("Some content here"); // Gather the files which will be appended to our template document. // In this case we search only for files with the ".doc" extension. File srcDir = new File(getMyDir()); File[] files = srcDir.listFiles(new FilenameFilter() { public boolean accept(File dir, String name) { return name.endsWith(".doc"); } }); // The list of files may come in any order, let's sort the files by name so the documents are appended alphabetically. Arrays.sort(files); // Iterate through every file in the directory and append each one to the end of the template document. for (File file : files) { String fileName = file.getCanonicalPath(); // We have some encrypted test documents in our directory, skip them. FileFormatInfo info = FileFormatUtil.detectFileFormat(fileName); if (info.isEncrypted()) continue; Document subDoc = new Document(fileName); baseDoc.appendDocument(subDoc, ImportFormatMode.USE_DESTINATION_STYLES); } // Save the combined document to disk. baseDoc.save(getMyDir() + "Document.AppendDocumentsFromFolder Out.doc"); //ExEnd
public boolean accept ( File dir , String name ) { return name . endsWith ( " .doc " ) ; }
public void joinRunsWithSameFormatting ( ) throws Exception { //ExStart //ExFor:Document.JoinRunsWithSameFormatting //ExSummary:Shows how to join runs in a document to reduce unneeded runs. // Let's load this particular document. It contains a lot of content that has been edited many times. // This means the document will most likely contain a large number of runs with duplicate formatting. Document doc = new Document(getMyDir() + "Rendering.doc"); // This is for illustration purposes only, remember how many run nodes we had in the original document. int runsBefore = doc.getChildNodes(NodeType.RUN, true, false).getCount(); // Join runs with the same formatting. This is useful to speed up processing and may also reduce redundant // tags when exporting to HTML which will reduce the output file size. int joinCount = doc.joinRunsWithSameFormatting(); // This is for illustration purposes only, see how many runs are left after joining. int runsAfter = doc.getChildNodes(NodeType.RUN, true, false).getCount(); System.out.println(MessageFormat.format("Number of runs before:{0}, after:{1}, joined:{2}", runsBefore, runsAfter, joinCount)); // Save the optimized document to disk. doc.save(getMyDir() + "Document.JoinRunsWithSameFormatting Out.html"); //ExEnd // Verify that runs were joined in the document. Assert.assertTrue(runsAfter < runsBefore); Assert.assertNotSame(joinCount, 0); }
public void detachTemplate ( ) throws Exception { //ExStart //ExFor:Document.AttachedTemplate //ExSummary:Opens a document, makes sure it is no longer attached to a template and saves the document. Document doc = new Document(getMyDir() + "Document.doc"); doc.setAttachedTemplate(""); doc.save(getMyDir() + "Document.DetachTemplate Out.doc"); //ExEnd
public void defaultTabStop ( ) throws Exception { //ExStart //ExFor:Document.DefaultTabStop //ExFor:ControlChar.Tab //ExFor:ControlChar.TabChar //ExSummary:Changes default tab positions for the document and inserts text with some tab characters. DocumentBuilder builder = new DocumentBuilder(); // Set default tab stop to 72 points (1 inch). builder.getDocument().setDefaultTabStop(72); builder.writeln("Hello" + ControlChar.TAB + "World!"); builder.writeln("Hello" + ControlChar.TAB_CHAR + "World!"); //ExEnd
public void cloneDocument ( ) throws Exception { //ExStart //ExFor:Document.Clone //ExId:CloneDocument //ExSummary:Shows how to deep clone a document. Document doc = new Document(getMyDir() + "Document.doc"); Document clone = doc.deepClone(); //ExEnd
public void documentGetText_ToTxt ( ) throws Exception { //ExStart //ExFor:CompositeNode.GetText //ExFor:Node.ToTxt //ExId:NodeTxtExportDifferences //ExSummary:Shows the difference between calling the GetText and ToTxt methods on a node. Document doc = new Document(); // Enter a dummy field into the document. DocumentBuilder builder = new DocumentBuilder(doc); builder.insertField("MERGEFIELD Field"); // GetText will retrieve all field codes and special characters System.out.println("GetText() Result: " + doc.getText()); // ToTxt will not retrieve fields code or special characters, but will still contain some natural formatting characters // such as paragraph markers etc. This is the same as "viewing" the document as if it was opened in a text editor // Only the results of fields are shown without any internal codes or characters System.out.println("ToTxt() Result: " + doc.toTxt()); //ExEnd
public void documentByteArray ( ) throws Exception { //ExStart //ExId:DocumentToFromByteArray //ExSummary:Shows how to convert a document object to an array of bytes and back into a document object again. // Load the document. Document doc = new Document(getMyDir() + "Document.doc"); // Create a new memory stream. ByteArrayOutputStream outStream = new ByteArrayOutputStream(); // Save the document to stream. doc.save(outStream, SaveFormat.DOCX); // Convert the document to byte form. byte[] docBytes = outStream.toByteArray(); // The bytes are now ready to be stored/transmitted. // Now reverse the steps to load the bytes back into a document object. ByteArrayInputStream inStream = new ByteArrayInputStream(docBytes); // Load the stream into a new document object. Document loadDoc = new Document(inStream); //ExEnd Assert.assertEquals(doc.getText(), loadDoc.getText()); }
public void protectUnprotectDocument ( ) throws Exception { //ExStart //ExFor:Document.Protect(ProtectionType,String) //ExId:ProtectDocument //ExSummary:Shows how to protect a document. Document doc = new Document(); doc.protect(ProtectionType.ALLOW_ONLY_FORM_FIELDS, "password"); //ExEnd //ExStart //ExFor:Document.Unprotect //ExId:UnprotectDocument //ExSummary:Shows how to unprotect any document. Note that the password is not required. doc.unprotect(); //ExEnd
public void getProtectionType ( ) throws Exception { //ExStart //ExFor:Document.ProtectionType //ExId:GetProtectionType //ExSummary:Shows how to get protection type currently set in the document. Document doc = new Document(getMyDir() + "Document.doc"); int protectionType = doc.getProtectionType(); //ExEnd
public void documentEnsureMinimum ( ) throws Exception { //ExStart //ExFor:Document.EnsureMinimum //ExSummary:Shows how to ensure the Document is valid (has the minimum nodes required to be valid). // Create a blank document then remove all nodes from it, the result will be a completely empty document. Document doc = new Document(); doc.removeAllChildren(); // Ensure that the document is valid. Since the document has no nodes this method will create an empty section // and add an empty paragraph to make it valid. doc.ensureMinimum(); //ExEnd
public void removeMacrosFromDocument ( ) throws Exception { //ExStart //ExFor:Document.RemoveMacros //ExSummary:Shows how to remove all macros from a document. Document doc = new Document(getMyDir() + "Document.doc"); doc.removeMacros(); //ExEnd
public void updateTableLayout ( ) throws Exception { //ExStart //ExFor:Document.UpdateTableLayout //ExId:UpdateTableLayout //ExSummary:Shows how to update the layout of tables in a document. Document doc = new Document(getMyDir() + "Document.doc"); // Normally this method is not necessary to call, as cell and table widths are maintained automatically. // This method may need to be called when exporting to PDF in rare cases when the table layout appears // incorrectly in the rendered output. doc.updateTableLayout(); //ExEnd
public void GetPageCount ( ) throws Exception { //ExStart //ExFor:Document.PageCount //ExSummary:Shows how to invoke page layout and retrieve the number of pages in the document. Document doc = new Document(getMyDir() + "Document.doc"); // This invokes page layout which builds the document in memory so note that with large documents this // method can take time. After invoking this method, any rendering operation e.g rendering to PDF or image // will be instantaneous. int pageCount = doc.getPageCount(); //ExEnd Assert.assertEquals(pageCount, 1); }
public void updateFields ( ) throws Exception { //ExStart //ExFor:Document.UpdateFields //ExId:UpdateFieldsInDocument //ExSummary:Shows how to update all fields in a document. Document doc = new Document(getMyDir() + "Document.doc"); doc.updateFields(); //ExEnd
public void tableStyleToDirectFormatting ( ) throws Exception { //ExStart //ExFor:Document.ExpandTableStylesToDirectFormatting //ExId:TableStyleToDirectFormatting //ExSummary:Shows how to expand the formatting from styles onto the rows and cells of the table as direct formatting. Document doc = new Document(getMyDir() + "Table.TableStyle.docx"); // Get the first cell of the first table in the document. Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); Cell firstCell = table.getFirstRow().getFirstCell(); // First print the color of the cell shading. This should be empty as the current shading // is stored in the table style. Color cellShadingBefore = firstCell.getCellFormat().getShading().getBackgroundPatternColor(); System.out.println("Cell shading before style expansion: " + cellShadingBefore); // Expand table style formatting to direct formatting. doc.expandTableStylesToDirectFormatting(); // Now print the cell shading after expanding table styles. A blue background pattern color // should have been applied from the table style. Color cellShadingAfter = firstCell.getCellFormat().getShading().getBackgroundPatternColor(); System.out.println("Cell shading after style expansion: " + cellShadingAfter); //ExEnd doc.save(getMyDir() + "Table.ExpandTableStyleFormatting Out.docx"); Assert.assertSame(cellShadingBefore.getRGB(), 0); Assert.assertNotSame(cellShadingAfter.getRGB(), 0); }
public void getUpdatedPageProperties ( ) throws Exception { //ExStart //ExFor:Document.UpdateWordCount() //ExFor:BuiltInDocumentProperties.Characters //ExFor:BuiltInDocumentProperties.Words //ExFor:BuiltInDocumentProperties.Paragraphs //ExSummary:Shows how to update all list labels in a document. Document doc = new Document(getMyDir() + "Document.doc"); // Some work should be done here that changes the document's content. // Update the word, character and paragraph count of the document. doc.updateWordCount(); // Display the updated document properties. System.out.println(MessageFormat.format("Characters: {0}", doc.getBuiltInDocumentProperties().getCharacters())); System.out.println(MessageFormat.format("Words: {0}", doc.getBuiltInDocumentProperties().getWords())); System.out.println(MessageFormat.format("Paragraphs: {0}", doc.getBuiltInDocumentProperties().getParagraphs())); //ExEnd
public void getOriginalFileInfo ( ) throws Exception { //ExStart //ExFor:Document.OriginalFileName //ExFor:Document.OriginalLoadFormat //ExSummary:Shows how to retrieve the details of the path, filename and LoadFormat of a document from when the document was first loaded into memory. Document doc = new Document(getMyDir() + "Document.doc"); // This property will return the full path and file name where the document was loaded from. String originalFilePath = doc.getOriginalFileName(); // Let's get just the file name from the full path. String originalFileName = new File(originalFilePath).getName(); // This is the original LoadFormat of the document. int loadFormat = doc.getOriginalLoadFormat(); //ExEnd
public void removeSmartTagsFromDocument ( ) throws Exception { //ExStart //ExFor:CompositeNode.RemoveSmartTags //ExSummary:Shows how to remove all smart tags from a document. Document doc = new Document(getMyDir() + "Document.doc"); doc.removeSmartTags(); //ExEnd
public void setZoom ( ) throws Exception { //ExStart //ExFor:Document.ViewOptions //ExFor:ViewOptions //ExFor:ViewOptions.ViewType //ExFor:ViewOptions.ZoomPercent //ExFor:ViewType //ExId:SetZoom //ExSummary:The following code shows how to make sure the document is displayed at 50% zoom when opened in Microsoft Word. Document doc = new Document(getMyDir() + "Document.doc"); doc.getViewOptions().setViewType(ViewType.PAGE_LAYOUT); doc.getViewOptions().setZoomPercent(50); doc.save(getMyDir() + "Document.SetZoom Out.doc"); //ExEnd
public void getDocumentVariables ( ) throws Exception { //ExStart //ExFor:Document.Variables //ExFor:VariableCollection //ExId:GetDocumentVariables //ExSummary:Shows how to enumerate over document variables. Document doc = new Document(getMyDir() + "Document.doc"); for (java.util.Map.Entry entry : doc.getVariables()) {
public void writeAndFont ( ) throws Exception { //ExStart //ExFor:Font.Size //ExFor:Font.Bold //ExFor:Font.Name //ExFor:Font.Color //ExFor:Font.Underline //ExFor:DocumentBuilder.#ctor //ExId:DocumentBuilderInsertText //ExSummary:Inserts formatted text using DocumentBuilder. DocumentBuilder builder = new DocumentBuilder(); // Specify font formatting before adding text. Font font = builder.getFont(); font.setSize(16); font.setBold(true); font.setColor(Color.BLUE); font.setName("Arial"); font.setUnderline(Underline.DASH); builder.write("Sample text."); //ExEnd
public void headersAndFooters ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.#ctor(Document) //ExFor:DocumentBuilder.MoveToHeaderFooter //ExFor:DocumentBuilder.MoveToSection //ExFor:DocumentBuilder.InsertBreak //ExFor:HeaderFooterType //ExFor:PageSetup.DifferentFirstPageHeaderFooter //ExFor:PageSetup.OddAndEvenPagesHeaderFooter //ExFor:BreakType //ExId:DocumentBuilderMoveToHeaderFooter //ExSummary:Creates headers and footers in a document using DocumentBuilder. // Create a blank document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Specify that we want headers and footers different for first, even and odd pages. builder.getPageSetup().setDifferentFirstPageHeaderFooter(true); builder.getPageSetup().setOddAndEvenPagesHeaderFooter(true); // Create the headers. builder.moveToHeaderFooter(HeaderFooterType.HEADER_FIRST); builder.write("Header First"); builder.moveToHeaderFooter(HeaderFooterType.HEADER_EVEN); builder.write("Header Even"); builder.moveToHeaderFooter(HeaderFooterType.HEADER_PRIMARY); builder.write("Header Odd"); // Create three pages in the document. builder.moveToSection(0); builder.writeln("Page1"); builder.insertBreak(BreakType.PAGE_BREAK); builder.writeln("Page2"); builder.insertBreak(BreakType.PAGE_BREAK); builder.writeln("Page3"); doc.save(getMyDir() + "DocumentBuilder.HeadersAndFooters Out.doc"); //ExEnd
public void insertMergeField ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertField(string) //ExId:DocumentBuilderInsertField //ExSummary:Inserts a merge field into a document using DocumentBuilder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.insertField("MERGEFIELD MyFieldName \\* MERGEFORMAT"); //ExEnd
public void insertField ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertField(string) //ExFor:Field //ExFor:Field.Update //ExFor:Field.Result //ExFor:Field.GetFieldCode //ExFor:Field.Type //ExFor:Field.Remove //ExFor:FieldType //ExSummary:Inserts a field into a document using DocumentBuilder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Insert a simple Date field into the document. // When we insert a field through the DocumentBuilder class we can get the // special Field object which contains information about the field. Field dateField = builder.insertField("DATE \\* MERGEFORMAT"); // Update this particular field in the document so we can get the FieldResult. dateField.update(); // Display some information from this field. // The field result is where the last evaluated value is stored. This is what is displayed in the document // When field codes are not showing. System.out.println(MessageFormat.format("FieldResult: {0}", dateField.getResult())); // Display the field code which defines the behaviour of the field. This can been seen in Microsoft Word by pressing ALT+F9. System.out.println(MessageFormat.format("FieldCode: {0}", dateField.getFieldCode())); // The field type defines what type of field in the Document this is. In this case the type is "FieldDate" System.out.println(MessageFormat.format("FieldType: {0}", dateField.getType())); // Finally let's completely remove the field from the document. This can easily be done by invoking the Remove method on the object. dateField.remove(); //ExEnd
public void documentBuilderAndSave ( ) throws Exception { //ExStart //ExId:DocumentBuilderAndSave //ExSummary:Shows how to create build a document using a document builder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.writeln("Hello World!"); doc.save(getMyDir() + "DocumentBuilderAndSave Out.docx"); //ExEnd
public void insertHyperlink ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertHyperlink //ExFor:Font.ClearFormatting //ExFor:Font.Color //ExFor:Font.Underline //ExFor:Underline //ExId:DocumentBuilderInsertHyperlink //ExSummary:Inserts a hyperlink into a document using DocumentBuilder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.write("Please make sure to visit "); // Specify font formatting for the hyperlink. builder.getFont().setColor(Color.BLUE); builder.getFont().setUnderline(Underline.SINGLE); // Insert the link. builder.insertHyperlink("Aspose Website", "http://www.aspose.com", false); // Revert to default formatting. builder.getFont().clearFormatting(); builder.write(" for more information."); doc.save(getMyDir() + "DocumentBuilder.InsertHyperlink Out.doc"); //ExEnd
public void pushPopFont ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.PushFont //ExFor:DocumentBuilder.PopFont //ExFor:DocumentBuilder.InsertHyperlink //ExSummary:Shows how to use temporarily save and restore character formatting when building a document with DocumentBuilder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Set up font formatting and write text that goes before the hyperlink. builder.getFont().setName("Arial"); builder.getFont().setSize(24); builder.getFont().setBold(true); builder.write("To go to an important location, click "); // Save the font formatting so we use different formatting for hyperlink and restore old formatting later. builder.pushFont(); // Set new font formatting for the hyperlink and insert the hyperlink. // The "Hyperlink" style is a Microsoft Word built-in style so we don't have to worry to // create it, it will be created automatically if it does not yet exist in the document. builder.getFont().setStyleIdentifier(StyleIdentifier.HYPERLINK); builder.insertHyperlink("here", "http://www.google.com", false); // Restore the formatting that was before the hyperlink. builder.popFont(); builder.writeln(". We hope you enjoyed the example."); doc.save(getMyDir() + "DocumentBuilder.PushPopFont Out.doc"); //ExEnd
public void insertWatermark ( ) throws Exception { //ExStart //ExFor:HeaderFooterType //ExFor:DocumentBuilder.MoveToHeaderFooter //ExFor:PageSetup.PageWidth //ExFor:PageSetup.PageHeight //ExFor:DocumentBuilder.InsertImage(Image) //ExFor:WrapType //ExFor:RelativeHorizontalPosition //ExFor:RelativeVerticalPosition //ExSummary:Inserts a watermark image into a document using DocumentBuilder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // The best place for the watermark image is in the header or footer so it is shown on every page. builder.moveToHeaderFooter(HeaderFooterType.HEADER_PRIMARY); // Insert a floating picture. BufferedImage image = ImageIO.read(new File(getMyDir() + "Watermark.png")); Shape shape = builder.insertImage(image); shape.setWrapType(WrapType.NONE); shape.setBehindText(true); shape.setRelativeHorizontalPosition(RelativeHorizontalPosition.PAGE); shape.setRelativeVerticalPosition(RelativeVerticalPosition.PAGE); // Calculate image left and top position so it appears in the centre of the page. shape.setLeft((builder.getPageSetup().getPageWidth() - shape.getWidth()) / 2); shape.setTop((builder.getPageSetup().getPageHeight() - shape.getHeight()) / 2); doc.save(getMyDir() + "DocumentBuilder.InsertWatermark Out.doc");
public void insertHtml ( ) throws Exception { //ExStart //ExFor:DocumentBuilder //ExFor:DocumentBuilder.InsertHtml //ExId:DocumentBuilderInsertHtml //ExSummary:Inserts HTML into a document using DocumentBuilder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.insertHtml( "<P align='right'>Paragraph right</P>" + "<b>Implicit paragraph left</b>" + "<div align='center'>Div center</div>" + "<h1 align='left'>Heading 1 left.</h1>"); doc.save(getMyDir() + "DocumentBuilder.InsertHtml Out.doc"); //ExEnd
public void insertTextAndBookmark ( ) throws Exception { //ExStart //ExFor:DocumentBuilder //ExFor:DocumentBuilder.StartBookmark //ExFor:DocumentBuilder.EndBookmark //ExSummary:Adds some text into the document and encloses the text in a bookmark using DocumentBuilder. DocumentBuilder builder = new DocumentBuilder(); builder.startBookmark("MyBookmark"); builder.writeln("Text inside a bookmark."); builder.endBookmark("MyBookmark"); //ExEnd
public void createForm ( ) throws Exception { //ExStart //ExFor:TextFormFieldType //ExFor:DocumentBuilder.InsertTextInput //ExFor:DocumentBuilder.InsertComboBox //ExFor:DocumentBuilder.InsertCheckBox //ExSummary:Builds a sample form to fill. DocumentBuilder builder = new DocumentBuilder(); // Insert a text form field for input a name. builder.insertTextInput("", TextFormFieldType.REGULAR, "", "Enter your name here", 30); // Insert 2 blank lines. builder.writeln(""); builder.writeln(""); String[] items = new String[] { "-- Select your favorite footwear --", "Sneakers", "Oxfords", "Flip-flops", "Other", "I prefer to be barefoot" }; // Insert a combo box to select a footwear type. builder.insertComboBox("", items, 0); // Insert two blank lines. builder.writeln(""); builder.writeln(""); // Insert a check box to ensure the form filler does look after his/her footwear. builder.insertCheckBox("", true, 0); builder.writeln("My boots are always polished and nice-looking."); builder.getDocument().save(getMyDir() + "DocumentBuilder.CreateForm Out.doc"); //ExEnd
public void workingWithNodes ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.MoveTo(Node) //ExFor:DocumentBuilder.MoveToBookmark(String) //ExFor:DocumentBuilder.CurrentParagraph //ExFor:DocumentBuilder.CurrentNode //ExFor:DocumentBuilder.MoveToDocumentStart //ExFor:DocumentBuilder.MoveToDocumentEnd //ExSummary:Shows how to move between nodes and manipulate current ones. Document doc = new Document(getMyDir() + "DocumentBuilder.WorkingWithNodes.doc"); DocumentBuilder builder = new DocumentBuilder(doc); // Move to a bookmark and delete the parent paragraph. builder.moveToBookmark("ParaToDelete"); builder.getCurrentParagraph().remove(); // Move to a particular paragraph's run and replace all occurrences of "bad" with "good" within this run. builder.moveTo(doc.getLastSection().getBody().getParagraphs().get(0).getRuns().get(0)); builder.getCurrentNode().getRange().replace("bad", "good", false, true); // Mark the beginning of the document. builder.moveToDocumentStart(); builder.writeln("Start of document."); // Mark the ending of the document. builder.moveToDocumentEnd(); builder.writeln("End of document."); doc.save(getMyDir() + "DocumentBuilder.WorkingWithNodes Out.doc"); //ExEnd
public void fillingDocument ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.MoveToMergeField(string) //ExFor:DocumentBuilder.Bold //ExFor:DocumentBuilder.Italic //ExSummary:Fills document merge fields with some data. Document doc = new Document(getMyDir() + "DocumentBuilder.FillingDocument.doc"); DocumentBuilder builder = new DocumentBuilder(doc); builder.moveToMergeField("TeamLeaderName"); builder.setBold(true); builder.writeln("Roman Korchagin"); builder.moveToMergeField("SoftwareDeveloper1Name"); builder.setItalic(true); builder.writeln("Dmitry Vorobyev"); builder.moveToMergeField("SoftwareDeveloper2Name"); builder.setItalic(true); builder.writeln("Vladimir Averkin"); doc.save(getMyDir() + "DocumentBuilder.FillingDocument Out.doc"); //ExEnd
public void insertToc ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertTableOfContents //ExFor:Document.UpdateFields //ExFor:DocumentBuilder.#ctor(Document) //ExFor:ParagraphFormat.StyleIdentifier //ExFor:DocumentBuilder.InsertBreak //ExFor:BreakType //ExId:InsertTableOfContents //ExSummary:Demonstrates how to insert a Table of contents (TOC) into a document using heading styles as entries. // Use a blank document Document doc = new Document(); // Create a document builder to insert content with into document. DocumentBuilder builder = new DocumentBuilder(doc); // Insert a table of contents at the beginning of the document. builder.insertTableOfContents("\\o \"1-3\" \\h \\z \\u"); // Start the actual document content on the second page. builder.insertBreak(BreakType.PAGE_BREAK); // Build a document with complex structure by applying different heading styles thus creating TOC entries. builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.HEADING_1); builder.writeln("Heading 1"); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.HEADING_2); builder.writeln("Heading 1.1"); builder.writeln("Heading 1.2"); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.HEADING_1); builder.writeln("Heading 2"); builder.writeln("Heading 3"); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.HEADING_2); builder.writeln("Heading 3.1"); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.HEADING_3); builder.writeln("Heading 3.1.1"); builder.writeln("Heading 3.1.2"); builder.writeln("Heading 3.1.3"); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.HEADING_2); builder.writeln("Heading 3.2"); builder.writeln("Heading 3.3"); // Call the method below to update the TOC. doc.updateFields(); //ExEnd doc.save(getMyDir() + "DocumentBuilder.InsertToc Out.docx"); }
public void insertTable ( ) throws Exception { //ExStart //ExFor:DocumentBuilder //ExFor:DocumentBuilder.StartTable //ExFor:DocumentBuilder.InsertCell //ExFor:DocumentBuilder.EndRow //ExFor:DocumentBuilder.EndTable //ExFor:DocumentBuilder.CellFormat //ExFor:DocumentBuilder.RowFormat //ExFor:CellFormat //ExFor:CellFormat.Width //ExFor:CellFormat.VerticalAlignment //ExFor:CellFormat.Shading //ExFor.CellFormat.Orientation //ExFor:RowFormat //ExFor:RowFormat.HeightRule //ExFor:RowFormat.Height //ExFor:RowFormat.Borders //ExFor:Shading.BackgroundPatternColor //ExFor:Shading.ClearFormatting //ExSummary:Shows how to build a nice bordered table. DocumentBuilder builder = new DocumentBuilder(); // Start building a table. builder.startTable(); // Set the appropriate paragraph, cell, and row formatting. The formatting properties are preserved // until they are explicitly modified so there's no need to set them for each row or cell. builder.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER); builder.getCellFormat().setWidth(300); builder.getCellFormat().setVerticalAlignment(CellVerticalAlignment.CENTER); builder.getCellFormat().getShading().setBackgroundPatternColor(new Color(173, 255, 47)); //"green-yellow" builder.getRowFormat().setHeightRule(HeightRule.EXACTLY); builder.getRowFormat().setHeight(50); builder.getRowFormat().getBorders().setLineStyle(LineStyle.ENGRAVE_3_D); builder.getRowFormat().getBorders().setColor(new Color(255, 165, 0)); // "orange" builder.insertCell(); builder.write("Row 1, Col 1"); builder.insertCell(); builder.write("Row 1, Col 2"); builder.endRow(); // Remove the shading (clear background). builder.getCellFormat().getShading().clearFormatting(); builder.insertCell(); builder.write("Row 2, Col 1"); builder.insertCell(); builder.write("Row 2, Col 2"); builder.endRow(); builder.insertCell(); // Make the row height bigger so that a vertically oriented text could fit into cells. builder.getRowFormat().setHeight(150); builder.getCellFormat().setOrientation(TextOrientation.UPWARD); builder.write("Row 3, Col 1"); builder.insertCell(); builder.getCellFormat().setOrientation(TextOrientation.DOWNWARD); builder.write("Row 3, Col 2"); builder.endRow(); builder.endTable(); builder.getDocument().save(getMyDir() + "DocumentBuilder.InsertTable Out.doc"); //ExEnd
public void insertTableSetHeadingRow ( ) throws Exception { //ExStart //ExFor:RowFormat.HeadingFormat //ExId:InsertTableWithHeadingFormat //ExSummary:Shows how to build a table which include heading rows that repeat on subsequent pages. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); Table table = builder.startTable(); builder.getRowFormat().setHeadingFormat(true); builder.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER); builder.getCellFormat().setWidth(100); builder.insertCell(); builder.writeln("Heading row 1"); builder.endRow(); builder.insertCell(); builder.writeln("Heading row 2"); builder.endRow(); builder.getCellFormat().setWidth(50); builder.getParagraphFormat().clearFormatting(); // Insert some content so the table is long enough to continue onto the next page. for (int i = 0; i < 50; i++) { builder.insertCell(); builder.getRowFormat().setHeadingFormat(false); builder.write("Column 1 Text"); builder.insertCell(); builder.write("Column 2 Text"); builder.endRow(); } doc.save(getMyDir() + "Table.HeadingRow Out.doc"); //ExEnd Assert.assertTrue(table.getFirstRow().getRowFormat().getHeadingFormat()); Assert.assertTrue(table.getRows().get(1).getRowFormat().getHeadingFormat()); Assert.assertFalse(table.getRows().get(2).getRowFormat().getHeadingFormat()); }
public void insertTableWithPreferredWidth ( ) throws Exception { //ExStart //ExFor:Table.PreferredWidth //ExFor:PreferredWidth.FromPercent //ExFor:PreferredWidth //ExId:TablePreferredWidth //ExSummary:Shows how to set a table to auto fit to 50% of the page width. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Insert a table with a width that takes up half the page width. Table table = builder.startTable(); // Insert a few cells builder.insertCell(); table.setPreferredWidth(PreferredWidth.fromPercent(50)); builder.writeln("Cell #1"); builder.insertCell(); builder.writeln("Cell #2"); builder.insertCell(); builder.writeln("Cell #3"); doc.save(getMyDir() + "Table.PreferredWidth Out.doc"); //ExEnd // Verify the correct settings were applied. Assert.assertEquals(table.getPreferredWidth().getType(), PreferredWidthType.PERCENT); Assert.assertEquals(table.getPreferredWidth().getValue(), 50.0); }
public void insertCellsWithDifferentPreferredCellWidths ( ) throws Exception { //ExStart //ExFor:CellFormat.PreferredWidth //ExFor:PreferredWidth //ExFor:PreferredWidth.FromPoints //ExFor:PreferredWidth.FromPercent //ExFor:PreferredWidth.Auto //ExId:CellPreferredWidths //ExSummary:Shows how to set the different preferred width settings. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Insert a table row made up of three cells which have different preferred widths. Table table = builder.startTable(); // Insert an absolute sized cell. builder.insertCell(); builder.getCellFormat().setPreferredWidth(PreferredWidth.fromPoints(40)); builder.getCellFormat().getShading().setBackgroundPatternColor(Color.RED); builder.writeln("Cell at 40 points width"); // Insert a relative (percent) sized cell. builder.insertCell(); builder.getCellFormat().setPreferredWidth(PreferredWidth.fromPercent(20)); builder.getCellFormat().getShading().setBackgroundPatternColor(Color.BLUE); builder.writeln("Cell at 20% width"); // Insert a auto sized cell. builder.insertCell(); builder.getCellFormat().setPreferredWidth(PreferredWidth.AUTO); builder.getCellFormat().getShading().setBackgroundPatternColor(Color.GREEN); builder.writeln("Cell automatically sized. The size of this cell is calculated from the table preferred width."); builder.writeln("In this case the cell will fill up the rest of the available space."); doc.save(getMyDir() + "Table.PreferredWidths Out.doc"); //ExEnd // Verify the correct settings were applied. Assert.assertEquals(table.getFirstRow().getFirstCell().getCellFormat().getPreferredWidth().getType(), PreferredWidthType.POINTS); Assert.assertEquals(table.getFirstRow().getCells().get(1).getCellFormat().getPreferredWidth().getType(), PreferredWidthType.PERCENT); Assert.assertEquals(table.getFirstRow().getCells().get(2).getCellFormat().getPreferredWidth().getType(), PreferredWidthType.AUTO); }
public void insertTableFromHtml ( ) throws Exception { //ExStart //ExId:InsertTableFromHtml //ExSummary:Shows how to insert a table in a document from a string containing HTML tags. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Insert the table from HTML. Note that AutoFitSettings does not apply to tables // inserted from HTML. builder.insertHtml("<table>" + "<tr>" + "<td>Row 1, Cell 1</td>" + "<td>Row 1, Cell 2</td>" + "</tr>" + "<tr>" + "<td>Row 2, Cell 2</td>" + "<td>Row 2, Cell 2</td>" + "</tr>" + "</table>"); doc.save(getMyDir() + "DocumentBuilder.InsertTableFromHtml Out.doc"); //ExEnd // Verify the table was constructed properly. Assert.assertEquals(doc.getChildNodes(NodeType.TABLE, true).getCount(), 1); Assert.assertEquals(doc.getChildNodes(NodeType.ROW, true).getCount(), 2); Assert.assertEquals(doc.getChildNodes(NodeType.CELL, true).getCount(), 4); }
public void buildNestedTableUsingDocumentBuilder ( ) throws Exception { //ExStart //ExFor:Cell.FirstParagraph //ExId:BuildNestedTableUsingDocumentBuilder //ExSummary:Shows how to insert a nested table using DocumentBuilder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Build the outer table. Cell cell = builder.insertCell(); builder.writeln("Outer Table Cell 1"); builder.insertCell(); builder.writeln("Outer Table Cell 2"); // This call is important in order to create a nested table within the first table // Without this call the cells inserted below will be appended to the outer table. builder.endTable(); // Move to the first cell of the outer table. builder.moveTo(cell.getFirstParagraph()); // Build the inner table. builder.insertCell(); builder.writeln("Inner Table Cell 1"); builder.insertCell(); builder.writeln("Inner Table Cell 2"); builder.endTable(); doc.save(getMyDir() + "DocumentBuilder.InsertNestedTable Out.doc"); //ExEnd Assert.assertEquals(doc.getChildNodes(NodeType.TABLE, true).getCount(), 2); Assert.assertEquals(doc.getChildNodes(NodeType.CELL, true).getCount(), 4); Assert.assertEquals(cell.getTables().get(0).getCount(), 1); Assert.assertEquals(cell.getTables().get(0).getFirstRow().getCells().getCount(), 2); }
public void buildSimpleTable ( ) throws Exception { //ExStart //ExFor:DocumentBuilder //ExFor:DocumentBuilder.Write //ExFor:DocumentBuilder.InsertCell //ExId:BuildSimpleTable //ExSummary:Shows how to create a simple table using DocumentBuilder with default formatting. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // We call this method to start building the table. builder.startTable(); builder.insertCell(); builder.write("Row 1, Cell 1 Content."); // Build the second cell builder.insertCell(); builder.write("Row 1, Cell 2 Content."); // Call the following method to end the row and start a new row. builder.endRow(); // Build the first cell of the second row. builder.insertCell(); builder.write("Row 2, Cell 1 Content"); // Build the second cell. builder.insertCell(); builder.write("Row 2, Cell 2 Content."); builder.endRow(); // Signal that we have finished building the table. builder.endTable(); // Save the document to disk. doc.save(getMyDir() + "DocumentBuilder.CreateSimpleTable Out.doc"); //ExEnd // Verify that the cell count of the table is four. Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); Assert.assertNotNull(table); Assert.assertEquals(4, table.getChildNodes(NodeType.CELL, true).getCount()); }
public void SetPreferredTypeConvertUtil ( ) throws Exception { //ExStart //ExFor:PreferredWidth.FromPoints //ExSummary:Shows how to specify a cell preferred width by converting inches to points. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); Table table = builder.startTable(); builder.getCellFormat().setPreferredWidth(PreferredWidth.fromPoints(ConvertUtil.inchToPoint(3))); builder.insertCell(); //ExEnd Assert.assertEquals(table.getFirstRow().getFirstCell().getCellFormat().getPreferredWidth().getValue(), 216.0); }
public void insertHyperlinkToLocalBookmark ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.StartBookmark //ExFor:DocumentBuilder.EndBookmark //ExFor:DocumentBuilder.InsertHyperlink //ExSummary:Inserts a hyperlink referencing local bookmark. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.startBookmark("Bookmark1"); builder.write("Bookmarked text."); builder.endBookmark("Bookmark1"); builder.writeln("Some other text"); // Specify font formatting for the hyperlink. builder.getFont().setColor(Color.BLUE); builder.getFont().setUnderline(Underline.SINGLE); // Insert hyperlink. // Switch \o is used to provide hyperlink tip text. builder.insertHyperlink("Hyperlink Text", "Bookmark1\" \\o \"Hyperlink Tip", true); // Clear hyperlink formatting. builder.getFont().clearFormatting(); doc.save(getMyDir() + "DocumentBuilder.InsertHyperlinkToLocalBookmark Out.doc"); //ExEnd
public void documentBuilderCtor ( ) throws Exception { //ExStart //ExId:DocumentBuilderCtor //ExSummary:Shows how to create a simple document using a document builder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.write("Hello World!"); //ExEnd
public void documentBuilderCursorPosition ( ) throws Exception { //ExStart //ExId:DocumentBuilderCursorPosition //ExSummary:Shows how to access the current node in a document builder. Document doc = new Document(getMyDir() + "DocumentBuilder.doc"); DocumentBuilder builder = new DocumentBuilder(doc); Node curNode = builder.getCurrentNode(); Paragraph curParagraph = builder.getCurrentParagraph(); //ExEnd
public void documentBuilderMoveToNode ( ) throws Exception { //ExStart //ExFor:Story.LastParagraph //ExFor:DocumentBuilder.MoveTo(Node) //ExId:DocumentBuilderMoveToNode //ExSummary:Shows how to move a cursor position to a specified node. Document doc = new Document(getMyDir() + "DocumentBuilder.doc"); DocumentBuilder builder = new DocumentBuilder(doc); builder.moveTo(doc.getFirstSection().getBody().getLastParagraph()); //ExEnd
public void documentBuilderMoveToDocumentStartEnd ( ) throws Exception { //ExStart //ExId:DocumentBuilderMoveToDocumentStartEnd //ExSummary:Shows how to move a cursor position to the beginning or end of a document. Document doc = new Document(getMyDir() + "DocumentBuilder.doc"); DocumentBuilder builder = new DocumentBuilder(doc); builder.moveToDocumentEnd(); builder.writeln("This is the end of the document."); builder.moveToDocumentStart(); builder.writeln("This is the beginning of the document."); //ExEnd
public void documentBuilderMoveToSection ( ) throws Exception { //ExStart //ExId:DocumentBuilderMoveToSection //ExSummary:Shows how to move a cursor position to the specified section. Document doc = new Document(getMyDir() + "DocumentBuilder.doc"); DocumentBuilder builder = new DocumentBuilder(doc); // Parameters are 0-index. Moves to third section. builder.moveToSection(2); builder.writeln("This is the 3rd section."); //ExEnd
public void documentBuilderMoveToParagraph ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.MoveToParagraph //ExId:DocumentBuilderMoveToParagraph //ExSummary:Shows how to move a cursor position to the specified paragraph. Document doc = new Document(getMyDir() + "DocumentBuilder.doc"); DocumentBuilder builder = new DocumentBuilder(doc); // Parameters are 0-index. Moves to third paragraph. builder.moveToParagraph(2, 0); builder.writeln("This is the 3rd paragraph."); //ExEnd
public void documentBuilderMoveToTableCell ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.MoveToCell //ExId:DocumentBuilderMoveToTableCell //ExSummary:Shows how to move a cursor position to the specified table cell. Document doc = new Document(getMyDir() + "DocumentBuilder.doc"); DocumentBuilder builder = new DocumentBuilder(doc); // All parameters are 0-index. Moves to the 2nd table, 3rd row, 5th cell. builder.moveToCell(1, 2, 4, 0); builder.writeln("Hello World!"); //ExEnd
public void documentBuilderMoveToBookmark ( ) throws Exception { //ExStart //ExId:DocumentBuilderMoveToBookmark //ExSummary:Shows how to move a cursor position to a bookmark. Document doc = new Document(getMyDir() + "DocumentBuilder.doc"); DocumentBuilder builder = new DocumentBuilder(doc); builder.moveToBookmark("CoolBookmark"); builder.writeln("This is a very cool bookmark."); //ExEnd
public void documentBuilderMoveToBookmarkEnd ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.MoveToBookmark(String, Boolean, Boolean) //ExId:DocumentBuilderMoveToBookmarkEnd //ExSummary:Shows how to move a cursor position to just after the bookmark end. Document doc = new Document(getMyDir() + "DocumentBuilder.doc"); DocumentBuilder builder = new DocumentBuilder(doc); builder.moveToBookmark("CoolBookmark", false, true); builder.writeln("This is a very cool bookmark."); //ExEnd
public void documentBuilderMoveToMergeField ( ) throws Exception { //ExStart //ExId:DocumentBuilderMoveToMergeField //ExSummary:Shows how to move the cursor to a position just beyond the specified merge field. Document doc = new Document(getMyDir() + "DocumentBuilder.doc"); DocumentBuilder builder = new DocumentBuilder(doc); builder.moveToMergeField("NiceMergeField"); builder.writeln("This is a very nice merge field."); //ExEnd
public void documentBuilderInsertParagraph ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertParagraph //ExFor:ParagraphFormat.FirstLineIndent //ExFor:ParagraphFormat.Alignment //ExFor:ParagraphFormat.KeepTogether //ExId:DocumentBuilderInsertParagraph //ExSummary:Shows how to insert a paragraph into the document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Specify font formatting Font font = builder.getFont(); font.setSize(16); font.setBold(true); font.setColor(Color.BLUE); font.setName("Arial"); font.setUnderline(Underline.DASH); // Specify paragraph formatting ParagraphFormat paragraphFormat = builder.getParagraphFormat(); paragraphFormat.setFirstLineIndent(8); paragraphFormat.setAlignment(ParagraphAlignment.JUSTIFY); paragraphFormat.setKeepTogether(true); builder.writeln("A whole paragraph."); //ExEnd
public void documentBuilderBuildTable ( ) throws Exception { //ExStart //ExFor:Table //ExFor:DocumentBuilder.StartTable //ExFor:DocumentBuilder.InsertCell //ExFor:DocumentBuilder.EndRow //ExFor:DocumentBuilder.EndTable //ExFor:DocumentBuilder.CellFormat //ExFor:DocumentBuilder.RowFormat //ExFor:DocumentBuilder.Write //ExFor:DocumentBuilder.Writeln(String) //ExFor:RowFormat.Height //ExFor:RowFormat.HeightRule //ExFor:CellVerticalAlignment //ExFor:CellFormat.Orientation //ExFor:TextOrientation //ExFor:Table.AutoFit //ExFor:AutoFitBehavior //ExId:DocumentBuilderBuildTable //ExSummary:Shows how to build a formatted table that contains 2 rows and 2 columns. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); Table table = builder.startTable(); // Insert a cell builder.insertCell(); // Use fixed column widths. table.autoFit(AutoFitBehavior.FIXED_COLUMN_WIDTHS); builder.getCellFormat().setVerticalAlignment(CellVerticalAlignment.CENTER); builder.write("This is row 1 cell 1"); // Insert a cell builder.insertCell(); builder.write("This is row 1 cell 2"); builder.endRow(); // Insert a cell builder.insertCell(); // Apply new row formatting builder.getRowFormat().setHeight(100); builder.getRowFormat().setHeightRule(HeightRule.EXACTLY); builder.getCellFormat().setOrientation(TextOrientation.UPWARD); builder.writeln("This is row 2 cell 1"); // Insert a cell builder.insertCell(); builder.getCellFormat().setOrientation(TextOrientation.DOWNWARD); builder.writeln("This is row 2 cell 2"); builder.endRow(); builder.endTable(); //ExEnd
public void documentBuilderInsertBreak ( ) throws Exception { //ExStart //ExId:DocumentBuilderInsertBreak //ExSummary:Shows how to insert page breaks into a document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.writeln("This is page 1."); builder.insertBreak(BreakType.PAGE_BREAK); builder.writeln("This is page 2."); builder.insertBreak(BreakType.PAGE_BREAK); builder.writeln("This is page 3."); //ExEnd
public void documentBuilderInsertInlineImage ( ) throws Exception { //ExStart //ExId:DocumentBuilderInsertInlineImage //ExSummary:Shows how to insert an inline image at the cursor position into a document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.insertImage(getMyDir() + "Watermark.png"); //ExEnd
public void documentBuilderInsertFloatingImage ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertImage(String, RelativeHorizontalPosition, Double, RelativeVerticalPosition, Double, Double, Double, WrapType) //ExId:DocumentBuilderInsertFloatingImage //ExSummary:Shows how to insert a floating image from a file or URL. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.insertImage(getMyDir() + "Watermark.png", RelativeHorizontalPosition.MARGIN,
public void InsertImageFromUrl ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertImage(String) //ExSummary:Shows how to insert an image into a document from a web address. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.insertImage("http://www.aspose.com/images/aspose-logo.gif"); doc.save(getMyDir() + "DocumentBuilder.InsertImageFromUrl Out.doc"); //ExEnd // Verify that the image was inserted into the document. Shape shape = (Shape) doc.getChild(NodeType.SHAPE, 0, true); Assert.assertNotNull(shape); Assert.assertTrue(shape.hasImage()); }
public void documentBuilderInsertImageSourceSize ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertImage(String, RelativeHorizontalPosition, Double, RelativeVerticalPosition, Double, Double, Double, WrapType) //ExId:DocumentBuilderInsertFloatingImageSourceSize //ExSummary:Shows how to insert a floating image from a file or URL and retain the original image size in the document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Pass a negative value to the width and height values to specify using the size of the source image. builder.insertImage(getMyDir() + "LogoSmall.png", RelativeHorizontalPosition.MARGIN, 200, RelativeVerticalPosition.MARGIN, 100, -1, -1, WrapType.SQUARE); //ExEnd doc.save(getMyDir() + "DocumentBuilder.InsertImageOriginalSize Out.doc"); }
public void documentBuilderInsertBookmark ( ) throws Exception { //ExStart //ExId:DocumentBuilderInsertBookmark //ExSummary:Shows how to insert a bookmark into a document using a document builder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.startBookmark("FineBookmark"); builder.writeln("This is just a fine bookmark."); builder.endBookmark("FineBookmark"); //ExEnd
public void documentBuilderInsertTextInputFormField ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertTextInput //ExId:DocumentBuilderInsertTextInputFormField //ExSummary:Shows how to insert a text input form field into a document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.insertTextInput("TextInput", TextFormFieldType.REGULAR, "", "Hello", 0); //ExEnd
public void documentBuilderInsertCheckBoxFormField ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertCheckBox //ExId:DocumentBuilderInsertCheckBoxFormField //ExSummary:Shows how to insert a checkbox form field into a document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.insertCheckBox("CheckBox", true, 0); //ExEnd
public void documentBuilderInsertComboBoxFormField ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertComboBox //ExId:DocumentBuilderInsertComboBoxFormField //ExSummary:Shows how to insert a combobox form field into a document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); String[] items = {"One", "Two", "Three"}; builder.insertComboBox("DropDown", items, 0); //ExEnd
public void documentBuilderInsertTOC ( ) throws Exception { //ExStart //ExId:DocumentBuilderInsertTOC //ExSummary:Shows how to insert a Table of Contents field into a document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Insert a table of contents at the beginning of the document. builder.insertTableOfContents("\\o \"1-3\" \\h \\z \\u"); // The newly inserted table of contents will be initially empty. // It needs to be populated by updating the fields in the document. doc.updateFields(); //ExEnd
public void documentBuilderSetFontFormatting ( ) throws Exception { //ExStart //ExId:DocumentBuilderSetFontFormatting //ExSummary:Shows how to set font formatting. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Set font formatting properties Font font = builder.getFont(); font.setBold(true); font.setColor(Color.BLUE); font.setItalic(true); font.setName("Arial"); font.setSize(24); font.setSpacing(5); font.setUnderline(Underline.DOUBLE); // Output formatted text builder.writeln("I'm a very nice formatted string."); //ExEnd
public void documentBuilderSetParagraphFormatting ( ) throws Exception { //ExStart //ExFor:ParagraphFormat.RightIndent //ExFor:ParagraphFormat.LeftIndent //ExFor:ParagraphFormat.SpaceAfter //ExId:DocumentBuilderSetParagraphFormatting //ExSummary:Shows how to set paragraph formatting. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Set paragraph formatting properties ParagraphFormat paragraphFormat = builder.getParagraphFormat(); paragraphFormat.setAlignment(ParagraphAlignment.CENTER); paragraphFormat.setLeftIndent(50); paragraphFormat.setRightIndent(50); paragraphFormat.setSpaceAfter(25); // Output text builder.writeln("I'm a very nice formatted paragraph. I'm intended to demonstrate how the left and right indents affect word wrapping."); builder.writeln("I'm another nice formatted paragraph. I'm intended to demonstrate how the space after paragraph looks like."); //ExEnd
public void documentBuilderSetCellFormatting ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.CellFormat //ExFor:CellFormat.Width //ExFor:CellFormat.LeftPadding //ExFor:CellFormat.RightPadding //ExFor:CellFormat.TopPadding //ExFor:CellFormat.BottomPadding //ExFor:DocumentBuilder.StartTable //ExFor:DocumentBuilder.EndTable //ExId:DocumentBuilderSetCellFormatting //ExSummary:Shows how to create a table that contains a single formatted cell. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.startTable(); builder.insertCell(); // Set the cell formatting CellFormat cellFormat = builder.getCellFormat(); cellFormat.setWidth(250); cellFormat.setLeftPadding(30); cellFormat.setRightPadding(30); cellFormat.setTopPadding(30); cellFormat.setBottomPadding(30); builder.writeln("I'm a wonderful formatted cell."); builder.endRow(); builder.endTable(); //ExEnd
public void documentBuilderSetRowFormatting ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.RowFormat //ExFor:RowFormat.Height //ExFor:RowFormat.HeightRule //ExFor:Table.LeftPadding //ExFor:Table.RightPadding //ExFor:Table.TopPadding //ExFor:Table.BottomPadding //ExId:DocumentBuilderSetRowFormatting //ExSummary:Shows how to create a table that contains a single cell and apply row formatting. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); Table table = builder.startTable(); builder.insertCell(); // Set the row formatting RowFormat rowFormat = builder.getRowFormat(); rowFormat.setHeight(100); rowFormat.setHeightRule(HeightRule.EXACTLY); // These formatting properties are set on the table and are applied to all rows in the table. table.setLeftPadding(30); table.setRightPadding(30); table.setTopPadding(30); table.setBottomPadding(30); builder.writeln("I'm a wonderful formatted row."); builder.endRow(); builder.endTable(); //ExEnd
public void documentBuilderSetListFormatting ( ) throws Exception { //ExStart //ExId:DocumentBuilderSetListFormatting //ExSummary:Shows how to build a multilevel list. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.getListFormat().applyNumberDefault(); builder.writeln("Item 1"); builder.writeln("Item 2"); builder.getListFormat().listIndent(); builder.writeln("Item 2.1"); builder.writeln("Item 2.2"); builder.getListFormat().listIndent(); builder.writeln("Item 2.2.1"); builder.writeln("Item 2.2.2"); builder.getListFormat().listOutdent(); builder.writeln("Item 2.3"); builder.getListFormat().listOutdent(); builder.writeln("Item 3"); builder.getListFormat().removeNumbers(); //ExEnd
public void InsertFootnote ( ) throws Exception { //ExStart //ExFor:Footnote //ExFor:FootnoteType //ExFor:DocumentBuilder.InsertFootnote //ExSummary:Shows how to add a footnote to a paragraph in the document using DocumentBuilder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.write("Some text"); builder.insertFootnote(FootnoteType.FOOTNOTE, "Footnote text."); //ExEnd Assert.assertEquals(doc.getChildNodes(NodeType.FOOTNOTE, true).get(0).toTxt().trim(), "Footnote text."); }
public void documentBuilderSetSectionFormatting ( ) throws Exception { //ExStart //ExId:DocumentBuilderSetSectionFormatting //ExSummary:Shows how to set such properties as page size and orientation for the current section. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Set page properties builder.getPageSetup().setOrientation(Orientation.LANDSCAPE); builder.getPageSetup().setLeftMargin(50); builder.getPageSetup().setPaperSize(PaperSize.PAPER_10_X_14); //ExEnd
public void documentBuilderApplyParagraphStyle ( ) throws Exception { //ExStart //ExId:DocumentBuilderApplyParagraphStyle //ExSummary:Shows how to apply a paragraph style. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Set paragraph style builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.TITLE); builder.write("Hello"); //ExEnd
public void documentBuilderApplyBordersAndShading ( ) throws Exception { //ExStart //ExFor:BorderCollection.Item(BorderType) //ExFor:Shading //ExFor:TextureIndex //ExFor:ParagraphFormat.Shading //ExFor:Shading.Texture //ExFor:Shading.BackgroundPatternColor //ExFor:Shading.ForegroundPatternColor //ExId:DocumentBuilderApplyBordersAndShading //ExSummary:Shows how to apply borders and shading to a paragraph. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Set paragraph borders BorderCollection borders = builder.getParagraphFormat().getBorders(); borders.setDistanceFromText(20); borders.getByBorderType(BorderType.LEFT).setLineStyle(LineStyle.DOUBLE); borders.getByBorderType(BorderType.RIGHT).setLineStyle(LineStyle.DOUBLE); borders.getByBorderType(BorderType.TOP).setLineStyle(LineStyle.DOUBLE); borders.getByBorderType(BorderType.BOTTOM).setLineStyle(LineStyle.DOUBLE); // Set paragraph shading Shading shading = builder.getParagraphFormat().getShading(); shading.setTexture(TextureIndex.TEXTURE_DIAGONAL_CROSS); shading.setBackgroundPatternColor(new Color(240, 128, 128)); // Light Coral shading.setForegroundPatternColor(new Color(255, 160, 122)); // Light Salmon builder.write("I'm a formatted paragraph with double border and nice shading."); //ExEnd
void save ( String fileName , int saveFormat ) throws Exception //ExEnd { // Do nothing. } //ExStart //ExId:CollectionItemSignature //ExSummary:Shows difference in signatures of collection indexers in .NET vs Java. public class HeaderFooterCollection { // Get by index is an indexer. public HeaderFooter get(int index) throws Exception //ExSkip { //ExSkip return null; //ExSkip } //ExSkip // Get by header footer type is an overloaded indexer. public HeaderFooter getByHeaderFooterType(int headerFooterType) throws Exception //ExSkip { //ExSkip return null; //ExSkip } //ExSkip } //ExEnd }
public HeaderFooter get ( int index ) throws Exception //ExSkip { //ExSkip return null; //ExSkip } //ExSkip
public HeaderFooter getByHeaderFooterType ( int headerFooterType ) throws Exception //ExSkip { //ExSkip return null; //ExSkip } //ExSkip
public void updateTOC ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExId:UpdateTOC //ExSummary:Shows how to completely rebuild TOC fields in the document by invoking field update. doc.updateFields(); //ExEnd
public void GetFieldType ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Document.TableOfContents.doc " ) ; //ExStart //ExFor:FieldType //ExFor:FieldChar //ExFor:FieldChar.FieldType //ExSummary:Shows how to find the type of field that is represented by a node which is derived from FieldChar. FieldChar fieldStart = (FieldChar)doc.getChild(NodeType.FIELD_START, 0, true); int type = fieldStart.getFieldType(); //ExEnd
public void insertTCField ( ) throws Exception { //ExStart //ExId:InsertTCField //ExSummary:Shows how to insert a TC field into the document using DocumentBuilder. // Create a blank document. Document doc = new Document(); // Create a document builder to insert content with. DocumentBuilder builder = new DocumentBuilder(doc); // Insert a TC field at the current document builder position. builder.insertField("TC \"Entry Text\" \\f t"); //ExEnd
public void changeLocale ( ) throws Exception { // Create a blank document. Document doc = new Document(); DocumentBuilder b = new DocumentBuilder(doc); b.insertField("MERGEFIELD Date"); //ExStart //ExId:ChangeCurrentCulture //ExSummary:Shows how to change the culture used in formatting fields during update. // Store the current culture so it can be set back once mail merge is complete. Locale currentCulture = Locale.getDefault(); // Set to German language so dates and numbers are formatted using this culture during mail merge. Locale.setDefault(new Locale("de", "DE")); // Execute mail merge doc.getMailMerge().execute(new String[]{"Date"}, new Object[]{new Date()}); // Restore the original culture. Locale.setDefault(currentCulture); //ExEnd doc.save(getMyDir() + "Field.ChangeLocale Out.doc"); }
public void removeTOCFromDocumentCaller ( ) throws Exception { removeTOCFromDocument ( ) ; }
public void removeTOCFromDocument ( ) throws Exception { // Open a document which contains a TOC. Document doc = new Document(getMyDir() + "Document.TableOfContents.doc"); // Remove the first table of contents from the document. removeTableOfContents(doc, 0); // Save the output. doc.save(getMyDir() + "Document.TableOfContentsRemoveTOC Out.doc"); }
static void removeTableOfContents ( Document doc , int index ) throws Exception { // Store the FieldStart nodes of TOC fields in the document for quick access. ArrayList fieldStarts = new ArrayList(); // This is a list to store the nodes found inside the specified TOC. They will be removed // at thee end of this method. ArrayList nodeList = new ArrayList(); for (FieldStart start : (Iterable<FieldStart>) doc.getChildNodes(NodeType.FIELD_START, true)) { if (start.getFieldType() == FieldType.FIELD_TOC) { // Add all FieldStarts which are of type FieldTOC. fieldStarts.add(start); } } // Ensure the TOC specified by the passed index exists. if (index > fieldStarts.size() - 1) throw new ArrayIndexOutOfBoundsException("TOC index is out of range"); boolean isRemoving = true; // Get the FieldStart of the specified TOC. Node currentNode = (Node)fieldStarts.get(index); while (isRemoving) { // It is safer to store these nodes and delete them all at once later. nodeList.add(currentNode); currentNode = currentNode.nextPreOrder(doc); // Once we encounter a FieldEnd node of type FieldTOC then we know we are at the end // of the current TOC and we can stop here. if (currentNode.getNodeType() == NodeType.FIELD_END) { FieldEnd fieldEnd = (FieldEnd)currentNode; if (fieldEnd.getFieldType() == FieldType.FIELD_TOC) isRemoving = false; } } // Remove all nodes found in the specified TOC. for (Node node : (Iterable<Node>) nodeList) {
public void insertTCFieldsAtText ( ) throws Exception { Document doc = new Document ( ) ; // Insert a TC field which displays "Chapter 1" just before the text "The Beginning" in the document. doc.getRange().replace(Pattern.compile("The Beginning"), new InsertTCFieldHandler("Chapter 1", "\\l 1"), false); }
public int replacing ( ReplacingArgs args ) throws Exception { // Create a builder to insert the field. DocumentBuilder builder = new DocumentBuilder((Document)args.getMatchNode().getDocument()); // Move to the first node of the match. builder.moveTo(args.getMatchNode()); // If the user specified text to be used in the field as display text then use that, otherwise use the // match string as the display text. String insertText; if (!(mFieldText == null || "".equals(mFieldText))) insertText = mFieldText; else insertText = args.getMatch().group(); // Insert the TC field before this node using the specified string as the display text and user defined switches. builder.insertField(java.text.MessageFormat.format("TC \"{0}\" {1}", insertText, mFieldSwitches)); // We have done what we want so skip replacement. return ReplaceAction.SKIP; }
public void createFormattedRun ( ) throws Exception { //ExStart //ExFor:Document.#ctor //ExFor:Font //ExFor:Font.Name //ExFor:Font.Size //ExFor:Font.HighlightColor //ExFor:Run //ExFor:Run.#ctor(DocumentBase,String) //ExFor:Story.FirstParagraph //ExSummary:Shows how to add a formatted run of text to a document using the object model. // Create an empty document. It contains one empty paragraph. Document doc = new Document(); // Create a new run of text. Run run = new Run(doc, "Hello"); // Specify character formatting for the run of text. Font f = run.getFont(); f.setName("Courier New"); f.setSize(36); f.setHighlightColor(Color.YELLOW); // Append the run of text to the end of the first paragraph // in the body of the first section of the document. doc.getFirstSection().getBody().getFirstParagraph().appendChild(run); //ExEnd
public void caps ( ) throws Exception { //ExStart //ExFor:Font.AllCaps //ExFor:Font.SmallCaps //ExSummary:Shows how to use all capitals and small capitals character formatting properties. // Create an empty document. It contains one empty paragraph. Document doc = new Document(); // Get the paragraph from the document, we will be adding runs of text to it. Paragraph para = (Paragraph)doc.getChild(NodeType.PARAGRAPH, 0, true); Run run = new Run(doc, "All capitals"); run.getFont().setAllCaps(true); para.appendChild(run); run = new Run(doc, "SMALL CAPITALS"); run.getFont().setSmallCaps(true); para.appendChild(run); //ExEnd
public void getDocumentFonts ( ) throws Exception { //ExStart: //ExFor:FontInfoCollection //ExFor:DocumentBase.FontInfos //ExFor:FontInfo //ExFor:FontInfo.Name //ExFor:FontInfo.IsTrueType //ExSummary:Shows how to gather the details of what fonts are present in a document. Document doc = new Document(getMyDir() + "Document.doc"); FontInfoCollection fonts = doc.getFontInfos(); int fontIndex = 1; // The fonts info extracted from this document does not necessarily mean that the fonts themselves are // used in the document. If a font is present but not used then most likely they were referenced at some time // and then removed from the Document. for (FontInfo info : fonts) {
public void strikethrough ( ) throws Exception { //ExStart //ExFor:Font.StrikeThrough //ExFor:Font.DoubleStrikeThrough //ExSummary:Shows how to use strike-through character formatting properties. // Create an empty document. It contains one empty paragraph. Document doc = new Document(); // Get the paragraph from the document, we will be adding runs of text to it. Paragraph para = (Paragraph)doc.getChild(NodeType.PARAGRAPH, 0, true); Run run = new Run(doc, "Double strike through text"); run.getFont().setDoubleStrikeThrough(true); para.appendChild(run); run = new Run(doc, "Single strike through text"); run.getFont().setStrikeThrough(true); para.appendChild(run); //ExEnd
public void positionSubscript ( ) throws Exception { //ExStart //ExFor:Font.Position //ExFor:Font.Subscript //ExFor:Font.Superscript //ExSummary:Shows how to use subscript, superscript and baseline text position properties. // Create an empty document. It contains one empty paragraph. Document doc = new Document(); // Get the paragraph from the document, we will be adding runs of text to it. Paragraph para = (Paragraph)doc.getChild(NodeType.PARAGRAPH, 0, true); // Add a run of text that is raised 5 points above the baseline. Run run = new Run(doc, "Raised text"); run.getFont().setPosition(5); para.appendChild(run); // Add a run of normal text. run = new Run(doc, "Normal text"); para.appendChild(run); para.appendChild(run); // Add a run of text that appears as subscript. run = new Run(doc, "Subscript"); run.getFont().setSubscript(true); para.appendChild(run); // Add a run of text that appears as superscript. run = new Run(doc, "Superscript"); run.getFont().setSuperscript(true); para.appendChild(run); //ExEnd
public void scalingSpacing ( ) throws Exception { //ExStart //ExFor:Font.Scaling //ExFor:Font.Spacing //ExSummary:Shows how to use character scaling and spacing properties. // Create an empty document. It contains one empty paragraph. Document doc = new Document(); // Get the paragraph from the document, we will be adding runs of text to it. Paragraph para = (Paragraph)doc.getChild(NodeType.PARAGRAPH, 0, true); // Add a run of text with characters 150% width of normal characters. Run run = new Run(doc, "Wide characters"); run.getFont().setScaling(150); para.appendChild(run); // Add a run of text with extra 1pt space between characters. run = new Run(doc, "Expanded by 1pt"); run.getFont().setSpacing(1); para.appendChild(run); // Add a run of text with with space between characters reduced by 1pt. run = new Run(doc, "Condensed by 1pt"); run.getFont().setSpacing(-1); para.appendChild(run); //ExEnd
public void embossItalic ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Font.Emboss //ExFor:Font.Italic //ExSummary:Shows how to create a run of formatted text. Run run = new Run(doc, "Hello"); run.getFont().setEmboss(true); run.getFont().setItalic(true); //ExEnd
public void engrave ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Font.Engrave //ExSummary:Shows how to create a run of text formatted as engraved. Run run = new Run(doc, "Hello"); run.getFont().setEngrave(true); //ExEnd
public void shadow ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Font.Shadow //ExSummary:Shows how to create a run of text formatted with a shadow. Run run = new Run(doc, "Hello"); run.getFont().setEngrave(true); //ExEnd
public void outline ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Font.Outline //ExSummary:Shows how to create a run of text formatted as outline. Run run = new Run(doc, "Hello"); run.getFont().setOutline(true); //ExEnd
public void hidden ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Font.Hidden //ExSummary:Shows how to create a hidden run of text. Run run = new Run(doc, "Hello"); run.getFont().setHidden(true); //ExEnd
public void kerning ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Font.Kerning //ExSummary:Shows how to specify the font size at which kerning starts. Run run = new Run(doc, "Hello"); run.getFont().setKerning(24); //ExEnd
public void noProofing ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Font.NoProofing //ExSummary:Shows how to specify that the run of text is not to be spell checked by Microsoft Word. Run run = new Run(doc, "Hello"); run.getFont().setNoProofing(true); //ExEnd
public void underlines ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Font.Underline //ExFor:Font.UnderlineColor //ExSummary:Shows how use the underline character formatting properties. Run run = new Run(doc, "Hello"); run.getFont().setUnderline(Underline.DOTTED); run.getFont().setUnderlineColor(Color.RED); //ExEnd
public void shading ( ) throws Exception { //ExStart //ExFor:Font.Shading //ExSummary:Shows how to apply shading for a run of text. DocumentBuilder builder = new DocumentBuilder(); Shading shd = builder.getFont().getShading(); shd.setTexture(TextureIndex.TEXTURE_DIAGONAL_CROSS); shd.setBackgroundPatternColor(Color.BLUE); shd.setForegroundPatternColor(new Color(138, 43, 226)); // Violet-blue builder.getFont().setColor(Color.WHITE); builder.writeln("White text on a blue background with texture."); //ExEnd
public void changeStyleIdentifier ( ) throws Exception { //ExStart //ExFor:Font.StyleIdentifier //ExFor:StyleIdentifier //ExSummary:Shows how to use style identifier to find text formatted with a specific character style and apply different character style. Document doc = new Document(getMyDir() + "Font.StyleIdentifier.doc"); // Select all run nodes in the document. NodeCollection runs = doc.getChildNodes(NodeType.RUN, true); // Loop through every run node. for (Run run : (Iterable<Run>) runs) { // If the character style of the run is what we want, do what we need. Change the style in this case. // Note that using StyleIdentifier we can identify a built-in style regardless // of the language of Microsoft Word used to create the document. if (run.getFont().getStyleIdentifier() == StyleIdentifier.EMPHASIS) run.getFont().setStyleIdentifier(StyleIdentifier.STRONG); } doc.save(getMyDir() + "Font.StyleIdentifier Out.doc"); //ExEnd
public void changeStyleName ( ) throws Exception { //ExStart //ExFor:Font.StyleName //ExSummary:Shows how to use style name to find text formatted with a specific character style and apply different character style. Document doc = new Document(getMyDir() + "Font.StyleName.doc"); // Select all run nodes in the document. NodeCollection runs = doc.getChildNodes(NodeType.RUN, true); // Loop through every run node. for (Run run : (Iterable<Run>) runs) { // If the character style of the run is what we want, do what we need. Change the style in this case. // Note that names of built in styles could be different in documents // created by Microsoft Word versions for different languages. if (run.getFont().getStyleName().equals("Emphasis")) run.getFont().setStyleName("Strong"); } doc.save(getMyDir() + "Font.StyleName Out.doc"); //ExEnd
public void style ( ) throws Exception { //ExStart //ExFor:Font.Style //ExFor:Style.BuiltIn //ExSummary:Applies double underline to all runs in a document that are formatted with custom character styles. Document doc = new Document(getMyDir() + "Font.Style.doc"); // Select all run nodes in the document. NodeCollection runs = doc.getChildNodes(NodeType.RUN, true); // Loop through every run node. for (Run run : (Iterable<Run>) runs) { Style charStyle = run.getFont().getStyle(); // If the style of the run is not a built-in character style, apply double underline. if (!charStyle.getBuiltIn()) run.getFont().setUnderline(Underline.DOUBLE); } doc.save(getMyDir() + "Font.Style Out.doc"); //ExEnd
public void getAllFonts ( ) throws Exception { //ExStart //ExFor:Run //ExSummary:Gets all fonts used in a document. Document doc = new Document(getMyDir() + "Font.Names.doc"); // Select all runs in the document. NodeCollection runs = doc.getChildNodes(NodeType.RUN, true, false); // Use a hashtable so we will keep only unique font names. HashMap fontNames = new HashMap(); for (Run run : (Iterable<Run>) runs) { // This adds an entry into the hashmap. // The key is the font name. The value is null, we don't need the value. fontNames.put(run.getFont().getName(), null); } // There are two fonts used in this document. System.out.println("Font Count: " + fontNames.size()); //ExEnd // Verify the font count is correct. Assert.assertEquals(fontNames.size(), 2);
public void removeHiddenContentCaller ( ) throws Exception { removeHiddenContentFromDocument ( ) ; }
public void removeHiddenContentFromDocument ( ) throws Exception { // Open the document we want to remove hidden content from. Document doc = new Document(getMyDir() + "Font.Hidden.doc"); // Create an object that inherits from the DocumentVisitor class. RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor(); // This is the well known Visitor pattern. Get the model to accept a visitor. // The model will iterate through itself by calling the corresponding methods // on the visitor object (this is called visiting). // We can run it over the entire the document like so: doc.accept(hiddenContentRemover); // Or we can run it on only a specific node. Paragraph para = (Paragraph)doc.getChild(NodeType.PARAGRAPH, 4, true); para.accept(hiddenContentRemover); // Or over a different type of node like below. Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); table.accept(hiddenContentRemover); doc.save(getMyDir() + "Font.Hidden Out.doc"); Assert.assertEquals(doc.getChildNodes(NodeType.PARAGRAPH, true).getCount(), 13); //ExSkip Assert.assertEquals(doc.getChildNodes(NodeType.TABLE, true).getCount(), 1); //ExSkip }
public int visitFieldStart ( FieldStart fieldStart ) throws Exception { // If this node is hidden, then remove it. if (isHidden(fieldStart)) fieldStart.remove(); return VisitorAction.CONTINUE; }
public int visitFieldEnd ( FieldEnd fieldEnd ) throws Exception { if ( isHidden ( fieldEnd ) ) fieldEnd . remove ( ) ; return VisitorAction . CONTINUE ; }
public int visitRun ( Run run ) throws Exception { if ( isHidden ( run ) ) run . remove ( ) ; return VisitorAction . CONTINUE ; }
public int visitParagraphStart ( Paragraph paragraph ) throws Exception { if ( isHidden ( paragraph ) ) paragraph . remove ( ) ; return VisitorAction . CONTINUE ; }
public int visitFormField ( FormField field ) throws Exception { if ( isHidden ( field ) ) field . remove ( ) ; return VisitorAction . CONTINUE ; }
public int visitGroupShapeStart ( GroupShape groupShape ) throws Exception { if ( isHidden ( groupShape ) ) groupShape . remove ( ) ; return VisitorAction . CONTINUE ; }
public int visitShapeStart ( Shape shape ) throws Exception { if ( isHidden ( shape ) ) shape . remove ( ) ; return VisitorAction . CONTINUE ; }
public int visitCommentStart ( Comment comment ) throws Exception { if ( isHidden ( comment ) ) comment . remove ( ) ; return VisitorAction . CONTINUE ; }
public int visitFootnoteStart ( Footnote footnote ) throws Exception { if ( isHidden ( footnote ) ) footnote . remove ( ) ; return VisitorAction . CONTINUE ; }
public int visitDrawingML ( DrawingML drawingML ) throws Exception { if ( isHidden ( drawingML ) ) drawingML . remove ( ) ; return VisitorAction . CONTINUE ; }
public int visitTableEnd ( Table table ) throws Exception { // At the moment there is no way to tell if a particular Table/Row/Cell is hidden. // Instead, if the content of a table is hidden, then all inline child nodes of the table should be // hidden and thus removed by previous visits as well. This will result in the container being empty // so if this is the case we know to remove the table node. // // Note that a table which is not hidden but simply has no content will not be affected by this algorthim, // as technically they are not completely empty (for example a properly formed Cell will have at least // an empty paragraph in it) if (!table.hasChildNodes()) table.remove(); return VisitorAction.CONTINUE; }
public int visitCellEnd ( Cell cell ) throws Exception { if ( ! cell . hasChildNodes ( ) & & cell . getParentNode ( ) ! = null ) cell . remove ( ) ; return VisitorAction . CONTINUE ; }
public int visitRowEnd ( Row row ) throws Exception { if ( ! row . hasChildNodes ( ) & & row . getParentNode ( ) ! = null ) row . remove ( ) ; return VisitorAction . CONTINUE ; }
public int visitSpecialChar ( SpecialChar character ) throws Exception { if ( isHidden ( character ) ) character . remove ( ) ; return VisitorAction . CONTINUE ; }
private boolean isHidden ( Node node ) throws Exception { if ( node instanceof Inline ) { // If the node is Inline then cast it to retrieve the Font property which contains the hidden property Inline currentNode = (Inline)node; return currentNode.getFont().getHidden(); } else if (node.getNodeType() == NodeType.PARAGRAPH) { // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property Paragraph para = (Paragraph)node; return para.getParagraphBreakFont().getHidden(); } else if (node instanceof ShapeBase) { // Node is a shape or groupshape. ShapeBase shape = (ShapeBase)node; return shape.getFont().getHidden(); } else if (node instanceof InlineStory) { // Node is a comment or footnote. InlineStory inlineStory = (InlineStory)node; return inlineStory.getFont().getHidden(); } // A node that is passed to this method which does not contain a hidden property will end up here. // By default nodes are not hidden so return false. return false; }
public void formFieldsGetFormFieldsCollection ( ) throws Exception { //ExStart //ExFor:Range.FormFields //ExFor:FormFieldCollection //ExId:FormFieldsGetFormFieldsCollection //ExSummary:Shows how to get a collection of form fields. Document doc = new Document(getMyDir() + "FormFields.doc"); FormFieldCollection formFields = doc.getRange().getFormFields(); //ExEnd
public void formFieldsGetByName ( ) throws Exception { //ExStart //ExFor:FormField //ExId:FormFieldsGetByName //ExSummary:Shows how to access form fields. Document doc = new Document(getMyDir() + "FormFields.doc"); FormFieldCollection documentFormFields = doc.getRange().getFormFields(); FormField formField1 = documentFormFields.get(3); FormField formField2 = documentFormFields.get("CustomerName"); //ExEnd
public void formFieldsWorkWithProperties ( ) throws Exception { //ExStart //ExFor:FormField //ExFor:FormField.Result //ExFor:FormField.Type //ExFor:FormField.Name //ExId:FormFieldsWorkWithProperties //ExSummary:Shows how to work with form field name, type, and result. Document doc = new Document(getMyDir() + "FormFields.doc"); FormField formField = doc.getRange().getFormFields().get(3); if (formField.getType() == FieldType.FIELD_FORM_TEXT_INPUT) formField.setResult("My name is " + formField.getName());
public void insertAndRetrieveFormFields ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertTextInput //ExId:FormFieldsInsertAndRetrieve //ExSummary:Shows how to insert FormFields, set options annd gather them back in for use Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Insert a text input field. The unique name of this field is "TextInput1", the other parameters define // what type of FormField it is, the format of the text, the field result and the maximum text length (0 = no limit) builder.insertTextInput("TextInput1", TextFormFieldType.REGULAR, "", "", 0); //ExEnd
public void createFooter ( ) throws Exception { //ExStart //ExFor:HeaderFooter //ExFor:HeaderFooter.#ctor(DocumentBase, HeaderFooterType) //ExFor:HeaderFooterCollection //ExFor:Story.AppendParagraph //ExSummary:Creates a footer using the document object model and inserts it into a section. Document doc = new Document(); HeaderFooter footer = new HeaderFooter(doc, HeaderFooterType.FOOTER_PRIMARY); doc.getFirstSection().getHeadersFooters().add(footer); // Add a paragraph with text to the footer. footer.appendParagraph("TEST FOOTER"); doc.save(getMyDir() + "HeaderFooter.CreateFooter Out.doc"); //ExEnd doc = new Document(getMyDir() + "HeaderFooter.CreateFooter Out.doc"); Assert.assertTrue(doc.getFirstSection().getHeadersFooters().getByHeaderFooterType(HeaderFooterType.FOOTER_PRIMARY).getRange().getText().contains("TEST FOOTER")); }
public void removeFooters ( ) throws Exception { //ExStart //ExFor:Section.HeadersFooters //ExFor:HeaderFooterCollection //ExFor:HeaderFooterCollection.Item(HeaderFooterType) //ExFor:HeaderFooter //ExFor:HeaderFooterType //ExId:RemoveFooters //ExSummary:Deletes all footers from all sections, but leaves headers intact. Document doc = new Document(getMyDir() + "HeaderFooter.RemoveFooters.doc"); for (Section section : doc.getSections()) { // Up to three different footers are possible in a section (for first, even and odd pages). // We check and delete all of them. HeaderFooter footer; footer = section.getHeadersFooters().getByHeaderFooterType(HeaderFooterType.FOOTER_FIRST); if (footer != null) footer.remove(); // Primary footer is the footer used for odd pages. footer = section.getHeadersFooters().getByHeaderFooterType(HeaderFooterType.FOOTER_PRIMARY); if (footer != null) footer.remove(); footer = section.getHeadersFooters().getByHeaderFooterType(HeaderFooterType.FOOTER_EVEN); if (footer != null) footer.remove(); } doc.save(getMyDir() + "HeaderFooter.RemoveFooters Out.doc"); //ExEnd
public void SetExportHeadersFootersMode ( ) throws Exception { //ExStart //ExFor:ExportHeadersFootersMode //ExFor:HtmlSaveOptions.ExportHeadersFootersMode //ExSummary:Demonstrates how to disable the export of headers and footers when saving to HTML based formats. Document doc = new Document(getMyDir() + "HeaderFooter.RemoveFooters.doc"); HtmlSaveOptions saveOptions = new HtmlSaveOptions(SaveFormat.HTML); saveOptions.setExportHeadersFootersMode(ExportHeadersFootersMode.NONE); // Disables exporting headers and footers. doc.save(getMyDir() + "HeaderFooter.DisableHeadersFooters Out.html", saveOptions); //ExEnd // Verify that the output document is correct. doc = new Document(getMyDir() + "HeaderFooter.DisableHeadersFooters Out.html"); Assert.assertFalse(doc.getRange().getText().contains("DYNAMIC TEMPLATE")); }
public void replaceText ( ) throws Exception { //ExStart //ExFor:Document.FirstSection //ExFor:Section.HeadersFooters //ExFor:HeaderFooterCollection.Item(HeaderFooterType) //ExFor:HeaderFooter //ExFor:Range.Replace(String, String, Boolean, Boolean) //ExSummary:Shows how to replace text in the document footer. // Open the template document, containing obsolete copyright information in the footer. Document doc = new Document(getMyDir() + "HeaderFooter.ReplaceText.doc"); HeaderFooterCollection headersFooters = doc.getFirstSection().getHeadersFooters(); HeaderFooter footer = headersFooters.getByHeaderFooterType(HeaderFooterType.FOOTER_PRIMARY); footer.getRange().replace("(C) 2006 Aspose Pty Ltd.", "Copyright (C) 2011 by Aspose Pty Ltd.", false, false); doc.save(getMyDir() + "HeaderFooter.ReplaceText Out.doc"); //ExEnd // Verify that the appropriate changes were made to the output document. doc = new Document(getMyDir() + "HeaderFooter.ReplaceText Out.doc"); Assert.assertTrue(doc.getRange().getText().contains("Copyright (C) 2011 by Aspose Pty Ltd.")); }
public void headerFooterPrimerCaller ( ) throws Exception { primer ( ) ; }
private static void copyHeadersFootersFromPreviousSection ( Section section ) throws Exception { Section previousSection = ( Section ) section . getPreviousSibling ( ) ; if ( previousSection = = null ) return ; section . getHeadersFooters ( ) . clear ( ) ; for ( HeaderFooter headerFooter : previousSection . getHeadersFooters ( ) ) section . getHeadersFooters ( ) . add ( headerFooter . deepClone ( true ) ) ;
public void createFromUrl ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertImage(string) //ExFor:DocumentBuilder.Writeln //ExSummary:Shows how to inserts an image from a URL. The image is inserted inline and at 100% scale. // This creates a builder and also an empty document inside the builder. DocumentBuilder builder = new DocumentBuilder(); builder.write("Image from local file: "); builder.insertImage(getMyDir() + "Aspose.Words.gif"); builder.writeln(); builder.write("Image from an internet url, automatically downloaded for you: "); builder.insertImage("http://www.aspose.com/Images/aspose-logo.jpg"); builder.writeln(); builder.getDocument().save(getMyDir() + "Image.CreateFromUrl Out.doc"); //ExEnd
public void createFromStream ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertImage(Stream) //ExSummary:Shows how to insert an image from a stream. The image is inserted inline and at 100% scale. // This creates a builder and also an empty document inside the builder. DocumentBuilder builder = new DocumentBuilder(); InputStream stream = new FileInputStream(getMyDir() + "Aspose.Words.gif"); try { builder.write("Image from stream: "); builder.insertImage(stream); } finally { stream.close(); } builder.getDocument().save(getMyDir() + "Image.CreateFromStream Out.doc"); //ExEnd
public void createFromImage ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertImage(Image) //ExSummary:Shows how to insert a .NET Image object into a document. The image is inserted inline and at 100% scale. // This creates a builder and also an empty document inside the builder. DocumentBuilder builder = new DocumentBuilder(); // Insert a raster image. BufferedImage rasterImage = ImageIO.read(new File(getMyDir() + "Aspose.Words.gif")); builder.write("Raster image: "); builder.insertImage(rasterImage); builder.writeln(); // Aspose.Words allows to insert a metafile too, but on Java you should specify a filename or a stream, not a BufferedImage. builder.write("Metafile: "); builder.insertImage(getMyDir() + "Hammer.wmf"); builder.writeln(); builder.getDocument().save(getMyDir() + "Image.CreateFromImage Out.doc"); //ExEnd
public void createFloatingPageCenter ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.InsertImage(string) //ExFor:Shape //ExFor:ShapeBase //ExFor:ShapeBase.WrapType //ExFor:ShapeBase.BehindText //ExFor:ShapeBase.RelativeHorizontalPosition //ExFor:ShapeBase.RelativeVerticalPosition //ExFor:ShapeBase.HorizontalAlignment //ExFor:ShapeBase.VerticalAlignment //ExFor:WrapType //ExFor:RelativeHorizontalPosition //ExFor:RelativeVerticalPosition //ExFor:HorizontalAlignment //ExFor:VerticalAlignment //ExSummary:Shows how to insert a floating image in the middle of a page. // This creates a builder and also an empty document inside the builder. DocumentBuilder builder = new DocumentBuilder(); // By default, the image is inline. Shape shape = builder.insertImage(getMyDir() + "Aspose.Words.gif"); // Make the image float, put it behind text and center on the page. shape.setWrapType(WrapType.NONE); shape.setBehindText(true); shape.setRelativeHorizontalPosition(RelativeHorizontalPosition.PAGE); shape.setHorizontalAlignment(HorizontalAlignment.CENTER); shape.setRelativeVerticalPosition(RelativeVerticalPosition.PAGE); shape.setVerticalAlignment(VerticalAlignment.CENTER); builder.getDocument().save(getMyDir() + "Image.CreateFloatingPageCenter Out.doc"); //ExEnd
public void createFloatingPositionSize ( ) throws Exception { //ExStart //ExFor:ShapeBase.Left //ExFor:ShapeBase.Top //ExFor:ShapeBase.Width //ExFor:ShapeBase.Height //ExFor:DocumentBuilder.CurrentSection //ExFor:PageSetup.PageWidth //ExSummary:Shows how to insert a floating image and specify its position and size. // This creates a builder and also an empty document inside the builder. DocumentBuilder builder = new DocumentBuilder(); // By default, the image is inline. Shape shape = builder.insertImage(getMyDir() + "Hammer.wmf"); // Make the image float, put it behind text and center on the page. shape.setWrapType(WrapType.NONE); // Make position relative to the page. shape.setRelativeHorizontalPosition(RelativeHorizontalPosition.PAGE); shape.setRelativeVerticalPosition(RelativeVerticalPosition.PAGE); // Make the shape occupy a band 50 points high at the very top of the page. shape.setLeft(0); shape.setTop(0); shape.setWidth(builder.getCurrentSection().getPageSetup().getPageWidth()); shape.setHeight(50); builder.getDocument().save(getMyDir() + "Image.CreateFloatingPositionSize Out.doc"); //ExEnd
public void insertImageWithHyperlink ( ) throws Exception { //ExStart //ExFor:ShapeBase.HRef //ExFor:ShapeBase.ScreenTip //ExSummary:Shows how to insert an image with a hyperlink. // This creates a builder and also an empty document inside the builder. DocumentBuilder builder = new DocumentBuilder(); Shape shape = builder.insertImage(getMyDir() + "Hammer.wmf"); shape.setHRef("http://www.aspose.com/Community/Forums/75/ShowForum.aspx"); shape.setScreenTip("Aspose.Words Support Forums"); builder.getDocument().save(getMyDir() + "Image.InsertImageWithHyperlink Out.doc"); //ExEnd
public void createImageDirectly ( ) throws Exception { //ExStart //ExFor:Shape.#ctor(DocumentBase,ShapeType) //ExFor:ShapeType //ExSummary:Shows how to create and add an image to a document without using document builder. Document doc = new Document(); Shape shape = new Shape(doc, ShapeType.IMAGE); shape.getImageData().setImage(getMyDir() + "Hammer.wmf"); shape.setWidth(100); shape.setHeight(100); doc.getFirstSection().getBody().getFirstParagraph().appendChild(shape); doc.save(getMyDir() + "Image.CreateImageDirectly Out.doc"); //ExEnd
public void createLinkedImage ( ) throws Exception { //ExStart //ExFor:Shape.ImageData //ExFor:ImageData //ExFor:ImageData.SourceFullName //ExFor:ImageData.SetImage(string) //ExFor:DocumentBuilder.InsertNode //ExSummary:Shows how to insert a linked image into a document. DocumentBuilder builder = new DocumentBuilder(); String imageFileName = getMyDir() + "Hammer.wmf"; builder.write("Image linked, not stored in the document: "); Shape linkedOnly = new Shape(builder.getDocument(), ShapeType.IMAGE); linkedOnly.setWrapType(WrapType.INLINE); linkedOnly.getImageData().setSourceFullName(imageFileName); builder.insertNode(linkedOnly); builder.writeln(); builder.write("Image linked and stored in the document: "); Shape linkedAndStored = new Shape(builder.getDocument(), ShapeType.IMAGE); linkedAndStored.setWrapType(WrapType.INLINE); linkedAndStored.getImageData().setSourceFullName(imageFileName); linkedAndStored.getImageData().setImage(imageFileName); builder.insertNode(linkedAndStored); builder.writeln(); builder.write("Image stored in the document, but not linked: "); Shape stored = new Shape(builder.getDocument(), ShapeType.IMAGE); stored.setWrapType(WrapType.INLINE); stored.getImageData().setImage(imageFileName); builder.insertNode(stored); builder.writeln(); builder.getDocument().save(getMyDir() + "Image.CreateLinkedImage Out.doc"); //ExEnd
public void deleteAllImages ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Image.SampleImages.doc " ) ; Assert . assertEquals ( doc . getChildNodes ( NodeType . SHAPE , true , false ) . getCount ( ) , 6 ) ; //ExStart //ExFor:Shape.HasImage //ExFor:Node.Remove //ExSummary:Shows how to delete all images from a document. // Here we get all shapes from the document node, but you can do this for any smaller // node too, for example delete shapes from a single section or a paragraph. NodeCollection shapes = doc.getChildNodes(NodeType.SHAPE, true, false); // We cannot delete shape nodes while we enumerate through the collection. // One solution is to add nodes that we want to delete to a temporary array and delete afterwards. ArrayList shapesToDelete = new ArrayList(); for (Shape shape : (Iterable<Shape>) shapes) { // Several shape types can have an image including image shapes and OLE objects. if (shape.hasImage()) shapesToDelete.add(shape); } // Now we can delete shapes. for (Shape shape : (Iterable<Shape>) shapesToDelete) shape.remove(); //ExEnd Assert.assertEquals(doc.getChildNodes(NodeType.SHAPE, true, false).getCount(), 1); doc.save(getMyDir() + "Image.DeleteAllImages Out.doc"); }
public void deleteAllImagesPreOrder ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Image.SampleImages.doc " ) ; Assert . assertEquals ( doc . getChildNodes ( NodeType . SHAPE , true , false ) . getCount ( ) , 6 ) ; //ExStart //ExFor:Node.NextPreOrder //ExSummary:Shows how to delete all images from a document using pre-order tree traversal. Node curNode = doc; while (curNode != null) { Node nextNode = curNode.nextPreOrder(doc); if (curNode.getNodeType() == NodeType.SHAPE) { Shape shape = (Shape)curNode; // Several shape types can have an image including image shapes and OLE objects. if (shape.hasImage()) shape.remove(); } curNode = nextNode; } //ExEnd Assert.assertEquals(doc.getChildNodes(NodeType.SHAPE, true, false).getCount(), 1); doc.save(getMyDir() + "Image.DeleteAllImagesPreOrder Out.doc"); }
public void extractImagesToFiles ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Image.SampleImages.doc " ) ; NodeCollection shapes = doc . getChildNodes ( NodeType . SHAPE , true , false ) ; int imageIndex = 0 ; for ( Shape shape : ( Iterable < Shape > ) shapes ) {
public void scaleImage ( ) throws Exception { //ExStart //ExFor:ImageData.ImageSize //ExFor:ImageSize //ExFor:ImageSize.WidthPoints //ExFor:ImageSize.HeightPoints //ExFor:ShapeBase.Width //ExFor:ShapeBase.Height //ExSummary:Shows how to resize an image shape. DocumentBuilder builder = new DocumentBuilder(); // By default, the image is inserted at 100% scale. Shape shape = builder.insertImage(getMyDir() + "Aspose.Words.gif"); // It is easy to change the shape size. In this case, make it 50% relative to the current shape size. shape.setWidth(shape.getWidth() * 0.5); shape.setHeight(shape.getHeight() * 0.5); // However, we can also go back to the original image size and scale from there, say 110%. ImageSize imageSize = shape.getImageData().getImageSize(); shape.setWidth(imageSize.getWidthPoints() * 1.1); shape.setHeight(imageSize.getHeightPoints() * 1.1); builder.getDocument().save(getMyDir() + "Image.ScaleImage Out.doc"); //ExEnd
public void addFootnote ( ) throws Exception { //ExStart //ExFor:Footnote //ExFor:FootnoteType //ExFor:InlineStory //ExFor:InlineStory.Paragraphs //ExFor:InlineStory.FirstParagraph //ExFor:Footnote.#ctor //ExSummary:Shows how to add a footnote to a paragraph in the document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.write("Some text is added."); Footnote footnote = new Footnote(doc, FootnoteType.FOOTNOTE); builder.getCurrentParagraph().appendChild(footnote); footnote.getParagraphs().add(new Paragraph(doc)); footnote.getFirstParagraph().getRuns().add(new Run(doc, "Footnote text.")); //ExEnd Assert.assertEquals(doc.getChildNodes(NodeType.FOOTNOTE, true).get(0).toTxt().trim(), "Footnote text."); }
public void addComment ( ) throws Exception { //ExStart //ExFor:Comment //ExFor:InlineStory //ExFor:InlineStory.Paragraphs //ExFor:InlineStory.FirstParagraph //ExFor:Comment.#ctor(DocumentBase, String, String, DateTime) //ExSummary:Shows how to add a comment to a paragraph in the document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.write("Some text is added."); Comment comment = new Comment(doc, "Amy Lee", "AL", new Date()); builder.getCurrentParagraph().appendChild(comment); comment.getParagraphs().add(new Paragraph(doc)); comment.getFirstParagraph().getRuns().add(new Run(doc, "Comment text.")); //ExEnd Assert.assertEquals((doc.getChildNodes(NodeType.COMMENT, true).get(0)).getText(), "Comment text.\r"); }
public static void insertDocument ( Node insertAfterNode , Document srcDoc ) throws Exception { // Make sure that the node is either a paragraph or table. if ((insertAfterNode.getNodeType() != NodeType.PARAGRAPH) & (insertAfterNode.getNodeType() != NodeType.TABLE)) throw new IllegalArgumentException("The destination node should be either a paragraph or table."); // We will be inserting into the parent of the destination paragraph. CompositeNode dstStory = insertAfterNode.getParentNode(); // This object will be translating styles and lists during the import. NodeImporter importer = new NodeImporter(srcDoc, insertAfterNode.getDocument(), ImportFormatMode.KEEP_SOURCE_FORMATTING); // Loop through all sections in the source document. for (Section srcSection : srcDoc.getSections()) {
public void insertDocumentAtBookmark ( ) throws Exception { //ExStart //ExId:InsertDocumentAtBookmark //ExSummary:Invokes the InsertDocument method shown above to insert a document at a bookmark. Document mainDoc = new Document(getMyDir() + "InsertDocument1.doc"); Document subDoc = new Document(getMyDir() + "InsertDocument2.doc"); Bookmark bookmark = mainDoc.getRange().getBookmarks().get("insertionPlace"); insertDocument(bookmark.getBookmarkStart().getParentNode(), subDoc); mainDoc.save(getMyDir() + "InsertDocumentAtBookmark Out.doc"); //ExEnd
public void insertDocumentAtMailMergeCaller ( ) throws Exception { insertDocumentAtMailMerge ( ) ; }
public void insertDocumentAtMailMerge ( ) throws Exception { // Open the main document. Document mainDoc = new Document(getMyDir() + "InsertDocument1.doc"); // Add a handler to MergeField event mainDoc.getMailMerge().setFieldMergingCallback(new InsertDocumentAtMailMergeHandler()); // The main document has a merge field in it called "Document_1". // The corresponding data for this field contains fully qualified path to the document // that should be inserted to this field. mainDoc.getMailMerge().execute( new String[] { "Document_1" }, new String[] { getMyDir() + "InsertDocument2.doc" }); mainDoc.save(getMyDir() + "InsertDocumentAtMailMerge Out.doc"); }
public void fieldMerging ( FieldMergingArgs e ) throws Exception { if ( " Document_1 " . equals ( e . getDocumentFieldName ( ) ) ) {
public void imageFieldMerging ( ImageFieldMergingArgs args ) throws Exception { // Do nothing. } } //ExEnd @Test public void insertDocumentAtReplaceCaller() throws Exception { insertDocumentAtReplace(); } //ExStart //ExFor:Range.Replace(Regex,IReplacingCallback,Boolean) //ExFor:IReplacingCallback //ExFor:IReplacingCallback.Replacing //ExFor:ReplaceAction //ExFor:ReplacingArgs //ExFor:ReplacingArgs.MatchNode //ExId:InsertDocumentAtReplace //ExSummary:Shows how to insert content of one document into another during a customized find and replace operation. public void insertDocumentAtReplace() throws Exception { Document mainDoc = new Document(getMyDir() + "InsertDocument1.doc"); mainDoc.getRange().replace(Pattern.compile("\\[MY_DOCUMENT\\]"), new InsertDocumentAtReplaceHandler(), false); mainDoc.save(getMyDir() + "InsertDocumentAtReplace Out.doc"); } private class InsertDocumentAtReplaceHandler implements IReplacingCallback { public int replacing(ReplacingArgs e) throws Exception { Document subDoc = new Document(getMyDir() + "InsertDocument2.doc"); // Insert a document after the paragraph, containing the match text. Paragraph para = (Paragraph)e.getMatchNode().getParentNode(); insertDocument(para, subDoc); // Remove the paragraph with the match text. para.remove(); return ReplaceAction.SKIP; } } //ExEnd }
public void insertDocumentAtReplaceCaller ( ) throws Exception { insertDocumentAtReplace ( ) ; }
public void insertDocumentAtReplace ( ) throws Exception { Document mainDoc = new Document ( getMyDir ( ) + " InsertDocument1.doc " ) ; mainDoc . getRange ( ) . replace ( Pattern . compile ( " \\ [MY_DOCUMENT \\ ] " ) , new InsertDocumentAtReplaceHandler ( ) , false ) ; mainDoc . save ( getMyDir ( ) + " InsertDocumentAtReplace Out.doc " ) ; }
public int replacing ( ReplacingArgs e ) throws Exception { Document subDoc = new Document ( getMyDir ( ) + " InsertDocument2.doc " ) ; // Insert a document after the paragraph, containing the match text. Paragraph para = (Paragraph)e.getMatchNode().getParentNode(); insertDocument(para, subDoc); // Remove the paragraph with the match text. para.remove(); return ReplaceAction.SKIP; }
public void applyDefaultBulletsAndNumbers ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.ListFormat //ExFor:ListFormat.ApplyNumberDefault //ExFor:ListFormat.ApplyBulletDefault //ExFor:ListFormat.ListIndent //ExFor:ListFormat.ListOutdent //ExFor:ListFormat.RemoveNumbers //ExSummary:Shows how to apply default bulleted or numbered list formatting to paragraphs when using DocumentBuilder. DocumentBuilder builder = new DocumentBuilder(); builder.writeln("Aspose.Words allows:"); builder.writeln(); // Start a numbered list with default formatting. builder.getListFormat().applyNumberDefault(); builder.writeln("Opening documents from different formats:"); // Go to second list level, add more text. builder.getListFormat().listIndent(); builder.writeln("DOC"); builder.writeln("PDF"); builder.writeln("HTML"); // Outdent to the first list level. builder.getListFormat().listOutdent(); builder.writeln("Processing documents"); builder.writeln("Saving documents in different formats:"); // Indent the list level again. builder.getListFormat().listIndent(); builder.writeln("DOC"); builder.writeln("PDF"); builder.writeln("HTML"); builder.writeln("MHTML"); builder.writeln("Plain text"); // Outdent the list level again. builder.getListFormat().listOutdent(); builder.writeln("Doing many other things!"); // End the numbered list. builder.getListFormat().removeNumbers(); builder.writeln(); builder.writeln("Aspose.Words main advantages are:"); builder.writeln(); // Start a bulleted list with default formatting. builder.getListFormat().applyBulletDefault(); builder.writeln("Great performance"); builder.writeln("High reliability"); builder.writeln("Quality code and working"); builder.writeln("Wide variety of features"); builder.writeln("Easy to understand API"); // End the bulleted list. builder.getListFormat().removeNumbers(); builder.getDocument().save(getMyDir() + "Lists.ApplyDefaultBulletsAndNumbers Out.doc"); //ExEnd
public void specifyListLevel ( ) throws Exception { //ExStart //ExFor:ListCollection //ExFor:List //ExFor:ListFormat //ExFor:ListFormat.ListLevelNumber //ExFor:ListFormat.List //ExFor:ListTemplate //ExFor:DocumentBase.Lists //ExFor:ListCollection.Add(ListTemplate) //ExSummary:Shows how to specify list level number when building a list using DocumentBuilder. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Create a numbered list based on one of the Microsoft Word list templates and // apply it to the current paragraph in the document builder. builder.getListFormat().setList(doc.getLists().add(ListTemplate.NUMBER_ARABIC_DOT)); // There are 9 levels in this list, lets try them all. for (int i = 0; i < 9; i++) { builder.getListFormat().setListLevelNumber(i); builder.writeln("Level " + i); } // Create a bulleted list based on one of the Microsoft Word list templates // and apply it to the current paragraph in the document builder. builder.getListFormat().setList(doc.getLists().add(ListTemplate.BULLET_DIAMONDS)); // There are 9 levels in this list, lets try them all. for (int i = 0; i < 9; i++) { builder.getListFormat().setListLevelNumber(i); builder.writeln("Level " + i); } // This is a way to stop list formatting. builder.getListFormat().setList(null); builder.getDocument().save(getMyDir() + "Lists.SpecifyListLevel Out.doc"); //ExEnd
public void nestedLists ( ) throws Exception { //ExStart //ExFor:ListFormat.List //ExSummary:Shows how to start a numbered list, add a bulleted list inside it, then return to the numbered list. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Create an outline list for the headings. List outlineList = doc.getLists().add(ListTemplate.OUTLINE_NUMBERS); builder.getListFormat().setList(outlineList); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.HEADING_1); builder.writeln("This is my Chapter 1"); // Create a numbered list. List numberedList = doc.getLists().add(ListTemplate.NUMBER_DEFAULT); builder.getListFormat().setList(numberedList); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.NORMAL); builder.writeln("Numebered list item 1."); // Create a bulleted list. List bulletedList = doc.getLists().add(ListTemplate.BULLET_DEFAULT); builder.getListFormat().setList(bulletedList); builder.getParagraphFormat().setLeftIndent(72); builder.writeln("Bulleted list item 1."); builder.writeln("Bulleted list item 2."); builder.getParagraphFormat().clearFormatting(); // Revert to the numbered list. builder.getListFormat().setList(numberedList); builder.writeln("Numbered list item 2."); builder.writeln("Numbered list item 3."); // Revert to the outline list. builder.getListFormat().setList(outlineList); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.HEADING_1); builder.writeln("This is my Chapter 2"); builder.getParagraphFormat().clearFormatting(); builder.getDocument().save(getMyDir() + "Lists.NestedLists Out.doc"); //ExEnd
public void createCustomList ( ) throws Exception { //ExStart //ExFor:List //ExFor:List.ListLevels //ExFor:ListLevelCollection //ExFor:ListLevelCollection.Item //ExFor:ListLevel //ExFor:ListLevel.Alignment //ExFor:ListLevel.Font //ExFor:ListLevel.NumberStyle //ExFor:ListLevel.StartAt //ExFor:ListLevel.TrailingCharacter //ExFor:ListLevelAlignment //ExFor:NumberStyle //ExFor:ListTrailingCharacter //ExFor:ListLevel.NumberFormat //ExFor:ListLevel.NumberPosition //ExFor:ListLevel.TextPosition //ExFor:ListLevel.TabPosition //ExSummary:Shows how to apply custom list formatting to paragraphs when using DocumentBuilder. Document doc = new Document(); // Create a list based on one of the Microsoft Word list templates. List list = doc.getLists().add(ListTemplate.NUMBER_DEFAULT); // Completely customize one list level. ListLevel level1 = list.getListLevels().get(0); level1.getFont().setColor(Color.RED); level1.getFont().setSize(24); level1.setNumberStyle(NumberStyle.ORDINAL_TEXT); level1.setStartAt(21); level1.setNumberFormat("\u0000"); level1.setNumberPosition(-36); level1.setTextPosition(144); level1.setTabPosition(144); // Completely customize yet another list level. ListLevel level2 = list.getListLevels().get(1); level2.setAlignment(ListLevelAlignment.RIGHT); level2.setNumberStyle(NumberStyle.BULLET); level2.getFont().setName("Wingdings"); level2.getFont().setColor(Color.BLUE); level2.getFont().setSize(24); level2.setNumberFormat("\uf0af"); // A bullet that looks like some sort of a star. level2.setTrailingCharacter(ListTrailingCharacter.SPACE); level2.setNumberPosition(144); // Now add some text that uses the list that we created. // It does not matter when to customize the list - before or after adding the paragraphs. DocumentBuilder builder = new DocumentBuilder(doc); builder.getListFormat().setList(list); builder.writeln("The quick brown fox..."); builder.writeln("The quick brown fox..."); builder.getListFormat().listIndent(); builder.writeln("jumped over the lazy dog."); builder.writeln("jumped over the lazy dog."); builder.getListFormat().listOutdent(); builder.writeln("The quick brown fox..."); builder.getListFormat().removeNumbers(); builder.getDocument().save(getMyDir() + "Lists.CreateCustomList Out.doc"); //ExEnd
public void restartNumberingUsingListCopy ( ) throws Exception { //ExStart //ExFor:List //ExFor:ListCollection //ExFor:ListCollection.Add(ListTemplate) //ExFor:ListCollection.AddCopy //ExFor:ListLevel.StartAt //ExFor:ListTemplate //ExFor:ListFormat.List //ExSummary:Shows how to restart numbering in a list by copying a list. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Create a list based on a template. List list1 = doc.getLists().add(ListTemplate.NUMBER_ARABIC_PARENTHESIS); // Modify the formatting of the list. list1.getListLevels().get(0).getFont().setColor(Color.RED); list1.getListLevels().get(0).setAlignment(ListLevelAlignment.RIGHT); builder.writeln("List 1 starts below:"); // Use the first list in the document for a while. builder.getListFormat().setList(list1); builder.writeln("Item 1"); builder.writeln("Item 2"); builder.getListFormat().removeNumbers(); // Now I want to reuse the first list, but need to restart numbering. // This should be done by creating a copy of the original list formatting. List list2 = doc.getLists().addCopy(list1); // We can modify the new list in any way. Including setting new start number. list2.getListLevels().get(0).setStartAt(10); // Use the second list in the document. builder.writeln("List 2 starts below:"); builder.getListFormat().setList(list2); builder.writeln("Item 1"); builder.writeln("Item 2"); builder.getListFormat().removeNumbers(); builder.getDocument().save(getMyDir() + "Lists.RestartNumberingUsingListCopy Out.doc"); //ExEnd
public void detectBulletedParagraphs ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Paragraph.ListFormat //ExFor:ListFormat.IsListItem //ExFor:CompositeNode.GetText //ExFor:List.ListId //ExSummary:Finds and outputs all paragraphs in a document that are bulleted or numbered. NodeCollection paras = doc.getChildNodes(NodeType.PARAGRAPH, true); for (Paragraph para : (Iterable<Paragraph>) paras) {
public void removeBulletsFromParagraphs ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Paragraph.ListFormat //ExFor:ListFormat.RemoveNumbers //ExSummary:Removes bullets and numbering from all paragraphs in the main text of a section. Body body = doc.getFirstSection().getBody(); for (Paragraph paragraph : (Iterable<Paragraph>) body.getParagraphs()) paragraph.getListFormat().removeNumbers();
public void applyExistingListToParagraphs ( ) throws Exception { Document doc = new Document ( ) ; doc . getLists ( ) . add ( ListTemplate . NUMBER_DEFAULT ) ; //ExStart //ExFor:Paragraph.ListFormat //ExFor:ListFormat.List //ExFor:ListFormat.ListLevelNumber //ExFor:ListCollection.Item //ExSummary:Applies list formatting of an existing list to a collection of paragraphs. Body body = doc.getFirstSection().getBody(); List list = doc.getLists().get(0); for (Paragraph paragraph : body.getParagraphs()) {
public void applyNewListToParagraphs ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Paragraph.ListFormat //ExFor:ListFormat.ListLevelNumber //ExFor:ListCollection.Add(ListTemplate) //ExSummary:Creates new list formatting and applies it to a collection of paragraphs. List list = doc.getLists().add(ListTemplate.NUMBER_UPPERCASE_LETTER_DOT); Body body = doc.getFirstSection().getBody(); for (Paragraph paragraph : body.getParagraphs()) {
public void outlineHeadingTemplatesCaller ( ) throws Exception { outlineHeadingTemplates ( ) ; }
public void outlineHeadingTemplates ( ) throws Exception { Document doc = new Document ( ) ; DocumentBuilder builder = new DocumentBuilder ( doc ) ; List list = doc . getLists ( ) . add ( ListTemplate . OUTLINE_HEADINGS_ARTICLE_SECTION ) ; addOutlineHeadingParagraphs ( builder , list , " Aspose.Words Outline 1 " ) ; list = doc . getLists ( ) . add ( ListTemplate . OUTLINE_HEADINGS_LEGAL ) ; addOutlineHeadingParagraphs ( builder , list , " Aspose.Words Outline 2 " ) ; builder . insertBreak ( BreakType . PAGE_BREAK ) ; list = doc . getLists ( ) . add ( ListTemplate . OUTLINE_HEADINGS_NUMBERS ) ; addOutlineHeadingParagraphs ( builder , list , " Aspose.Words Outline 3 " ) ; list = doc . getLists ( ) . add ( ListTemplate . OUTLINE_HEADINGS_CHAPTER ) ; addOutlineHeadingParagraphs ( builder , list , " Aspose.Words Outline 4 " ) ; builder . getDocument ( ) . save ( getMyDir ( ) + " Lists.OutlineHeadingTemplates Out.doc " ) ; }
private static void addOutlineHeadingParagraphs ( DocumentBuilder builder , List list , String title ) throws Exception { builder . getParagraphFormat ( ) . clearFormatting ( ) ; builder . writeln ( title ) ; for ( int i = 0 ; i < 9 ; i + + ) { builder . getListFormat ( ) . setList ( list ) ; builder . getListFormat ( ) . setListLevelNumber ( i ) ; String styleName = " Heading " + Integer . toString ( ( i + 1 ) ) ; builder . getParagraphFormat ( ) . setStyleName ( styleName ) ; builder . writeln ( styleName ) ; } builder . getListFormat ( ) . removeNumbers ( ) ; }
public void printOutAllListsCaller ( ) throws Exception { printOutAllLists ( ) ; }
public void printOutAllLists ( ) throws Exception { // You can use any of your documents to try this little program out. Document srcDoc = new Document(getMyDir() + "Lists.PrintOutAllLists.doc"); // This will be the sample document we product. Document dstDoc = new Document(); DocumentBuilder builder = new DocumentBuilder(dstDoc); for (List srcList : srcDoc.getLists()) { // This copies the list formatting from the source into the destination document. List dstList = dstDoc.getLists().addCopy(srcList); addListSample(builder, dstList); } dstDoc.save(getMyDir() + "Lists.PrintOutAllLists Out.doc"); }
private static void addListSample ( DocumentBuilder builder , List list ) throws Exception { builder . writeln ( " Sample formatting of list with ListId: " + list . getListId ( ) ) ; builder . getListFormat ( ) . setList ( list ) ; for ( int i = 0 ; i < list . getListLevels ( ) . getCount ( ) ; i + + ) { builder . getListFormat ( ) . setListLevelNumber ( i ) ; builder . writeln ( " Level " + i ) ; } builder . getListFormat ( ) . removeNumbers ( ) ; builder . writeln ( ) ; }
public void listDocument ( ) throws Exception { //ExStart //ExFor:ListCollection.Document //ExFor:ListCollection.Count //ExFor:ListCollection.Item //ExFor:ListCollection.GetListByListId //ExFor:List.Document //ExFor:List.ListId //ExSummary:Illustrates the owner document properties of lists. Document doc = new Document(); ListCollection lists = doc.getLists(); // All of these should be equal. System.out.println("ListCollection document is doc: " + (doc == lists.getDocument())); System.out.println("List count: " + lists.getCount()); List list = lists.add(ListTemplate.BULLET_DEFAULT); System.out.println("List document is doc: " + (list.getDocument() == doc)); System.out.println("List count after adding list: " + lists.getCount()); System.out.println("Is the first document list: " + (lists.get(0) == list)); System.out.println("ListId: " + list.getListId()); System.out.println("List is the same by ListId: " + (lists.getListByListId(1) == list)); //ExEnd // Verify these properties Assert.assertEquals(doc, lists.getDocument()); Assert.assertEquals(doc, list.getDocument()); Assert.assertEquals(lists.getCount(), 1); Assert.assertEquals(list, lists.get(0)); Assert.assertEquals(list.getListId(), 1); Assert.assertEquals(list, lists.getListByListId(1)); }
public void listFormatListLevel ( ) throws Exception { //ExStart //ExFor:ListFormat.ListLevel //ExSummary:Shows how to modify list formatting of the current list level. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Create and apply list formatting to the current paragraph. builder.getListFormat().setList(doc.getLists().add(ListTemplate.NUMBER_DEFAULT)); // Modify formatting of the current (first) list level. builder.getListFormat().getListLevel().getFont().setBold(true); builder.writeln("Item 1"); builder.writeln("Item 2"); builder.getListFormat().removeNumbers(); //ExEnd
public void createListRestartAfterHigher ( ) throws Exception { //ExStart //ExFor:ListLevel.NumberStyle //ExFor:ListLevel.NumberFormat //ExFor:ListLevel.IsLegal //ExFor:ListLevel.RestartAfterLevel //ExFor:ListLevel.LinkedStyle //ExFor:ListLevelCollection.GetEnumerator //ExSummary:Shows how to create a list with some advanced formatting. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); List list = doc.getLists().add(ListTemplate.NUMBER_DEFAULT); // Level 1 labels will be "Appendix A", continuous and linked to the Heading 1 paragraph style. list.getListLevels().get(0).setNumberFormat("Appendix \u0000"); list.getListLevels().get(0).setNumberStyle(NumberStyle.UPPERCASE_LETTER); list.getListLevels().get(0).setLinkedStyle(doc.getStyles().get("Heading 1")); // Level 2 labels will be "Section (1.01)" and restarting after Level 2 item appears. list.getListLevels().get(1).setNumberFormat("Section (\u0000.\u0001)"); list.getListLevels().get(1).setNumberStyle(NumberStyle.LEADING_ZERO); // Notice the higher level uses UppercaseLetter numbering, but we want arabic number // of the higher levels to appear in this level, therefore set this property. list.getListLevels().get(1).isLegal(true); list.getListLevels().get(1).setRestartAfterLevel(0); // Level 3 labels will be "-I-" and restarting after Level 2 item appears. list.getListLevels().get(2).setNumberFormat("-\u0002-"); list.getListLevels().get(2).setNumberStyle(NumberStyle.UPPERCASE_ROMAN); list.getListLevels().get(2).setRestartAfterLevel(1); // Make labels of all list levels bold. for (ListLevel level : list.getListLevels()) level.getFont().setBold(true); // Apply list formatting to the current paragraph. builder.getListFormat().setList(list); // Exercise the 3 levels we created two times. for (int n = 0; n < 2; n++) { for (int i = 0; i < 3; i++) { builder.getListFormat().setListLevelNumber(i); builder.writeln("Level " + i); } } builder.getListFormat().removeNumbers(); builder.getDocument().save(getMyDir() + "Lists.CreateListRestartAfterHigher Out.doc"); //ExEnd
public void paragraphStyleBulleted ( ) throws Exception { //ExStart //ExFor:StyleCollection //ExFor:DocumentBase.Styles //ExFor:Style //ExFor:Font //ExFor:Style.Font //ExFor:Style.ParagraphFormat //ExFor:Style.ListFormat //ExFor:ParagraphFormat.Style //ExSummary:Shows how to create and use a paragraph style with list formatting. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Create a paragraph style and specify some formatting for it. Style style = doc.getStyles().add(StyleType.PARAGRAPH, "MyStyle1"); style.getFont().setSize(24); style.getFont().setName("Verdana"); style.getParagraphFormat().setSpaceAfter(12); // Create a list and make sure the paragraphs that use this style will use this list. style.getListFormat().setList(doc.getLists().add(ListTemplate.BULLET_DEFAULT)); style.getListFormat().setListLevelNumber(0); // Apply the paragraph style to the current paragraph in the document and add some text. builder.getParagraphFormat().setStyle(style); builder.writeln("Hello World: MyStyle1, bulleted."); // Change to a paragraph style that has no list formatting. builder.getParagraphFormat().setStyle(doc.getStyles().get("Normal")); builder.writeln("Hello World: Normal."); builder.getDocument().save(getMyDir() + "Lists.ParagraphStyleBulleted Out.doc"); //ExEnd
public void getListLabels ( ) throws Exception { //ExStart //ExFor:Document.UpdateListLabels() //ExFor:Node.ToTxt //ExFor:ListLabel //ExFor:Paragraph.ListLabel //ExFor:ListLabel.LabelValue //ExFor:ListLabel.LabelString //ExSummary:Shows how to extract the label of each paragraph in a list as a value or a string. Document doc = new Document(getMyDir() + "Lists.PrintOutAllLists.doc"); doc.updateListLabels(); int listParaCount = 1; for (Paragraph paragraph : (Iterable<Paragraph>) doc.getChildNodes(NodeType.PARAGRAPH, true)) {
public void executeArray ( ) throws Exception { //ExStart //ExFor:MailMerge.Execute(String[],Object[]) //ExFor:ContentDisposition //ExId:MailMergeArray //ExSummary:Performs a simple insertion of data into merge fields. // Open an existing document. Document doc = new Document(getMyDir() + "MailMerge.ExecuteArray.doc"); // Fill the fields in the document with user data. doc.getMailMerge().execute( new String[] {"FullName", "Company", "Address", "Address2", "City"}, new Object[] {"James Bond", "MI5 Headquarters", "Milbank", "", "London"}); doc.save(getMyDir() + "MailMerge.ExecuteArray Out.doc"); //ExEnd
public void executeDataTable ( ) throws Exception { //ExStart //ExFor:Document //ExFor:MailMerge //ExFor:MailMerge.Execute(DataTable) //ExFor:Document.MailMerge //ExSummary:Executes mail merge from data stored in a ResultSet. Document doc = new Document(getMyDir() + "MailMerge.ExecuteDataTable.doc"); // This example creates a table, but you would normally load table from a database. java.sql.ResultSet resultSet = createCachedRowSet(new String[] {"CustomerName", "Address"}); addRow(resultSet, new String[] {"Thomas Hardy", "120 Hanover Sq., London"}); addRow(resultSet, new String[] {"Paolo Accorti", "Via Monte Bianco 34, Torino"}); com.aspose.words.DataTable table = new com.aspose.words.DataTable(resultSet, "Test"); // Field values from the table are inserted into the mail merge fields found in the document. doc.getMailMerge().execute(table); doc.save(getMyDir() + "MailMerge.ExecuteDataTable Out.doc"); //ExEnd
public void executeWithRegionsDataSet ( ) throws Exception { //ExStart //ExFor:MailMerge.ExecuteWithRegions(DataSet) //ExSummary:Executes a mail merge with repeatable regions from an ADO.NET DataSet. // Open the document. // For a mail merge with repeatable regions, the document should have mail merge regions // in the document designated with MERGEFIELD TableStart:MyTableName and TableEnd:MyTableName. Document doc = new Document(getMyDir() + "MailMerge.ExecuteWithRegions.doc"); int orderId = 10444; // Populate tables and add them to the dataset. // For a mail merge with repeatable regions, DataTable.TableName should be // set to match the name of the region defined in the document. com.aspose.words.DataSet dataSet = new com.aspose.words.DataSet(); com.aspose.words.DataTable orderTable = getTestOrder(orderId); dataSet.getTables().add(orderTable); com.aspose.words.DataTable orderDetailsTable = getTestOrderDetails(orderId, "ProductID"); dataSet.getTables().add(orderDetailsTable); // This looks through all mail merge regions inside the document and for each // region tries to find a DataTable with a matching name inside the DataSet. // If a table is found, its content is merged into the mail merge region in the document. doc.getMailMerge().executeWithRegions(dataSet); doc.save(getMyDir() + "MailMerge.ExecuteWithRegionsDataSet Out.doc"); //ExEnd
public void executeWithRegionsDataTableCaller ( ) throws Exception { executeWithRegionsDataTable ( ) ; }
public void executeWithRegionsDataTable ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " MailMerge.ExecuteWithRegions.doc " ) ; int orderId = 10444 ; // Perform several mail merge operations populating only part of the document each time. // Use DataTable as a data source. // The table name property should be set to match the name of the region defined in the document. com.aspose.words.DataTable orderTable = getTestOrder(orderId); doc.getMailMerge().executeWithRegions(orderTable); com.aspose.words.DataTable orderDetailsTable = getTestOrderDetails(orderId, "ExtendedPrice DESC"); doc.getMailMerge().executeWithRegions(orderDetailsTable); doc.save(getMyDir() + "MailMerge.ExecuteWithRegionsDataTable Out.doc"); }
private static com . aspose . words . DataTable getTestOrder ( int orderId ) throws Exception { java . sql . ResultSet resultSet = executeDataTable ( java . text . MessageFormat . format ( " SELECT * FROM AsposeWordOrders WHERE OrderId = {0} " , Integer . toString ( orderId ) ) ) ; return new com . aspose . words . DataTable ( resultSet , " Orders " ) ; }
private static com . aspose . words . DataTable getTestOrderDetails ( int orderId , String orderBy ) throws Exception { StringBuilder builder = new StringBuilder ( ) ; builder . append ( java . text . MessageFormat . format ( " SELECT * FROM AsposeWordOrderDetails WHERE OrderId = {0} " , Integer . toString ( orderId ) ) ) ; if ( ( orderBy ! = null ) & & ( orderBy . length ( ) > 0 ) ) { builder . append ( " ORDER BY " ) ; builder . append ( orderBy ) ; } java . sql . ResultSet resultSet = executeDataTable ( builder . toString ( ) ) ; return new com . aspose . words . DataTable ( resultSet , " OrderDetails " ) ; }
private static java . sql . ResultSet executeDataTable ( String commandText ) throws Exception { Class . forName ( " sun.jdbc.odbc.JdbcOdbcDriver " ) ; // Loads the driver // Open the database connection. String connString = "jdbc:odbc:DRIVER={Microsoft Access Driver (*.mdb)};" + "DBQ=" + getDatabaseDir() + "Northwind.mdb" + ";UID=Admin"; // From Wikipedia: The Sun driver has a known issue with character encoding and Microsoft Access databases. // Microsoft Access may use an encoding that is not correctly translated by the driver, leading to the replacement // in strings of, for example, accented characters by question marks. // // In this case I have to set CP1252 for the european characters to come through in the data values. java.util.Properties props = new java.util.Properties(); props.put("charSet", "Cp1252"); // DSN-less DB connection. java.sql.Connection conn = java.sql.DriverManager.getConnection(connString, props); // Create and execute a command. java.sql.Statement statement = conn.createStatement(); return statement.executeQuery(commandText); }
public void mappedDataFields ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:MailMerge.MappedDataFields //ExFor:MappedDataFieldCollection //ExFor:MappedDataFieldCollection.Add //ExId:MailMergeMappedDataFields //ExSummary:Shows how to add a mapping when a merge field in a document and a data field in a data source have different names. doc.getMailMerge().getMappedDataFields().add("MyFieldName_InDocument", "MyFieldName_InDataSource"); //ExEnd
public void getFieldNames ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:MailMerge.GetFieldNames //ExId:MailMergeGetFieldNames //ExSummary:Shows how to get names of all merge fields in a document. String[] fieldNames = doc.getMailMerge().getFieldNames(); //ExEnd
public void deleteFields ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:MailMerge.DeleteFields //ExId:MailMergeDeleteFields //ExSummary:Shows how to delete all merge fields from a document. doc.getMailMerge().deleteFields(); //ExEnd
public void removeEmptyParagraphs ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:MailMerge.RemoveEmptyParagraphs //ExId:MailMergeRemoveEmptyParagraphs //ExSummary:Shows how to make sure empty paragraphs that result from merging fields with no data are removed from the document. doc.getMailMerge().setRemoveEmptyParagraphs(true); //ExEnd
public void useNonMergeFields ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:MailMerge.UseNonMergeFields //ExSummary:Shows how to perform mail merge into merge fields and into additional fields types. doc.getMailMerge().setUseNonMergeFields(true); //ExEnd
public void mailMergeCustomDataSourceCaller ( ) throws Exception { mailMergeCustomDataSource ( ) ; }
public void mailMergeCustomDataSource ( ) throws Exception { // Create some data that we will use in the mail merge. CustomerList customers = new CustomerList(); customers.add(new Customer("Thomas Hardy", "120 Hanover Sq., London")); customers.add(new Customer("Paolo Accorti", "Via Monte Bianco 34, Torino")); // Open the template document. Document doc = new Document(getMyDir() + "MailMerge.CustomDataSource.doc"); // To be able to mail merge from your own data source, it must be wrapped // into an object that implements the IMailMergeDataSource interface. CustomerMailMergeDataSource customersDataSource = new CustomerMailMergeDataSource(customers); // Now you can pass your data source into Aspose.Words. doc.getMailMerge().execute(customersDataSource); doc.save(getMyDir() + "MailMerge.CustomDataSource Out.doc"); }
public String getFullName ( ) throws Exception { return mFullName ; } public void setFullName ( String value ) throws Exception { mFullName = value ; }
public void setFullName ( String value ) throws Exception { mFullName = value ; }
public String getAddress ( ) throws Exception { return mAddress ; } public void setAddress ( String value ) throws Exception { mAddress = value ; }
public void setAddress ( String value ) throws Exception { mAddress = value ; }
public Customer get ( int index ) { return ( Customer ) super . get ( index ) ; } public void set ( int index , Customer value ) { super . set ( index , value ) ; }
public void set ( int index , Customer value ) { super . set ( index , value ) ; } }
public String getTableName ( ) throws Exception { return " Customer " ; }
public boolean getValue ( String fieldName , Object [ ] fieldValue ) throws Exception { if ( fieldName . equals ( " FullName " ) ) {
public boolean moveNext ( ) throws Exception { if ( ! isEof ( ) ) mRecordIndex + + ; return ( ! isEof ( ) ) ; }
public IMailMergeDataSource getChildDataSource ( String tableName ) throws Exception { return null ; }
private boolean isEof ( ) throws Exception { return ( mRecordIndex > = mCustomers . size ( ) ) ; }
public void mailMergeInsertHtmlCaller ( ) throws Exception { mailMergeInsertHtml ( ) ; }
public void mailMergeInsertHtml ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " MailMerge.InsertHtml.doc " ) ; // Add a handler for the MergeField event. doc.getMailMerge().setFieldMergingCallback(new HandleMergeFieldInsertHtml()); // Load some Html from file. StringBuilder htmlText = new StringBuilder(); BufferedReader reader = new BufferedReader(new FileReader(getMyDir() + "MailMerge.HtmlData.html")); String line; while ((line = reader.readLine()) != null) { htmlText.append(line); htmlText.append("\r\n"); } // Execute mail merge. doc.getMailMerge().execute(new String[]{"htmlField1"}, new String[]{htmlText.toString()}); // Save resulting document with a new name. doc.save(getMyDir() + "MailMerge.InsertHtml Out.doc"); }
public void fieldMerging ( FieldMergingArgs e ) throws Exception { // All merge fields that expect HTML data should be marked with some prefix, e.g. 'html'. if (e.getDocumentFieldName().startsWith("html")) { // Insert the text for this merge field as HTML data, using DocumentBuilder.
public void mailMergeInsertCheckBoxCaller ( ) throws Exception { mailMergeInsertCheckBox ( ) ; }
public void mailMergeInsertCheckBox ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " MailMerge.InsertCheckBox.doc " ) ; // Add a handler for the MergeField event. doc.getMailMerge().setFieldMergingCallback(new HandleMergeFieldInsertCheckBox()); // Execute mail merge with regions. com.aspose.words.DataTable dataTable = getStudentCourseDataTable(); doc.getMailMerge().executeWithRegions(dataTable); // Save resulting document with a new name. doc.save(getMyDir() + "MailMerge.InsertCheckBox Out.doc"); }
public void fieldMerging ( FieldMergingArgs e ) throws Exception { if ( e . getDocumentFieldName ( ) . equals ( " CourseName " ) ) { // Insert the checkbox for this merge field, using DocumentBuilder.
private static com . aspose . words . DataTable getStudentCourseDataTable ( ) throws Exception { java . sql . ResultSet resultSet = createCachedRowSet ( new String [ ] { " CourseName " } ) ; for ( int i = 0 ; i < 10 ; i + + ) addRow ( resultSet , new String [ ] { " Course " + Integer . toString ( i ) } ) ; return new com . aspose . words . DataTable ( resultSet , " StudentCourse " ) ; }
public void mailMergeAlternatingRowsCaller ( ) throws Exception { mailMergeAlternatingRows ( ) ; }
public void mailMergeAlternatingRows ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " MailMerge.AlternatingRows.doc " ) ; // Add a handler for the MergeField event. doc.getMailMerge().setFieldMergingCallback(new HandleMergeFieldAlternatingRows()); // Execute mail merge with regions. com.aspose.words.DataTable dataTable = getSuppliersDataTable(); doc.getMailMerge().executeWithRegions(dataTable); doc.save(getMyDir() + "MailMerge.AlternatingRows Out.doc"); }
public void fieldMerging ( FieldMergingArgs e ) throws Exception { if ( mBuilder = = null ) mBuilder = new DocumentBuilder ( e . getDocument ( ) ) ; // This way we catch the beginning of a new row. if (e.getFieldName().equals("CompanyName")) { // Select the color depending on whether the row number is even or odd.
private static boolean isOdd ( int value ) throws Exception { return ( value % 2 ! = 0 ) ; }
private static com . aspose . words . DataTable getSuppliersDataTable ( ) throws Exception { java . sql . ResultSet resultSet = createCachedRowSet ( new String [ ] { " CompanyName " , " ContactName " } ) ; for ( int i = 0 ; i < 10 ; i + + ) addRow ( resultSet , new String [ ] { " Company " + Integer . toString ( i ) , " Contact " + Integer . toString ( i ) } ) ; return new com . aspose . words . DataTable ( resultSet , " Suppliers " ) ; }
public void MailMergeImageFromUrl ( ) throws Exception { //ExStart //ExFor:MailMerge.Execute(String[], Object[]) //ExSummary:Demonstrates how to merge an image from a web address using an Image field. Document doc = new Document(getMyDir() + "MailMerge.MergeImageSimple.doc"); // Pass a URL which points to the image to merge into the document. doc.getMailMerge().execute(new String[]{"Logo"}, new Object[]{"http://www.aspose.com/images/aspose-logo.gif"}); doc.save(getMyDir() + "MailMerge.MergeImageFromUrl Out.doc"); //ExEnd // Verify the image was merged into the document. Shape logoImage = (Shape) doc.getChild(NodeType.SHAPE, 0, true); Assert.assertNotNull(logoImage); Assert.assertTrue(logoImage.hasImage()); }
public void mailMergeImageFromBlobCaller ( ) throws Exception { mailMergeImageFromBlob ( ) ; }
public void mailMergeImageFromBlob ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " MailMerge.MergeImage.doc " ) ; // Set up the event handler for image fields. doc.getMailMerge().setFieldMergingCallback(new HandleMergeImageFieldFromBlob()); Class.forName("sun.jdbc.odbc.JdbcOdbcDriver"); // Loads the driver // Open the database connection. String connString = "jdbc:odbc:DRIVER={Microsoft Access Driver (*.mdb)};" + "DBQ=" + getDatabaseDir() + "Northwind.mdb" + ";UID=Admin"; // DSN-less DB connection. java.sql.Connection conn = java.sql.DriverManager.getConnection(connString); // Create and execute a command. java.sql.Statement statement = conn.createStatement(); java.sql.ResultSet resultSet = statement.executeQuery("SELECT * FROM Employees"); com.aspose.words.DataTable table = new com.aspose.words.DataTable(resultSet, "Employees"); // Perform mail merge. doc.getMailMerge().executeWithRegions(table); // Close the database. conn.close(); doc.save(getMyDir() + "MailMerge.MergeImage Out.doc"); }
public void fieldMerging ( FieldMergingArgs args ) throws Exception { // Do nothing. } /** * This is called when mail merge engine encounters Image:XXX merge field in the document. * You have a chance to return an Image object, file name or a stream that contains the image. */ public void imageFieldMerging(ImageFieldMergingArgs e) throws Exception { // The field value is a byte array, just cast it and create a stream on it. ByteArrayInputStream imageStream = new ByteArrayInputStream((byte[]) e.getFieldValue()); // Now the mail merge engine will retrieve the image from the stream. e.setImageStream(imageStream); } } //ExEnd }
public void imageFieldMerging ( ImageFieldMergingArgs e ) throws Exception { // The field value is a byte array, just cast it and create a stream on it. ByteArrayInputStream imageStream = new ByteArrayInputStream((byte[]) e.getFieldValue()); // Now the mail merge engine will retrieve the image from the stream. e.setImageStream(imageStream); }
public static void convertRtfToDocx ( String inFileName , String outFileName ) throws Exception { // Load an RTF file into Aspose.Words. Document doc = new Document(inFileName); // Save the document in the OOXML format. doc.save(outFileName, SaveFormat.DOCX); }
public void MailMergeCustomDataSource ( ) throws Exception { // Create some data that we will use in the mail merge. CustomerList customers = new CustomerList(); customers.add(new Customer("Thomas Hardy", "120 Hanover Sq., London")); customers.add(new Customer("Paolo Accorti", "Via Monte Bianco 34, Torino")); // Create some data for nesting in the mail merge. customers.get(0).getOrders().add(new Order("Rugby World Cup Cap", 2)); customers.get(0).getOrders().add(new Order("Rugby World Cup Ball", 1)); customers.get(1).getOrders().add(new Order("Rugby World Cup Guide", 1)); // Open the template document. Document doc = new Document(getMyDir() + "NestedMailMerge.CustomDataSource.doc"); // To be able to mail merge from your own data source, it must be wrapped // into an object that implements the IMailMergeDataSource interface. CustomerMailMergeDataSource customersDataSource = new CustomerMailMergeDataSource(customers); // Now you can pass your data source into Aspose.Words. doc.getMailMerge().executeWithRegions(customersDataSource); doc.save(getMyDir() + "NestedMailMerge.CustomDataSource Out.doc"); }
public String getFullName ( ) { return mFullName ; }
public void setFullName ( String value ) { mFullName = value ; }
public String getAddress ( ) { return mAddress ; }
public void setAddress ( String value ) { mAddress = value ; }
public OrderList getOrders ( ) { return mOrders ; }
public void setOrders ( OrderList value ) { mOrders = value ; }
public Customer get ( int index ) { return ( Customer ) super . get ( index ) ; }
public void set ( int index , Customer value ) { super . set ( index , value ) ; }
public String getName ( ) { return mName ; }
public void setName ( String value ) { mName = value ; }
public int getQuantity ( ) { return mQuantity ; }
public void setName ( int value ) { mQuantity = value ; }
public Order get ( int index ) { return ( Order ) super . get ( index ) ; }
public void set ( int index , Order value ) { super . set ( index , value ) ; }
public String getTableName ( ) { return " Customer " ; }
public boolean getValue ( String fieldName , Object [ ] fieldValue ) { if ( fieldName . equals ( " FullName " ) ) {
public boolean moveNext ( ) { if ( ! isEof ( ) ) mRecordIndex + + ; return ( ! isEof ( ) ) ; }
public IMailMergeDataSource getChildDataSource ( String tableName ) { // Get the child collection to merge it with the region provided with tableName variable. if(tableName.equals("Order")) return new OrderMailMergeDataSource(mCustomers.get(mRecordIndex).getOrders());
private boolean isEof ( ) { return ( mRecordIndex > = mCustomers . size ( ) ) ; }
public String getTableName ( ) { return " Order " ; }
public boolean getValue ( String fieldName , Object [ ] fieldValue ) { if ( fieldName . equals ( " Name " ) ) {
public IMailMergeDataSource getChildDataSource ( String tableName ) { return null ; }
private boolean isEof ( ) { return ( mRecordIndex > = mOrders . size ( ) ) ; }
public void useNodeType ( ) throws Exception { //ExStart //ExFor:NodeType //ExId:UseNodeType //ExSummary:The following example shows how to use the NodeType enumeration. Document doc = new Document(); // Returns NodeType.Document int type = doc.getNodeType(); //ExEnd
public void cloneCompositeNode ( ) throws Exception { //ExStart //ExFor:Node //ExFor:CompositeNode.Clone //ExFor:Paragraph.Clone //ExSummary:Shows how to clone composite nodes with and without their child nodes. // Create a new empty document. Document doc = new Document(); // Add some text to the first paragraph Paragraph para = doc.getFirstSection().getBody().getFirstParagraph(); para.appendChild(new Run(doc, "Some text")); // Clone the paragraph and the child nodes. Node cloneWithChildren = para.deepClone(true); // Only clone the paragraph and no child nodes. Node cloneWithoutChildren = para.deepClone(false); //ExEnd Assert.assertTrue(((CompositeNode)cloneWithChildren).hasChildNodes()); Assert.assertFalse(((CompositeNode)cloneWithoutChildren).hasChildNodes()); }
public void getParentNode ( ) throws Exception { //ExStart //ExFor:Node.ParentNode //ExId:AccessParentNode //ExSummary:Shows how to access the parent node. // Create a new empty document. It has one section. Document doc = new Document(); // The section is the first child node of the document. Node section = doc.getFirstChild(); // The section's parent node is the document. System.out.println("Section parent is the document: " + (doc == section.getParentNode())); //ExEnd Assert.assertEquals(doc, section.getParentNode()); }
public void ownerDocument ( ) throws Exception { //ExStart //ExFor:Node.Document //ExFor:Node.ParentNode //ExId:CreatingNodeRequiresDocument //ExSummary:Shows that when you create any node, it requires a document that will own the node. // Open a file from disk. Document doc = new Document(); // Creating a new node of any type requires a document passed into the constructor. Paragraph para = new Paragraph(doc); // The new paragraph node does not yet have a parent. System.out.println("Paragraph has no parent node: " + (para.getParentNode() == null)); // But the paragraph node knows its document. System.out.println("Both nodes' documents are the same: " + (para.getDocument() == doc)); // The fact that a node always belongs to a document allows us to access and modify // properties that reference the document-wide data such as styles or lists. para.getParagraphFormat().setStyleName("Heading 1"); // Now add the paragraph to the main text of the first section. doc.getFirstSection().getBody().appendChild(para); // The paragraph node is now a child of the Body node. System.out.println("Paragraph has a parent node: " + (para.getParentNode() != null)); //ExEnd Assert.assertEquals(doc, para.getDocument()); Assert.assertNotNull(para.getParentNode()); }
public void enumerateChildNodes ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Node //ExFor:CompositeNode //ExFor:CompositeNode.GetChild //ExSummary:Shows how to extract a specific child node from a CompositeNode by using the GetChild method and passing the NodeType and index. Paragraph paragraph = (Paragraph)doc.getChild(NodeType.PARAGRAPH, 0, true); //ExEnd //ExStart //ExFor:CompositeNode.ChildNodes //ExFor:CompositeNode.GetEnumerator //ExId:ChildNodesForEach //ExSummary:Shows how to enumerate immediate children of a CompositeNode using the enumerator provided by the ChildNodes collection. NodeCollection children = paragraph.getChildNodes(); for (Node child : (Iterable<Node>) children) {
public void indexChildNodes ( ) throws Exception { Document doc = new Document ( ) ; Paragraph paragraph = ( Paragraph ) doc . getChild ( NodeType . PARAGRAPH , 0 , true ) ; //ExStart //ExFor:NodeCollection.Count //ExFor:NodeCollection.Item //ExId:ChildNodesIndexer //ExSummary:Shows how to enumerate immediate children of a CompositeNode using indexed access. NodeCollection children = paragraph.getChildNodes(); for (int i = 0; i < children.getCount(); i++) {
public void recurseAllNodesCaller ( ) throws Exception { recurseAllNodes ( ) ; }
public void recurseAllNodes ( ) throws Exception { // Open a document. Document doc = new Document(getMyDir() + "Node.RecurseAllNodes.doc"); // Invoke the recursive function that will walk the tree. traverseAllNodes(doc); }
public void traverseAllNodes ( CompositeNode parentNode ) throws Exception { // This is the most efficient way to loop through immediate children of a node. for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
public void removeNodes ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Node //ExFor:Node.NodeType //ExFor:Node.Remove //ExSummary:Shows how to remove all nodes of a specific type from a composite node. In this example we remove tables from a section body. // Get the section that we want to work on. Section section = doc.getSections().get(0); Body body = section.getBody(); // Select the first child node in the body. Node curNode = body.getFirstChild(); while (curNode != null) {
public void enumNextSibling ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:CompositeNode.FirstChild //ExFor:Node.NextSibling //ExFor:Node.NodeTypeToString //ExFor:Node.NodeType //ExSummary:Shows how to enumerate immediate child nodes of a composite node using NextSibling. In this example we enumerate all paragraphs of a section body. // Get the section that we want to work on. Section section = doc.getSections().get(0); Body body = section.getBody(); // Loop starting from the first child until we reach null. for (Node node = body.getFirstChild(); node != null; node = node.getNextSibling()) {
public void typedAccess ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Story.Tables //ExFor:Table.FirstRow //ExFor:Table.LastRow //ExFor:TableCollection //ExId:TypedPropertiesAccess //ExSummary:Demonstrates how to use typed properties to access nodes of the document tree. // Quick typed access to the first child Section node of the Document. Section section = doc.getFirstSection(); // Quick typed access to the Body child node of the Section. Body body = section.getBody(); // Quick typed access to all Table child nodes contained in the Body. TableCollection tables = body.getTables(); for (Table table : tables) {
public void UpdateFieldsInRange ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:Range.UpdateFields //ExSummary:Demonstrates how to update document fields in the body of the first section only. doc.getFirstSection().getBody().getRange().updateFields(); //ExEnd
public void removeChild ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:CompositeNode.LastChild //ExFor:Node.PreviousSibling //ExFor:CompositeNode.RemoveChild //ExSummary:Demonstrates use of methods of Node and CompositeNode to remove a section before the last section in the document. // Document is a CompositeNode and LastChild returns the last child node in the Document node. // Since the Document can contain only Section nodes, the last child is the last section. Node lastSection = doc.getLastChild(); // Each node knows its next and previous sibling nodes. // Previous sibling of a section is a section before the specified section. // If the node is the first child, PreviousSibling will return null. Node sectionBeforeLast = lastSection.getPreviousSibling(); if (sectionBeforeLast != null) doc.removeChild(sectionBeforeLast);
public void compositeNode_SelectNodes ( ) throws Exception { //ExStart //ExFor:CompositeNode.SelectSingleNode //ExFor:CompositeNode.SelectNodes //ExSummary:Shows how to select certain nodes using an XPath expression. Document doc = new Document(getMyDir() + "Table.Document.doc"); // This expression will extract all paragraph nodes which are descendants of any table node in the document. // This will return any paragraphs which are in a table. NodeList nodeList = doc.selectNodes("//Table//Paragraph"); // This expression will select any paragraphs that are direct children of any body node in the document. nodeList = doc.selectNodes("//Body/Paragraph"); // Use SelectSingleNode to select the first result of the same expression as above. Node node = doc.selectSingleNode("//Body/Paragraph"); //ExEnd
public void testNodeIsInsideField ( ) throws Exception { //ExStart: //ExFor:CompositeNode.SelectNodes //ExFor:CompositeNode.GetChild //ExSummary:Shows how to test if a node is inside a field using an XPath expression. // Let's pick a document we know has some fields in. Document doc = new Document(getMyDir() + "MailMerge.MergeImage.doc"); // Let's say we want to check if the Run below is inside a field. Run run = (Run)doc.getChild(NodeType.RUN, 5, true); // Evaluate the XPath expression. The resulting NodeList will contain all nodes found inside a field a field (between FieldStart // and FieldEnd exclusive). There can however be FieldStart and FieldEnd nodes in the list if there are nested fields // in the path. Currently does not find rare fields in which the FieldCode or FieldResult spans across multiple paragraphs. NodeList resultList = doc.selectNodes("//FieldStart/following-sibling::node()[following-sibling::FieldEnd]"); // Check if the specified run is one of the nodes that are inside the field. for (Node node : (Iterable<Node>)resultList) {
public void createAndAddParagraphNode ( ) throws Exception { //ExStart //ExId:CreateAndAddParagraphNode //ExSummary:Creates and adds a paragraph node. Document doc = new Document(); Paragraph para = new Paragraph(doc); Section section = doc.getLastSection(); section.getBody().appendChild(para); //ExEnd
public void removeSmartTagsFromCompositeNode ( ) throws Exception { //ExStart //ExFor:CompositeNode.RemoveSmartTags //ExSummary:Removes all smart tags from descendant nodes of the composite node. Document doc = new Document(getMyDir() + "Document.doc"); // Remove smart tags from the first paragraph in the document. doc.getFirstSection().getBody().getFirstParagraph().removeSmartTags(); //ExEnd
public void GetIndexOfNode ( ) throws Exception { //ExStart //ExFor:CompositeNode.IndexOf //ExSummary:Shows how to get the index of a given child node from its parent. Document doc = new Document(getMyDir() + "Rendering.doc"); // Get the body of the first section in the document. Body body = doc.getFirstSection().getBody(); // Retrieve the index of the last paragraph in the body. int index = body.getChildNodes().indexOf(body.getLastParagraph()); //ExEnd // Verify that the index is correct. Assert.assertEquals(index, 24); }
public void getNodeTypeEnums ( ) throws Exception { //ExStart //ExFor:Paragraph.NodeType //ExFor:Table.NodeType //ExFor:Node.NodeType //ExFor:Footnote.NodeType //ExFor:FormField.NodeType //ExFor:SmartTag.NodeType //ExFor:Cell.NodeType //ExFor:Row.NodeType //ExFor:Document.NodeType //ExFor:Comment.NodeType //ExFor:Run.NodeType //ExFor:Section.NodeType //ExFor:SpecialChar.NodeType //ExFor:Shape.NodeType //ExFor:FieldEnd.NodeType //ExFor:FieldSeparator.NodeType //ExFor:FieldStart.NodeType //ExFor:BookmarkStart.NodeType //ExFor:CommentRangeEnd.NodeType //ExFor:BuildingBlock.NodeType //ExFor:GlossaryDocument.NodeType //ExFor:BookmarkEnd.NodeType //ExFor:GroupShape.NodeType //ExFor:CommentRangeStart.NodeType //ExFor:DrawingML.NodeType //ExId:GetNodeTypeEnums //ExSummary:Shows how to retrieve the NodeType enumeration of nodes. Document doc = new Document(getMyDir() + "Document.doc"); // Let's pick a node that we can't be quite sure of what type it is. // In this case lets pick the first node of the first paragraph in the body of the document Node node = doc.getFirstSection().getBody().getFirstParagraph().getFirstChild(); System.out.println("NodeType of first child: " + Node.nodeTypeToString(node.getNodeType())); // This time let's pick a node that we know the type of. Create a new paragraph and a table node. Paragraph para = new Paragraph(doc); Table table = new Table(doc); // Access to NodeType for typed nodes will always return their specific NodeType. // i.e A paragraph node will always return NodeType.Paragraph, a table node will always return NodeType.Table. System.out.println("NodeType of Paragraph: " + Node.nodeTypeToString(para.getNodeType())); System.out.println("NodeType of Table: " + Node.nodeTypeToString(table.getNodeType())); //ExEnd
public void clearFormatting ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.PageSetup //ExFor:DocumentBuilder.InsertBreak //ExFor:DocumentBuilder.Document //ExFor:PageSetup //ExFor:PageSetup.Orientation //ExFor:PageSetup.VerticalAlignment //ExFor:PageSetup.ClearFormatting //ExFor:Orientation //ExFor:PageVerticalAlignment //ExFor:BreakType //ExSummary:Shows how to insert sections using DocumentBuilder, specify page setup for a section and reset page setup to defaults. DocumentBuilder builder = new DocumentBuilder(); // Modify the first section in the document. builder.getPageSetup().setOrientation(Orientation.LANDSCAPE); builder.getPageSetup().setVerticalAlignment(PageVerticalAlignment.CENTER); builder.writeln("Section 1, landscape oriented and text vertically centered."); // Start a new section and reset its formatting to defaults. builder.insertBreak(BreakType.SECTION_BREAK_NEW_PAGE); builder.getPageSetup().clearFormatting(); builder.writeln("Section 2, back to default Letter paper size, portrait orientation and top alignment."); builder.getDocument().save(getMyDir() + "PageSetup.ClearFormatting Out.doc"); //ExEnd
public void differentHeaders ( ) throws Exception { //ExStart //ExFor:PageSetup.DifferentFirstPageHeaderFooter //ExFor:PageSetup.OddAndEvenPagesHeaderFooter //ExSummary:Creates headers and footers different for first, even and odd pages using DocumentBuilder. DocumentBuilder builder = new DocumentBuilder(); PageSetup ps = builder.getPageSetup(); ps.setDifferentFirstPageHeaderFooter(true); ps.setOddAndEvenPagesHeaderFooter(true); builder.moveToHeaderFooter(HeaderFooterType.HEADER_FIRST); builder.writeln("First page header."); builder.moveToHeaderFooter(HeaderFooterType.HEADER_EVEN); builder.writeln("Even pages header."); builder.moveToHeaderFooter(HeaderFooterType.HEADER_PRIMARY); builder.writeln("Odd pages header."); // Move back to the main story of the first section. builder.moveToSection(0); builder.writeln("Text page 1."); builder.insertBreak(BreakType.PAGE_BREAK); builder.writeln("Text page 2."); builder.insertBreak(BreakType.PAGE_BREAK); builder.writeln("Text page 3."); builder.getDocument().save(getMyDir() + "PageSetup.DifferentHeaders Out.doc"); //ExEnd
public void sectionStart ( ) throws Exception { //ExStart //ExFor:SectionStart //ExFor:PageSetup.SectionStart //ExFor:Document.Sections //ExSummary:Specifies how the section starts, from a new page, on the same page or other. Document doc = new Document(); doc.getSections().get(0).getPageSetup().setSectionStart(com.aspose.words.SectionStart.CONTINUOUS); //ExEnd
public void defaultPaperTray ( ) throws Exception { //ExStart //ExFor:PageSetup.FirstPageTray //ExFor:PageSetup.OtherPagesTray //ExSummary:Changes all sections in a document to use the default paper tray of the selected printer. Document doc = new Document(); // Find the printer that will be used for printing this document. In this case it is the default printer. // You can define a specific printer by using PrintServiceLookup.lookupPrintServices. PrintService printService = PrintServiceLookup.lookupDefaultPrintService(); Media defaultTray = (Media)printService.getDefaultAttributeValue(Media.class); // The paper tray value stored in documents is completely printer specific. This means // The code below resets all page tray values to use the current printers default tray. // You can enumerate getSupportedAttributeValues for Media type to find the other valid // paper tray values of the selected printer. for (Section section : doc.getSections()) {
public void paperTrayForDifferentPaperType ( ) throws Exception { //ExStart //ExFor:PageSetup.FirstPageTray //ExFor:PageSetup.OtherPagesTray //ExSummary:Shows how to set up printing using different printer trays for different paper sizes. Document doc = new Document(); // Choose the default printer to be used for printing this document. PrintService printService = PrintServiceLookup.lookupDefaultPrintService(); Media[] trays = (Media[])printService.getSupportedAttributeValues(Media.class, null, null); // This is the tray we will use for A4 paper size. This is the first tray in the media set. int printerTrayForA4 = trays[0].getValue(); // This is the tray we will use Letter paper size. This is the second tray in the media set. int printerTrayForLetter = trays[1].getValue(); // Set the tray used for each section based off the paper size used in the section. for (Section section : doc.getSections()) {
public void pageMargins ( ) throws Exception { //ExStart //ExFor:ConvertUtil //ExFor:ConvertUtil.InchToPoint //ExFor:PaperSize //ExFor:PageSetup.PaperSize //ExFor:PageSetup.Orientation //ExFor:PageSetup.TopMargin //ExFor:PageSetup.BottomMargin //ExFor:PageSetup.LeftMargin //ExFor:PageSetup.RightMargin //ExFor:PageSetup.HeaderDistance //ExFor:PageSetup.FooterDistance //ExSummary:Specifies paper size, orientation, margins and other settings for a section. DocumentBuilder builder = new DocumentBuilder(); PageSetup ps = builder.getPageSetup(); ps.setPaperSize(PaperSize.LEGAL); ps.setOrientation(Orientation.LANDSCAPE); ps.setTopMargin(ConvertUtil.inchToPoint(1.0)); ps.setBottomMargin(ConvertUtil.inchToPoint(1.0)); ps.setLeftMargin(ConvertUtil.inchToPoint(1.5)); ps.setRightMargin(ConvertUtil.inchToPoint(1.5)); ps.setHeaderDistance(ConvertUtil.inchToPoint(0.2)); ps.setFooterDistance(ConvertUtil.inchToPoint(0.2)); builder.writeln("Hello world."); builder.getDocument().save(getMyDir() + "PageSetup.PageMargins Out.doc"); //ExEnd
public void columnsSameWidth ( ) throws Exception { //ExStart //ExfFor:PageSetup.TextColumns //ExFor:TextColumnCollection //ExFor:TextColumnCollection.Spacing //ExFor:TextColumnCollection.SetCount //ExSummary:Creates multiple evenly spaced columns in a section using DocumentBuilder. DocumentBuilder builder = new DocumentBuilder(); TextColumnCollection columns = builder.getPageSetup().getTextColumns(); // Make spacing between columns wider. columns.setSpacing(100); // This creates two columns of equal width. columns.setCount(2); builder.writeln("Text in column 1."); builder.insertBreak(BreakType.COLUMN_BREAK); builder.writeln("Text in column 2."); builder.getDocument().save(getMyDir() + "PageSetup.ColumnsSameWidth Out.doc"); //ExEnd
public void columnsCustomWidth ( ) throws Exception { //ExStart //ExFor:TextColumnCollection.LineBetween //ExFor:TextColumnCollection.EvenlySpaced //ExFor:TextColumnCollection.Item //ExFor:TextColumn //ExFor:TextColumn.Width //ExFor:TextColumn.SpaceAfter //ExSummary:Creates multiple columns of different widths in a section using DocumentBuilder. DocumentBuilder builder = new DocumentBuilder(); TextColumnCollection columns = builder.getPageSetup().getTextColumns(); // Show vertical line between columns. columns.setLineBetween(true); // Indicate we want to create column with different widths. columns.setEvenlySpaced(false); // Create two columns, note they will be created with zero widths, need to set them. columns.setCount(2); // Set the first column to be narrow. TextColumn c1 = columns.get(0); c1.setWidth(100); c1.setSpaceAfter(20); // Set the second column to take the rest of the space available on the page. TextColumn c2 = columns.get(1); PageSetup ps = builder.getPageSetup(); double contentWidth = ps.getPageWidth() - ps.getLeftMargin() - ps.getRightMargin(); c2.setWidth(contentWidth - c1.getWidth() - c1.getSpaceAfter()); builder.writeln("Narrow column 1."); builder.insertBreak(BreakType.COLUMN_BREAK); builder.writeln("Wide column 2."); builder.getDocument().save(getMyDir() + "PageSetup.ColumnsCustomWidth Out.doc"); //ExEnd
public void lineNumbers ( ) throws Exception { //ExStart //ExFor:PageSetup.LineStartingNumber //ExFor:PageSetup.LineNumberCountBy //ExFor:PageSetup.LineNumberRestartMode //ExFor:LineNumberRestartMode //ExSummary:Turns on Microsoft Word line numbering for a section. DocumentBuilder builder = new DocumentBuilder(); PageSetup ps = builder.getPageSetup(); ps.setLineStartingNumber(1); ps.setLineNumberCountBy(5); ps.setLineNumberRestartMode(LineNumberRestartMode.RESTART_PAGE); for (int i = 1; i <= 20; i++) builder.writeln(java.text.MessageFormat.format("Line {0}.", i)); builder.getDocument().save(getMyDir() + "PageSetup.LineNumbers Out.doc"); //ExEnd
public void pageBorderProperties ( ) throws Exception { //ExStart //ExFor:Section.PageSetup //ExFor:PageSetup.BorderAlwaysInFront //ExFor:PageSetup.BorderDistanceFrom //ExFor:PageSetup.BorderAppliesTo //ExFor:PageBorderDistanceFrom //ExFor:PageBorderAppliesTo //ExFor:Border.DistanceFromText //ExSummary:Creates a page border that looks like a wide blue band at the top of the first page only. Document doc = new Document(); PageSetup ps = doc.getSections().get(0).getPageSetup(); ps.setBorderAlwaysInFront(false); ps.setBorderDistanceFrom(PageBorderDistanceFrom.PAGE_EDGE); ps.setBorderAppliesTo(PageBorderAppliesTo.FIRST_PAGE); Border border = ps.getBorders().getByBorderType(BorderType.TOP); border.setLineStyle(LineStyle.SINGLE); border.setLineWidth(30); border.setColor(Color.BLUE); border.setDistanceFromText(0); doc.save(getMyDir() + "PageSetup.PageBorderTop Out.doc"); //ExEnd
public void pageBorders ( ) throws Exception { //ExStart //ExFor:Border.Shadow //ExFor:PageSetup.Borders //ExFor:BorderCollection.LineStyle //ExFor:BorderCollection.LineWidth //ExFor:BorderCollection.Color //ExFor:BorderCollection.DistanceFromText //ExFor:BorderCollection.Shadow //ExSummary:Creates a fancy looking green wavy page border with a shadow. Document doc = new Document(); PageSetup ps = doc.getSections().get(0).getPageSetup(); ps.getBorders().setLineStyle(LineStyle.DOUBLE_WAVE); ps.getBorders().setLineWidth(2); ps.getBorders().setColor(Color.GREEN); ps.getBorders().setDistanceFromText(24); ps.getBorders().setShadow(true); doc.save(getMyDir() + "PageSetup.PageBorders Out.doc"); //ExEnd
public void pageNumbering ( ) throws Exception { //ExStart //ExFor:PageSetup.RestartPageNumbering //ExFor:PageSetup.PageStartingNumber //ExFor:PageSetup.PageNumberStyle //ExFor:DocumentBuilder.InsertField(string, string) //ExSummary:Shows how to control page numbering per section. // This document has two sections, but no page numbers yet. Document doc = new Document(getMyDir() + "PageSetup.PageNumbering.doc"); // Use document builder to create a header with a page number field for the first section. // The page number will look like "Page V". DocumentBuilder builder = new DocumentBuilder(doc); builder.moveToSection(0); builder.moveToHeaderFooter(HeaderFooterType.HEADER_PRIMARY); builder.write("Page "); builder.insertField("PAGE", ""); // Set first section page numbering. Section section = doc.getSections().get(0); section.getPageSetup().setRestartPageNumbering(true); section.getPageSetup().setPageStartingNumber(5); section.getPageSetup().setPageNumberStyle(NumberStyle.UPPERCASE_ROMAN); // Create a header for the section section. // The page number will look like " - 10 - ". builder.moveToSection(1); builder.moveToHeaderFooter(HeaderFooterType.HEADER_PRIMARY); builder.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER); builder.write(" - "); builder.insertField("PAGE", ""); builder.write(" - "); // Set second section page numbering. section = doc.getSections().get(1); section.getPageSetup().setPageStartingNumber(10); section.getPageSetup().setRestartPageNumbering(true); section.getPageSetup().setPageNumberStyle(NumberStyle.ARABIC); doc.save(getMyDir() + "PageSetup.PageNumbering Out.doc"); //ExEnd
public void enumerateProperties ( ) throws Exception { //ExStart //ExFor:Document.BuiltInDocumentProperties //ExFor:Document.CustomDocumentProperties //ExFor:BuiltInDocumentProperties //ExFor:CustomDocumentProperties //ExId:DocumentProperties //ExSummary:Enumerates through all built-in and custom properties in a document. String fileName = getMyDir() + "Properties.doc"; Document doc = new Document(fileName); System.out.println(MessageFormat.format("1. Document name: {0}", fileName)); System.out.println("2. Built-in Properties"); for (DocumentProperty prop : doc.getBuiltInDocumentProperties()) System.out.println(MessageFormat.format("{0} : {1}", prop.getName(), prop.getValue())); System.out.println("3. Custom Properties"); for (DocumentProperty prop : doc.getCustomDocumentProperties()) System.out.println(MessageFormat.format("{0} : {1}", prop.getName(), prop.getValue()));
public void enumeratePropertiesWithIndexer ( ) throws Exception { //ExStart //ExFor:DocumentPropertyCollection.Count //ExFor:DocumentPropertyCollection.Item(int) //ExFor:DocumentProperty //ExFor:DocumentProperty.Name //ExFor:DocumentProperty.Value //ExFor:DocumentProperty.Type //ExSummary:Enumerates through all built-in and custom properties in a document using indexed access. String fileName = getMyDir() + "Properties.doc"; Document doc = new Document(fileName); System.out.println(MessageFormat.format("1. Document name: {0}", fileName)); System.out.println("2. Built-in Properties"); for (int i = 0; i < doc.getBuiltInDocumentProperties().getCount(); i++) { DocumentProperty prop = doc.getBuiltInDocumentProperties().get(i); System.out.println(MessageFormat.format("{0}({1}) : {2}", prop.getName(), prop.getType(), prop.getValue())); } System.out.println("3. Custom Properties"); for (int i = 0; i < doc.getCustomDocumentProperties().getCount(); i++) {
public void builtInNamedAccess ( ) throws Exception { //ExStart //ExFor:BuiltInDocumentProperties.Item(String) //ExFor:DocumentProperty.ToString //ExSummary:Retrieves a built-in document property by name. Document doc = new Document(getMyDir() + "Properties.doc"); DocumentProperty prop = doc.getBuiltInDocumentProperties().get("Keywords"); System.out.println(prop.toString()); //ExEnd
public void customNamedAccess ( ) throws Exception { //ExStart //ExFor:DocumentPropertyCollection.Item(String) //ExFor:CustomDocumentProperties.Add(String,DateTime) //ExFor:DocumentProperty.ToDateTime //ExSummary:Retrieves a custom document property by name. Document doc = new Document(getMyDir() + "Properties.doc"); DocumentProperty prop = doc.getCustomDocumentProperties().get("Authorized Date"); if (prop != null) {
public void customAdd ( ) throws Exception { //ExStart //ExFor:CustomDocumentProperties.Add(String,String) //ExFor:CustomDocumentProperties.Add(String,Boolean) //ExFor:CustomDocumentProperties.Add(String,int) //ExFor:CustomDocumentProperties.Add(String,DateTime) //ExFor:CustomDocumentProperties.Add(String,Double) //ExId:AddCustomProperties //ExSummary:Checks if a custom property with a given name exists in a document and adds few more custom document properties. Document doc = new Document(getMyDir() + "Properties.doc"); CustomDocumentProperties props = doc.getCustomDocumentProperties(); if (props.get("Authorized") == null) {
public void customRemove ( ) throws Exception { //ExStart //ExFor:DocumentPropertyCollection.Remove //ExId:RemoveCustomProperties //ExSummary:Removes a custom document property. Document doc = new Document(getMyDir() + "Properties.doc"); doc.getCustomDocumentProperties().remove("Authorized Date"); //ExEnd
public void propertyTypes ( ) throws Exception { //ExStart //ExFor:DocumentProperty.Type //ExFor:DocumentProperty.ToBool //ExFor:DocumentProperty.ToInt //ExFor:DocumentProperty.ToDouble //ExFor:DocumentProperty.ToString //ExFor:DocumentProperty.ToDateTime //ExFor:PropertyType //ExSummary:Retrieves the types and values of the custom document properties. Document doc = new Document(getMyDir() + "Properties.doc"); for (DocumentProperty prop : doc.getCustomDocumentProperties()) {
public void deleteSelection ( ) throws Exception { //ExStart //ExFor:Node.Range //ExFor:Range.Delete //ExSummary:Shows how to delete a section from a Word document. // Open Word document. Document doc = new Document(getMyDir() + "Range.DeleteSection.doc"); // The document contains two sections. Each section has a paragraph of text. System.out.println(doc.getText()); // Delete the first section from the document. doc.getSections().get(0).getRange().delete(); // Check the first section was deleted by looking at the text of the whole document again. System.out.println(doc.getText()); //ExEnd Assert.assertEquals(doc.getText(), "Hello2\f"); }
public void replaceSimple ( ) throws Exception { //ExStart //ExFor:Range.Replace(String,String,Boolean,Boolean) //ExSummary:Simple find and replace operation. // Open the document. Document doc = new Document(getMyDir() + "Range.ReplaceSimple.doc"); // Check the document contains what we are about to test. System.out.println(doc.getFirstSection().getBody().getParagraphs().get(0).getText()); // Replace the text in the document. doc.getRange().replace("_CustomerName_", "James Bond", false, false); // Save the modified document. doc.save(getMyDir() + "Range.ReplaceSimple Out.doc"); //ExEnd Assert.assertEquals(doc.getText(), "Hello James Bond,\r\f"); }
public void replaceWithInsertHtmlCaller ( ) throws Exception { replaceWithInsertHtml ( ) ; }
public void replaceWithInsertHtml ( ) throws Exception { // Open the document. Document doc = new Document(getMyDir() + "Range.ReplaceWithInsertHtml.doc"); doc.getRange().replace(Pattern.compile("<CustomerName>"), new ReplaceWithHtmlEvaluator(), false); // Save the modified document. doc.save(getMyDir() + "Range.ReplaceWithInsertHtml Out.doc"); Assert.assertEquals(doc.getText(), "Hello James Bond,\r\f"); //ExSkip }
public int replacing ( ReplacingArgs e ) throws Exception { DocumentBuilder builder = new DocumentBuilder ( ( Document ) e . getMatchNode ( ) . getDocument ( ) ) ; builder . moveTo ( e . getMatchNode ( ) ) ; // Replace '<CustomerName>' text with a red bold name. builder.insertHtml("<b><font color='red'>James Bond</font></b>"); e.setReplacement(""); return ReplaceAction.REPLACE; }
public void rangesGetText ( ) throws Exception { //ExStart //ExFor:Range //ExFor:Range.Text //ExId:RangesGetText //ExSummary:Shows how to get plain, unformatted text of a range. Document doc = new Document(getMyDir() + "Document.doc"); String text = doc.getRange().getText(); //ExEnd
public void replaceWithString ( ) throws Exception { //ExStart //ExFor:Range //ExId:RangesReplaceString //ExSummary:Shows how to replace all occurrences of word "sad" to "bad". Document doc = new Document(getMyDir() + "Document.doc"); doc.getRange().replace("sad", "bad", false, true); //ExEnd doc.save(getMyDir() + "ReplaceWithString Out.doc"); }
public void replaceWithRegex ( ) throws Exception { //ExStart //ExFor:Range.Replace(Regex, String) //ExId:RangesReplaceRegex //ExSummary:Shows how to replace all occurrences of words "sad" or "mad" to "bad". Document doc = new Document(getMyDir() + "Document.doc"); doc.getRange().replace(Pattern.compile("[s|m]ad"), "bad"); //ExEnd doc.save(getMyDir() + "ReplaceWithRegex Out.doc"); }
public void replaceWithEvaluatorCaller ( ) throws Exception { replaceWithEvaluator ( ) ; }
public void replaceWithEvaluator ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Range.ReplaceWithEvaluator.doc " ) ; doc . getRange ( ) . replace ( Pattern . compile ( " [s|m]ad " ) , new MyReplaceEvaluator ( ) , true ) ; doc . save ( getMyDir ( ) + " Range.ReplaceWithEvaluator Out.doc " ) ; }
public int replacing ( ReplacingArgs e ) throws Exception { e . setReplacement ( e . getMatch ( ) . group ( ) + Integer . toString ( mMatchNumber ) ) ; mMatchNumber + + ; return ReplaceAction . REPLACE ; }
public void rangesDeleteText ( ) throws Exception { //ExStart //ExId:RangesDeleteText //ExSummary:Shows how to delete all characters of a range. Document doc = new Document(getMyDir() + "Document.doc"); doc.getSections().get(0).getRange().delete(); //ExEnd
public void changeTextToHyperlinks ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Range.ChangeTextToHyperlinks.doc " ) ; // Create regular expression for URL search // Group 1 - protocol // Group 2 - domain Pattern regexUrl = Pattern.compile("(\\w+):\\/\\/([\\w.]+\\/?)\\S*(?x)"); // Run replacement, using regular expression and evaluator. doc.getRange().replace(regexUrl, new ChangeTextToHyperlinksEvaluator(doc), false); // Save updated document. doc.save(getMyDir() + "Range.ChangeTextToHyperlinks Out.docx"); }
public /*ReplaceAction*/ int /*IReplacingCallback.*/ replacing ( ReplacingArgs e ) throws Exception { // This is the run node that contains the found text. Note that the run might contain other // text apart from the URL. All the complexity below is just to handle that. I don't think there // is a simpler way at the moment. Run run = (Run)e.getMatchNode(); Paragraph para = run.getParentParagraph(); String url = e.getMatch().group(); // We are using \xbf (inverted question mark) symbol for temporary purposes. // Any symbol will do that is non-special and is guaranteed not to be presented in the document. // The purpose is to split the matched run into two and insert a hyperlink field between them. para.getRange().replace(url, "\u00bf", true, true); Run subRun = (Run)run.deepClone(false); int pos = run.getText().indexOf("\u00bf"); subRun.setText(subRun.getText().substring(0, pos)); run.setText(run.getText().substring(pos + 1, run.getText().length())); para.getChildNodes().insert(para.getChildNodes().indexOf(run), subRun); mBuilder.moveTo(run); // Specify font formatting for the hyperlink. mBuilder.getFont().setColor(Color.BLUE); mBuilder.getFont().setUnderline(Underline.SINGLE); // Insert the hyperlink. mBuilder.insertHyperlink(url, url, false); // Clear hyperlink formatting. mBuilder.getFont().clearFormatting(); // Let's remove run if it is empty. if (run.getText().equals("")) run.remove(); // No replace action is necessary - we have already done what we intended to do. return ReplaceAction.SKIP; }
public void renameMergeFields ( ) throws Exception { // Specify your document name here. Document doc = new Document(getMyDir() + "RenameMergeFields.doc"); // Select all field start nodes so we can find the merge fields. NodeCollection fieldStarts = doc.getChildNodes(NodeType.FIELD_START, true, false); for (FieldStart fieldStart : (Iterable<FieldStart>) fieldStarts) { if (fieldStart.getFieldType() == FieldType.FIELD_MERGE_FIELD) { MergeField mergeField = new MergeField(fieldStart); mergeField.setName(mergeField.getName() + "_Renamed"); } } doc.save(getMyDir() + "RenameMergeFields Out.doc"); }
private void updateFieldCode ( String fieldName ) throws Exception { // Field code is stored in a Run node between field start and field separator. Run fieldCode = (Run)mFieldStart.getNextSibling(); Matcher matcher = G_REGEX.matcher(fieldCode.getText()); matcher.find(); String newFieldCode = java.text.MessageFormat.format("{0} {1} {2}", matcher.group(1).toString(), fieldName, matcher.group(3).toString()); fieldCode.setText(newFieldCode); // But sometimes the field code can consist of more than one run, delete these runs. removeSameParent(fieldCode.getNextSibling(), mFieldSeparator); }
private static Node findNextSibling ( Node startNode , int nodeType ) throws Exception { for ( Node node = startNode ; node ! = null ; node = node . getNextSibling ( ) ) { if ( node . getNodeType ( ) = = nodeType ) return node ; } return null ; }
private static String getTextSameParent ( Node startNode , Node endNode ) throws Exception { if ( ( endNode ! = null ) & & ( startNode . getParentNode ( ) ! = endNode . getParentNode ( ) ) ) throw new IllegalArgumentException ( " Start and end nodes are expected to have the same parent. " ) ; StringBuilder builder = new StringBuilder ( ) ; for ( Node child = startNode ; ! child . equals ( endNode ) ; child = child . getNextSibling ( ) ) builder . append ( child . getText ( ) ) ; return builder . toString ( ) ; }
private static void removeSameParent ( Node startNode , Node endNode ) throws Exception { if ( ( endNode ! = null ) & & ( startNode . getParentNode ( ) ! = endNode . getParentNode ( ) ) ) throw new IllegalArgumentException ( " Start and end nodes are expected to have the same parent. " ) ; Node curChild = startNode ; while ( ( curChild ! = null ) & & ( curChild ! = endNode ) ) {
public void saveToPdfDefault ( ) throws Exception { //ExStart //ExFor:Document.Save(String) //ExSummary:Converts a whole document to PDF using default options. Document doc = new Document(getMyDir() + "Rendering.doc"); doc.save(getMyDir() + "Rendering.SaveToPdfDefault Out.pdf"); //ExEnd
public void saveToPdfWithOutline ( ) throws Exception { //ExStart //ExFor:Document.Save(String, SaveOptions) //ExFor:PdfSaveOptions //ExFor:PdfSaveOptions.HeadingsOutlineLevels //ExFor:PdfSaveOptions.ExpandedOutlineLevels //ExSummary:Converts a whole document to PDF with three levels in the document outline. Document doc = new Document(getMyDir() + "Rendering.doc"); PdfSaveOptions options = new PdfSaveOptions(); options.setHeadingsOutlineLevels(3); options.setExpandedOutlineLevels(1); doc.save(getMyDir() + "Rendering.SaveToPdfWithOutline Out.pdf", options); //ExEnd
public void saveToPdfStreamOnePage ( ) throws Exception { //ExStart //ExFor:PdfSaveOptions.PageIndex //ExFor:PdfSaveOptions.PageCount //ExFor:Document.Save(Stream, SaveOptions) //ExSummary:Converts just one page (third page in this example) of the document to PDF. Document doc = new Document(getMyDir() + "Rendering.doc"); OutputStream stream = new FileOutputStream(getMyDir() + "Rendering.SaveToPdfStreamOnePage Out.pdf"); try {
public void saveToPdfNoCompression ( ) throws Exception { //ExStart //ExFor:PdfSaveOptions //ExFor:PdfSaveOptions.TextCompression //ExFor:PdfTextCompression //ExSummary:Saves a document to PDF without compression. Document doc = new Document(getMyDir() + "Rendering.doc"); PdfSaveOptions options = new PdfSaveOptions(); options.setTextCompression(PdfTextCompression.NONE); doc.save(getMyDir() + "Rendering.SaveToPdfNoCompression Out.pdf", options); //ExEnd
public void saveAsPdf ( ) throws Exception { //ExStart //ExFor:PdfSaveOptions.PreserveFormFields //ExFor:Document.Save(String) //ExFor:Document.Save(Stream, SaveFormat) //ExFor:Document.Save(String, SaveOptions) //ExId:SaveToPdf_NewAPI //ExSummary:Shows how to save a document to the PDF format using the Save method and the PdfSaveOptions class. // Open the document Document doc = new Document(getMyDir() + "Rendering.doc"); // Option 1: Save document to file in the PDF format with default options doc.save(getMyDir() + "Rendering.PdfDefaultOptions Out.pdf"); // Option 2: Save the document to stream in the PDF format with default options ByteArrayOutputStream stream = new ByteArrayOutputStream(); doc.save(stream, SaveFormat.PDF); // Option 3: Save document to the PDF format with specified options // Render the first page only and preserve form fields as usable controls and not as plain text PdfSaveOptions pdfOptions = new PdfSaveOptions(); pdfOptions.setPageIndex(0); pdfOptions.setPageCount(1); pdfOptions.setPreserveFormFields(true); doc.save(getMyDir() + "Rendering.PdfCustomOptions Out.pdf", pdfOptions); //ExEnd
public void saveAsXps ( ) throws Exception { //ExStart //ExFor:XpsSaveOptions //ExFor:Document.Save(String) //ExFor:Document.Save(Stream, SaveFormat) //ExFor:Document.Save(String, SaveOptions) //ExId:SaveToXps_NewAPI //ExSummary:Shows how to save a document to the Xps format using the Save method and the XpsSaveOptions class. // Open the document Document doc = new Document(getMyDir() + "Rendering.doc"); // Save document to file in the Xps format with default options doc.save(getMyDir() + "Rendering.XpsDefaultOptions Out.xps"); // Save document to stream in the Xps format with default options ByteArrayOutputStream docStream = new ByteArrayOutputStream(); doc.save(docStream, SaveFormat.XPS); // Save document to file in the Xps format with specified options // Render the first page only XpsSaveOptions xpsOptions = new XpsSaveOptions(); xpsOptions.setPageIndex(0); xpsOptions.setPageCount(1); doc.save(getMyDir() + "Rendering.XpsCustomOptions Out.xps", xpsOptions); //ExEnd
public void saveAsImage ( ) throws Exception { //ExStart //ExFor:Document.Save(String) //ExFor:Document.Save(Stream, SaveFormat) //ExFor:Document.Save(String, SaveOptions) //ExId:SaveToImage_NewAPI //ExSummary:Shows how to save a document to the Jpeg format using the Save method and the ImageSaveOptions class. // Open the document Document doc = new Document(getMyDir() + "Rendering.doc"); // Save as a Jpeg image file with default options doc.save(getMyDir() + "Rendering.JpegDefaultOptions Out.jpg"); // Save document to an ByteArrayOutputStream as a Jpeg with default options ByteArrayOutputStream docStream = new ByteArrayOutputStream(); doc.save(docStream, SaveFormat.JPEG); // Save document to a Jpeg image with specified options. // Render the third page only and set the jpeg quality to 80% // In this case we need to pass the desired SaveFormat to the ImageSaveOptions constructor // to signal what type of image to save as. ImageSaveOptions imageOptions = new ImageSaveOptions(SaveFormat.JPEG); imageOptions.setPageIndex(2); imageOptions.setPageCount(1); imageOptions.setJpegQuality(80); doc.save(getMyDir() + "Rendering.JpegCustomOptions Out.jpg", imageOptions); //ExEnd
public void saveToTiffDefault ( ) throws Exception { //ExStart //ExFor:Document.Save(String) //ExSummary:Converts a whole document into a multipage TIFF file using default options. Document doc = new Document(getMyDir() + "Rendering.doc"); doc.save(getMyDir() + "Rendering.SaveToTiffDefault Out.tiff"); //ExEnd
public void saveToTiffCompression ( ) throws Exception { //ExStart //ExFor:TiffCompression //ExFor:ImageSaveOptions.TiffCompression //ExFor:ImageSaveOptions.PageIndex //ExFor:ImageSaveOptions.PageCount //ExFor:Document.Save(String, SaveOptions) //ExSummary:Converts a page of a Word document into a TIFF image and uses the CCITT compression. Document doc = new Document(getMyDir() + "Rendering.doc"); ImageSaveOptions options = new ImageSaveOptions(SaveFormat.TIFF); options.setTiffCompression(TiffCompression.CCITT_3); options.setPageIndex(0); options.setPageCount(1); doc.save(getMyDir() + "Rendering.SaveToTiffCompression Out.tif", options); //ExEnd
public void saveToImageResolution ( ) throws Exception { //ExStart //ExFor:ImageSaveOptions //ExFor:ImageSaveOptions.Resolution //ExSummary:Renders a page of a Word document into a PNG image at a specific resolution. Document doc = new Document(getMyDir() + "Rendering.doc"); ImageSaveOptions options = new ImageSaveOptions(SaveFormat.PNG); options.setResolution(300); options.setPageCount(1); doc.save(getMyDir() + "Rendering.SaveToImageResolution Out.png", options); //ExEnd
public void saveToImageJpegQuality ( ) throws Exception { //ExStart //ExFor:ImageSaveOptions //ExFor:ImageSaveOptions.JpegQuality //ExSummary:Converts a page of a Word document into JPEG images of different qualities. Document doc = new Document(getMyDir() + "Rendering.doc"); ImageSaveOptions options = new ImageSaveOptions(SaveFormat.JPEG); // Try worst quality. options.setJpegQuality(0); doc.save(getMyDir() + "Rendering.SaveToImageJpegQuality0 Out.jpeg", options); // Try best quality. options.setJpegQuality(100); doc.save(getMyDir() + "Rendering.SaveToImageJpegQuality100 Out.jpeg", options); //ExEnd
public void saveToImagePaperColor ( ) throws Exception { //ExStart //ExFor:ImageSaveOptions //ExFor:ImageSaveOptions.PaperColor //ExSummary:Renders a page of a Word document into an image with transparent or coloured background. Document doc = new Document(getMyDir() + "Rendering.doc"); ImageSaveOptions imgOptions = new ImageSaveOptions(SaveFormat.PNG); imgOptions.setPaperColor(new Color(0, 0, 0, 0)); doc.save(getMyDir() + "Rendering.SaveToImagePaperColorTransparent Out.png", imgOptions); imgOptions.setPaperColor(new Color(0x80, 0x80, 0x70)); doc.save(getMyDir() + "Rendering.SaveToImagePaperColorCoral Out.png", imgOptions); //ExEnd
public void saveToImageStream ( ) throws Exception { //ExStart //ExFor:Document.Save(Stream, SaveFormat) //ExSummary:Saves a document page as a BMP image into a ByteArayOutputStream. Document doc = new Document(getMyDir() + "Rendering.doc"); ByteArrayOutputStream stream = new ByteArrayOutputStream(); doc.save(stream, SaveFormat.BMP); // The stream now contains image bytes. byte[] imageBytes = stream.toByteArray(); // Read the bytes back into an image. BufferedImage image = ImageIO.read(new ByteArrayInputStream(imageBytes)); //ExEnd
public void updatePageLayout ( ) throws Exception { //ExStart //ExFor:StyleCollection.Item(String) //ExFor:SectionCollection.Item(Int32) //ExFor:Document.UpdatePageLayout //ExSummary:Shows when to request page layout of the document to be recalculated. Document doc = new Document(getMyDir() + "Rendering.doc"); // Saving a document to PDF or to image or printing for the first time will automatically // layout document pages and this information will be cached inside the document. doc.save(getMyDir() + "Rendering.UpdatePageLayout1 Out.pdf"); // Modify the document in any way. doc.getStyles().get("Normal").getFont().setSize(6); doc.getSections().get(0).getPageSetup().setOrientation(com.aspose.words.Orientation.LANDSCAPE); // In the current version of Aspose.Words, modifying the document does not automatically rebuild // the cached page layout. If you want to save to PDF or render a modified document again, // you need to manually request page layout to be updated. doc.updatePageLayout(); doc.save(getMyDir() + "Rendering.UpdatePageLayout2 Out.pdf"); //ExEnd
public void updateFieldsBeforeRendering ( ) throws Exception { //ExStart //ExFor:Document.UpdateFields //ExId:UpdateFieldsBeforeRendering //ExSummary:Shows how to update all fields before rendering a document. Document doc = new Document(getMyDir() + "Rendering.doc"); // This updates all fields in the document. doc.updateFields(); doc.save(getMyDir() + "Rendering.UpdateFields Out.pdf"); //ExEnd
public void print ( ) throws Exception { //ExStart //ExFor:Document.Print //ExSummary:Prints the whole document to the default printer. Document doc = new Document(getMyDir() + "Document.doc"); doc.print(); //ExEnd
public void printToNamedPrinter ( ) throws Exception { //ExStart //ExFor:Document.Print(String) //ExSummary:Prints the whole document to a specified printer. Document doc = new Document(getMyDir() + "Document.doc"); doc.print("KONICA MINOLTA magicolor 2400W"); //ExEnd
public void printRange ( ) throws Exception { //ExStart //ExFor:Document.Print(PrinterSettings) //ExSummary:Prints a range of pages. Document doc = new Document(getMyDir() + "Rendering.doc"); AttributeSet printerSettings = new HashAttributeSet(); // Page numbers in printer settings are 1-based. printerSettings.add(new PageRanges(1, 3)); doc.print(printerSettings); //ExEnd
public void PrintRangeWithDocumentName ( ) throws Exception { //ExStart //ExFor:Document.Print(PrinterSettings, String) //ExSummary:Prints a range of pages along with the name of the document. Document doc = new Document(getMyDir() + "Rendering.doc"); AttributeSet printerSettings = new HashAttributeSet(); // Page numbers in printer settings are 1-based. printerSettings.add(new PageRanges(1, 3)); doc.print(printerSettings, "My Print Document.doc"); //ExEnd
public void printWithPrintDialog ( ) throws Exception { //ExStart //ExFor:AsposeWordsPrintDocument //ExSummary:Shows the standard Java print dialog that allows selecting the printer and the specified page range to print the document with. Document doc = new Document(getMyDir() + "Rendering.doc"); PrinterJob pj = PrinterJob.getPrinterJob(); // Initialize the Print Dialog with the number of pages in the document. PrintRequestAttributeSet attributes = new HashPrintRequestAttributeSet(); attributes.add(new PageRanges(1, doc.getPageCount())); // Returns true if the user accepts the print dialog. if (!pj.printDialog(attributes)) return; // Create the Aspose.Words' implementation of the Java Pageable interface. AsposeWordsPrintDocument awPrintDoc = new AsposeWordsPrintDocument(doc); // Pass the document to the printer. pj.setPageable(awPrintDoc); // Print the document with the user specified print settings. pj.print(attributes); //ExEnd
public void renderToScale ( ) throws Exception { //ExStart //ExFor:Document.RenderToScale //ExFor:Document.GetPageInfo //ExFor:PageInfo //ExFor:PageInfo.GetSizeInPixels //ExSummary:Renders a page of a Word document into a BufferedImage using a specified zoom factor. Document doc = new Document(getMyDir() + "Rendering.doc"); PageInfo pageInfo = doc.getPageInfo(0); // Let's say we want the image at 50% zoom. float MY_SCALE = 0.50f; Dimension pageSize = pageInfo.getSizeInPixels(MY_SCALE, 96.0f); BufferedImage img = new BufferedImage((int)pageSize.getWidth(), (int)pageSize.getHeight(), BufferedImage.TYPE_INT_ARGB); Graphics2D gr = img.createGraphics(); try { // You can apply various settings to the Graphics object. gr.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON); // Fill the page background. gr.setPaint(Color.black); // Render the page using the zoom. doc.renderToScale(0, gr, 0, 0, MY_SCALE); } finally { if (gr != null) gr.dispose(); } ImageIO.write(img, "PNG", new File(getMyDir() + "Rendering.RenderToScale Out.png")); //ExEnd
public void renderToSize ( ) throws Exception { //ExStart //ExFor:Document.RenderToSize //ExSummary:Render to a BufferedImage at a specified location and size. Document doc = new Document(getMyDir() + "Rendering.doc"); // Bitmap bmp = new Bitmap(700, 700); BufferedImage img = new BufferedImage(700, 700, BufferedImage.TYPE_INT_ARGB); // User has some sort of a Graphics object. In this case created from a bitmap. Graphics2D gr = img.createGraphics(); try {
public void createThumbnails ( ) throws Exception { //ExStart //ExFor:Document.RenderToScale //ExSummary:Renders individual pages to graphics to create one image with thumbnails of all pages. // The user opens or builds a document. Document doc = new Document(getMyDir() + "Rendering.doc"); // This defines the number of columns to display the thumbnails in. final int THUMB_COLUMNS = 2; // Calculate the required number of rows for thumbnails. // We can now get the number of pages in the document. int thumbRows = doc.getPageCount() / THUMB_COLUMNS; int remainder = doc.getPageCount() % THUMB_COLUMNS; if (remainder > 0) thumbRows++; // Lets say I want thumbnails to be of this zoom. float SCALE = 0.25f; // For simplicity lets pretend all pages in the document are of the same size, // so we can use the size of the first page to calculate the size of the thumbnail. Dimension thumbSize = doc.getPageInfo(0).getSizeInPixels(SCALE, 96); // Calculate the size of the image that will contain all the thumbnails. int imgWidth = (int)(thumbSize.getWidth() * THUMB_COLUMNS); int imgHeight = (int)(thumbSize.getHeight() * thumbRows); BufferedImage img = new BufferedImage(imgWidth, imgHeight, BufferedImage.TYPE_INT_ARGB); // The user has to provides a Graphics object to draw on. // The Graphics object can be created from a bitmap, from a metafile, printer or window. Graphics2D gr = img.createGraphics(); try {
public void customPrint ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Rendering.doc " ) ; // Create an instance of our own Pageable document. MyPrintDocument printDoc = new MyPrintDocument(doc, 2, 6); // Print with the default printer PrinterJob pj = PrinterJob.getPrinterJob(); // Set our custom class as the print target. pj.setPageable(printDoc); // Print the document to the default printer. pj.print(); }
public int getNumberOfPages ( ) { return ( mToPage - mFromPage ) + 1 ; }
public PageFormat getPageFormat ( int pageIndex ) { PageFormat format = new PageFormat ( ) ; Paper paper = new Paper ( ) ; try { // Retrieve the page info of the requested page. The pageIndex starts at 0 and is the first page to print. // We calculate the real page to print based on the start page. PageInfo info = mDocument.getPageInfo(pageIndex + mFromPage - 1); // Set the page orientation as landscape or portrait based off the document page. boolean isLandscape = info.getLandscape(); format.setOrientation(isLandscape ? PageFormat.LANDSCAPE : PageFormat.PORTRAIT); // Set some margins for the printable area of the page. paper.setImageableArea(1.0, 1.0, paper.getWidth() - 2, paper.getHeight() -2); } catch(Exception e) { // If there are any errors then use the default paper size. } format.setPaper(paper); return format; }
public Printable getPrintable ( int pageIndex ) { return this ; }
public int print ( Graphics g , PageFormat pf , int pageIndex ) { try { mDocument . renderToScale ( pageIndex + mFromPage - 1 , ( Graphics2D ) g , ( int ) pf . getImageableX ( ) , ( int ) pf . getImageableY ( ) , 1.0f ) ; } catch ( Exception e ) { // If there are any problems with rendering the document or when the given index is out of bounds we arrive here. // We return Printable.NO_SUCH_PAGE is returned so that printing finishes here. return Printable.NO_SUCH_PAGE; } return Printable.PAGE_EXISTS; }
public void writePageInfo ( ) throws Exception { //ExStart //ExFor:PageInfo //ExFor:PageInfo.PaperSize //ExFor:PageInfo.PaperTray //ExFor:PageInfo.Landscape //ExFor:PageInfo.WidthInPoints //ExFor:PageInfo.HeightInPoints //ExSummary:Retrieves page size and orientation information for every page in a Word document. Document doc = new Document(getMyDir() + "Rendering.doc"); System.out.println(MessageFormat.format("Document \"{0}\" contains {1} pages.", doc.getOriginalFileName(), doc.getPageCount())); for (int i = 0; i < doc.getPageCount(); i++) {
public void setTrueTypeFontsFolder ( ) throws Exception { // Store the font folders currently used so we can restore them later. String[] fontFolders = FontSettings.getFontsFolders(); //ExStart //ExFor:FontSettings //ExFor:FontSettings.SetFontsFolder(String, Boolean) //ExId:SetFontsFolderCustomFolder //ExSummary:Demonstrates how to set the folder Aspose.Words uses to look for TrueType fonts during rendering. Document doc = new Document(getMyDir() + "Rendering.doc"); // Set fonts to be scanned for under the specified directory. Do not search within sub-folders. FontSettings.setFontsFolder("C:\\MyFonts\\", false); doc.save(getMyDir() + "Rendering.SetFontsFolder Out.pdf"); //ExEnd // Restore the original folders used to search for fonts. FontSettings.setFontsFolders(fontFolders, true); }
public void setFontsFoldersMultipleFolders ( ) throws Exception { // Store the font folders currently used so we can restore them later. String[] fontFolders = FontSettings.getFontsFolders(); //ExStart //ExFor:FontSettings //ExFor:FontSettings.SetFontsFolders(String[], Boolean) //ExId:SetFontsFoldersMultipleFolders //ExSummary:Demonstrates how to set Aspose.Words to look in multiple folders for TrueType fonts when rendering. Document doc = new Document(getMyDir() + "Rendering.doc"); // Pass true to the second parameter to search within all sub-folders of the specified folders as well. FontSettings.setFontsFolders(new String[] {"C:\\MyFonts\\", "D:\\Misc\\Fonts\\"}, true); doc.save(getMyDir() + "Rendering.SetFontsFolders Out.pdf"); //ExEnd // Restore the original folders used to search for fonts. FontSettings.setFontsFolders(fontFolders, true); }
public void SetFontsFoldersSystemAndCustomFolder ( ) throws Exception { // Store the font folders currently used so we can restore them later. String[] origFontFolders = FontSettings.getFontsFolders(); //ExStart //ExFor:FontSettings //ExFor:FontSettings.SetFontsFolders(String[], Boolean) //ExId:SetFontsFoldersSystemAndCustomFolder //ExSummary:Demonstrates how to set Aspose.Words to look for TrueType fonts in system folders and a custom defined folder as well. Document doc = new Document(getMyDir() + "Rendering.doc"); // Retrieve the array of environment-dependent font folders that are searched by default. For example this will contain "Windows\Fonts\" on a Windows machines. ArrayList fontFolders = new ArrayList(Arrays.asList(FontSettings.getFontsFolders())); // Add our custom folder to the list. fontFolders.add("C:\\MyFonts\\"); // Convert the list to an array to pass back to the FontSettings class. FontSettings.setFontsFolders((String[])fontFolders.toArray(new String[fontFolders.size()]), true); doc.save(getMyDir() + "Rendering.SetFontsFolders Out.pdf"); //ExEnd // Verify that folders are set correctly. Assert.assertTrue(FontSettings.getFontsFolders()[0].toLowerCase().contains("fonts")); // Regardless of OS the system fonts path should contain "Fonts". Assert.assertEquals("C:\\MyFonts\\", FontSettings.getFontsFolders()[1]); // Restore the original folders used to search for fonts. FontSettings.setFontsFolders(origFontFolders, true); }
public void SetPdfEncryptionPermissions ( ) throws Exception { //ExStart //ExFor:PdfEncryptionDetails.#ctor //ExFor:PdfSaveOptions.EncryptionDetails //ExFor:PdfEncryptionAlgorithm //ExFor:PdfEncryptionDetails.Permissions //ExFor:PdfPermissions //ExFor:PdfEncryptionDetails //ExSummary:Demonstrates how to set permissions on a PDF document generated by Aspose.Words. Document doc = new Document(getMyDir() + "Rendering.doc"); PdfSaveOptions saveOptions = new PdfSaveOptions(); // Create encryption details and set owner password. PdfEncryptionDetails encryptionDetails = new PdfEncryptionDetails("", "password", PdfEncryptionAlgorithm.RC_4_128); // Start by disallowing all permissions. encryptionDetails.setPermissions(PdfPermissions.DISALLOW_ALL); // Extend permissions to allow editing or modifying annotations. encryptionDetails.setPermissions(PdfPermissions.MODIFY_ANNOTATIONS | PdfPermissions.DOCUMENT_ASSEMBLY); saveOptions.setEncryptionDetails(encryptionDetails); // Render the document to PDF format with the specified permissions. doc.save(getMyDir() + "Rendering.SpecifyPermissions Out.pdf", saveOptions); //ExEnd
public void replaceHyperlinks ( ) throws Exception { // Specify your document name here. Document doc = new Document(getMyDir() + "ReplaceHyperlinks.doc"); // Hyperlinks in a Word documents are fields, select all field start nodes so we can find the hyperlinks. NodeList fieldStarts = doc.selectNodes("//FieldStart"); for (FieldStart fieldStart : (Iterable<FieldStart>) fieldStarts) { if (fieldStart.getFieldType() == FieldType.FIELD_HYPERLINK) { // The field is a hyperlink field, use the "facade" class to help to deal with the field. Hyperlink hyperlink = new Hyperlink(fieldStart); // Some hyperlinks can be local (links to bookmarks inside the document), ignore these. if (hyperlink.isLocal()) continue; // The Hyperlink class allows to set the target URL and the display name // of the link easily by setting the properties. hyperlink.setTarget(NEW_URL); hyperlink.setName(NEW_NAME); } } doc.save(getMyDir() + "ReplaceHyperlinks Out.doc"); }
String getName ( ) throws Exception { return getTextSameParent ( mFieldSeparator , mFieldEnd ) ; }
void setName ( String value ) throws Exception { // Hyperlink display name is stored in the field result which is a Run // node between field separator and field end. Run fieldResult = (Run)mFieldSeparator.getNextSibling(); fieldResult.setText(value); // But sometimes the field result can consist of more than one run, delete these runs. removeSameParent(fieldResult.getNextSibling(), mFieldEnd); }
String getTarget ( ) throws Exception { return mTarget ; }
void setTarget ( String value ) throws Exception { mTarget = value ; updateFieldCode ( ) ; }
boolean isLocal ( ) throws Exception { return mIsLocal ; }
void isLocal ( boolean value ) throws Exception { mIsLocal = value ; updateFieldCode ( ) ; }
private void updateFieldCode ( ) throws Exception { // Field code is stored in a Run node between field start and field separator. Run fieldCode = (Run)mFieldStart.getNextSibling(); fieldCode.setText(java.text.MessageFormat.format("HYPERLINK {0}\"{1}\"", ((mIsLocal) ? "\\l " : ""), mTarget)); // But sometimes the field code can consist of more than one run, delete these runs. removeSameParent(fieldCode.getNextSibling(), mFieldSeparator); }
public void protect ( ) throws Exception { //ExStart //ExFor:Document.Protect(ProtectionType) //ExFor:ProtectionType //ExFor:Section.ProtectedForForms //ExSummary:Protects a section so only editing in form fields is possible. // Create a blank document Document doc = new Document(); // Insert two sections with some text DocumentBuilder builder = new DocumentBuilder(doc); builder.writeln("Section 1. Unprotected."); builder.insertBreak(BreakType.SECTION_BREAK_CONTINUOUS); builder.writeln("Section 2. Protected."); // Section protection only works when document protection is turned and only editing in form fields is allowed. doc.protect(ProtectionType.ALLOW_ONLY_FORM_FIELDS); // By default, all sections are protected, but we can selectively turn protection off. doc.getSections().get(0).setProtectedForForms(false); builder.getDocument().save(getMyDir() + "Section.Protect Out.doc"); //ExEnd
public void addRemove ( ) throws Exception { //ExStart //ExFor:Document.Sections //ExFor:Section.Clone //ExFor:SectionCollection //ExFor:NodeCollection.RemoveAt(Int32) //ExSummary:Shows how to add/remove sections in a document. // Open the document. Document doc = new Document(getMyDir() + "Section.AddRemove.doc"); // This shows what is in the document originally. The document has two sections. System.out.println(doc.getText()); // Delete the first section from the document doc.getSections().removeAt(0); // Duplicate the last section and append the copy to the end of the document. int lastSectionIdx = doc.getSections().getCount() - 1; Section newSection = doc.getSections().get(lastSectionIdx).deepClone(); doc.getSections().add(newSection); // Check what the document contains after we changed it. System.out.println(doc.getText()); //ExEnd Assert.assertEquals(doc.getText(), "Hello2\fHello2\f"); }
public void ensureSectionMinimum ( ) throws Exception { //ExStart //ExFor:Section.EnsureMinimum //ExSummary:Ensures that a section is valid. // Create a blank document Document doc = new Document(); Section section = doc.getFirstSection(); // Makes sure that the section contains a body with at least one paragraph. section.ensureMinimum(); //ExEnd
public void bodyEnsureMinimum ( ) throws Exception { //ExStart //ExFor:Section.Body //ExFor:Body.EnsureMinimum //ExSummary:Clears main text from all sections from the document leaving the sections themselves. // Open a document. Document doc = new Document(getMyDir() + "Section.BodyEnsureMinimum.doc"); // This shows what is in the document originally. The document has two sections. System.out.println(doc.getText()); // Loop through all sections in the document. for (Section section : doc.getSections()) { // Each section has a Body node that contains main story (main text) of the section. Body body = section.getBody(); // This clears all nodes from the body. body.removeAllChildren(); // Technically speaking, for the main story of a section to be valid, it needs to have // at least one empty paragraph. That's what the EnsureMinimum method does. body.ensureMinimum(); } // Check how the content of the document looks now. System.out.println(doc.getText()); //ExEnd Assert.assertEquals(doc.getText(), "\f\f"); }
public void bodyNodeType ( ) throws Exception { //ExStart //ExFor:Body.NodeType //ExFor:HeaderFooter.NodeType //ExFor:Document.FirstSection //ExSummary:Shows how you can enumerate through children of a composite node and detect types of the children nodes. // Open a document. Document doc = new Document(getMyDir() + "Section.BodyNodeType.doc"); // Get the first section in the document. Section section = doc.getFirstSection(); // A Section is a composite node and therefore can contain child nodes. // Section can contain only Body and HeaderFooter nodes. for (Node node : (Iterable<Node>) section) {
public void sectionsAccessByIndex ( ) throws Exception { //ExStart //ExFor:SectionCollection.Item(Int32) //ExId:SectionsAccessByIndex //ExSummary:Shows how to access a section at the specified index. Document doc = new Document(getMyDir() + "Document.doc"); Section section = doc.getSections().get(0); //ExEnd
public void sectionsAddSection ( ) throws Exception { //ExStart //ExFor:NodeCollection.Add //ExId:SectionsAddSection //ExSummary:Shows how to add a section to the end of the document. Document doc = new Document(getMyDir() + "Document.doc"); Section sectionToAdd = new Section(doc); doc.getSections().add(sectionToAdd); //ExEnd
public void sectionsDeleteSection ( ) throws Exception { //ExStart //ExId:SectionsDeleteSection //ExSummary:Shows how to remove a section at the specified index. Document doc = new Document(getMyDir() + "Document.doc"); doc.getSections().removeAt(0); //ExEnd
public void sectionsDeleteAllSections ( ) throws Exception { //ExStart //ExFor:NodeCollection.Clear //ExId:SectionsDeleteAllSections //ExSummary:Shows how to remove all sections from a document. Document doc = new Document(getMyDir() + "Document.doc"); doc.getSections().clear(); //ExEnd
public void sectionsAppendSectionContent ( ) throws Exception { //ExStart //ExFor:Section.AppendContent //ExFor:Section.PrependContent //ExId:SectionsAppendSectionContent //ExSummary:Shows how to append content of an existing section. The number of sections in the document remains the same. Document doc = new Document(getMyDir() + "Section.AppendContent.doc"); // This is the section that we will append and prepend to. Section section = doc.getSections().get(2); // This copies content of the 1st section and inserts it at the beginning of the specified section. Section sectionToPrepend = doc.getSections().get(0); section.prependContent(sectionToPrepend); // This copies content of the 2nd section and inserts it at the end of the specified section. Section sectionToAppend = doc.getSections().get(1); section.appendContent(sectionToAppend); //ExEnd
public void sectionsDeleteSectionContent ( ) throws Exception { //ExStart //ExFor:Section.ClearContent //ExId:SectionsDeleteSectionContent //ExSummary:Shows how to delete main content of a section. Document doc = new Document(getMyDir() + "Document.doc"); Section section = doc.getSections().get(0); section.clearContent(); //ExEnd
public void sectionsDeleteHeaderFooter ( ) throws Exception { //ExStart //ExFor:Section.ClearHeadersFooters //ExId:SectionsDeleteHeaderFooter //ExSummary:Clears content of all headers and footers in a section. Document doc = new Document(getMyDir() + "Document.doc"); Section section = doc.getSections().get(0); section.clearHeadersFooters(); //ExEnd
public void sectionDeleteHeaderFooterShapes ( ) throws Exception { //ExStart //ExFor:Section.DeleteHeaderFooterShapes //ExSummary:Removes all images and shapes from all headers footers in a section. Document doc = new Document(getMyDir() + "Document.doc"); Section section = doc.getSections().get(0); section.deleteHeaderFooterShapes(); //ExEnd
public void sectionsCloneSection ( ) throws Exception { //ExStart //ExId:SectionsCloneSection //ExSummary:Shows how to create a duplicate of a particular section. Document doc = new Document(getMyDir() + "Document.doc"); Section cloneSection = doc.getSections().get(0).deepClone(); //ExEnd
public void sectionsImportSection ( ) throws Exception { //ExStart //ExId:SectionsImportSection //ExSummary:Shows how to copy sections between documents. Document srcDoc = new Document(getMyDir() + "Document.doc"); Document dstDoc = new Document(); Section sourceSection = srcDoc.getSections().get(0); Section newSection = (Section)dstDoc.importNode(sourceSection, true); dstDoc.getSections().add(newSection); //ExEnd
public void migrateFrom2XImportSection ( ) throws Exception { Document srcDoc = new Document ( ) ; Document dstDoc = new Document ( ) ; //ExStart //ExId:MigrateFrom2XImportSection //ExSummary:This fragment shows how to insert a section from another document in Aspose.Words 3.0 or higher. Section sourceSection = srcDoc.getSections().get(0); Section newSection = (Section)dstDoc.importNode(sourceSection, true); dstDoc.getSections().add(newSection); //ExEnd
public void modifyPageSetupInAllSections ( ) throws Exception { //ExStart //ExId:ModifyPageSetupInAllSections //ExSummary:Shows how to set paper size for the whole document. Document doc = new Document(getMyDir() + "Section.ModifyPageSetupInAllSections.doc"); // It is important to understand that a document can contain many sections and each // section has its own page setup. In this case we want to modify them all. for (Node node : doc) { Section section = (Section)node; section.getPageSetup().setPaperSize(PaperSize.LETTER); } doc.save(getMyDir() + "Section.ModifyPageSetupInAllSections Out.doc"); //ExEnd
public void deleteAllShapes ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Shape.DeleteAllShapes.doc " ) ; //ExStart //ExFor:Shape //ExSummary:Shows how to delete all shapes from a document. // Here we get all shapes from the document node, but you can do this for any smaller // node too, for example delete shapes from a single section or a paragraph. NodeCollection shapes = doc.getChildNodes(NodeType.SHAPE, true, false); shapes.clear(); // There could also be group shapes, they have different node type, remove them all too. NodeCollection groupShapes = doc.getChildNodes(NodeType.GROUP_SHAPE, true, false); groupShapes.clear(); //ExEnd Assert.assertEquals(doc.getChildNodes(NodeType.SHAPE, true, false).getCount(), 0); Assert.assertEquals(doc.getChildNodes(NodeType.GROUP_SHAPE, true, false).getCount(), 0); doc.save(getMyDir() + "Shape.DeleteAllShapes Out.doc"); }
public void checkShapeInline ( ) throws Exception { //ExStart //ExFor:ShapeBase.IsInline //ExSummary:Shows how to test if a shape in the document is inline or floating. Document doc = new Document(getMyDir() + "Shape.DeleteAllShapes.doc"); for (Shape shape : (Iterable<Shape>) doc.getChildNodes(NodeType.SHAPE, true)) { if(shape.isInline()) System.out.println("Shape is inline."); else System.out.println("Shape is floating."); } //ExEnd // Verify that the first shape in the document is not inline. Assert.assertFalse(((Shape)doc.getChild(NodeType.SHAPE, 0, true)).isInline()); }
public void lineFlipOrientation ( ) throws Exception { //ExStart //ExFor:ShapeBase.Bounds //ExFor:ShapeBase.FlipOrientation //ExFor:FlipOrientation //ExSummary:Creates two line shapes. One line goes from top left to bottom right. Another line goes from bottom left to top right. Document doc = new Document(); // The lines will cross the whole page. float pageWidth = (float)doc.getFirstSection().getPageSetup().getPageWidth(); float pageHeight = (float)doc.getFirstSection().getPageSetup().getPageHeight(); // This line goes from top left to bottom right by default. Shape lineA = new Shape(doc, ShapeType.LINE); lineA.setBounds(new Rectangle2D.Float(0, 0, pageWidth, pageHeight)); lineA.setRelativeHorizontalPosition(RelativeHorizontalPosition.PAGE); lineA.setRelativeVerticalPosition(RelativeVerticalPosition.PAGE); doc.getFirstSection().getBody().getFirstParagraph().appendChild(lineA); // This line goes from bottom left to top right because we flipped it. Shape lineB = new Shape(doc, ShapeType.LINE); lineB.setBounds(new Rectangle2D.Float(0, 0, pageWidth, pageHeight)); lineB.setFlipOrientation(FlipOrientation.HORIZONTAL); lineB.setRelativeHorizontalPosition(RelativeHorizontalPosition.PAGE); lineB.setRelativeVerticalPosition(RelativeVerticalPosition.PAGE); doc.getFirstSection().getBody().getFirstParagraph().appendChild(lineB); doc.save(getMyDir() + "Shape.LineFlipOrientation Out.doc"); //ExEnd
public void fill ( ) throws Exception { //ExStart //ExFor:Shape.Fill //ExFor:Shape.FillColor //ExFor:Fill //ExFor:Fill.Opacity //ExSummary:Demonstrates how to create shapes with fill. DocumentBuilder builder = new DocumentBuilder(); builder.writeln(); builder.writeln(); builder.writeln(); builder.write("Some text under the shape."); // Create a red balloon, semitransparent. // The shape is floating and its coordinates are (0,0) by default, relative to the current paragraph. Shape shape = new Shape(builder.getDocument(), ShapeType.BALLOON); shape.setFillColor(Color.RED); shape.getFill().setOpacity(0.3); shape.setWidth(100); shape.setHeight(100); shape.setTop(-100); builder.insertNode(shape); builder.getDocument().save(getMyDir() + "Shape.Fill Out.doc"); //ExEnd
public void replaceTextboxesWithImages ( ) throws Exception { //ExStart //ExFor:ShapeBase.WrapSide //ExFor:WrapSide //ExFor:NodeCollection //ExFor:CompositeNode.InsertAfter(Node, Node) //ExFor:NodeCollection.ToArray //ExSummary:Shows how to replace all textboxes with images. Document doc = new Document(getMyDir() + "Shape.ReplaceTextboxesWithImages.doc"); // This gets a live collection of all shape nodes in the document. NodeCollection shapeCollection = doc.getChildNodes(NodeType.SHAPE, true); // Since we will be adding/removing nodes, it is better to copy all collection // into a fixed size array, otherwise iterator will be invalidated. Node[] shapes = shapeCollection.toArray(); for (Node node : shapes) { Shape shape = (Shape)node; // Filter out all shapes that we don't need. if (shape.getShapeType() == ShapeType.TEXT_BOX) { // Create a new shape that will replace the existing shape. Shape image = new Shape(doc, ShapeType.IMAGE); // Load the image into the new shape. image.getImageData().setImage(getMyDir() + "Hammer.wmf"); // Make new shape's position to match the old shape. image.setLeft(shape.getLeft()); image.setTop(shape.getTop()); image.setWidth(shape.getWidth()); image.setHeight(shape.getHeight()); image.setRelativeHorizontalPosition(shape.getRelativeHorizontalPosition()); image.setRelativeVerticalPosition(shape.getRelativeVerticalPosition()); image.setHorizontalAlignment(shape.getHorizontalAlignment()); image.setVerticalAlignment(shape.getVerticalAlignment()); image.setWrapType(shape.getWrapType()); image.setWrapSide(shape.getWrapSide()); // Insert new shape after the old shape and remove the old shape. shape.getParentNode().insertAfter(image, shape); shape.remove(); } } doc.save(getMyDir() + "Shape.ReplaceTextboxesWithImages Out.doc"); //ExEnd
public void createTextBox ( ) throws Exception { //ExStart //ExFor:Shape.#ctor(DocumentBase, ShapeType) //ExFor:ShapeBase.ZOrder //ExFor:Story.FirstParagraph //ExFor:Shape.FirstParagraph //ExFor:ShapeBase.WrapType //ExSummary:Creates a textbox with some text and different formatting options in a new document. // Create a blank document. Document doc = new Document(); // Create a new shape of type TextBox Shape textBox = new Shape(doc, ShapeType.TEXT_BOX); // Set some settings of the textbox itself. // Set the wrap of the textbox to inline textBox.setWrapType(WrapType.NONE); // Set the horizontal and vertical alignment of the text inside the shape. textBox.setHorizontalAlignment(HorizontalAlignment.CENTER); textBox.setVerticalAlignment(VerticalAlignment.TOP); // Set the textbox height and width. textBox.setHeight(50); textBox.setWidth(200); // Set the textbox in front of other shapes with a lower ZOrder textBox.setZOrder(2); // Let's create a new paragraph for the textbox manually and align it in the center. Make sure we add the new nodes to the textbox as well. textBox.appendChild(new Paragraph(doc)); Paragraph para = textBox.getFirstParagraph(); para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER); // Add some text to the paragraph. Run run = new Run(doc); run.setText("Content in textbox"); para.appendChild(run); // Append the textbox to the first paragraph in the body. doc.getFirstSection().getBody().getFirstParagraph().appendChild(textBox); // Save the output doc.save(getMyDir() + "Shape.CreateTextBox Out.doc"); //ExEnd
public void getStyles ( ) throws Exception { //ExStart //ExFor:DocumentBase.Styles //ExFor:Style.Name //ExId:GetStyles //ExSummary:Shows how to get access to the collection of styles defined in the document. Document doc = new Document(); StyleCollection styles = doc.getStyles(); for (Style style : styles) System.out.println(style.getName());
public void setAllStyles ( ) throws Exception { //ExStart //ExFor:Style.Font //ExFor:Style //ExSummary:Shows how to change the font formatting of all styles in a document. Document doc = new Document(); for (Style style : doc.getStyles()) {
public void changeStyleOfTOCLevel ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExId:ChangeTOCStyle //ExSummary:Changes a formatting property used in the first level TOC style. // Retrieve the style used for the first level of the TOC and change the formatting of the style. doc.getStyles().getByStyleIdentifier(StyleIdentifier.TOC_1).getFont().setBold(true); //ExEnd
public void changeTOCTabStops ( ) throws Exception { //ExStart //ExFor:TabStop //ExFor:TabStopCollection.RemoveByPosition //ExFor:Style.StyleIdentifier //ExFor:ParagraphFormat.TabStops //ExFor:TabStop.Alignment //ExFor:TabStop.Position //ExFor:TabStop.Leader //ExId:ChangeTOCTabStops //ExSummary:Shows how to modify the position of the right tab stop in TOC related paragraphs. Document doc = new Document(getMyDir() + "Document.TableOfContents.doc"); // Iterate through all paragraphs in the document for (Paragraph para : (Iterable<Paragraph>) doc.getChildNodes(NodeType.PARAGRAPH, true)) { // Check if this paragraph is formatted using the TOC result based styles. This is any style between TOC and TOC9. if (para.getParagraphFormat().getStyle().getStyleIdentifier() >= StyleIdentifier.TOC_1 && para.getParagraphFormat().getStyle().getStyleIdentifier() <= StyleIdentifier.TOC_9) { // Get the first tab used in this paragraph, this should be the tab used to align the page numbers. TabStop tab = para.getParagraphFormat().getTabStops().get(0); // Remove the old tab from the collection. para.getParagraphFormat().getTabStops().removeByPosition(tab.getPosition()); // Insert a new tab using the same properties but at a modified position. // We could also change the separators used (dots) by passing a different Leader type para.getParagraphFormat().getTabStops().add(tab.getPosition() - 50, tab.getAlignment(), tab.getLeader()); } } doc.save(getMyDir() + "Document.TableOfContentsTabStops Out.doc"); //ExEnd
public void HideControls ( ) throws Exception { //ExStart //ExFor:SwfSaveOptions.TopPaneControlFlags //ExFor:SwfTopPaneControlFlags //ExFor:SwfSaveOptions.ShowSearch //ExSummary:Shows how to choose which controls to display in the embedded document viewer. Document doc = new Document(getMyDir() + "Document.doc"); // Create an instance of SwfSaveOptions and set some buttons as hidden. SwfSaveOptions options = new SwfSaveOptions(); // Hide all the buttons with the exception of the page control buttons. Similar flags can be used for the left control pane as well. options.setTopPaneControlFlags(SwfTopPaneControlFlags.HIDE_ALL | SwfTopPaneControlFlags.SHOW_ACTUAL_SIZE | SwfTopPaneControlFlags.SHOW_FIT_TO_WIDTH | SwfTopPaneControlFlags.SHOW_FIT_TO_HEIGHT | SwfTopPaneControlFlags.SHOW_ZOOM_IN | SwfTopPaneControlFlags.SHOW_ZOOM_OUT); // You can also choose to show or hide the main elements of the viewer. Hide the search control. options.setShowSearch(false); //ExEnd doc.save(getMyDir() + "SwfSaveOptions.HideControls Out.swf", options); }
public void SetLogo ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Document.doc " ) ; //ExStart //ExFor:SwfSaveOptions //ExFor:SwfSaveOptions.LogoImageBytes //ExFor:SwfSaveOptions.LogoLink //ExSummary:Shows how to specify a custom logo and link it to a web address in the embedded document viewer. // Create an instance of SwfSaveOptions. SwfSaveOptions options = new SwfSaveOptions(); // Read the image from disk into byte array. FileInputStream fin = new FileInputStream(getMyDir() + "LogoSmall.png"); byte[] logoBytes = new byte[fin.available()]; fin.read(logoBytes); // Specify the logo image to use. options.setLogoImageBytes(logoBytes); // You can specify the URL of web page that should be opened when you click on the logo. options.setLogoLink("http://www.aspose.com"); //ExEnd doc.save(getMyDir() + "SwfSaveOptions.CustomLogo Out.swf", options); }
public void displayContentOfTables ( ) throws Exception { //ExStart //ExFor:Table //ExFor:Row.Cells //ExFor:Table.Rows //ExFor:Cell //ExFor:Row //ExFor:RowCollection //ExFor:CellCollection //ExFor:NodeCollection.IndexOf(Node) //ExSummary:Shows how to iterate through all tables in the document and display the content from each cell. Document doc = new Document(getMyDir() + "Table.Document.doc"); // Here we get all tables from the Document node. You can do this for any other composite node // which can contain block level nodes. For example you can retrieve tables from header or from a cell // containing another table (nested tables). NodeCollection tables = doc.getChildNodes(NodeType.TABLE, true); // Iterate through all tables in the document for (Table table : (Iterable<Table>) tables) { // Get the index of the table node as contained in the parent node of the table int tableIndex = table.getParentNode().getChildNodes().indexOf(table); System.out.println(MessageFormat.format("Start of Table {0}", tableIndex)); // Iterate through all rows in the table for (Row row : table.getRows()) { int rowIndex = table.getRows().indexOf(row); System.out.println(MessageFormat.format("\tStart of Row {0}", rowIndex)); // Iterate through all cells in the row for (Cell cell : row.getCells()) { int cellIndex = row.getCells().indexOf(cell); // Get the content of this cell String cellText = cell.toTxt().trim(); // Print the content of the cell System.out.println(MessageFormat.format("\t\tContents of Cell:{0} = \"{1}\"", cellIndex, cellText)); } //Console.WriteLine(); System.out.println(MessageFormat.format("\tEnd of Row {0}", rowIndex)); } System.out.println(MessageFormat.format("End of Table {0}", tableIndex)); System.out.println(); } //ExEnd Assert.assertTrue(tables.getCount() > 0); }
public void calculateDepthOfNestedTablesCaller ( ) throws Exception { calculateDepthOfNestedTables ( ) ; }
public void calculateDepthOfNestedTables ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Table.NestedTables.doc " ) ; int tableIndex = 0 ; for ( Table table : ( Iterable < Table > ) doc . getChildNodes ( NodeType . TABLE , true ) ) {
private static int getNestedDepthOfTable ( Table table ) throws Exception { int depth = 0 ; int type = table . getNodeType ( ) ; // The parent of the table will be a Cell, instead attempt to find a grandparent that is of type Table Node parent = table.getAncestor(type); while (parent != null) { // Every time we find a table a level up we increase the depth counter and then try to find an // ancestor of type table from the parent. depth++; parent = parent.getAncestor(type); } return depth; }
private static int getChildTableCount ( Table table ) throws Exception { int tableCount = 0 ; // Iterate through all child rows in the table for (Row row : table.getRows()) { // Iterate through all child cells in the row for (Cell Cell : row.getCells()) { // Retrieve the collection of child tables of this cell TableCollection childTables = Cell.getTables(); // If this cell has a table as a child then return true if (childTables.getCount() > 0) tableCount++; } } // No cell contains a table return tableCount; }
public void convertTextboxToTableCaller ( ) throws Exception { convertTextboxToTable ( ) ; }
public void convertTextboxToTable ( ) throws Exception { // Open the document Document doc = new Document(getMyDir() + "Shape.Textbox.doc"); // Convert all shape nodes which contain child nodes. // We convert the collection to an array as static "snapshot" because the original textboxes will be removed after conversion which will // invalidate the enumerator. Node[] nodes = doc.getChildNodes(NodeType.SHAPE, true).toArray(); for (Node node : nodes) { Shape shape = (Shape)node; if (shape.hasChildNodes()) { convertTextboxToTable(shape); } } doc.save(getMyDir() + "Table.ConvertTextboxToTable Out.html"); }
public void ensureTableMinimum ( ) throws Exception { //ExStart //ExFor:Table.EnsureMinimum //ExSummary:Shows how to ensure a table node is valid. Document doc = new Document(); // Create a new table and add it to the document. Table table = new Table(doc); doc.getFirstSection().getBody().appendChild(table); // Ensure the table is valid (has at least one row with one cell). table.ensureMinimum(); //ExEnd
public void ensureRowMinimum ( ) throws Exception { //ExStart //ExFor:Row.EnsureMinimum //ExSummary:Shows how to ensure a row node is valid. Document doc = new Document(); // Create a new table and add it to the document. Table table = new Table(doc); doc.getFirstSection().getBody().appendChild(table); // Create a new row and add it to the table. Row row = new Row(doc); table.appendChild(row); // Ensure the row is valid (has at least one cell). row.ensureMinimum(); //ExEnd
public void ensureCellMinimum ( ) throws Exception { //ExStart //ExFor:Cell.EnsureMinimum //ExSummary:Shows how to ensure a cell node is valid. Document doc = new Document(getMyDir() + "Table.Document.doc"); // Gets the first cell in the document. Cell cell = (Cell)doc.getChild(NodeType.CELL, 0, true); // Ensure the cell is valid (the last child is a paragraph). cell.ensureMinimum(); //ExEnd
public void getIndexOfTableElements ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Table.Document.doc " ) ; Table table = ( Table ) doc . getChild ( NodeType . TABLE , 0 , true ) ; //ExStart //ExFor:NodeCollection.IndexOf //ExId:IndexOfTable //ExSummary:Retrieves the index of a table in the document. NodeCollection allTables = doc.getChildNodes(NodeType.TABLE, true); int tableIndex = allTables.indexOf(table); //ExEnd Row row = table.getRows().get(2); //ExStart //ExFor:Row //ExFor:CompositeNode.IndexOf //ExId:IndexOfRow //ExSummary:Retrieves the index of a row in a table. int rowIndex = table.indexOf(row); //ExEnd Cell cell = row.getLastCell(); //ExStart //ExFor:Cell //ExFor:CompositeNode.IndexOf //ExId:IndexOfCell //ExSummary:Retrieves the index of a cell in a row. int cellIndex = row.indexOf(cell); //ExEnd Assert.assertEquals(tableIndex, 0); Assert.assertEquals(rowIndex, 2); Assert.assertEquals(cellIndex, 4); }
public void checkCellsMerged ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Table.MergedCells.doc " ) ; // Retrieve the first table in the document. Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); for (Row row : table.getRows()) { for (Cell cell : row.getCells()) { System.out.println(printCellMergeType(cell)); } } Assert.assertEquals(printCellMergeType(table.getFirstRow().getFirstCell()), "The cell at R1, C1 is horizontally merged."); //ExSkip }
public String printCellMergeType ( Cell cell ) { boolean isHorizontallyMerged = cell . getCellFormat ( ) . getHorizontalMerge ( ) ! = CellMerge . NONE ; boolean isVerticallyMerged = cell . getCellFormat ( ) . getVerticalMerge ( ) ! = CellMerge . NONE ; String cellLocation = MessageFormat . format ( " R{0}, C{1} " , cell . getParentRow ( ) . getParentTable ( ) . indexOf ( cell . getParentRow ( ) ) + 1 , cell . getParentRow ( ) . indexOf ( cell ) + 1 ) ; if ( isHorizontallyMerged & & isVerticallyMerged ) return MessageFormat . format ( " The cell at {0} is both horizontally and vertically merged " , cellLocation ) ;
public void MergeCellRange ( ) throws Exception { // Open the document Document doc = new Document(getMyDir() + "Table.Document.doc"); // Retrieve the first table in the body of the first section. Table table = doc.getFirstSection().getBody().getTables().get(0); //ExStart //ExId:MergeCellRange //ExSummary:Merges the range of cells between the two specified cells. // We want to merge the range of cells found inbetween these two cells. Cell cellStartRange = table.getRows().get(2).getCells().get(2); Cell cellEndRange = table.getRows().get(3).getCells().get(3); // Merge all the cells between the two specified cells into one. mergeCells(cellStartRange, cellEndRange); //ExEnd // Save the document. doc.save(getMyDir() + "Table.MergeCellRange Out.doc"); // Verify the cells were merged int mergedCellsCount = 0; for(Cell cell : (Iterable<Cell>) table.getChildNodes(NodeType.CELL, true)) if(cell.getCellFormat().getHorizontalMerge() != CellMerge.NONE || cell.getCellFormat().getHorizontalMerge() != CellMerge.NONE) mergedCellsCount++; Assert.assertEquals(4, mergedCellsCount); Assert.assertTrue(table.getRows().get(2).getCells().get(2).getCellFormat().getHorizontalMerge() == CellMerge.FIRST); Assert.assertTrue(table.getRows().get(2).getCells().get(2).getCellFormat().getVerticalMerge() == CellMerge.FIRST); Assert.assertTrue(table.getRows().get(3).getCells().get(3).getCellFormat().getHorizontalMerge() == CellMerge.PREVIOUS); Assert.assertTrue(table.getRows().get(3).getCells().get(3).getCellFormat().getVerticalMerge() == CellMerge.PREVIOUS); }
public static void mergeCells ( Cell startCell , Cell endCell ) { Table parentTable = startCell . getParentRow ( ) . getParentTable ( ) ; // Find the row and cell indices for the start and end cell. Point startCellPos = new Point(startCell.getParentRow().indexOf(startCell), parentTable.indexOf(startCell.getParentRow())); Point endCellPos = new Point(endCell.getParentRow().indexOf(endCell), parentTable.indexOf(endCell.getParentRow())); // Create the range of cells to be merged based off these indices. Inverse each index if the end cell if before the start cell. Rectangle mergeRange = new Rectangle(Math.min(startCellPos.x, endCellPos.x), Math.min(startCellPos.y, endCellPos.y), Math.abs(endCellPos.x - startCellPos.x) + 1, Math.abs(endCellPos.y - startCellPos.y) + 1); for (Row row : parentTable.getRows()) {
public void setTableBordersOutline ( ) throws Exception { //ExStart //ExFor:Table.Alignment //ExFor:TableAlignment //ExFor:Table.ClearBorders //ExFor:Table.SetBorder //ExFor:TextureIndex //ExFor:Table.SetShading //ExId:TableBordersOutline //ExSummary:Shows how to apply a outline border to a table. Document doc = new Document(getMyDir() + "Table.EmptyTable.doc"); Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // Align the table to the center of the page. table.setAlignment(TableAlignment.CENTER); // Clear any existing borders from the table. table.clearBorders(); // Set a green border around the table but not inside. table.setBorder(BorderType.LEFT, LineStyle.SINGLE, 1.5, Color.GREEN, true); table.setBorder(BorderType.RIGHT, LineStyle.SINGLE, 1.5, Color.GREEN, true); table.setBorder(BorderType.TOP, LineStyle.SINGLE, 1.5, Color.GREEN, true); table.setBorder(BorderType.BOTTOM, LineStyle.SINGLE, 1.5, Color.GREEN, true); // Fill the cells with a light green solid color. table.setShading(TextureIndex.TEXTURE_SOLID, Color.GREEN, Color.GREEN); doc.save(getMyDir() + "Table.SetOutlineBorders Out.doc"); //ExEnd // Verify the borders were set correctly. doc = new Document(getMyDir() + "Table.SetOutlineBorders Out.doc"); Assert.assertEquals(table.getAlignment(), TableAlignment.CENTER); Assert.assertEquals(table.getFirstRow().getRowFormat().getBorders().getTop().getColor().getRGB(), Color.GREEN.getRGB()); Assert.assertEquals(table.getFirstRow().getRowFormat().getBorders().getRight().getColor().getRGB(), Color.GREEN.getRGB()); Assert.assertEquals(table.getFirstRow().getRowFormat().getBorders().getBottom().getColor().getRGB(), Color.GREEN.getRGB()); Assert.assertEquals(table.getFirstRow().getRowFormat().getBorders().getLeft().getColor().getRGB(), Color.GREEN.getRGB()); Assert.assertNotSame(table.getFirstRow().getRowFormat().getBorders().getHorizontal().getColor().getRGB(), Color.GREEN.getRGB()); Assert.assertNotSame(table.getFirstRow().getRowFormat().getBorders().getVertical().getColor().getRGB(), Color.GREEN.getRGB()); Assert.assertEquals(table.getFirstRow().getFirstCell().getCellFormat().getShading().getForegroundPatternColor().getRGB(), Color.GREEN.getRGB()); }
public void setTableBordersAll ( ) throws Exception { //ExStart //ExFor:Table.SetBorders //ExId:TableBordersAll //ExSummary:Shows how to build a table with all borders enabled (grid). Document doc = new Document(getMyDir() + "Table.EmptyTable.doc"); Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // Clear any existing borders from the table. table.clearBorders(); // Set a green border around and inside the table. table.setBorders(LineStyle.SINGLE, 1.5, Color.GREEN); doc.save(getMyDir() + "Table.SetAllBorders Out.doc"); //ExEnd // Verify the borders were set correctly. doc = new Document(getMyDir() + "Table.SetAllBorders Out.doc"); Assert.assertEquals(table.getFirstRow().getRowFormat().getBorders().getLeft().getColor().getRGB(), Color.GREEN.getRGB()); Assert.assertEquals(table.getFirstRow().getRowFormat().getBorders().getTop().getColor().getRGB(), Color.GREEN.getRGB()); Assert.assertEquals(table.getFirstRow().getRowFormat().getBorders().getRight().getColor().getRGB(), Color.GREEN.getRGB()); Assert.assertEquals(table.getFirstRow().getRowFormat().getBorders().getBottom().getColor().getRGB(), Color.GREEN.getRGB()); Assert.assertEquals(table.getFirstRow().getRowFormat().getBorders().getHorizontal().getColor().getRGB(), Color.GREEN.getRGB()); Assert.assertEquals(table.getFirstRow().getRowFormat().getBorders().getVertical().getColor().getRGB(), Color.GREEN.getRGB()); }
public void rowFormatProperties ( ) throws Exception { //ExStart //ExFor:RowFormat //ExFor:Row.RowFormat //ExId:RowFormatProperties //ExSummary:Shows how to modify formatting of a table row. Document doc = new Document(getMyDir() + "Table.Document.doc"); Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // Retrieve the first row in the table. Row firstRow = table.getFirstRow(); // Modify some row level properties. firstRow.getRowFormat().getBorders().setLineStyle(LineStyle.NONE); firstRow.getRowFormat().setHeightRule(HeightRule.AUTO); firstRow.getRowFormat().setAllowBreakAcrossPages(true); //ExEnd doc.save(getMyDir() + "Table.RowFormat Out.doc"); doc = new Document(getMyDir() + "Table.RowFormat Out.doc"); table = (Table)doc.getChild(NodeType.TABLE, 0, true); Assert.assertEquals(table.getFirstRow().getRowFormat().getBorders().getLineStyle(), LineStyle.NONE); Assert.assertEquals(table.getFirstRow().getRowFormat().getHeightRule(), HeightRule.AUTO); Assert.assertTrue(table.getFirstRow().getRowFormat().getAllowBreakAcrossPages()); }
public void cellFormatProperties ( ) throws Exception { //ExStart //ExFor:CellFormat //ExFor:Cell.CellFormat //ExId:CellFormatProperties //ExSummary:Shows how to modify formatting of a table cell. Document doc = new Document(getMyDir() + "Table.Document.doc"); Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // Retrieve the first cell in the table. Cell firstCell = table.getFirstRow().getFirstCell(); // Modify some row level properties. firstCell.getCellFormat().setWidth(30); // in points firstCell.getCellFormat().setOrientation(TextOrientation.DOWNWARD); firstCell.getCellFormat().getShading().setForegroundPatternColor(Color.GREEN); //ExEnd doc.save(getMyDir() + "Table.CellFormat Out.doc"); doc = new Document(getMyDir() + "Table.CellFormat Out.doc"); table = (Table)doc.getChild(NodeType.TABLE, 0, true); Assert.assertEquals(table.getFirstRow().getFirstCell().getCellFormat().getWidth(), 30.0); Assert.assertEquals(table.getFirstRow().getFirstCell().getCellFormat().getOrientation(), TextOrientation.DOWNWARD); Assert.assertEquals(table.getFirstRow().getFirstCell().getCellFormat().getShading().getForegroundPatternColor(), Color.GREEN); }
public void removeBordersFromAllCells ( ) throws Exception { //ExStart //ExFor:Table //ExFor:Table.ClearBorders //ExSummary:Shows how to remove all borders from a table. Document doc = new Document(getMyDir() + "Table.Document.doc"); // Remove all borders from the first table in the document. Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // Clear the borders all cells in the table. table.clearBorders(); doc.save(getMyDir() + "Table.ClearBorders Out.doc"); //ExEnd
public void replaceTextInTable ( ) throws Exception { //ExStart //ExFor:Cell //ExFor:Range.Replace(String, String, Boolean, Boolean) //ExId:ReplaceTextTable //ExSummary:Shows how to replace all instances of string of text in a table and cell. Document doc = new Document(getMyDir() + "Table.SimpleTable.doc"); // Get the first table in the document. Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // Replace any instances of our string in the entire table. table.getRange().replace("Carrots", "Eggs", true, true); // Replace any instances of our string in the last cell of the table only. table.getLastRow().getLastCell().getRange().replace("50", "20", true, true); doc.save(getMyDir() + "Table.ReplaceCellText Out.docx"); //ExEnd Assert.assertEquals(table.getLastRow().getLastCell().toTxt().trim(), "20"); }
public void rowFormatDisableBreakAcrossPages ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Table.TableAcrossPage.doc " ) ; // Retrieve the first table in the document. Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); //ExStart //ExFor:RowFormat.AllowBreakAcrossPages //ExId:RowFormatAllowBreaks //ExSummary:Shows how to disable rows breaking across pages for every row in a table. // Disable breaking across pages for all rows in the table. for(Row row : table) row.getRowFormat().setAllowBreakAcrossPages(false); //ExEnd doc.save(getMyDir() + "Table.DisableBreakAcrossPages Out.doc"); Assert.assertFalse(table.getFirstRow().getRowFormat().getAllowBreakAcrossPages()); Assert.assertFalse(table.getLastRow().getRowFormat().getAllowBreakAcrossPages()); }
public void keepTableTogether ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Table.TableAcrossPage.doc " ) ; // Retrieve the first table in the document. Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); //ExStart //ExFor:ParagraphFormat.KeepWithNext //ExFor:Row.IsLastRow //ExFor:Paragraph.IsEndOfCell //ExFor:Cell.ParentRow //ExFor:Cell.Paragraphs //ExId:KeepTableTogether //ExSummary:Shows how to set a table to stay together on the same page. // To keep a table from breaking across a page we need to enable KeepWithNext // for every paragraph in the table except for the last paragraphs in the last // row of the table. for (Cell cell : (Iterable<Cell>) table.getChildNodes(NodeType.CELL, true)) for (Paragraph para : cell.getParagraphs()) if (!(cell.getParentRow().isLastRow() && para.isEndOfCell())) para.getParagraphFormat().setKeepWithNext(true); //ExEnd doc.save(getMyDir() + "Table.KeepTableTogether Out.doc"); // Verify the correct paragraphs were set properly. for (Paragraph para : (Iterable<Paragraph>) table.getChildNodes(NodeType.PARAGRAPH, true)) if (para.isEndOfCell() && ((Cell)para.getParentNode()).getParentRow().isLastRow())
public void nestedTablesUsingNodeConstructors ( ) throws Exception { Document doc = new Document ( ) ; // Create the outer table with three rows and four columns. Table outerTable = createTable(doc, 3, 4, "Outer Table"); // Add it to the document body. doc.getFirstSection().getBody().appendChild(outerTable); // Create another table with two rows and two columns. Table innerTable = createTable(doc, 2, 2, "Inner Table"); // Add this table to the first cell of the outer table. outerTable.getFirstRow().getFirstCell().appendChild(innerTable); doc.save(getMyDir() + "Table.CreateNestedTable Out.doc"); Assert.assertEquals(doc.getChildNodes(NodeType.TABLE, true).getCount(), 2); //ExSkip Assert.assertEquals(outerTable.getFirstRow().getFirstCell().getTables().getCount(), 1); //ExSkip Assert.assertEquals(outerTable.getChildNodes(NodeType.CELL, true).getCount(), 16); //ExSkip Assert.assertEquals(innerTable.getChildNodes(NodeType.CELL, true).getCount(), 4); //ExSkip }
private Table createTable ( Document doc , int rowCount , int cellCount , String cellText ) { Table table = new Table ( doc ) ; // Create the specified number of rows. for (int rowId = 1; rowId <= rowCount; rowId++) { Row row = new Row(doc); table.appendChild(row); // Create the specified number of cells for each row. for (int cellId = 1; cellId <= cellCount; cellId++) { Cell cell = new Cell(doc); row.appendChild(cell); // Add a blank paragraph to the cell. cell.appendChild(new Paragraph(doc)); // Add the text. cell.getFirstParagraph().appendChild(new Run(doc, cellText)); } } return table; }
public void allowAutoFitOnTable ( ) throws Exception { Document doc = new Document ( ) ; Table table = new Table ( doc ) ; table . ensureMinimum ( ) ; //ExStart //ExFor:Table.AllowAutoFit //ExId:AllowAutoFit //ExSummary:Shows how to set a table to shrink or grow each cell to accommodate its contents. table.setAllowAutoFit(true); //ExEnd
public void printTableRange ( ) throws Exception { //ExStart //ExId:PrintTableRange //ExSummary:Shows how to print the text range of a table. Document doc = new Document(getMyDir() + "Table.SimpleTable.doc"); // Get the first table in the document. Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // The range text will include control characters such as "\a" for a cell. // You can call ToTxt() on the desired node to find the plain text. // Print the plain text range of the table to the screen. System.out.println("Contents of the table: "); System.out.println(table.getRange().getText()); //ExEnd //ExStart //ExId:PrintRowAndCellRange //ExSummary:Shows how to print the text range of row and table elements. // Print the contents of the first row to the screen. System.out.println("\nContents of the row: "); System.out.println(table.getFirstRow().getRange().getText()); // Print the contents of the last cell in the table to the screen. System.out.println("\nContents of the cell: "); System.out.println(table.getLastRow().getLastCell().getRange().getText()); //ExEnd
public void getPreferredWidthTypeAndValue ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Table.Document.doc " ) ; // Find the first table in the document Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); //ExStart //ExFor:PreferredWidthType //ExFor:PreferredWidth.Type //ExFor:PreferredWidth.Value //ExId:GetPreferredWidthTypeAndValue //ExSummary:Retrieves the preferred width type of a table cell. Cell firstCell = table.getFirstRow().getFirstCell(); int type = firstCell.getCellFormat().getPreferredWidth().getType(); double value = firstCell.getCellFormat().getPreferredWidth().getValue(); //ExEnd Assert.assertEquals(type, PreferredWidthType.PERCENT); Assert.assertEquals(value, 11.16); }
public void fixDefaultTableWidthsInAW105 ( ) throws Exception { //ExStart //ExId:FixTablesDefaultFixedColumnWidth //ExSummary:Shows how to revert the default behaviour of table sizing to use column widths. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Keep a reference to the table being built. Table table = builder.startTable(); // Apply some formatting. builder.getCellFormat().setWidth(100); builder.getCellFormat().getShading().setBackgroundPatternColor(Color.RED); builder.insertCell(); // This will cause the table to be structured using column widths as in previous verisons // instead of fitted to the page width like in the newer versions. table.autoFit(AutoFitBehavior.FIXED_COLUMN_WIDTHS);
public void fixDefaultTableBordersIn105 ( ) throws Exception { //ExStart //ExId:FixTablesDefaultBorders //ExSummary:Shows how to revert the default borders on tables back to no border lines. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Keep a reference to the table being built. Table table = builder.startTable(); builder.insertCell(); // Clear all borders to match the defaults used in previous versions. table.clearBorders();
public void fixDefaultTableFormattingExceptionIn105 ( ) throws Exception { //ExStart //ExId:FixTableFormattingException //ExSummary:Shows how to avoid encountering an exception when applying table formatting. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Keep a reference to the table being built. Table table = builder.startTable(); // We must first insert a new cell which in turn inserts a row into the table. builder.insertCell(); // Once a row exists in our table we can apply table wide formatting. table.setAllowAutoFit(true);
public void fixRowFormattingNotAppliedIn105 ( ) throws Exception { //ExStart //ExId:FixRowFormattingNotApplied //ExSummary:Shows how to fix row formatting not being applied to some rows. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); builder.startTable(); // For the first row this will be set correctly. builder.getRowFormat().setHeadingFormat(true); builder.insertCell(); builder.writeln("Text"); builder.insertCell(); builder.writeln("Text"); // End the first row. builder.endRow(); // Here we would normally define some other row formatting, such as disabling the // heading format. However at the moment this will be ignored and the value from the // first row reapplied to the row. builder.insertCell(); // Instead make sure to specify the row formatting for the second row here. builder.getRowFormat().setHeadingFormat(false);
public void addClonedRowToTable ( ) throws Exception { //ExStart //ExFor:Row //ExId:AddClonedRowToTable //ExSummary:Shows how to make a clone of the last row of a table and append it to the table. Document doc = new Document(getMyDir() + "Table.SimpleTable.doc"); // Retrieve the first table in the document. Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // Clone the last row in the table. Row clonedRow = (Row)table.getLastRow().deepClone(true); // Remove all content from the cloned row's cells. This makes the row ready for // new content to be inserted into. for(Cell cell : clonedRow.getCells()) cell.removeAllChildren(); // Add the row to the end of the table. table.appendChild(clonedRow); doc.save(getMyDir() + "Table.AddCloneRowToTable Out.doc"); //ExEnd // Verify that the row was cloned and appended properly. Assert.assertEquals(table.getRows().getCount(), 5); Assert.assertEquals(table.getLastRow().toTxt().trim(), ""); Assert.assertEquals(table.getLastRow().getCells().getCount(), 2); }
public void cloneTable ( ) throws Exception { //ExStart //ExId:CloneTable //ExSummary:Shows how to make a clone of a table in the document and insert it after the original table. Document doc = new Document(getMyDir() + "Table.SimpleTable.doc"); // Retrieve the first table in the document. Table table = (Table)doc.getChild(NodeType.TABLE, 0, true); // Create a clone of the table. Table tableClone = (Table)table.deepClone(true); // Insert the cloned table into the document after the original table.getParentNode().insertAfter(tableClone, table); // Insert an empty paragraph between the two tables or else they will be combined into one // upon save. This has to do with document validation. table.getParentNode().insertAfter(new Paragraph(doc), table); doc.save(getMyDir() + "Table.CloneTableAndInsert Out.doc"); //ExEnd // Verify that the table was cloned and inserted properly. Assert.assertEquals(doc.getChildNodes(NodeType.TABLE, true).getCount(), 2); Assert.assertEquals(tableClone.getRange().getText(), table.getRange().getText()); //ExStart //ExId:CloneTableRemoveContent //ExSummary:Shows how to remove all content from the cells of a cloned table. for (Cell cell : (Iterable<Cell>) tableClone.getChildNodes(NodeType.CELL, true)) cell.removeAllChildren(); //ExEnd Assert.assertEquals(tableClone.toTxt().trim(), ""); }
public void combineTables ( ) throws Exception { //ExStart //ExFor:Table //ExFor:Cell.CellFormat //ExFor:CellFormat.Borders //ExFor:Table.Rows //ExFor:Table.FirstRow //ExFor:CellFormat.ClearFormatting //ExId:CombineTables //ExSummary:Shows how to combine the rows from two tables into one. // Load the document. Document doc = new Document(getMyDir() + "Table.Document.doc"); // Get the first and second table in the document. // The rows from the second table will be appended to the end of the first table. Table firstTable = (Table)doc.getChild(NodeType.TABLE, 0, true); Table secondTable = (Table)doc.getChild(NodeType.TABLE, 1, true); // Append all rows from the current table to the next. // Due to the design of tables even tables with different cell count and widths can be joined into one table. while (secondTable.hasChildNodes()) firstTable.getRows().add(secondTable.getFirstRow()); // Remove the empty table container. secondTable.remove(); doc.save(getMyDir() + "Table.CombineTables Out.doc"); //ExEnd Assert.assertEquals(doc.getChildNodes(NodeType.TABLE, true).getCount(), 1); Assert.assertEquals(doc.getFirstSection().getBody().getTables().get(0).getRows().getCount(), 9); Assert.assertEquals(doc.getFirstSection().getBody().getTables().get(0).getChildNodes(NodeType.CELL, true).getCount(), 42); }
public void splitTable ( ) throws Exception { //ExStart //ExId:SplitTableAtRow //ExSummary:Shows how to split a table into two tables a specific row. // Load the document. Document doc = new Document(getMyDir() + "Table.SimpleTable.doc"); // Get the first table in the document. Table firstTable = (Table)doc.getChild(NodeType.TABLE, 0, true); // We will split the table at the third row (inclusive). Row row = firstTable.getRows().get(2); // Create a new container for the split table. Table table = (Table)firstTable.deepClone(false); // Insert the container after the original. firstTable.getParentNode().insertAfter(table, firstTable); // Add a buffer paragraph to ensure the tables stay apart. firstTable.getParentNode().insertAfter(new Paragraph(doc), firstTable); Row currentRow; do { currentRow = firstTable.getLastRow(); table.prependChild(currentRow); } while (currentRow != row); doc.save(getMyDir() + "Table.SplitTable Out.doc"); //ExEnd doc = new Document(getMyDir() + "Table.SplitTable Out.doc"); // Test we are adding the rows in the correct order and the // selected row was also moved. Assert.assertEquals(table.getFirstRow(), row); Assert.assertEquals(firstTable.getRows().getCount(), 2); Assert.assertEquals(table.getRows().getCount(), 2); Assert.assertEquals(doc.getChildNodes(NodeType.TABLE, true).getCount(), 2); }
public void RemoveColumnFromTable ( ) throws Exception { //ExStart //ExId:RemoveTableColumn //ExSummary:Shows how to remove a column from a table in a document. Document doc = new Document(getMyDir() + "Table.Document.doc"); Table table = (Table)doc.getChild(NodeType.TABLE, 1, true); // Get the third column from the table and remove it. Column column = Column.fromIndex(table, 2); column.remove(); doc.save(getMyDir() + "Table.RemoveColumn Out.doc"); //ExEnd Assert.assertEquals(table.getChildNodes(NodeType.CELL, true).getCount(), 16); Assert.assertEquals(table.getRows().get(2).getCells().get(2).toTxt().trim(), "Cell 3 contents"); Assert.assertEquals(table.getLastRow().getCells().get(2).toTxt().trim(), "Cell 3 contents"); }
public void InsertNewColumnIntoTable ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Table.Document.doc " ) ; Table table = ( Table ) doc . getChild ( NodeType . TABLE , 1 , true ) ; //ExStart //ExId:InsertNewColumn //ExSummary:Shows how to insert a blank column into a table. // Get the second column in the table. Column column = Column.fromIndex(table, 1); // Create a new column to the left of this column. // This is the same as using the "Insert Column Before" command in Microsoft Word. Column newColumn = column.insertColumnBefore(); // Add some text to each of the column cells. for (Cell cell : newColumn.getCells()) cell.getFirstParagraph().appendChild(new Run(doc, "Column Text " + newColumn.indexOf(cell))); //ExEnd doc.save(getMyDir() + "Table.InsertColumn Out.doc"); Assert.assertEquals(24, table.getChildNodes(NodeType.CELL, true).getCount()); Assert.assertEquals("Column Text 0", table.getFirstRow().getCells().get(1).toTxt().trim()); Assert.assertEquals("Column Text 3", table.getLastRow().getCells().get(1).toTxt().trim()); }
public void TableColumnToTxt ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Table.Document.doc " ) ; Table table = ( Table ) doc . getChild ( NodeType . TABLE , 1 , true ) ; //ExStart //ExId:TableColumnToTxt //ExSummary:Shows how to get the plain text of a table column. // Get the first column in the table. Column column = Column.fromIndex(table, 0); // Print the plain text of the column to the screen. System.out.println(column.toTxt()); //ExEnd Assert.assertEquals(column.toTxt(), "\r\nRow 1\r\nRow 2\r\nRow 3\r\n"); }
public static Column fromIndex ( Table table , int columnIndex ) { return new Column ( table , columnIndex ) ; }
public Cell [ ] getCells ( ) { ArrayList columnCells = getColumnCells ( ) ; return ( Cell [ ] ) columnCells . toArray ( new Cell [ columnCells . size ( ) ] ) ; }
public int indexOf ( Cell cell ) { return getColumnCells ( ) . indexOf ( cell ) ; }
public Column insertColumnBefore ( ) { Cell [ ] columnCells = getCells ( ) ; if ( columnCells . length = = 0 ) throw new IllegalArgumentException ( " Column must not be empty " ) ; // Create a clone of this column. for(Cell cell : columnCells) cell.getParentRow().insertBefore(cell.deepClone(false), cell); // This is the new column. Column column = new Column(columnCells[0].getParentRow().getParentTable(), mColumnIndex); // We want to make sure that the cells are all valid to work with (have at least one paragraph). for (Cell cell : column.getCells()) cell.ensureMinimum(); // Increase the index which this column represents since there is now one extra column infront. mColumnIndex++; return column; }
public void remove ( ) { for ( Cell cell : getCells ( ) ) cell . remove ( ) ;
public String toTxt ( ) throws Exception { StringBuilder builder = new StringBuilder ( ) ; for ( Cell cell : getCells ( ) ) builder . append ( cell . toTxt ( ) ) ; return builder . toString ( ) ; }
private ArrayList getColumnCells ( ) { ArrayList columnCells = new ArrayList ( ) ; for ( Row row : mTable . getRows ( ) ) { Cell cell = row . getCells ( ) . get ( mColumnIndex ) ; if ( cell ! = null ) columnCells . add ( cell ) ; } return columnCells ; }
public void utilityClassesUseControlCharacters ( ) throws Exception { String text = " test \ r " ; //ExStart //ExFor:ControlChar //ExFor:ControlChar.Cr //ExFor:ControlChar.CrLf //ExId:UtilityClassesUseControlCharacters //ExSummary:Shows how to use control characters. // Replace "\r" control character with "\r\n" text = text.replace(ControlChar.CR, ControlChar.CR_LF); //ExEnd
public void utilityClassesConvertBetweenMeasurementUnits ( ) throws Exception { //ExStart //ExFor:ConvertUtil //ExId:UtilityClassesConvertBetweenMeasurementUnits //ExSummary:Shows how to specify page properties in inches. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); PageSetup pageSetup = builder.getPageSetup(); pageSetup.setTopMargin(ConvertUtil.inchToPoint(1.0)); pageSetup.setBottomMargin(ConvertUtil.inchToPoint(1.0)); pageSetup.setLeftMargin(ConvertUtil.inchToPoint(1.5)); pageSetup.setRightMargin(ConvertUtil.inchToPoint(1.5)); pageSetup.setHeaderDistance(ConvertUtil.inchToPoint(0.2)); pageSetup.setFooterDistance(ConvertUtil.inchToPoint(0.2)); //ExEnd
public void toTextCaller ( ) throws Exception { toText ( ) ; }
public void toText ( ) throws Exception { // Open the document we want to convert. Document doc = new Document(getMyDir() + "Visitor.ToText.doc"); // Create an object that inherits from the DocumentVisitor class. MyDocToTxtWriter myConverter = new MyDocToTxtWriter(); // This is the well known Visitor pattern. Get the model to accept a visitor. // The model will iterate through itself by calling the corresponding methods // on the visitor object (this is called visiting). // // Note that every node in the object model has the Accept method so the visiting // can be executed not only for the whole document, but for any node in the document. doc.accept(myConverter); // Once the visiting is complete, we can retrieve the result of the operation, // that in this example, has accumulated in the visitor. System.out.println(myConverter.getText()); }
public String getText ( ) throws Exception { return mBuilder . toString ( ) ; }
public int visitRun ( Run run ) throws Exception { appendText ( run . getText ( ) ) ; // Let the visitor continue visiting other nodes. return VisitorAction.CONTINUE; }
public int visitFieldStart ( FieldStart fieldStart ) throws Exception { // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows // after a field start character. We want to skip field codes and output field // result only, therefore we use a flag to suspend the output while inside a field code. // // Note this is a very simplistic implementation and will not work very well // if you have nested fields in a document. mIsSkipText = true; return VisitorAction.CONTINUE; }
public int visitFieldSeparator ( FieldSeparator fieldSeparator ) throws Exception { // Once reached a field separator node, we enable the output because we are // now entering the field result nodes. mIsSkipText = false; return VisitorAction.CONTINUE; }
public int visitFieldEnd ( FieldEnd fieldEnd ) throws Exception { // Make sure we enable the output when reached a field end because some fields // do not have field separator and do not have field result. mIsSkipText = false; return VisitorAction.CONTINUE; }
public int visitParagraphEnd ( Paragraph paragraph ) throws Exception { // When outputting to plain text we output Cr+Lf characters. appendText(ControlChar.CR_LF); return VisitorAction.CONTINUE; }
public int visitBodyStart ( Body body ) throws Exception { // We can detect beginning and end of all composite nodes such as Section, Body, // Table, Paragraph etc and provide custom handling for them. mBuilder.append("*** Body Started ***\r\n"); return VisitorAction.CONTINUE; }
public int visitBodyEnd ( Body body ) throws Exception { mBuilder . append ( " *** Body Ended *** \ r \ n " ) ; return VisitorAction . CONTINUE ; }
public int visitHeaderFooterStart ( HeaderFooter headerFooter ) throws Exception { // Returning this value from a visitor method causes visiting of this // node to stop and move on to visiting the next sibling node. // The net effect in this example is that the text of headers and footers // is not included in the resulting output. return VisitorAction.SKIP_THIS_NODE; }
private void appendText ( String text ) throws Exception { if ( ! mIsSkipText ) mBuilder . append ( text ) ;
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); gDataDir = new File(exeDir.resolve("../../Data")) + File.separator; // Call methods to test extraction of different types from the document. extractContentBetweenParagraphs(); extractContentBetweenBlockLevelNodes(); extractContentBetweenParagraphStyles(); extractContentBetweenRuns(); extractContentUsingField(); extractContentBetweenBookmark(); extractContentBetweenCommentRange(); }
public static void extractContentBetweenParagraphs ( ) throws Exception { //ExStart //ExId:ExtractBetweenNodes_BetweenParagraphs //ExSummary:Shows how to extract the content between specific paragraphs using the ExtractContent method above. // Load in the document Document doc = new Document(gDataDir + "TestFile.doc"); // Gather the nodes. The GetChild method uses 0-based index Paragraph startPara = (Paragraph)doc.getFirstSection().getChild(NodeType.PARAGRAPH, 6, true); Paragraph endPara = (Paragraph)doc.getFirstSection().getChild(NodeType.PARAGRAPH, 10, true); // Extract the content between these nodes in the document. Include these markers in the extraction. ArrayList extractedNodes = extractContent(startPara, endPara, true); // Insert the content into a new separate document and save it to disk. Document dstDoc = generateDocument(doc, extractedNodes); dstDoc.save(gDataDir + "TestFile.Paragraphs Out.doc"); //ExEnd
public static void extractContentBetweenBlockLevelNodes ( ) throws Exception { //ExStart //ExId:ExtractBetweenNodes_BetweenNodes //ExSummary:Shows how to extract the content between a paragraph and table using the ExtractContent method. // Load in the document Document doc = new Document(gDataDir + "TestFile.doc"); Paragraph startPara = (Paragraph)doc.getLastSection().getChild(NodeType.PARAGRAPH, 2, true); Table endTable = (Table)doc.getLastSection().getChild(NodeType.TABLE, 0, true); // Extract the content between these nodes in the document. Include these markers in the extraction. ArrayList extractedNodes = extractContent(startPara, endTable, true); // Lets reverse the array to make inserting the content back into the document easier. Collections.reverse(extractedNodes); while (extractedNodes.size() > 0) { // Insert the last node from the reversed list endTable.getParentNode().insertAfter((Node)extractedNodes.get(0), endTable); // Remove this node from the list after insertion. extractedNodes.remove(0); } // Save the generated document to disk. doc.save(gDataDir + "TestFile.DuplicatedContent Out.doc"); //ExEnd
public static void extractContentBetweenParagraphStyles ( ) throws Exception { //ExStart //ExId:ExtractBetweenNodes_BetweenStyles //ExSummary:Shows how to extract content between paragraphs with specific styles using the ExtractContent method. // Load in the document Document doc = new Document(gDataDir + "TestFile.doc"); // Gather a list of the paragraphs using the respective heading styles. ArrayList parasStyleHeading1 = paragraphsByStyleName(doc, "Heading 1"); ArrayList parasStyleHeading3 = paragraphsByStyleName(doc, "Heading 3"); // Use the first instance of the paragraphs with those styles. Node startPara1 = (Node)parasStyleHeading1.get(0); Node endPara1 = (Node)parasStyleHeading3.get(0); // Extract the content between these nodes in the document. Don't include these markers in the extraction. ArrayList extractedNodes = extractContent(startPara1, endPara1, false); // Insert the content into a new separate document and save it to disk. Document dstDoc = generateDocument(doc, extractedNodes); dstDoc.save(gDataDir + "TestFile.Styles Out.doc"); //ExEnd
public static void extractContentBetweenRuns ( ) throws Exception { //ExStart //ExId:ExtractBetweenNodes_BetweenRuns //ExSummary:Shows how to extract content between specific runs of the same paragraph using the ExtractContent method. // Load in the document Document doc = new Document(gDataDir + "TestFile.doc"); // Retrieve a paragraph from the first section. Paragraph para = (Paragraph)doc.getChild(NodeType.PARAGRAPH, 7, true); // Use some runs for extraction. Run startRun = para.getRuns().get(1); Run endRun = para.getRuns().get(4); // Extract the content between these nodes in the document. Include these markers in the extraction. ArrayList extractedNodes = extractContent(startRun, endRun, true); // Get the node from the list. There should only be one paragraph returned in the list. Node node = (Node)extractedNodes.get(0); // Print the text of this node to the console. System.out.println(node.toTxt()); //ExEnd
public static void extractContentUsingField ( ) throws Exception { //ExStart //ExFor:DocumentBuilder.MoveToMergeField(String, Boolean, Boolean) //ExId:ExtractBetweenNodes_UsingField //ExSummary:Shows how to extract content between a specific field and paragraph in the document using the ExtractContent method. // Load in the document Document doc = new Document(gDataDir + "TestFile.doc"); // Use a document builder to retrieve the field start of a merge field. DocumentBuilder builder = new DocumentBuilder(doc); // Pass the first boolean parameter to get the DocumentBuilder to move to the FieldStart of the field. // We could also get FieldStarts of a field using GetChildNode method as in the other examples. builder.moveToMergeField("Fullname", false, false); // The builder cursor should be positioned at the start of the field. FieldStart startField = (FieldStart)builder.getCurrentNode(); Paragraph endPara = (Paragraph)doc.getFirstSection().getChild(NodeType.PARAGRAPH, 5, true); // Extract the content between these nodes in the document. Don't include these markers in the extraction. ArrayList extractedNodes = extractContent(startField, endPara, false); // Insert the content into a new separate document and save it to disk. Document dstDoc = generateDocument(doc, extractedNodes); dstDoc.save(gDataDir + "TestFile.Fields Out.pdf"); //ExEnd
public static void extractContentBetweenBookmark ( ) throws Exception { //ExStart //ExId:ExtractBetweenNodes_BetweenBookmark //ExSummary:Shows how to extract the content referenced a bookmark using the ExtractContent method. // Load in the document Document doc = new Document(gDataDir + "TestFile.doc"); // Retrieve the bookmark from the document. Bookmark bookmark = doc.getRange().getBookmarks().get("Bookmark1"); // We use the BookmarkStart and BookmarkEnd nodes as markers. BookmarkStart bookmarkStart = bookmark.getBookmarkStart(); BookmarkEnd bookmarkEnd = bookmark.getBookmarkEnd(); // Firstly extract the content between these nodes including the bookmark. ArrayList extractedNodesInclusive = extractContent(bookmarkStart, bookmarkEnd, true); Document dstDoc = generateDocument(doc, extractedNodesInclusive); dstDoc.save(gDataDir + "TestFile.BookmarkInclusive Out.doc"); // Secondly extract the content between these nodes this time without including the bookmark. ArrayList extractedNodesExclusive = extractContent(bookmarkStart, bookmarkEnd, false); dstDoc = generateDocument(doc, extractedNodesExclusive); dstDoc.save(gDataDir + "TestFile.BookmarkExclusive Out.doc"); //ExEnd
public static void extractContentBetweenCommentRange ( ) throws Exception { //ExStart //ExId:ExtractBetweenNodes_BetweenComment //ExSummary:Shows how to extract content referenced by a comment using the ExtractContent method. // Load in the document Document doc = new Document(gDataDir + "TestFile.doc"); // This is a quick way of getting both comment nodes. // Your code should have a proper method of retrieving each corresponding start and end node. CommentRangeStart commentStart = (CommentRangeStart)doc.getChild(NodeType.COMMENT_RANGE_START, 0, true); CommentRangeEnd commentEnd = (CommentRangeEnd)doc.getChild(NodeType.COMMENT_RANGE_END, 0, true); // Firstly extract the content between these nodes including the comment as well. ArrayList extractedNodesInclusive = extractContent(commentStart, commentEnd, true); Document dstDoc = generateDocument(doc, extractedNodesInclusive); dstDoc.save(gDataDir + "TestFile.CommentInclusive Out.doc"); // Secondly extract the content between these nodes without the comment. ArrayList extractedNodesExclusive = extractContent(commentStart, commentEnd, false); dstDoc = generateDocument(doc, extractedNodesExclusive); dstDoc.save(gDataDir + "TestFile.CommentExclusive Out.doc"); //ExEnd
private static void verifyParameterNodes ( Node startNode , Node endNode ) throws Exception { // The order in which these checks are done is important. if (startNode == null) throw new IllegalArgumentException("Start node cannot be null"); if (endNode == null) throw new IllegalArgumentException("End node cannot be null"); if (!startNode.getDocument().equals(endNode.getDocument())) throw new IllegalArgumentException("Start node and end node must belong to the same document"); if (startNode.getAncestor(NodeType.BODY) == null || endNode.getAncestor(NodeType.BODY) == null) throw new IllegalArgumentException("Start node and end node must be a child or descendant of a body"); // Check the end node is after the start node in the DOM tree // First check if they are in different sections, then if they're not check their position in the body of the same section they are in. Section startSection = (Section)startNode.getAncestor(NodeType.SECTION); Section endSection = (Section)endNode.getAncestor(NodeType.SECTION); int startIndex = startSection.getParentNode().indexOf(startSection); int endIndex = endSection.getParentNode().indexOf(endSection); if (startIndex == endIndex) {
private static boolean isInline ( Node node ) throws Exception { // Test if the node is desendant of a Paragraph or Table node and also is not a paragraph or a table a paragraph inside a comment class which is decesant of a pararaph is possible. return ((node.getAncestor(NodeType.PARAGRAPH) != null || node.getAncestor(NodeType.TABLE) != null) && !(node.getNodeType() == NodeType.PARAGRAPH || node.getNodeType() == NodeType.TABLE)); }
public static Document generateDocument ( Document srcDoc , ArrayList nodes ) throws Exception { // Create a blank document. Document dstDoc = new Document(); // Remove the first paragraph from the empty document. dstDoc.getFirstSection().getBody().removeAllChildren(); // Import each node from the list into the new document. Keep the original formatting of the node. NodeImporter importer = new NodeImporter(srcDoc, dstDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING); for (Node node : (Iterable<Node>) nodes) { Node importNode = importer.importNode(node, true); dstDoc.getFirstSection().getBody().appendChild(importNode); } // Return the generated document. return dstDoc; }
public static ArrayList paragraphsByStyleName ( Document doc , String styleName ) throws Exception { // Create an array to collect paragraphs of the specified style. ArrayList paragraphsWithStyle = new ArrayList(); // Get all paragraphs from the document. NodeCollection paragraphs = doc.getChildNodes(NodeType.PARAGRAPH, true); // Look through all paragraphs to find those with the specified style. for (Paragraph paragraph : (Iterable<Paragraph>) paragraphs) { if (paragraph.getParagraphFormat().getStyle().getName().equals(styleName)) paragraphsWithStyle.add(paragraph); } return paragraphsWithStyle; }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; //ExStart //ExId:ExtractContentBasedOnStyles_Main //ExSummary:Run queries and display results. // Open the document. Document doc = new Document(dataDir + "TestFile.doc"); // Define style names as they are specified in the Word document. final String PARA_STYLE = "Heading 1"; final String RUN_STYLE = "Intense Emphasis"; // Collect paragraphs with defined styles. // Show the number of collected paragraphs and display the text of this paragraphs. ArrayList paragraphs = paragraphsByStyleName(doc, PARA_STYLE); System.out.println(java.text.MessageFormat.format("Paragraphs with \"{0}\" styles ({1}):", PARA_STYLE, paragraphs.size())); for (Paragraph paragraph : (Iterable<Paragraph>) paragraphs) System.out.print(paragraph.toTxt()); // Collect runs with defined styles. // Show the number of collected runs and display the text of this runs. ArrayList runs = runsByStyleName(doc, RUN_STYLE); System.out.println(java.text.MessageFormat.format("\nRuns with \"{0}\" styles ({1}):", RUN_STYLE, runs.size())); for (Run run : (Iterable<Run>) runs) System.out.println(run.getRange().getText());
public static ArrayList runsByStyleName ( Document doc , String styleName ) throws Exception { // Create an array to collect runs of the specified style. ArrayList runsWithStyle = new ArrayList(); // Get all runs from the document. NodeCollection runs = doc.getChildNodes(NodeType.RUN, true); // Look through all runs to find those with the specified style. for (Run run : (Iterable<Run>) runs) { if (run.getFont().getStyle().getName().equals(styleName)) runsWithStyle.add(run); } return runsWithStyle; }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; Document doc = new Document(dataDir + "TestFile.doc"); // We want the "your document" phrase to be highlighted. Pattern regex = Pattern.compile("your document", Pattern.CASE_INSENSITIVE); doc.getRange().replace(regex, new ReplaceEvaluatorFindAndHighlight(), true); // Save the output document. doc.save(dataDir + "TestFile Out.doc"); }
public int replacing ( ReplacingArgs e ) throws Exception { // This is a Run node that contains either the beginning or the complete match. Node currentNode = e.getMatchNode(); // The first (and may be the only) run can contain text before the match, // in this case it is necessary to split the run. if (e.getMatchOffset() > 0) currentNode = splitRun((Run)currentNode, e.getMatchOffset()); // This array is used to store all nodes of the match for further highlighting. ArrayList runs = new ArrayList(); // Find all runs that contain parts of the match string. int remainingLength = e.getMatch().group().length(); while ( (remainingLength > 0) && (currentNode != null) && (currentNode.getText().length() <= remainingLength)) { runs.add(currentNode); remainingLength = remainingLength - currentNode.getText().length(); // Select the next Run node. // Have to loop because there could be other nodes such as BookmarkStart etc. do { currentNode = currentNode.getNextSibling(); } while ((currentNode != null) && (currentNode.getNodeType() != NodeType.RUN)); } // Split the last run that contains the match if there is any text left. if ((currentNode != null) && (remainingLength > 0)) { splitRun((Run)currentNode, remainingLength); runs.add(currentNode); } // Now highlight all runs in the sequence. for (Run run : (Iterable<Run>) runs) run.getFont().setHighlightColor(Color.YELLOW); // Signal to the replace engine to do nothing because we have already done all what we wanted. return ReplaceAction.SKIP; }
private static Run splitRun ( Run run , int position ) throws Exception { Run afterRun = ( Run ) run . deepClone ( true ) ; afterRun . setText ( run . getText ( ) . substring ( position ) ) ; run . setText ( run . getText ( ) . substring ( ( 0 ) , ( 0 ) + ( position ) ) ) ; run . getParentNode ( ) . insertAfter ( afterRun , run ) ; return afterRun ; }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; convertImageToPdf(dataDir + "Test.jpg", dataDir + "TestJpg Out.pdf"); convertImageToPdf(dataDir + "Test.png", dataDir + "TestPng Out.pdf"); convertImageToPdf(dataDir + "Test.bmp", dataDir + "TestBmp Out.pdf"); convertImageToPdf(dataDir + "Test.gif", dataDir + "TestGif Out.pdf"); }
public static void convertImageToPdf ( String inputFileName , String outputFileName ) throws Exception { // Create Aspose.Words.Document and DocumentBuilder. // The builder makes it simple to add content to the document. Document doc = new Document(); DocumentBuilder builder = new DocumentBuilder(doc); // Load images from the disk using the approriate reader. // The file formats that can be loaded depends on the image readers available on the machine. ImageInputStream iis = ImageIO.createImageInputStream(new File(inputFileName)); ImageReader reader = ImageIO.getImageReaders(iis).next(); reader.setInput(iis, false); try { // Get the number of frames in the image. int framesCount = reader.getNumImages(true); // Loop through all frames. for (int frameIdx = 0; frameIdx < framesCount; frameIdx++) { // Insert a section break before each new page, in case of a multi-frame image. if (frameIdx != 0) builder.insertBreak(BreakType.SECTION_BREAK_NEW_PAGE); // Select active frame. BufferedImage image = reader.read(frameIdx); // We want the size of the page to be the same as the size of the image. // Convert pixels to points to size the page to the actual image size. PageSetup ps = builder.getPageSetup(); ps.setPageWidth(ConvertUtil.pixelToPoint(image.getWidth())); ps.setPageHeight(ConvertUtil.pixelToPoint(image.getHeight())); // Insert the image into the document and position it at the top left corner of the page. builder.insertImage( image, RelativeHorizontalPosition.PAGE, 0, RelativeVerticalPosition.PAGE, 0, ps.getPageWidth(), ps.getPageHeight(), WrapType.NONE); } } finally { if (iis != null) { iis.close(); reader.dispose(); } } // Save the document to PDF. doc.save(outputFileName); }
public static void main ( String [ ] args ) throws Exception { URI exeDir = Program . class . getResource ( " " ) . toURI ( ) ; String dataDir = new File ( exeDir . resolve ( " ../../Data " ) ) + File . separator ; // Load DOC with footnotes into a document object. Document srcDoc = new Document(dataDir + "FootnoteSample.doc"); // Save to HTML file. Footnotes get converted to hyperlinks. HtmlSaveOptions saveOptions = new HtmlSaveOptions(); saveOptions.setPrettyFormat(true); String htmlFile = dataDir + "FootnoteSample Out.html"; srcDoc.save(htmlFile, saveOptions); // Load HTML back into a document object. // In the current version of Aspose.Words hyperlinks do not become footnotes again, // they become just regular hyperlinks. Document dstDoc = new Document(htmlFile); // You can open this document in MS Word and see there are no footnotes, just hyperlinks. dstDoc.save(dataDir + "FootnoteSample Out1.doc"); // This is the workaround method I'm suggesting. It will recognize hyperlinks that // should become footnotes and convert them into footnotes. convertHyperlinksToFootnotes(dstDoc); // You can open this document in MS Word and see the footnotes are as expected. dstDoc.save(dataDir + "FootnoteSample Out2.doc"); }
static void convertHyperlinksToFootnotes ( Document doc ) throws Exception { // When processing HYPERLINK fields we will remove them (convert to footnotes). // Since it is not a good thing to delete nodes while iterating over a collection, // we will collect the nodes during the first pass and delete them during the second. // // These collections contain HYPERLINK field starts of footnotes and endnotes in the main document. HashMap ftnFieldStarts = new HashMap(); HashMap ednFieldStarts = new HashMap(); // These collections contain HYPERLINK field starts of footnotes and endnotes themselves. HashMap ftnRefFieldStarts = new HashMap(); HashMap ednRefFieldStarts = new HashMap(); // Collect all the nodes into arrays before we start deleting them. collectFieldStarts(doc, ftnFieldStarts, ednFieldStarts, ftnRefFieldStarts, ednRefFieldStarts); // Remove the HR shapes that separate footnotes and endnotes from the main text. removeHorizontalLine(ftnRefFieldStarts); removeHorizontalLine(ednRefFieldStarts); // Convert the HYPERLINK fields into proper footnotes and endnotes. convertFieldsToNotes(ftnFieldStarts, ftnRefFieldStarts, FootnoteType.FOOTNOTE); convertFieldsToNotes(ednFieldStarts, ednRefFieldStarts, FootnoteType.ENDNOTE); }
private static void collectFieldStarts ( Document doc , HashMap ftnFieldStarts , HashMap ednFieldStarts , HashMap ftnRefFieldStarts , HashMap ednRefFieldStarts ) throws Exception { // This regex parses the "command" which we use to determine the footnote/endnote type // and the id. Pattern pattern = Pattern.compile("HYPERLINK \\\\l \"(_ftn|_edn|_ftnref|_ednref)([0-9]+)\""); // We need to process all HYPERLINK fields. Therefore select all field starts. NodeCollection fieldStarts = doc.getChildNodes(NodeType.FIELD_START, true); for (FieldStart fieldStart : (Iterable<FieldStart>) fieldStarts) {
private static String getFieldCode ( FieldStart fieldStart ) throws Exception { StringBuilder fieldCode = new StringBuilder ( ) ; Node curNode = fieldStart . getNextSibling ( ) ; while ( curNode instanceof Run ) { fieldCode . append ( curNode . getText ( ) ) ; curNode = curNode . getNextSibling ( ) ; } return fieldCode . toString ( ) ; }
private static void convertFieldsToNotes ( HashMap noteFieldStarts , HashMap refNoteFieldStarts , int noteType ) throws Exception { for ( Map . Entry entry : ( Iterable < Map . Entry > ) noteFieldStarts . entrySet ( ) ) {
private static void convertFieldToNote ( FieldStart noteFieldStart , FieldStart refNoteFieldStart , int noteType ) throws Exception { // This is the paragraph that contains the text of the footnote. Paragraph oldNotePara = refNoteFieldStart.getParentParagraph(); // Delete the hyperlink field from the text of the footnote because we don't need it anymore. deleteField(refNoteFieldStart); // Use document builder to move to the place in the main document where the footnote // should be and insert a proper footnote. DocumentBuilder builder = new DocumentBuilder((Document)noteFieldStart.getDocument()); builder.moveTo(noteFieldStart); Footnote note = builder.insertFootnote(noteType, ""); // Move all content from the old footnote paragraphs into the new. Paragraph newNotePara = note.getFirstParagraph(); Node curNode = oldNotePara.getFirstChild(); while (curNode != null) { Node nextNode = curNode.getNextSibling(); newNotePara.appendChild(curNode); curNode = nextNode; } // Delete the old paragraph that represented the footnote. oldNotePara.remove(); // Remove the hyperlink field from the main text to the footnote. deleteField(noteFieldStart); }
private static void deleteField ( FieldStart fieldStart ) throws Exception { Node curNode = fieldStart ; while ( curNode . getNodeType ( ) ! = NodeType . FIELD_END ) { Node nextNode = curNode . getNextSibling ( ) ; curNode . remove ( ) ; curNode = nextNode ; } curNode . remove ( ) ; }
private static void removeHorizontalLine ( HashMap noteRefFieldStarts ) throws Exception { // Footnote and endnote ids start from 1. Therefore we can get the first note. FieldStart noteFieldStart = (FieldStart)noteRefFieldStarts.get(1); // This is the paragraph that contains the first footnote. Paragraph notePara = noteFieldStart.getParentParagraph(); // This is the previous paragraph that contains the HR shape. Delete the paragraph. Paragraph hrPara = (Paragraph)notePara.getPreviousSibling(); hrPara.remove(); }
private static BufferedImage getImageFromByteArray ( byte [ ] imageBytes ) throws Exception { // Microsoft Access adds a lot of junk data to the start of binary storage fields. // This means we cannot directly read the bytes into an image, we first need // to skip past until we find the start of the image. String imageString = new String(imageBytes, "ASCII"); int index = imageString.indexOf("BM"); // return Image.FromStream(new MemoryStream(imageBytes, index, imageBytes.length - index)); int length = imageBytes.length - index; byte[] destination = new byte[length]; System.arraycopy(imageBytes, index, destination, 0, length); return ImageIO.read(new ByteArrayInputStream(destination)); }
private static DataTable getEmployees ( String databaseDir ) throws Exception { // Open a database connection. Class.forName("sun.jdbc.odbc.JdbcOdbcDriver"); // Loads the driver // Open the database connection. String connString = "jdbc:odbc:DRIVER={Microsoft Access Driver (*.mdb)};" + "DBQ=" + databaseDir + "Northwind.mdb" + ";UID=Admin"; // DSN-less DB connection. java.sql.Connection conn = java.sql.DriverManager.getConnection(connString); // Create and execute a command. java.sql.Statement statement = conn.createStatement(); java.sql.ResultSet resultSet = statement.executeQuery("SELECT TOP 5 EmployeeID, LastName, FirstName, Title, Birthdate, Address, City, PhotoBLOB FROM Employees"); return new DataTable(resultSet, "Employees"); }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; // This object will help us generate the document. DocumentBuilder builder = new DocumentBuilder(); FileInputStream stream = new FileInputStream(dataDir + "LoadTxt.txt"); try { // You might need to specify a different encoding depending on your plain text files. BufferedReader reader = new BufferedReader(new InputStreamReader(stream, "UTF8")); String line = null; // Read plain text "lines" and convert them into paragraphs in the document. while ((line = reader.readLine()) != null) { builder.writeln(line); } reader.close(); } finally { if (stream != null) stream.close(); } // Save in any Aspose.Words supported format. builder.getDocument().save(dataDir + "LoadTxt Out.docx"); builder.getDocument().save(dataDir + "LoadTxt Out.html"); }
public static void main ( String [ ] args ) throws Exception { Program program = new Program ( ) ; program . execute ( ) ; }
private void execute ( ) throws Exception { URI exeDir = Program . class . getResource ( " " ) . toURI ( ) ; String dataDir = new File ( exeDir . resolve ( " ../../Data " ) ) + File . separator ; // Load the template document. Document doc = new Document(dataDir + "Template.doc"); // Setup mail merge event handler to do the custom work. doc.getMailMerge().setFieldMergingCallback(new HandleMergeField()); // This is the data for mail merge. String[] fieldNames = new String[] {"RecipientName", "SenderName", "FaxNumber", "PhoneNumber", "Subject", "Body", "Urgent", "ForReview", "PleaseComment"}; Object[] fieldValues = new Object[] {"Josh", "Jenny", "123456789", "", "Hello", "Test message 1", true, false, true}; // Execute the mail merge. doc.getMailMerge().execute(fieldNames, fieldValues); // Save the finished document. doc.save(dataDir + "Template Out.doc"); }
public void fieldMerging ( FieldMergingArgs e ) throws Exception { if ( mBuilder = = null ) mBuilder = new DocumentBuilder ( e . getDocument ( ) ) ; // We decided that we want all boolean values to be output as check box form fields. if (e.getFieldValue() instanceof Boolean) { // Move the "cursor" to the current merge field. mBuilder.moveToMergeField(e.getFieldName()); // It is nice to give names to check boxes. Lets generate a name such as MyField21 or so. String checkBoxName = java.text.MessageFormat.format("{0}{1}", e.getFieldName(), e.getRecordIndex()); // Insert a check box. mBuilder.insertCheckBox(checkBoxName, (Boolean)e.getFieldValue(), 0); // Nothing else to do for this field. return; } // Another example, we want the Subject field to come out as text input form field. if ("Subject".equals(e.getFieldName())) {
public void imageFieldMerging ( ImageFieldMergingArgs args ) throws Exception { // Do nothing. } private DocumentBuilder mBuilder; } } //ExEnd
public static void main ( String [ ] args ) throws Exception { //Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; produceMultipleDocuments(dataDir, "TestFile.doc"); }
public static void produceMultipleDocuments ( String dataDir , String srcDoc ) throws Exception { // Open the database connection. ResultSet rs = getData(dataDir, "SELECT * FROM Customers"); // Open the template document. Document doc = new Document(dataDir + srcDoc); // A record of how many documents that have been generated so far. int counter = 1; // Loop though all records in the data source. while(rs.next()) {
public static Hashtable getRowData ( ResultSet rs ) throws Exception { ResultSetMetaData metaData = rs . getMetaData ( ) ; Hashtable values = new Hashtable ( ) ; for ( int i = 1 ; i < = metaData . getColumnCount ( ) ; i + + ) { values . put ( metaData . getColumnName ( i ) , rs . getObject ( i ) ) ; } return values ; }
public static String [ ] keySetToArray ( Hashtable table ) { return ( String [ ] ) table . keySet ( ) . toArray ( new String [ table . size ( ) ] ) ; }
public static ResultSet getData ( String dataDir , String query ) throws Exception { // Load a DB driver that is used by the demos Class.forName("sun.jdbc.odbc.JdbcOdbcDriver"); // Compose connection string. String connectionString = "jdbc:odbc:DRIVER={Microsoft Access Driver (*.mdb)};" + "DBQ=" + new File(dataDir, "Customers.mdb") + ";UID=Admin"; // DSN-less DB connection. Connection connection = DriverManager.getConnection(connectionString); Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY); return statement.executeQuery(query); }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; //ExStart //ExId:MultiplePagesOnSheet_PrintAndPreview //ExSummary:The usage of the MultipagePrintDocument for printing. // Open the document. Document doc = new Document(dataDir + "TestFile.doc"); // Create a print job to print our document with. PrinterJob pj = PrinterJob.getPrinterJob(); // Initialize an attribute set with the number of pages in the document. PrintRequestAttributeSet attributes = new HashPrintRequestAttributeSet(); attributes.add(new PageRanges(1, doc.getPageCount())); // Pass the printer settings along with the other parameters to the print document. MultipagePrintDocument awPrintDoc = new MultipagePrintDocument(doc, 4, true, attributes); // Pass the document to be printed using the print job. pj.setPrintable(awPrintDoc); pj.print(); //ExEnd
private Dimension GetThumbCount ( int pagesPerSheet , PageFormat pf ) { Dimension size ; // Define the number of the columns and rows on the sheet for the Landscape-oriented paper. switch (pagesPerSheet) { case 16: size = new Dimension(4, 4); break; case 9: size = new Dimension(3, 3); break; case 8: size = new Dimension(4, 2); break; case 6: size = new Dimension(3, 2); break; case 4: size = new Dimension(2, 2); break; case 2: size = new Dimension(2, 1); break; default : size = new Dimension(1, 1); break; } // Swap the width and height if the paper is in the Portrait orientation. if ((pf.getWidth() - pf.getImageableX()) < (pf.getHeight() - pf.getImageableY())) return new Dimension((int)size.getHeight(), (int)size.getWidth()); return size; }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; // Create the dataset which will hold each DataTable used for mail merge. DataSet pizzaDs = new DataSet(); // Create a connection to the database createConnection(dataDir); // Populate each DataTable from the database. Each query which return a ResultSet object containing the data from the table. // This ResultSet is wrapped into an Aspose.Words implementation of the DataTable class and added to a DataSet. DataTable orders = new DataTable(executeQuery("SELECT * from Orders"), "Orders"); pizzaDs.getTables().add(orders); DataTable itemDetails = new DataTable(executeQuery("SELECT * from Items"), "Items"); pizzaDs.getTables().add(itemDetails); // In order for nested mail merge to work, the mail merge engine must know the relation between parent and child tables. // Add a DataRelation to specify relations between these tables. pizzaDs.getRelations().add(new DataRelation( "OrderToItemDetails", "Orders", "Items", new String[]{"OrderID"}, new String[]{"OrderID"})); // Open the template document. Document doc = new Document(dataDir + "Invoice Template.doc"); // Execute nested mail merge with regions doc.getMailMerge().executeWithRegions(pizzaDs); // Save the output to disk doc.save(dataDir + "Invoice Out.doc"); assert doc.getMailMerge().getFieldNames().length == 0 : "There was a problem with mail merge"; //ExSkip }
public static void createConnection ( String dataDir ) throws Exception { // Load a DB driver that is used by the demos Class.forName("sun.jdbc.odbc.JdbcOdbcDriver"); // The path to the database on the disk. File dataBase = new File(dataDir, "InvoiceDB.mdb"); // Compose connection string. String connectionString = "jdbc:odbc:DRIVER={Microsoft Access Driver (*.mdb)};" + "DBQ=" + dataBase + ";UID=Admin"; // Create a connection to the database. mConnection = DriverManager.getConnection(connectionString); }
protected static void cachedRowSetExample ( ) throws Exception { //ExStart //ExId:CreateCachedRowSet //ExSummary:Shows how to store the results from a database query in a CachedRowSet so the database connection can be closed. ResultSet resultSet = createStatement().executeQuery("SELECT * FROM Orders"); CachedRowSetImpl cached = new CachedRowSetImpl(); // This loads the data into a CachedResultSet. The connection can be closed after this line. cached.populate(resultSet); // Load the cached data into a new DataTable. DataTable orders = new DataTable(cached, "Orders"); //ExEnd
public static void createRelationship ( ) { DataSet dataSet = new DataSet ( ) ; DataTable orderTable = new DataTable ( null , " Orders " ) ; DataTable itemTable = new DataTable ( null , " Items " ) ; //ExStart //ExId:NestedMailMergeCreateRelationship //ExSummary:Shows how to create a simple DataRelation for use in nested mail merge. dataSet.getRelations().add(new DataRelation("OrderToItem", orderTable.getTableName(), itemTable.getTableName(), new String[] {"Order_Id"}, new String[] {"Order_Id"})); //ExEnd
public static void main ( String [ ] args ) throws Exception { // A sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; // Open the document. Document doc = new Document(dataDir + "TestFile.doc"); //ExStart //ExId:ProcessComments_Main //ExSummary: The demo-code that illustrates the methods for the comments extraction and removal. // Extract the information about the comments of all the authors. for (String comment : (Iterable<String>) extractComments(doc)) System.out.print(comment); // Remove comments by the "pm" author. removeComments(doc, "pm"); System.out.println("Comments from \"pm\" are removed!"); // Extract the information about the comments of the "ks" author. for (String comment : (Iterable<String>) extractComments(doc, "ks")) System.out.print(comment); // Remove all comments. removeComments(doc); System.out.println("All comments are removed!"); // Save the document. doc.save(dataDir + "Test File Out.doc"); //ExEnd
static ArrayList extractComments ( Document doc ) throws Exception { ArrayList collectedComments = new ArrayList ( ) ; // Collect all comments in the document NodeCollection comments = doc.getChildNodes(NodeType.COMMENT, true); // Look through all comments and gather information about them. for (Comment comment : (Iterable<Comment>) comments) { collectedComments.add(comment.getAuthor() + " " + comment.getDateTime() + " " + comment.toTxt()); } return collectedComments; }
static ArrayList extractComments ( Document doc , String authorName ) throws Exception { ArrayList collectedComments = new ArrayList ( ) ; // Collect all comments in the document NodeCollection comments = doc.getChildNodes(NodeType.COMMENT, true); // Look through all comments and gather information about those written by the authorName author. for (Comment comment : (Iterable<Comment>) comments) { if (comment.getAuthor() == authorName) collectedComments.add(comment.getAuthor() + " " + comment.getDateTime() + " " + comment.toTxt()); } return collectedComments; }
static void removeComments ( Document doc ) throws Exception { // Collect all comments in the document NodeCollection comments = doc.getChildNodes(NodeType.COMMENT, true); // Remove all comments. comments.clear(); }
static void removeComments ( Document doc , String authorName ) throws Exception { // Collect all comments in the document NodeCollection comments = doc.getChildNodes(NodeType.COMMENT, true); // Look through all comments and remove those written by the authorName author. for (int i = comments.getCount() - 1; i >= 0; i--) {
public static void main ( String [ ] args ) throws Exception { // The sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; // Open the document. Document doc = new Document(dataDir + "TestFile.doc"); // Remove the page and section breaks from the document. // In Aspose.Words section breaks are represented as separate Section nodes in the document. // To remove these separate sections the sections are combined. removePageBreaks(doc); removeSectionBreaks(doc); // Save the document. doc.save(dataDir + "TestFile Out.doc"); }
private static void removePageBreaks ( Document doc ) throws Exception { // Retrieve all paragraphs in the document. NodeCollection paragraphs = doc.getChildNodes(NodeType.PARAGRAPH, true); // Iterate through all paragraphs for (Paragraph para : (Iterable<Paragraph>) paragraphs) {
private static void removeSectionBreaks ( Document doc ) throws Exception { // Loop through all sections starting from the section that precedes the last one // and moving to the first section. for (int i = doc.getSections().getCount() - 2; i >= 0; i--) {
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; //ExStart //ExFor:MailMerge.RemoveEmptyRegions //ExId:RemoveEmptyRegions //ExSummary:Shows how to remove unmerged mail merge regions from the document. // Open the document. Document doc = new Document(dataDir + "TestFile.doc"); // Create a dummy data source containing two empty DataTables which corresponds to the regions in the document. DataSet data = new DataSet(); DataTable suppliers = new DataTable(new CachedRowSetImpl(), "Suppliers"); DataTable storeDetails = new DataTable(new CachedRowSetImpl(), "StoreDetails"); data.getTables().add(suppliers); data.getTables().add(storeDetails); // Set the RemoveEmptyRegions to true in order to remove unmerged mail merge regions from the document. doc.getMailMerge().setRemoveEmptyRegions(true); // Execute mail merge. It will have no effect as there is no data. doc.getMailMerge().executeWithRegions(data); // Save the output document to disk. doc.save(dataDir + "TestFile.RemoveEmptyRegions Out.doc"); //ExEnd
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; // Call a method to show how to convert all IF fields in a document to static text. convertFieldsInDocument(dataDir); // Reload the document and this time convert all PAGE fields only encountered in the first body of the document. convertFieldsInBody(dataDir); // Reload the document again and convert only the IF field in the last paragraph to static text. convertFieldsInParagraph(dataDir); }
public static void convertFieldsToStaticText ( CompositeNode compositeNode , int targetFieldType ) throws Exception { String originalNodeText = compositeNode . toTxt ( ) ; //ExSkip FieldsHelper helper = new FieldsHelper(targetFieldType); compositeNode.accept(helper); assert (originalNodeText.equals(compositeNode.toTxt())) : "Error: Text of the node converted differs from the original"; //ExSkip for (Node node : (Iterable<Node>)compositeNode.getChildNodes(NodeType.ANY, true)) //ExSkip assert (!(node instanceof FieldChar && ((FieldChar)node).getFieldType() == targetFieldType)) : "Error: A field node that should be removed still remains."; //ExSkip
public int visitFieldStart ( FieldStart fieldStart ) { // We must keep track of the starts and ends of fields incase of any nested fields. if (fieldStart.getFieldType() == mTargetFieldType) { mFieldDepth++; fieldStart.remove(); } else { // This removes the field start if it's inside a field that is being converted. CheckDepthAndRemoveNode(fieldStart); } return VisitorAction.CONTINUE; }
public int visitFieldSeparator ( FieldSeparator fieldSeparator ) { // When visiting a field separator we should decrease the depth level. if (fieldSeparator.getFieldType() == mTargetFieldType) { mFieldDepth--; fieldSeparator.remove(); } else { // This removes the field separator if it's inside a field that is being converted. CheckDepthAndRemoveNode(fieldSeparator); } return VisitorAction.CONTINUE; }
public int visitFieldEnd ( FieldEnd fieldEnd ) { if ( fieldEnd . getFieldType ( ) = = mTargetFieldType ) fieldEnd . remove ( ) ; else CheckDepthAndRemoveNode ( fieldEnd ) ; // This removes the field end if it's inside a field that is being converted. return VisitorAction.CONTINUE; }
public int visitRun ( Run run ) { // Remove the run if it is between the FieldStart and FieldSeparator of the field being converted. CheckDepthAndRemoveNode(run); return VisitorAction.CONTINUE; }
public int visitParagraphEnd ( Paragraph paragraph ) { if ( mFieldDepth > 0 ) { // The field code that is being converted continues onto another paragraph. We // need to copy the remaining content from this paragraph onto the next paragraph. Node nextParagraph = paragraph.getNextSibling(); // Skip ahead to the next available paragraph. while (nextParagraph != null && nextParagraph.getNodeType() != NodeType.PARAGRAPH) nextParagraph = nextParagraph.getNextSibling(); // Copy all of the nodes over. Keep a list of these nodes so we know not to remove them. while (paragraph.hasChildNodes()) { mNodesToSkip.add(paragraph.getLastChild()); ((Paragraph)nextParagraph).prependChild(paragraph.getLastChild()); } paragraph.remove(); } return VisitorAction.CONTINUE; }
public int visitTableStart ( Table table ) { CheckDepthAndRemoveNode ( table ) ; return VisitorAction . CONTINUE ; }
private void CheckDepthAndRemoveNode ( Node node ) { if ( mFieldDepth > 0 & & ! mNodesToSkip . contains ( node ) ) node . remove ( ) ;
public static void convertFieldsInDocument ( String dataDir ) throws Exception { //ExStart: //ExId:FieldsToStaticTextDocument //ExSummary:Shows how to convert all fields of a specified type in a document to static text. Document doc = new Document(dataDir + "TestFile.doc"); // Pass the appropriate parameters to convert all IF fields encountered in the document (including headers and footers) to static text. FieldsHelper.convertFieldsToStaticText(doc, FieldType.FIELD_IF); // Save the document with fields transformed to disk. doc.save(dataDir + "TestFileDocument Out.doc"); //ExEnd
public static void convertFieldsInBody ( String dataDir ) throws Exception { //ExStart: //ExId:FieldsToStaticTextBody //ExSummary:Shows how to convert all fields of a specified type in a body of a document to static text. Document doc = new Document(dataDir + "TestFile.doc"); // Pass the appropriate parameters to convert PAGE fields encountered to static text only in the body of the first section. FieldsHelper.convertFieldsToStaticText(doc.getFirstSection().getBody(), FieldType.FIELD_PAGE); // Save the document with fields transformed to disk. doc.save(dataDir + "TestFileBody Out.doc"); //ExEnd
public static void convertFieldsInParagraph ( String dataDir ) throws Exception { //ExStart: //ExId:FieldsToStaticTextParagraph //ExSummary:Shows how to convert all fields of a specified type in a paragraph to static text. Document doc = new Document(dataDir + "TestFile.doc"); // Pass the appropriate parameters to convert all IF fields to static text that are encountered only in the last // paragraph of the document. FieldsHelper.convertFieldsToStaticText(doc.getFirstSection().getBody().getLastParagraph(), FieldType.FIELD_IF); // Save the document with fields transformed to disk. doc.save(dataDir + "TestFileParagraph Out.doc"); //ExEnd
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; // Open the document. Document doc = new Document(dataDir + "TestFile.doc"); //ExStart //ExId:SaveAsMultipageTiff_save //ExSummary:Convert document to TIFF. // Save the document as multipage TIFF. doc.save(dataDir + "TestFile Out.tiff"); //ExEnd //ExStart //ExId:SaveAsMultipageTiff_SaveWithOptions //ExSummary:Convert to TIFF using customized options //Create an ImageSaveOptions object to pass to the Save method ImageSaveOptions options = new ImageSaveOptions(SaveFormat.TIFF); options.setPageIndex(0); options.setPageCount(2); options.setTiffCompression(TiffCompression.CCITT_4); options.setResolution(160); doc.save(dataDir + "TestFileWithOptions Out.tiff", options); //ExEnd
public void actionPerformed ( ActionEvent e ) { onOpen ( ) ; }
public void actionPerformed ( ActionEvent e ) { onSend ( ) ; }
private void closeWindow ( ) { System . exit ( 0 ) ; }
private String openDocument ( ) { // Create the file chooser and set the appropriate filters. JFileChooser mOpenDialog = new JFileChooser(); mOpenDialog.setAcceptAllFileFilterUsed(false); mOpenDialog.setFileFilter(OPEN_FILE_FILTER_DOC_FORMAT); mOpenDialog.setFileFilter(OPEN_FILE_FILTER_DOCX_FORMAT); mOpenDialog.setFileFilter(OPEN_FILE_FILTER_XML_FORMAT); mOpenDialog.setFileFilter(OPEN_FILE_FILTER_RTF_FORMAT); mOpenDialog.setFileFilter(OPEN_FILE_FILTER_ODT_FORMAT); mOpenDialog.setFileFilter(OPEN_FILE_FILTER_HTML_FORMAT); mOpenDialog.setFileFilter(OPEN_FILE_FILTER_ALL_SUPPORTED_FORMATS); // This is last so it will appear by default. mOpenDialog.setMultiSelectionEnabled(false); mOpenDialog.setFileSelectionMode(JFileChooser.FILES_ONLY); mOpenDialog.setDialogTitle("Open Document"); mOpenDialog.setCurrentDirectory(new File(mDocumentPath)); if (mOpenDialog.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
private void onSend ( ) { if ( textSmtp . getText ( ) . length ( ) = = 0 | | textEmail . getText ( ) . length ( ) = = 0 | | new String ( passwordField . getPassword ( ) ) . length ( ) = = 0 | | textRecipient . getText ( ) . length ( ) = = 0 | | textSubject . getText ( ) . length ( ) = = 0 | | formattedPortField . getText ( ) . trim ( ) . length ( ) = = 0 ) { JOptionPane . showMessageDialog ( this , " All fields are required. Please enter the appropriate information. " , APPLICATION_TITLE , JOptionPane . INFORMATION_MESSAGE ) ; return ; } // Set these as disabled during sending. disableTextFields(); labelSentMessage.setVisible(false); contentPane.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR)); buttonSend.setEnabled(false); // This is required to get the panel to refreshing the above changes before sending the message. this.update(getGraphics()); try {
private void disableTextFields ( ) { disableTextField ( textSmtp ) ; disableTextField ( textEmail ) ; disableTextField ( textRecipient ) ; disableTextField ( textSubject ) ; disableTextField ( passwordField ) ; disableTextField ( formattedPortField ) ; secureConnectionCheckBox . setEnabled ( false ) ; buttonSend . setEnabled ( false ) ; }
private void disableTextField ( JTextComponent text ) { text . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; text . setEditable ( false ) ; text . setBackground ( UIManager . getColor ( " TextField.disabled " ) ) ; }
private void enableTextFields ( ) { enableTextField ( textSmtp ) ; enableTextField ( textEmail ) ; enableTextField ( textRecipient ) ; enableTextField ( textSubject ) ; enableTextField ( passwordField ) ; enableTextField ( formattedPortField ) ; secureConnectionCheckBox . setEnabled ( true ) ; buttonSend . setEnabled ( true ) ; }
private void enableTextField ( JTextComponent text ) { text . setEditable ( true ) ; text . setBackground ( UIManager . getColor ( " TextField.background " ) ) ; }
private void createUIComponents ( ) { try { // We want our own mask formatter to match any number of numeric characters up to a length of five digits long.
public boolean accept ( File f ) { if ( f . isDirectory ( ) ) return true ; for ( String ext : mExtensions ) if ( f . getName ( ) . endsWith ( ext ) ) return true ; return false ; }
public String getDescription ( ) { return mDescription ; }
public static void main ( String [ ] args ) { Doc2Email frame = new Doc2Email ( ) ; }
public Object stringToValue ( String value ) throws ParseException { Object rv ; String mask = getMask ( ) ; if ( mask ! = null ) { setMask ( getMaskForString ( mask , value ) ) ; rv = super . stringToValue ( value . substring ( 0 , getMask ( ) . length ( ) ) ) ; setMask ( mask ) ; } else { rv = super . stringToValue ( value ) ; } return rv ; }
protected String getMaskForString ( String mask , String value ) { StringBuffer sb = new StringBuffer ( ) ; int maskLength = mask . length ( ) ; char placeHolder = getPlaceholderCharacter ( ) ; for ( int k = 0 , size = value . length ( ) ; k < size & & k < maskLength ; k + + ) { if ( placeHolder = = value . charAt ( k ) ) break ; sb . append ( mask . charAt ( k ) ) ; } return sb . toString ( ) ;
public static void main ( String [ ] args ) throws Exception { // Find out the directory where the file we want to send is stored. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; //ExStart //ExId:SaveMhtmlAndEmail //ExSummary:Shows how to save any document from Aspose.Words as MHTML and create a Outlook MSG file from it using Aspose.Network. // Load the document into Aspose.Words. String srcFileName = dataDir + "DinnerInvitationDemo.doc"; Document doc = new Document(srcFileName); // Save to an output stream in MHTML format. ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); doc.save(outputStream, SaveFormat.MHTML); // Load the MHTML stream back into an input stream for use with Aspose.Network. ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray()); // Create an Aspose.Network MIME email message from the stream. MailMessage message = MailMessage.load(inputStream, MessageFormat.getMht()); message.setFrom(new MailAddress("your_from@email.com")); message.getTo().add("your_to@email.com"); message.setSubject("Aspose.Words + Aspose.Network MHTML Test Message"); // Save the message in Outlook msg format. message.save(dataDir + "Message Out.msg", MailMessageSaveType.getOutlookMessageFormat()); //ExEnd
public static void main ( String [ ] args ) throws Exception { // You need to have a valid license for Aspose.Words. // The best way is to embed the license as a resource into the project // and specify only file name without path in the following call. // Aspose.Words.License license = new Aspose.Words.License(); // license.SetLicense(@"Aspose.Words.lic"); URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; String srcFileName = dataDir + "SOI 2007-2012-DeeM with footnote added.doc"; String tocTemplate = dataDir + "TocTemplate.doc"; File outDir = new File(dataDir, "Out"); outDir.mkdirs(); // This class does the job. Worker w = new Worker(); w.execute(srcFileName, tocTemplate, outDir.getPath()); System.out.println("Success."); }
public boolean moveNext ( ) throws Exception { if ( mIndex < mTopics . size ( ) - 1 ) {
public boolean getValue ( String fieldName , Object [ ] fieldValue ) throws Exception { if ( " TocEntry " . equals ( fieldName ) ) {
public String getTableName ( ) throws Exception { return " TOC " ; }
public IMailMergeDataSource getChildDataSource ( String tableName ) throws Exception { return null ; }
String getFileName ( ) throws Exception { return mFileName ; }
void execute ( String srcFileName , String tocTemplate , String dstDir ) throws Exception { mDoc = new Document ( srcFileName ) ; mTocTemplate = tocTemplate ; mDstDir = dstDir ; ArrayList topicStartParas = selectTopicStarts ( ) ; insertSectionBreaks ( topicStartParas ) ; ArrayList topics = saveHtmlTopics ( ) ; saveTableOfContents ( topics ) ; }
private ArrayList selectTopicStarts ( ) throws Exception { NodeCollection paras = mDoc . getChildNodes ( NodeType . PARAGRAPH , true , false ) ; ArrayList topicStartParas = new ArrayList ( ) ; for ( Paragraph para : ( Iterable < Paragraph > ) paras ) { int style = para . getParagraphFormat ( ) . getStyleIdentifier ( ) ; if ( style = = StyleIdentifier . HEADING_1 ) topicStartParas . add ( para ) ; } return topicStartParas ; }
private void insertSectionBreaks ( ArrayList topicStartParas ) throws Exception { DocumentBuilder builder = new DocumentBuilder ( mDoc ) ; for ( Paragraph para : ( Iterable < Paragraph > ) topicStartParas ) {
private ArrayList saveHtmlTopics ( ) throws Exception { ArrayList topics = new ArrayList ( ) ; for ( int sectionIdx = 0 ; sectionIdx < mDoc . getSections ( ) . getCount ( ) ; sectionIdx + + ) { Section section = mDoc . getSections ( ) . get ( sectionIdx ) ; String paraText = section . getBody ( ) . getFirstParagraph ( ) . getText ( ) ; // The text of the heading paragaph is used to generate the HTML file name. String fileName = makeTopicFileName(paraText); if ("".equals(fileName)) fileName = "UNTITLED SECTION " + sectionIdx; fileName = new File(mDstDir, fileName + ".html").getPath(); // The text of the heading paragraph is also used to generate the title for the TOC. String title = makeTopicTitle(paraText); if ("".equals(title)) title = "UNTITLED SECTION " + sectionIdx; Topic topic = new Topic(title, fileName); topics.add(topic); saveHtmlTopic(section, topic); } return topics; }
private static String makeTopicFileName ( String paraText ) throws Exception { StringBuilder b = new StringBuilder ( ) ; for ( int i = 0 ; i < paraText . length ( ) ; i + + ) { char c = paraText . charAt ( i ) ; if ( Character . isLetterOrDigit ( c ) ) b . append ( c ) ; else if ( c = = ' ' ) b . append ( '_' ) ; } return b . toString ( ) ; }
private static String makeTopicTitle ( String paraText ) throws Exception { return paraText . substring ( ( 0 ) , ( 0 ) + ( paraText . length ( ) - 1 ) ) ; }
private static void saveHtmlTopic ( Section section , Topic topic ) throws Exception { Document dummyDoc = new Document ( ) ; dummyDoc . removeAllChildren ( ) ; dummyDoc . appendChild ( dummyDoc . importNode ( section , true , ImportFormatMode . KEEP_SOURCE_FORMATTING ) ) ; dummyDoc . getBuiltInDocumentProperties ( ) . setTitle ( topic . getTitle ( ) ) ; HtmlSaveOptions saveOptions = new HtmlSaveOptions ( ) ; saveOptions . setPrettyFormat ( true ) ; // This is to allow headings to appear to the left of main text. saveOptions.setAllowNegativeLeftIndent(true); saveOptions.setExportHeadersFootersMode(ExportHeadersFootersMode.NONE); dummyDoc.save(topic.getFileName(), saveOptions); }
private void saveTableOfContents ( ArrayList topics ) throws Exception { Document tocDoc = new Document ( mTocTemplate ) ; // We use a custom mail merge even handler defined below. tocDoc.getMailMerge().setFieldMergingCallback(new HandleTocMergeField()); // We use a custom mail merge data source based on the collection of the topics we created. tocDoc.getMailMerge().executeWithRegions(new TocMailMergeDataSource(topics)); tocDoc.save(new File(mDstDir, "contents.html").getPath()); }
public void fieldMerging ( FieldMergingArgs e ) throws Exception { if ( mBuilder = = null ) mBuilder = new DocumentBuilder ( e . getDocument ( ) ) ; // Our custom data source returns topic objects. Topic topic = (Topic)e.getFieldValue(); // We use the document builder to move to the current merge field and insert a hyperlink. mBuilder.moveToMergeField(e.getFieldName()); mBuilder.insertHyperlink(topic.getTitle(), topic.getFileName(), false); // Signal to the mail merge engine that it does not need to insert text into the field // as we've done it already. e.setText(""); }
public void imageFieldMerging ( ImageFieldMergingArgs args ) throws Exception { // Do nothing. } private DocumentBuilder mBuilder; } private Document mDoc; private String mTocTemplate; private String mDstDir; }
public static void main ( String [ ] args ) throws Exception { URI exeDir = Program . class . getResource ( " " ) . toURI ( ) ; String dataDir = new File ( exeDir . resolve ( " ../../Data " ) ) + File . separator ; // Load a document. Document doc = new Document(dataDir + "TestDefect1352.doc"); // This perform the custom task of putting the row bookmark ends into the same row with the bookmark starts. untangleRowBookmarks(doc); // Now we can easily delete rows by a bookmark without damaging any other row's bookmarks. deleteRowByBookmark(doc, "ROW2"); // This is just to check that the other bookmark was not damaged. if (doc.getRange().getBookmarks().get("ROW1").getBookmarkEnd() == null) throw new Exception("Wrong, the end of the bookmark was deleted."); // Save the finished document. doc.save(dataDir + "TestDefect1352 Out.doc"); }
private static void untangleRowBookmarks ( Document doc ) throws Exception { for ( Bookmark bookmark : doc . getRange ( ) . getBookmarks ( ) ) {
private static void deleteRowByBookmark ( Document doc , String bookmarkName ) throws Exception { // Find the bookmark in the document. Exit if cannot find it. Bookmark bookmark = doc.getRange().getBookmarks().get(bookmarkName); if (bookmark == null) return; // Get the parent row of the bookmark. Exit if the bookmark is not in a row. Row row = (Row)bookmark.getBookmarkStart().getAncestor(Row.class); if (row == null) return; // Remove the row. row.remove(); }
public String getName ( ) throws Exception { return getTextSameParent ( mFieldSeparator , mFieldEnd ) ; }
public void setName ( String value ) throws Exception { // Hyperlink display name is stored in the field result which is a Run // node between field separator and field end. Run fieldResult = (Run)mFieldSeparator.getNextSibling(); fieldResult.setText(value); // But sometimes the field result can consist of more than one run, delete these runs. removeSameParent(fieldResult.getNextSibling(), mFieldEnd); }
public String getTarget ( ) throws Exception { return mTarget ; }
public void setTarget ( String value ) throws Exception { mTarget = value ; updateFieldCode ( ) ; }
public boolean isLocal ( ) throws Exception { return mIsLocal ; }
public void setLocal ( boolean value ) throws Exception { mIsLocal = value ; updateFieldCode ( ) ; }
private static Node findNextSibling ( Node start , int nodeType ) throws Exception { for ( Node node = start ; node ! = null ; node = node . getNextSibling ( ) ) { if ( node . getNodeType ( ) = = nodeType ) return node ; } return null ; }
private static String getTextSameParent ( Node start , Node end ) throws Exception { if ( ( end ! = null ) & & ( start . getParentNode ( ) ! = end . getParentNode ( ) ) ) throw new IllegalArgumentException ( " Start and end nodes are expected to have the same parent. " ) ; StringBuilder builder = new StringBuilder ( ) ; for ( Node child = start ; child ! = end ; child = child . getNextSibling ( ) ) builder . append ( child . getText ( ) ) ; return builder . toString ( ) ; }
private static void removeSameParent ( Node start , Node end ) throws Exception { if ( ( end ! = null ) & & ( start . getParentNode ( ) ! = end . getParentNode ( ) ) ) throw new IllegalArgumentException ( " Start and end nodes are expected to have the same parent. " ) ; Node curChild = start ; while ( curChild ! = end ) {
public static void main ( String [ ] args ) throws Exception { URI exeDir = Program . class . getResource ( " " ) . toURI ( ) ; // Specifies the source directory, processes all *.doc files found in it. String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; // Specifies the destination directory where the HTML files are output. File outPath = new File(dataDir, "Out"); // Remove any existing output and recreate the Out folder. if(outPath.exists()) { for(File file : outPath.listFiles()) { file.delete(); } } outPath.mkdirs(); String outDir = outPath.getAbsolutePath(); // Specifies the part of the URLs to remove. If there are any hyperlinks that start // with the above URL, this URL is removed. This allows the document designer to include // links to the HTML API and they will be "corrected" so they work both in the online // HTML and also in the compiled CHM. String fixUrl = ""; // *** LICENSING *** // An Aspose.Words license is required to use this project fully. // Without a license Aspose.Words will work in evaluation mode and truncate documents // and output watermarks. // // You can download a free 30-day trial license from the Aspose site. The easiest way is to set the license is to // include the license in the executing directory and uncomment the following code. // // Aspose.Words.License license = new Aspose.Words.License(); // license.setLicense("Aspose.Words.lic"); System.out.println(MessageFormat.format("Extracting topics from {0}.", dataDir)); TopicCollection topics = new TopicCollection(dataDir, fixUrl); topics.addFromDir(dataDir); topics.writeHtml(outDir); topics.writeContentXml(outDir); System.out.println("Conversion completed successfully."); }
public static Pattern getHtmlTitle ( ) throws Exception { if ( gHtmlTitle = = null ) { gHtmlTitle = Pattern . compile ( HTML_TITLE_PATTERN , Pattern . CASE_INSENSITIVE ) ; } return gHtmlTitle ; }
public static Pattern getHtmlHead ( ) throws Exception { if ( gHtmlHead = = null ) { gHtmlHead = Pattern . compile ( HTML_HEAD_PATTERN , Pattern . CASE_INSENSITIVE ) ; } return gHtmlHead ; }
public static Pattern getHtmlBodyDivStart ( ) throws Exception { if ( gHtmlBodyDivStart = = null ) { gHtmlBodyDivStart = Pattern . compile ( HTML_BODY_DIV_START_PATTERN , Pattern . CASE_INSENSITIVE ) ; } return gHtmlBodyDivStart ; }
private static void throwTopicException ( String message , Section section ) throws Exception { throw new Exception ( message + " Section text: " + section . getBody ( ) . toTxt ( ) . substring ( 0 , 50 ) ) ; }
private void fixHyperlinks ( DocumentBase originalDoc , String fixUrl ) throws Exception { if ( fixUrl . endsWith ( " / " ) ) fixUrl = fixUrl . substring ( 0 , fixUrl . length ( ) - 1 ) ; NodeCollection fieldStarts = mTopicDoc . getChildNodes ( NodeType . FIELD_START , true ) ; for ( FieldStart fieldStart : ( Iterable < FieldStart > ) fieldStarts ) {
public void writeHtml ( String htmlHeader , String htmlBanner , String htmlFooter , String outDir ) throws Exception { String fileName = new File ( outDir , getFileName ( ) ) . getAbsolutePath ( ) ; HtmlSaveOptions saveOptions = new HtmlSaveOptions ( ) ; saveOptions . setPrettyFormat ( true ) ; // This is to allow headings to appear to the left of main text. saveOptions.setAllowNegativeLeftIndent(true); // Disable headers and footers. saveOptions.setExportHeadersFootersMode(ExportHeadersFootersMode.NONE); // Export the document to HTML. mTopicDoc.save(fileName, saveOptions); // We need to modify the HTML string, read HTML back. String html; FileInputStream reader = null; try{ reader = new FileInputStream(fileName); byte[] fileBytes = new byte[reader.available()]; reader.read(fileBytes); html = new String(fileBytes); } finally { if (reader != null) reader.close(); } // Builds the HTML <head> element. String header = htmlHeader.replaceFirst(RegularExpressions.getHtmlTitle().pattern(), mTitle); // Applies the new <head> element instead of the original one. html = html.replaceFirst(RegularExpressions.getHtmlHead().pattern(), header); html = html.replaceFirst(RegularExpressions.getHtmlBodyDivStart().pattern(), " id=\"nstext\""); String banner = htmlBanner.replace("###TOPIC_NAME###", mTitle); // Add the standard banner. html = html.replace("<body>", "<body>" + banner); // Add the standard footer. html = html.replace("</body>", htmlFooter + "</body>"); FileOutputStream writer = null; try{ writer = new FileOutputStream(fileName);
private static String headingToFileName ( String heading ) throws Exception { StringBuilder b = new StringBuilder ( ) ; for ( int i = 0 ; i < heading . length ( ) ; i + + ) { char c = heading . charAt ( i ) ; if ( Character . isLetterOrDigit ( c ) ) b . append ( c ) ; } return b . toString ( ) ; }
public Document getDocument ( ) throws Exception { return mTopicDoc ; }
public String getFileName ( ) throws Exception { return headingToFileName ( mTitle ) + " .html " ; }
public String getTitle ( ) throws Exception { return mTitle ; }
public int getHeadingLevel ( ) throws Exception { return mHeadingLevel ; }
public boolean isHeadingOnly ( ) throws Exception { Body body = mTopicDoc . getFirstSection ( ) . getBody ( ) ; return ( body . getFirstParagraph ( ) = = null ) ; }
public void addFromDir ( String dirName ) throws Exception { FilenameFilter fileFilter = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( " .doc " ) ; } } ; for ( File filename : new File ( dirName ) . listFiles ( fileFilter ) ) addFromFile ( filename . getAbsolutePath ( ) ) ;
public boolean accept ( File dir , String name ) { return name . endsWith ( " .doc " ) ; }
public void addFromFile ( String fileName ) throws Exception { Document doc = new Document ( fileName ) ; insertTopicSections ( doc ) ; addTopics ( doc ) ; }
public void writeHtml ( String outDir ) throws Exception { for ( Topic topic : ( Iterable < Topic > ) mTopics ) {
private static void insertTopicSections ( Document doc ) throws Exception { DocumentBuilder builder = new DocumentBuilder ( doc ) ; NodeCollection paras = doc . getChildNodes ( NodeType . PARAGRAPH , true , false ) ; ArrayList topicStartParas = new ArrayList ( ) ; for ( Paragraph para : ( Iterable < Paragraph > ) paras ) { int style = para . getParagraphFormat ( ) . getStyleIdentifier ( ) ; if ( ( style > = StyleIdentifier . HEADING_1 ) & & ( style < = MAX_TOPIC_HEADING ) & & ( para . hasChildNodes ( ) ) ) { // Select heading paragraphs that must become topic starts. // We can't modify them in this loop, we have to remember them in an array first. topicStartParas.add(para); } else if ((style > MAX_TOPIC_HEADING) && (style <= StyleIdentifier.HEADING_9)) { // Pull up headings. For example: if Heading 1-4 become topics, then I want Headings 5+ // to become Headings 4+. Maybe I want to pull up even higher? para.getParagraphFormat().setStyleIdentifier((/*StyleIdentifier*/int)((int)style - 1)); } } for (Paragraph para : (Iterable<Paragraph>) topicStartParas) {
private void addTopics ( Document doc ) throws Exception { for ( Section section : doc . getSections ( ) ) {
private static Element writeBookStart ( Element root , Topic topic ) throws Exception { Element book = root . getOwnerDocument ( ) . createElement ( " book " ) ; root . appendChild ( book ) ; book . setAttribute ( " name " , topic . getTitle ( ) ) ; if ( ! topic . isHeadingOnly ( ) ) book . setAttribute ( " href " , topic . getFileName ( ) ) ; return book ; }
private static void writeItem ( Element root , String name , String href ) throws Exception { Element item = root . getOwnerDocument ( ) . createElement ( " item " ) ; root . appendChild ( item ) ; item . setAttribute ( " name " , name ) ; item . setAttribute ( " href " , href ) ; }
private static String readFile ( String fileName ) throws Exception { FileInputStream reader = null ; try {
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; // Use DocumentBuilder from the javax.xml.parsers package and Document class from the org.w3c.dom package to read // the XML data file and store it in memory. DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder(); // Parse the XML data. org.w3c.dom.Document xmlData = db.parse(dataDir + "Customers.xml"); // Open a template document. Document doc = new Document(dataDir + "TestFile.doc"); // Note that this class also works with a single repeatable region (and any nested regions). // To merge multiple regions at the same time from a single XML data source, use the XmlMailMergeDataSet class. // e.g doc.getMailMerge().executeWithRegions(new XmlMailMergeDataSet(xmlData)); doc.getMailMerge().execute(new XmlMailMergeDataTable(xmlData, "customer")); // Save the output document. doc.save(dataDir + "TestFile Out.doc"); }
public IMailMergeDataSource getDataSource ( String tableName ) throws Exception { return new XmlMailMergeDataTable ( mXmlDoc , tableName ) ; }
public String getTableName ( ) { return mTableName ; }
public boolean getValue ( String fieldName , Object [ ] fieldValue ) throws Exception { // Attempt to retrieve the child node matching the field name by using XPath. Node value = (Node)retrieveExpression(fieldName).evaluate(mCurrentNode, XPathConstants.NODE); // We also look for the field name in attributes of the element node. Element nodeAsElement = (Element)mCurrentNode; if (value != null) {
public boolean moveNext ( ) { if ( ! isEof ( ) ) { // Don't move to the next node if this the first record to be merged. if (!mIsFirstRecord) { // Find the next node which is an element and matches the table name represented by this class. // This skips any text nodes and any elements which belong to a different table. do { mCurrentNode = mCurrentNode.getNextSibling(); } while ((mCurrentNode != null) && !(mCurrentNode.getNodeName().equals(mTableName) && (mCurrentNode.getNodeType() == Node.ELEMENT_NODE))); } else { mIsFirstRecord = false; } } return (!isEof()); }
public IMailMergeDataSource getChildDataSource ( String tableName ) throws Exception { return new XmlMailMergeDataTable ( mCurrentNode , tableName ) ; }
private boolean isEof ( ) { return ( mCurrentNode = = null ) ; }
private XPathExpression retrieveExpression ( String path ) throws Exception { XPathExpression expression ; if ( mExpressionSet . containsKey ( path ) ) { expression = ( XPathExpression ) mExpressionSet . get ( path ) ; } else { expression = mXPath . compile ( path ) ; mExpressionSet . put ( path , expression ) ; } return expression ; }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; //ExStart //ExId:CustomHandleRegionsMain //ExSummary:Shows how to handle unmerged regions after mail merge with user defined code. // Open the document. Document doc = new Document(dataDir + "TestFile.doc"); // Create a data source which has some data missing. // This will result in some regions that are merged and some that remain after executing mail merge. DataSet data = getDataSource(); // Make sure that we have not set the removal of any unused regions as we will handle them manually. // We achieve this by removing the RemoveUnusedRegions flag from the cleanup options by using the bitwise XOR operator. doc.getMailMerge().setCleanupOptions(doc.getMailMerge().getCleanupOptions() ^ MailMergeCleanupOptions.REMOVE_UNUSED_REGIONS); // Execute mail merge. Some regions will be merged with data, others left unmerged. doc.getMailMerge().executeWithRegions(data); // The regions which contained data now would of been merged. Any regions which had no data and were // not merged will still remain in the document. Document mergedDoc = doc.deepClone(); //ExSkip // Apply logic to each unused region left in the document using the logic set out in the handler. // The handler class must implement the IFieldMergingCallback interface. executeCustomLogicOnEmptyRegions(doc, new EmptyRegionsHandler()); // Save the output document to disk. doc.save(dataDir + "TestFile.CustomLogicEmptyRegions1 Out.doc"); //ExEnd // Reload the original merged document. doc = mergedDoc.deepClone(); // Apply different logic to unused regions this time. executeCustomLogicOnEmptyRegions(doc, new EmptyRegionsHandler_MergeTable()); doc.save(dataDir + "TestFile.CustomLogicEmptyRegions2 Out.doc"); // Reload the original merged document. doc = mergedDoc.deepClone(); //ExStart //ExId:HandleContactDetailsRegion //ExSummary:Shows how to specify only the ContactDetails region to be handled through the handler class. // Only handle the ContactDetails region in our handler. ArrayList regions = new ArrayList(); regions.add("ContactDetails"); executeCustomLogicOnEmptyRegions(doc, new EmptyRegionsHandler(), regions); //ExEnd doc.save(dataDir + "TestFile.CustomLogicEmptyRegions3 Out.doc"); }
public static void executeCustomLogicOnEmptyRegions ( Document doc , IFieldMergingCallback handler , ArrayList regionsList ) throws Exception { // Certain regions can be skipped from applying logic to by not adding the table name inside the CreateEmptyDataSource method. // Enable this cleanup option so any regions which are not handled by the user's logic are removed automatically. doc.getMailMerge().setCleanupOptions(MailMergeCleanupOptions.REMOVE_UNUSED_REGIONS); // Set the user's handler which is called for each unmerged region. doc.getMailMerge().setFieldMergingCallback(handler); // Execute mail merge using the dummy dataset. The dummy data source contains the table names of // each unmerged region in the document (excluding ones that the user may have specified to be skipped). This will allow the handler // to be called for each field in the unmerged regions. doc.getMailMerge().executeWithRegions(createDataSourceFromDocumentRegions(doc, regionsList)); }
public void fieldMerging ( FieldMergingArgs args ) throws Exception { //ExStart //ExId:ContactDetailsCodeVariation //ExSummary:Shows how to replace an unused region with a message and remove extra paragraphs. // Store the parent paragraph of the current field for easy access. Paragraph parentParagraph = args.getField().getStart().getParentParagraph(); // Define the logic to be used when the ContactDetails region is encountered. // The region is removed and replaced with a single line of text stating that there are no records. if ("ContactDetails".equals(args.getTableName())) { // Called for the first field encountered in a region. This can be used to execute logic on the first field // in the region without needing to hard code the field name. Often the base logic is applied to the first field and // different logic for other fields. The rest of the fields in the region will have a null FieldValue. if ("FirstField".equals((String)args.getFieldValue())) { // Remove the "Name:" tag from the start of the paragraph parentParagraph.getRange().replace("Name:", "", false, false); // Set the text of the first field to display a message stating that there are no records. args.setText("No records to display"); } else { // We have already inserted our message in the paragraph belonging to the first field. The other paragraphs in the region // will still remain so we want to remove these. A check is added to ensure that the paragraph has not already been removed. // which may happen if more than one field is included in a paragraph. if (parentParagraph.getParentNode() != null) parentParagraph.remove(); } } //ExEnd //ExStart //ExFor:Cell.IsFirstCell //ExId:SuppliersCodeVariation //ExSummary:Shows how to merge all the parent cells of an unused region and display a message within the table. // Replace the unused region in the table with a "no records" message and merge all cells into one. if ("Suppliers".equals(args.getTableName())) {
public void imageFieldMerging ( ImageFieldMergingArgs args ) throws Exception { // Do Nothing } } /** * Returns the data used to merge the TestFile document. * This dataset purposely contains only rows for the StoreDetails region and only a select few for the child region. */ private static DataSet getDataSource() throws Exception { // Create empty disconnected Java result sets. ResultSet storeDetailsResultSet = createCachedRowSet(new String[]{"ID", "Name", "Address", "City", "Country"}); ResultSet contactDetailsResultSet = createCachedRowSet(new String[]{"ID", "Name", "Number"}); ResultSet suppliersResultSet = createCachedRowSet(new String[] {"ID", "CompanyName", "ContactName"}); // Create new Aspose.Words DataSet and DataTable objects to be used for mail merge. DataSet data = new DataSet(); DataTable storeDetails = new DataTable(storeDetailsResultSet, "StoreDetails"); DataTable contactDetails = new DataTable(contactDetailsResultSet, "ContactDetails"); // Add the data to the tables. addRow(storeDetailsResultSet, new String[] {"0", "Hungry Coyote Import Store", "2732 Baker Blvd", "Eugene", "USA"}); addRow(storeDetailsResultSet, new String[] {"1", "Great Lakes Food Market", "City Center Plaza, 516 Main St.", "San Francisco", "USA"}); // Add data to the child table only for the first record. addRow(contactDetailsResultSet, new String[] {"0", "Thomas Hardy", "(206) 555-9857 ext 237"}); addRow(contactDetailsResultSet, new String[] {"0", "Elizabeth Brown", "(206) 555-9857 ext 764"}); // Include the tables in the DataSet. data.getTables().add(storeDetails); data.getTables().add(contactDetails); // Setup the relation between the parent table (StoreDetails) and the child table (ContactDetails). data.getRelations().add(new DataRelation( null, "StoreDetails", "ContactDetails", new String[] {"ID"}, new String[] {"ID"})); return data; } }
private static DataSet getDataSource ( ) throws Exception { // Create empty disconnected Java result sets. ResultSet storeDetailsResultSet = createCachedRowSet(new String[]{"ID", "Name", "Address", "City", "Country"}); ResultSet contactDetailsResultSet = createCachedRowSet(new String[]{"ID", "Name", "Number"}); ResultSet suppliersResultSet = createCachedRowSet(new String[] {"ID", "CompanyName", "ContactName"}); // Create new Aspose.Words DataSet and DataTable objects to be used for mail merge. DataSet data = new DataSet(); DataTable storeDetails = new DataTable(storeDetailsResultSet, "StoreDetails"); DataTable contactDetails = new DataTable(contactDetailsResultSet, "ContactDetails"); // Add the data to the tables. addRow(storeDetailsResultSet, new String[] {"0", "Hungry Coyote Import Store", "2732 Baker Blvd", "Eugene", "USA"}); addRow(storeDetailsResultSet, new String[] {"1", "Great Lakes Food Market", "City Center Plaza, 516 Main St.", "San Francisco", "USA"}); // Add data to the child table only for the first record. addRow(contactDetailsResultSet, new String[] {"0", "Thomas Hardy", "(206) 555-9857 ext 237"}); addRow(contactDetailsResultSet, new String[] {"0", "Elizabeth Brown", "(206) 555-9857 ext 764"}); // Include the tables in the DataSet. data.getTables().add(storeDetails); data.getTables().add(contactDetails); // Setup the relation between the parent table (StoreDetails) and the child table (ContactDetails). data.getRelations().add(new DataRelation( null, "StoreDetails", "ContactDetails", new String[] {"ID"}, new String[] {"ID"})); return data; }
public void doc2EpubSave ( ) throws Exception { //ExStart //ExId:Doc2EpubSave //ExSummary:Converts a document to EPUB using default save options. // Open an existing document from disk. Document doc = new Document(getMyDir() + "Document.EpubConversion.doc"); // Save the document in EPUB format. doc.save(getMyDir() + "Document.EpubConversion Out.epub"); //ExEnd
public void doc2EpubSaveWithOptions ( ) throws Exception { //ExStart //ExFor:HtmlSaveOptions //ExFor:HtmlSaveOptions.Encoding //ExFor:HtmlSaveOptions.DocumentSplitCriteria //ExFor:HtmlSaveOptions.ExportDocumentProperties //ExFor:HtmlSaveOptions.SaveFormat //ExId:Doc2EpubSaveWithOptions //ExSummary:Converts a document to EPUB with save options specified. // Open an existing document from disk. Document doc = new Document(getMyDir() + "Document.EpubConversion.doc"); // Create a new instance of HtmlSaveOptions. This object allows us to set options that control // how the output document is saved. HtmlSaveOptions saveOptions = new HtmlSaveOptions(); // Specify the desired encoding. saveOptions.setEncoding(Charset.forName("UTF-8")); // Specify at what elements to split the internal HTML at. This creates a new HTML within the EPUB // which allows you to limit the size of each HTML part. This is useful for readers which cannot read // HTML files greater than a certain size e.g 300kb. saveOptions.setDocumentSplitCriteria(DocumentSplitCriteria.HEADING_PARAGRAPH); // Specify that we want to export document properties. saveOptions.setExportDocumentProperties(true); // Specify that we want to save in EPUB format. saveOptions.setSaveFormat(SaveFormat.EPUB); // Export the document as an EPUB file. doc.save(getMyDir() + "Document.EpubConversion Out.epub", saveOptions); //ExEnd
public void executeArray ( ) throws Exception { //ExStart //ExFor:MailMerge.Execute(String[],Object[]) //ExFor:ContentDisposition //ExId:MailMergeArray //ExSummary:Performs a simple insertion of data into merge fields. // Open an existing document. Document doc = new Document(getMyDir() + "MailMerge.ExecuteArray.doc"); // Fill the fields in the document with user data. doc.getMailMerge().execute( new String[] {"FullName", "Company", "Address", "Address2", "City"}, new Object[] {"James Bond", "MI5 Headquarters", "Milbank", "", "London"}); doc.save(getMyDir() + "MailMerge.ExecuteArray Out.doc"); //ExEnd
private static com . aspose . words . DataTable getTestOrder ( int orderId ) throws Exception { java . sql . ResultSet resultSet = executeDataTable ( java . text . MessageFormat . format ( " SELECT * FROM AsposeWordOrders WHERE OrderId = {0} " , Integer . toString ( orderId ) ) ) ; return new com . aspose . words . DataTable ( resultSet , " Orders " ) ; }
private static com . aspose . words . DataTable getTestOrderDetails ( int orderId , String orderBy ) throws Exception { StringBuilder builder = new StringBuilder ( ) ; builder . append ( java . text . MessageFormat . format ( " SELECT * FROM AsposeWordOrderDetails WHERE OrderId = {0} " , Integer . toString ( orderId ) ) ) ; if ( ( orderBy ! = null ) & & ( orderBy . length ( ) > 0 ) ) { builder . append ( " ORDER BY " ) ; builder . append ( orderBy ) ; } java . sql . ResultSet resultSet = executeDataTable ( builder . toString ( ) ) ; return new com . aspose . words . DataTable ( resultSet , " OrderDetails " ) ; }
private static java . sql . ResultSet executeDataTable ( String commandText ) throws Exception { Class . forName ( " sun.jdbc.odbc.JdbcOdbcDriver " ) ; // Loads the driver // Open the database connection. String connString = "jdbc:odbc:DRIVER={Microsoft Access Driver (*.mdb)};" + "DBQ=" + getDatabaseDir() + "Northwind.mdb" + ";UID=Admin"; // From Wikipedia: The Sun driver has a known issue with character encoding and Microsoft Access databases. // Microsoft Access may use an encoding that is not correctly translated by the driver, leading to the replacement // in strings of, for example, accented characters by question marks. // // In this case I have to set CP1252 for the european characters to come through in the data values. java.util.Properties props = new java.util.Properties(); props.put("charSet", "Cp1252"); // DSN-less DB connection. java.sql.Connection conn = java.sql.DriverManager.getConnection(connString, props); // Create and execute a command. java.sql.Statement statement = conn.createStatement(); return statement.executeQuery(commandText); }
public void deleteFields ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:MailMerge.DeleteFields //ExId:MailMergeDeleteFields //ExSummary:Shows how to delete all merge fields from a document without executing mail merge. doc.getMailMerge().deleteFields(); //ExEnd
public void removeContainingFields ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:MailMerge.CleanupOptions //ExFor:MailMergeCleanupOptions //ExId:MailMergeRemoveContainingFields //ExSummary:Shows how to instruct the mail merge engine to remove any containing fields from around a merge field during mail merge. doc.getMailMerge().setCleanupOptions(MailMergeCleanupOptions.REMOVE_CONTAINING_FIELDS); //ExEnd
public void removeUnusedFields ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:MailMerge.CleanupOptions //ExFor:MailMergeCleanupOptions //ExId:MailMergeRemoveUnusedFields //ExSummary:Shows how to automatically remove unmerged merge fields during mail merge. doc.getMailMerge().setCleanupOptions(MailMergeCleanupOptions.REMOVE_UNUSED_FIELDS); //ExEnd
public void removeEmptyParagraphs ( ) throws Exception { Document doc = new Document ( ) ; //ExStart //ExFor:MailMerge.CleanupOptions //ExFor:MailMergeCleanupOptions //ExId:MailMergeRemoveEmptyParagraphs //ExSummary:Shows how to make sure empty paragraphs that result from merging fields with no data are removed from the document. doc.getMailMerge().setCleanupOptions(MailMergeCleanupOptions.REMOVE_EMPTY_PARAGRAPHS); //ExEnd
private void updateFieldCode ( String fieldName ) throws Exception { // Field code is stored in a Run node between field start and field separator. Run fieldCode = (Run)mFieldStart.getNextSibling(); Matcher matcher = G_REGEX.matcher(fieldCode.getText()); matcher.find(); String newFieldCode = java.text.MessageFormat.format(" {0}{1} ", matcher.group(1).toString(), fieldName); fieldCode.setText(newFieldCode); // But sometimes the field code can consist of more than one run, delete these runs. removeSameParent(fieldCode.getNextSibling(), mFieldSeparator); }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; //ExStart //ExFor:MailMerge.RemoveEmptyRegions //ExId:RemoveEmptyRegions //ExSummary:Shows how to remove unmerged mail merge regions from the document. // Open the document. Document doc = new Document(dataDir + "TestFile.doc"); // Create a dummy data source containing no data. DataSet data = new DataSet(); // Set the appropriate mail merge clean up options to remove any unused regions from the document. doc.getMailMerge().setCleanupOptions(MailMergeCleanupOptions.REMOVE_UNUSED_REGIONS); // Execute mail merge which will have no effect as there is no data. However the regions found in the document will be removed // automatically as they are unused. doc.getMailMerge().executeWithRegions(data); // Save the output document to disk. doc.save(dataDir + "TestFile.RemoveEmptyRegions Out.doc"); //ExEnd assert doc.getMailMerge().getFieldNames().length == 0: "Error: There are still unused regions remaining in the document"; }
public void doc2EpubSaveWithOptions ( ) throws Exception { //ExStart //ExFor:HtmlSaveOptions //ExFor:HtmlSaveOptions.#ctor //ExFor:HtmlSaveOptions.Encoding //ExFor:HtmlSaveOptions.DocumentSplitCriteria //ExFor:HtmlSaveOptions.ExportDocumentProperties //ExFor:HtmlSaveOptions.SaveFormat //ExId:Doc2EpubSaveWithOptions //ExSummary:Converts a document to EPUB with save options specified. // Open an existing document from disk. Document doc = new Document(getMyDir() + "Document.EpubConversion.doc"); // Create a new instance of HtmlSaveOptions. This object allows us to set options that control // how the output document is saved. HtmlSaveOptions saveOptions = new HtmlSaveOptions(); // Specify the desired encoding. saveOptions.setEncoding(Charset.forName("UTF-8")); // Specify at what elements to split the internal HTML at. This creates a new HTML within the EPUB // which allows you to limit the size of each HTML part. This is useful for readers which cannot read // HTML files greater than a certain size e.g 300kb. saveOptions.setDocumentSplitCriteria(DocumentSplitCriteria.HEADING_PARAGRAPH); // Specify that we want to export document properties. saveOptions.setExportDocumentProperties(true); // Specify that we want to save in EPUB format. saveOptions.setSaveFormat(SaveFormat.EPUB); // Export the document as an EPUB file. doc.save(getMyDir() + "Document.EpubConversion Out.epub", saveOptions); //ExEnd
public void detectDocumentSignatures ( ) throws Exception { //ExStart //ExFor:FileFormatUtil.DetectFileFormat(String) //ExFor:FileFormatInfo.HasDigitalSignature //ExId:DetectDocumentSignatures //ExSummary:Shows how to check a document for digital signatures before loading it into a Document object. // The path to the document which is to be processed. String filePath = getMyDir() + "Document.Signed.docx"; FileFormatInfo info = FileFormatUtil.detectFileFormat(filePath); if (info.hasDigitalSignature()) { System.out.println(java.text.MessageFormat.format( "Document {0} has digital signatures, they will be lost if you open/save this document with Aspose.Words.", new File(filePath).getName())); } //ExEnd Document doc; }
public void validateAllDocumentSignatures ( ) throws Exception { //ExStart //ExFor:Document.DigitalSignatures //ExFor:DigitalSignatureCollection //ExFor:DigitalSignatureCollection.IsValid //ExId:ValidateAllDocumentSignatures //ExSummary:Shows how to validate all signatures in a document. // Load the signed document. Document doc = new Document(getMyDir() + "Document.Signed.docx"); if (doc.getDigitalSignatures().isValid()) System.out.println("Signatures belonging to this document are valid"); else System.out.println("Signatures belonging to this document are NOT valid"); //ExEnd Assert.assertTrue(doc.getDigitalSignatures().isValid()); }
public void validateIndividualDocumentSignatures ( ) throws Exception { //ExStart //ExFor:DigitalSignature //ExFor:Document.DigitalSignatures //ExFor:DigitalSignature.IsValid //ExFor:DigitalSignature.Comments //ExFor:DigitalSignature.SignTime //ExFor:DigitalSignature.SignatureType //ExFor:DigitalSignature.Certificate //ExId:ValidateIndividualSignatures //ExSummary:Shows how to validate each signature in a document and display basic information about the signature. // Load the document which contains signature. Document doc = new Document(getMyDir() + "Document.Signed.docx"); for (DigitalSignature signature : (Iterable<DigitalSignature>) doc.getDigitalSignatures()) { System.out.println("*** Signature Found ***"); System.out.println("Is valid: " + signature.isValid()); System.out.println("Reason for signing: " + signature.getComments()); // This property is available in MS Word documents only. System.out.println("Signature type: " + signature.getSignatureType()); System.out.println("Time of signing: " + signature.getSignTime()); System.out.println("Subject name: " + signature.getCertificate().getSubjectDN().getName()); System.out.println("Issuer name: " + signature.getCertificate().getIssuerDN().getName()); System.out.println(); } //ExEnd DigitalSignature digitalSig = doc.getDigitalSignatures().get(0); Assert.assertTrue(digitalSig.isValid()); Assert.assertEquals("Test Sign", digitalSig.getComments()); Assert.assertEquals("0", digitalSig.getSignatureType()); Assert.assertTrue(digitalSig.getCertificate().getSubjectDN().getName().contains("Aspose Pty Ltd")); Assert.assertTrue(digitalSig.getCertificate().getIssuerDN().getName().contains("VeriSign")); }
public void appendAllDocumentsInFolder ( ) throws Exception { // Delete the file that was created by the previous run as I don't want to append it again. new File(getMyDir() + "Document.AppendDocumentsFromFolder Out.doc").delete(); //ExStart //ExFor:Document.AppendDocument(Document, ImportFormatMode) //ExSummary:Shows how to use the AppendDocument method to combine all the documents in a folder to the end of a template document. // Lets start with a simple template and append all the documents in a folder to this document. Document baseDoc = new Document(); // Add some content to the template. DocumentBuilder builder = new DocumentBuilder(baseDoc); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.HEADING_1); builder.writeln("Template Document"); builder.getParagraphFormat().setStyleIdentifier(StyleIdentifier.NORMAL); builder.writeln("Some content here"); // Gather the files which will be appended to our template document. // In this case we search only for files with the ".doc" extension. File srcDir = new File(getMyDir()); File[] files = srcDir.listFiles(new FilenameFilter() { public boolean accept(File dir, String name) { return name.endsWith(".doc"); } }); // The list of files may come in any order, let's sort the files by name so the documents are enumerated alphabetically. Arrays.sort(files); // Iterate through every file in the directory and append each one to the end of the template document. for (File file : files) { String fileName = file.getCanonicalPath(); // We have some encrypted test documents in our directory, Aspose.Words can open encrypted documents // but only with the correct password. Let's just skip them here for simplicity. FileFormatInfo info = FileFormatUtil.detectFileFormat(fileName); if (info.isEncrypted()) continue; Document subDoc = new Document(fileName); baseDoc.appendDocument(subDoc, ImportFormatMode.USE_DESTINATION_STYLES); } // Save the combined document to disk. baseDoc.save(getMyDir() + "Document.AppendDocumentsFromFolder Out.doc"); //ExEnd
public void saveAsXps ( ) throws Exception { //ExStart //ExFor:XpsSaveOptions //ExFor:XpsSaveOptions.#ctor //ExFor:Document.Save(String) //ExFor:Document.Save(Stream, SaveFormat) //ExFor:Document.Save(String, SaveOptions) //ExId:SaveToXps_NewAPI //ExSummary:Shows how to save a document to the Xps format using the Save method and the XpsSaveOptions class. // Open the document Document doc = new Document(getMyDir() + "Rendering.doc"); // Save document to file in the Xps format with default options doc.save(getMyDir() + "Rendering.XpsDefaultOptions Out.xps"); // Save document to stream in the Xps format with default options ByteArrayOutputStream docStream = new ByteArrayOutputStream(); doc.save(docStream, SaveFormat.XPS); // Save document to file in the Xps format with specified options // Render the first page only XpsSaveOptions xpsOptions = new XpsSaveOptions(); xpsOptions.setPageIndex(0); xpsOptions.setPageCount(1); doc.save(getMyDir() + "Rendering.XpsCustomOptions Out.xps", xpsOptions); //ExEnd
public void saveAsImage ( ) throws Exception { //ExStart //ExFor:ImageSaveOptions.#ctor //ExFor:Document.Save(String) //ExFor:Document.Save(Stream, SaveFormat) //ExFor:Document.Save(String, SaveOptions) //ExId:SaveToImage_NewAPI //ExSummary:Shows how to save a document to the Jpeg format using the Save method and the ImageSaveOptions class. // Open the document Document doc = new Document(getMyDir() + "Rendering.doc"); // Save as a Jpeg image file with default options doc.save(getMyDir() + "Rendering.JpegDefaultOptions Out.jpg"); // Save document to an ByteArrayOutputStream as a Jpeg with default options ByteArrayOutputStream docStream = new ByteArrayOutputStream(); doc.save(docStream, SaveFormat.JPEG); // Save document to a Jpeg image with specified options. // Render the third page only and set the jpeg quality to 80% // In this case we need to pass the desired SaveFormat to the ImageSaveOptions constructor // to signal what type of image to save as. ImageSaveOptions imageOptions = new ImageSaveOptions(SaveFormat.JPEG); imageOptions.setPageIndex(2); imageOptions.setPageCount(1); imageOptions.setJpegQuality(80); doc.save(getMyDir() + "Rendering.JpegCustomOptions Out.jpg", imageOptions); //ExEnd
public void saveToTiffCompression ( ) throws Exception { //ExStart //ExFor:TiffCompression //ExFor:ImageSaveOptions.TiffCompression //ExFor:ImageSaveOptions.PageIndex //ExFor:ImageSaveOptions.PageCount //ExFor:Document.Save(String, SaveOptions) //ExSummary:Converts a page of a Word document into a TIFF image and uses the CCITT compression. Document doc = new Document(getMyDir() + "Rendering.doc"); ImageSaveOptions options = new ImageSaveOptions(SaveFormat.TIFF); options.setTiffCompression(TiffCompression.CCITT_3); options.setPageIndex(0); options.setPageCount(1); doc.save(getMyDir() + "Rendering.SaveToTiffCompression Out.tiff", options); //ExEnd
public void PrintRangeWithDocumentName ( ) throws Exception { //ExStart //ExFor:Document.Print(PrinterSettings, String) //ExSummary:Prints a range of pages along with the name of the document. Document doc = new Document(getMyDir() + "Rendering.doc"); AttributeSet printerSettings = new HashAttributeSet(); // Page numbers in printer settings are 1-based. printerSettings.add(new PageRanges(1, 3)); doc.print(printerSettings, "My Print Document.doc"); //ExEnd
public void setTrueTypeFontsFolder ( ) throws Exception { // Store the font sources currently used so we can restore them later. FontSourceBase[] fontSources = FontSettings.getFontsSources(); //ExStart //ExFor:FontSettings //ExFor:FontSettings.SetFontsFolder(String, Boolean) //ExId:SetFontsFolderCustomFolder //ExSummary:Demonstrates how to set the folder Aspose.Words uses to look for TrueType fonts during rendering or embedding of fonts. Document doc = new Document(getMyDir() + "Rendering.doc"); // Note that this setting will override any default font sources that are being searched by default. Now only these folders will be searched for // fonts when rendering or embedding fonts. To add an extra font source while keeping system font sources then use both FontSettings.GetFontSources and // FontSettings.SetFontSources instead. FontSettings.setFontsFolder("C:\\MyFonts\\", false); doc.save(getMyDir() + "Rendering.SetFontsFolder Out.pdf"); //ExEnd // Restore the original sources used to search for fonts. FontSettings.setFontsSources(fontSources); }
public void setFontsFoldersMultipleFolders ( ) throws Exception { // Store the font sources currently used so we can restore them later. FontSourceBase[] fontSources = FontSettings.getFontsSources(); //ExStart //ExFor:FontSettings //ExFor:FontSettings.SetFontsFolders(String[], Boolean) //ExId:SetFontsFoldersMultipleFolders //ExSummary:Demonstrates how to set Aspose.Words to look in multiple folders for TrueType fonts when rendering or embedding fonts. Document doc = new Document(getMyDir() + "Rendering.doc"); // Note that this setting will override any default font sources that are being searched by default. Now only these folders will be searched for // fonts when rendering or embedding fonts. To add an extra font source while keeping system font sources then use both FontSettings.GetFontSources and // FontSettings.SetFontSources instead. FontSettings.setFontsFolders(new String[] {"C:\\MyFonts\\", "D:\\Misc\\Fonts\\"}, true); doc.save(getMyDir() + "Rendering.SetFontsFolders Out.pdf"); //ExEnd // Restore the original sources used to search for fonts. FontSettings.setFontsSources(fontSources); }
public void setFontsFoldersSystemAndCustomFolder ( ) throws Exception { // Store the font sources currently used so we can restore them later. FontSourceBase[] origFontSources = FontSettings.getFontsSources(); //ExStart //ExFor:FontSettings //ExFor:FontSettings.GetFontsSources() //ExFor:FontSettings.SetFontsSources() //ExId:SetFontsFoldersSystemAndCustomFolder //ExSummary:Demonstrates how to set Aspose.Words to look for TrueType fonts in system folders as well as a custom defined folder when scanning for fonts. Document doc = new Document(getMyDir() + "Rendering.doc"); // Retrieve the array of environment-dependent font sources that are searched by default. For example this will contain a "Windows\Fonts\" source on a Windows machines. // We add this array to a new ArrayList to make adding or removing font entries much easier. ArrayList fontSources = new ArrayList(Arrays.asList(FontSettings.getFontsSources())); // Add a new folder source which will instruct Aspose.Words to search the following folder for fonts. FolderFontSource folderFontSource = new FolderFontSource("C:\\MyFonts\\", true); // Add the custom folder which contains our fonts to the list of existing font sources. fontSources.add(folderFontSource); // Convert the Arraylist of source back into a primitive array of FontSource objects. FontSourceBase[] updatedFontSources = (FontSourceBase[])fontSources.toArray(new FontSourceBase[fontSources.size()]); // Apply the new set of font sources to use. FontSettings.setFontsSources(updatedFontSources); doc.save(getMyDir() + "Rendering.SetFontsFolders Out.pdf"); //ExEnd // Verify that font sources are set correctly. Assert.assertTrue(FontSettings.getFontsSources()[0] instanceof SystemFontSource); // The first source should be a system font source. Assert.assertTrue(FontSettings.getFontsSources()[1] instanceof FolderFontSource); // The second source should be our folder font source. FolderFontSource folderSource = ((FolderFontSource)FontSettings.getFontsSources()[1]); Assert.assertEquals(folderSource.getFolderPath(), "C:\\MyFonts\\"); Assert.assertTrue(folderSource.getScanSubfolders()); // Restore the original sources used to search for fonts. FontSettings.setFontsSources(origFontSources); }
public void setDefaultFontName ( ) throws Exception { //ExStart //ExFor:FontSettings.DefaultFontName //ExId:SetDefaultFontName //ExSummary:Demonstrates how to specify what font to substitute for a missing font during rendering. Document doc = new Document(getMyDir() + "Rendering.doc"); // If the default font defined here cannot be found during rendering then the closest font on the machine is used instead. FontSettings.setDefaultFontName("Arial Unicode MS"); // Now the set default font is used in place of any missing fonts during any rendering calls. doc.save(getMyDir() + "Rendering.SetDefaultFont Out.pdf"); doc.save(getMyDir() + "Rendering.SetDefaultFont Out.xps"); //ExEnd
public void recieveFontSubstitutionNotification ( ) throws Exception { // Store the font sources currently used so we can restore them later. FontSourceBase[] origFontSources = FontSettings.getFontsSources(); //ExStart //ExFor:IWarningCallback //ExFor:SaveOptions.WarningCallback //ExId:FontSubstitutionNotification //ExSummary:Demonstrates how to recieve notifications of font substitutions by using IWarningCallback. // Load the document to render. Document doc = new Document(getMyDir() + "Document.doc"); // We can choose the default font to use in the case of any missing fonts. FontSettings.setDefaultFontName("Arial"); // For testing we will set Aspose.Words to look for fonts only in a folder which doesn't exist. Since Aspose.Words won't // find any fonts in the specified directory, then during rendering the fonts in the document will be subsuited with the default // font specified under FontSettings.DefaultFontName. We can pick up on this subsuition using our callback. FontSettings.setFontsFolder("", false); // Create a new class implementing IWarningCallback which collect any warnings produced during document save. HandleDocumentWarnings callback = new HandleDocumentWarnings(); // We assign the callback to the appropriate save options class. In this case, we are going to save to PDF // so we create a PdfSaveOptions class and assign the callback there. PdfSaveOptions saveOptions = new PdfSaveOptions(); saveOptions.setWarningCallback(callback); // Pass the save options along with the save path to the save method. doc.save(getMyDir() + "Rendering.MissingFontNotification Out.pdf", saveOptions); //ExEnd Assert.assertTrue(callback.mFontWarnings.getCount() > 0); Assert.assertTrue(callback.mFontWarnings.get(0).getWarningType() == WarningType.FONT_SUBSTITUTION); Assert.assertTrue(callback.mFontWarnings.get(0).getDescription().contains("has not been found")); // Restore default fonts. FontSettings.setFontsSources(origFontSources); }
public void warning ( WarningInfo info ) { // We are only interested in fonts being substituted. if (info.getWarningType() == WarningType.FONT_SUBSTITUTION) {
public void recieveFontSubstitutionUpdatePageLayout ( ) throws Exception { // Store the font sources currently used so we can restore them later. FontSourceBase[] origFontSources = FontSettings.getFontsSources(); // Load the document to render. Document doc = new Document(getMyDir() + "Document.doc"); // We can choose the default font to use in the case of any missing fonts. FontSettings.setDefaultFontName("Arial"); // For testing we will set Aspose.Words to look for fonts only in a folder which doesn't exist. Since Aspose.Words won't // find any fonts in the specified directory, then during rendering the fonts in the document will be subsuited with the default // font specified under FontSettings.DefaultFontName. We can pick up on this subsuition using our callback. FontSettings.setFontsFolder("", false); //ExStart //ExId:FontSubstitutionUpdatePageLayout //ExSummary:Demonstrates how IWarningCallback will still recieve warning notifcations even if UpdatePageLayout is called before document save. // When you call UpdatePageLayout the document is rendered in memory. Any warnings that occured during rendering // are stored until the document save and then sent to the appropriate WarningCallback. doc.updatePageLayout(); // Create a new class implementing IWarningCallback and assign it to the PdfSaveOptions class. HandleDocumentWarnings callback = new HandleDocumentWarnings(); PdfSaveOptions saveOptions = new PdfSaveOptions(); saveOptions.setWarningCallback(callback); // Even though the document was rendered previously, any save warnings are notified to the user during document save. doc.save(getMyDir() + "Rendering.FontsNotificationUpdatePageLayout Out.pdf", saveOptions); //ExEnd Assert.assertTrue(callback.mFontWarnings.getCount() > 0); Assert.assertTrue(callback.mFontWarnings.get(0).getWarningType() == WarningType.FONT_SUBSTITUTION); Assert.assertTrue(callback.mFontWarnings.get(0).getDescription().contains("has not been found")); // Restore default fonts. FontSettings.setFontsSources(origFontSources); }
public void embedFullFontsInPdf ( ) throws Exception { //ExStart //ExFor:PdfSaveOptions.#ctor //ExFor:PdfSaveOptions.EmbedFullFonts //ExId:EmbedFullFonts //ExSummary:Demonstrates how to set Aspose.Words to embed full fonts in the output PDF document. // Load the document to render. Document doc = new Document(getMyDir() + "Rendering.doc"); // Aspose.Words embeds full fonts by default when EmbedFullFonts is set to true. The property below can be changed // each time a document is rendered. PdfSaveOptions options = new PdfSaveOptions(); options.setEmbedFullFonts(true); // The output PDF will be embedded with all fonts found in the document. doc.save(getMyDir() + "Rendering.EmbedFullFonts Out.pdf"); //ExEnd
public void subsetFontsInPdf ( ) throws Exception { //ExStart //ExFor:PdfSaveOptions.EmbedFullFonts //ExId:Subset //ExSummary:Demonstrates how to set Aspose.Words to subset fonts in the output PDF. // Load the document to render. Document doc = new Document(getMyDir() + "Rendering.doc"); // To subset fonts in the output PDF document, simply create new PdfSaveOptions and set EmbedFullFonts to false. PdfSaveOptions options = new PdfSaveOptions(); options.setEmbedFullFonts(false); // The output PDF will contain subsets of the fonts in the document. Only the glyphs used // in the document are included in the PDF fonts. doc.save(getMyDir() + "Rendering.SubsetFonts Out.pdf"); //ExEnd
public void disableEmbeddingStandardWindowsFonts ( ) throws Exception { //ExStart //ExFor:PdfSaveOptions.EmbedStandardWindowsFonts //ExId:EmbedStandardWindowsFonts //ExSummary:Shows how to set Aspose.Words to skip embedding Arial and Times New Roman fonts into a PDF document. // Load the document to render. Document doc = new Document(getMyDir() + "Rendering.doc"); // To disable embedding standard windows font use the PdfSaveOptions and set the EmbedStandardWindowsFonts property to false. PdfSaveOptions options = new PdfSaveOptions(); options.setEmbedStandardWindowsFonts(false); // The output PDF will be saved without embedding standard windows fonts. doc.save(getMyDir() + "Rendering.DisableEmbedWindowsFonts Out.pdf"); //ExEnd
public void disableEmbeddingCoreFonts ( ) throws Exception { //ExStart //ExFor:PdfSaveOptions.UseCoreFonts //ExId:DisableUseOfCoreFonts //ExSummary:Shows how to set Aspose.Words to avoid embedding core fonts and let the reader subsuite PDF Type 1 fonts instead. // Load the document to render. Document doc = new Document(getMyDir() + "Rendering.doc"); // To disable embedding of core fonts and subsuite PDF type 1 fonts set UseCoreFonts to true. PdfSaveOptions options = new PdfSaveOptions(); options.setUseCoreFonts(true); // The output PDF will not be embedded with core fonts such as Arial, Times New Roman etc. doc.save(getMyDir() + "Rendering.DisableEmbedWindowsFonts Out.pdf"); //ExEnd
public void SetLogo ( ) throws Exception { Document doc = new Document ( getMyDir ( ) + " Document.doc " ) ; //ExStart //ExFor:SwfSaveOptions //ExFor:SwfSaveOptions.#ctor //ExFor:SwfSaveOptions.LogoImageBytes //ExFor:SwfSaveOptions.LogoLink //ExSummary:Shows how to specify a custom logo and link it to a web address in the embedded document viewer. // Create an instance of SwfSaveOptions. SwfSaveOptions options = new SwfSaveOptions(); // Read the image from disk into byte array. FileInputStream fin = new FileInputStream(getMyDir() + "LogoSmall.png"); byte[] logoBytes = new byte[fin.available()]; fin.read(logoBytes); // Specify the logo image to use. options.setLogoImageBytes(logoBytes); // You can specify the URL of web page that should be opened when you click on the logo. options.setLogoLink("http://www.aspose.com"); //ExEnd doc.save(getMyDir() + "SwfSaveOptions.CustomLogo Out.swf", options); }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; //ExStart //ExId:CustomHandleRegionsMain //ExSummary:Shows how to handle unmerged regions after mail merge with user defined code. // Open the document. Document doc = new Document(dataDir + "TestFile.doc"); // Create a data source which has some data missing. // This will result in some regions that are merged and some that remain after executing mail merge. DataSet data = getDataSource(); // Make sure that we have not set the removal of any unused regions as we will handle them manually. // We achieve this by removing the RemoveUnusedRegions flag from the cleanup options by using the AND and NOT bitwise operators. doc.getMailMerge().setCleanupOptions(doc.getMailMerge().getCleanupOptions() & ~MailMergeCleanupOptions.REMOVE_UNUSED_REGIONS); // Execute mail merge. Some regions will be merged with data, others left unmerged. doc.getMailMerge().executeWithRegions(data); // The regions which contained data now would of been merged. Any regions which had no data and were // not merged will still remain in the document. Document mergedDoc = doc.deepClone(); //ExSkip // Apply logic to each unused region left in the document using the logic set out in the handler. // The handler class must implement the IFieldMergingCallback interface. executeCustomLogicOnEmptyRegions(doc, new EmptyRegionsHandler()); // Save the output document to disk. doc.save(dataDir + "TestFile.CustomLogicEmptyRegions1 Out.doc"); //ExEnd // Reload the original merged document. doc = mergedDoc.deepClone(); // Apply different logic to unused regions this time. executeCustomLogicOnEmptyRegions(doc, new EmptyRegionsHandler_MergeTable()); doc.save(dataDir + "TestFile.CustomLogicEmptyRegions2 Out.doc"); // Reload the original merged document. doc = mergedDoc.deepClone(); //ExStart //ExId:HandleContactDetailsRegion //ExSummary:Shows how to specify only the ContactDetails region to be handled through the handler class. // Only handle the ContactDetails region in our handler. ArrayList regions = new ArrayList(); regions.add("ContactDetails"); executeCustomLogicOnEmptyRegions(doc, new EmptyRegionsHandler(), regions); //ExEnd doc.save(dataDir + "TestFile.CustomLogicEmptyRegions3 Out.doc"); }
public static void main ( String [ ] args ) throws Exception { // Sample infrastructure. URI exeDir = Program.class.getResource("").toURI(); String dataDir = new File(exeDir.resolve("../../Data")) + File.separator; // The encoding of the text file is automatically detected. Document doc = new Document(dataDir + "LoadTxt.txt"); // Save as any Aspose.Words supported format, such as DOCX. doc.save(dataDir + "LoadTxt Out.docx"); }
public Header getHeader ( ) { return header ; }
public Payload getPayload ( ) { return payload ; }
public String getSignature ( ) { return signature ; }
private void parseToken ( String token ) throws IOException { final String [ ] parts = splitToken ( token ) ; final JacksonConverter converter = new JacksonConverter ( new ObjectMapper ( ) ) ; // header = converter.parseHeader(Utils.base64Decode(parts[0])); payload = converter.parsePayload(Utils.base64Decode(parts[1])); signature = parts[2]; }
private String [ ] splitToken ( String token ) { String [ ] parts = token . split ( " \\ . " ) ; if ( parts . length ! = 3 ) { throw new JWTException ( String . format ( " The token was expected to have 3 parts, but got %s. " , parts . length ) ) ; } return parts ; }
public boolean isMissing ( ) { return true ; }
public Boolean asBoolean ( ) { throw new JWTException ( " Missing Claim " ) ; }
public Integer asInt ( ) { throw new JWTException ( " Missing Claim " ) ; }
public Double asDouble ( ) { throw new JWTException ( " Missing Claim " ) ; }
public String asString ( ) { throw new JWTException ( " Missing Claim " ) ; }
public Date asDate ( ) { throw new JWTException ( " Missing Claim " ) ; }
public < T > T [ ] asArray ( Class < T > tClazz ) throws Exception { throw new JWTException ( " Missing Claim " ) ; }
public < T > List < T > asList ( Class < T > tClazz ) throws Exception { throw new JWTException ( " Missing Claim " ) ; }
static String base64Decode ( String string ) throws JWTException { String decoded ; try { decoded = StringUtils . newStringUtf8 ( Base64 . decodeBase64 ( string ) ) ; } catch ( IllegalArgumentException e ) { throw new JWTException ( " Received bytes didn't correspond to a valid Base64 encoded string. " , e ) ; } return decoded ; }
public boolean isMissing ( ) { return false ; }
public boolean isMissing ( ) { return data . isMissingNode ( ) ; }
public boolean isNull ( ) { return data . isNull ( ) ; }
public Boolean asBoolean ( ) { return data . asBoolean ( ) ; }
public Integer asInt ( ) { return data . asInt ( ) ; }
public Double asDouble ( ) { return data . asDouble ( ) ; }
public String asString ( ) { return data . asText ( ) ; }
public Date asDate ( ) { long seconds = data . asLong ( ) ; return new Date ( seconds * 1000 ) ; }
public < T > T [ ] asArray ( Class < T > tClazz ) throws Exception { ObjectMapper mapper = new ObjectMapper ( ) ; if ( ! data . isArray ( ) ) { return ( T [ ] ) Array . newInstance ( tClazz , 0 ) ; } T [ ] arr = ( T [ ] ) Array . newInstance ( tClazz , data . size ( ) ) ; for ( int i = 0 ; i < data . size ( ) ; i + + ) { arr [ i ] = mapper . treeToValue ( data . get ( i ) , tClazz ) ; } return arr ; }
public < T > List < T > asList ( Class < T > tClazz ) throws Exception { ObjectMapper mapper = new ObjectMapper ( ) ; if ( ! data . isArray ( ) ) { return new ArrayList < > ( 0 ) ; } List < T > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < data . size ( ) ; i + + ) { list . add ( mapper . treeToValue ( data . get ( i ) , tClazz ) ) ; } return list ; }
public < T > String toJson ( T object , Class < T > tClazz ) throws IOException { return mapper . writeValueAsString ( object ) ; }
public < T > T fromJson ( String json , Class < T > tClazz ) throws IOException { return mapper . readValue ( json , tClazz ) ; }
public Payload parsePayload ( String json ) throws IOException { return mapper . readValue ( json , Payload . class ) ; }
public Header parseHeader ( String json ) throws IOException { return null ; //mapper.readValue(json, HeaderImpl.class); }
private void configureMapper ( ObjectMapper mapper ) { mapper . setSerializationInclusion ( JsonInclude . Include . NON_EMPTY ) ; SimpleModule module = new SimpleModule ( ) ; module . addDeserializer ( Payload . class , new PayloadDeserializer ( ) ) ; mapper . registerModule ( module ) ; }
public Payload deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { Map < String , JsonNode > tree = p . getCodec ( ) . readValue ( p , new TypeReference < Map < String , JsonNode > > ( ) { } ) ; if ( tree = = null ) { throw new JWTException ( " Null map " ) ; } return new PayloadImpl ( tree ) ; }
private Map < String , Claim > parsePublicClaims ( Map < String , JsonNode > tree ) { Map < String , Claim > map = new HashMap < > ( ) ; map . put ( ISSUER , extractClaim ( ISSUER , tree ) ) ; map . put ( SUBJECT , extractClaim ( SUBJECT , tree ) ) ; map . put ( EXPIRES_AT , extractClaim ( EXPIRES_AT , tree ) ) ; map . put ( NOT_BEFORE , extractClaim ( NOT_BEFORE , tree ) ) ; map . put ( ISSUED_AT , extractClaim ( ISSUED_AT , tree ) ) ; map . put ( JWT_ID , extractClaim ( JWT_ID , tree ) ) ; map . put ( AUDIENCE , extractClaim ( AUDIENCE , tree ) ) ; return map ; }
private Map < String , Claim > parseExtraClaims ( Map < String , JsonNode > tree ) { Map < String , Claim > map = new HashMap < > ( ) ; for ( Map . Entry < String , JsonNode > e : tree . entrySet ( ) ) { map . put ( e . getKey ( ) , claimFromNode ( e . getKey ( ) , e . getValue ( ) ) ) ; } return map ; }
public String getIssuer ( ) { return publicClaims . get ( ISSUER ) . asString ( ) ; }
public String getSubject ( ) { return publicClaims . get ( SUBJECT ) . asString ( ) ; }
public String [ ] getAudience ( ) { try { return publicClaims . get ( AUDIENCE ) . asArray ( String . class ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
public Date getExpiresAt ( ) { return publicClaims . get ( EXPIRES_AT ) . asDate ( ) ; }
public Date getNotBefore ( ) { return publicClaims . get ( NOT_BEFORE ) . asDate ( ) ; }
public Date getIssuedAt ( ) { return publicClaims . get ( ISSUED_AT ) . asDate ( ) ; }
public String getId ( ) { return publicClaims . get ( JWT_ID ) . asString ( ) ; }
public Claim getClaim ( @NotNull String name ) { return extraClaims . get ( name ) ; }
private Claim extractClaim ( @NotNull String claimName , @NotNull Map < String , JsonNode > tree ) { JsonNode node = tree . remove ( claimName ) ; return claimFromNode ( claimName , node ) ; }
private Claim claimFromNode ( String claimName , JsonNode node ) { if ( node = = null | | node . isMissingNode ( ) ) { return new MissingClaim ( claimName ) ; } return new ClaimImpl ( claimName , node ) ; }
String getName ( ) ; boolean isMissing ( ) ; boolean isNull ( ) ; /** * Get this Claim as a Boolean. * If the value isn't of type Boolean or it can't be converted to a Boolean, null will be returned. * * @return the value as a Boolean or null. */ @Nullable Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ @Nullable Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable public Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable public String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
boolean isMissing ( ) ; boolean isNull ( ) ; /** * Get this Claim as a Boolean. * If the value isn't of type Boolean or it can't be converted to a Boolean, null will be returned. * * @return the value as a Boolean or null. */ @Nullable Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ @Nullable Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable public Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable public String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
boolean isNull ( ) ; /** * Get this Claim as a Boolean. * If the value isn't of type Boolean or it can't be converted to a Boolean, null will be returned. * * @return the value as a Boolean or null. */ @Nullable Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ @Nullable Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable public Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable public String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ @Nullable Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable public Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable public String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable public Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable public String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
public Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable public String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
public String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
< T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
< T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
< T > String toJson ( T object , Class < T > tClazz ) throws IOException ; < T > T fromJson ( String json , Class < T > tClazz ) throws IOException ; }
< T > T fromJson ( String json , Class < T > tClazz ) throws IOException ; }
String getIssuer ( ) ; /** * Get the value of the "sub" claim, or null if it's not available. * * @return the Subject value or null. */ @Nullable String getSubject ( ) ; /** * Get the value of the "aud" claim, or null if it's not available. * * @return the Audience value or null. */ @Nullable String [ ] getAudience ( ) ; /** * Get the value of the "exp" claim, or null if it's not available. * * @return the Expiration Time value or null. */ @Nullable Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ @Nullable Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ @Nullable Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable public Claim getClaim ( @NotNull String name ) ; }
String getSubject ( ) ; /** * Get the value of the "aud" claim, or null if it's not available. * * @return the Audience value or null. */ @Nullable String [ ] getAudience ( ) ; /** * Get the value of the "exp" claim, or null if it's not available. * * @return the Expiration Time value or null. */ @Nullable Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ @Nullable Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ @Nullable Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable public Claim getClaim ( @NotNull String name ) ; }
String [ ] getAudience ( ) ; /** * Get the value of the "exp" claim, or null if it's not available. * * @return the Expiration Time value or null. */ @Nullable Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ @Nullable Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ @Nullable Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable public Claim getClaim ( @NotNull String name ) ; }
Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ @Nullable Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ @Nullable Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable public Claim getClaim ( @NotNull String name ) ; }
Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ @Nullable Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable public Claim getClaim ( @NotNull String name ) ; }
Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable public Claim getClaim ( @NotNull String name ) ; }
String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable public Claim getClaim ( @NotNull String name ) ; }
public void setUp ( ) throws Exception { } @Test public void getHeader ( ) throws Exception { } @Test public void getPayload ( ) throws Exception { JWTDecoder decoder = new JWTDecoder ( " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ " ) ; Payload jwt = decoder . getPayload ( ) ; assertThat ( jwt . getSubject ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getSubject ( ) , is ( " 1234567890 " ) ) ; } @Test public void getSignature ( ) throws Exception { } }
public void getHeader ( ) throws Exception { } @Test public void getPayload ( ) throws Exception { JWTDecoder decoder = new JWTDecoder ( " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ " ) ; Payload jwt = decoder . getPayload ( ) ; assertThat ( jwt . getSubject ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getSubject ( ) , is ( " 1234567890 " ) ) ; } @Test public void getSignature ( ) throws Exception { } }
public void getPayload ( ) throws Exception { JWTDecoder decoder = new JWTDecoder ( " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ " ) ; Payload jwt = decoder . getPayload ( ) ; assertThat ( jwt . getSubject ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getSubject ( ) , is ( " 1234567890 " ) ) ; }
public void getSignature ( ) throws Exception { } }
public static JWT decode ( String jwt ) { return new JWTDecoder ( jwt ) ; }
private void parseToken ( String token ) throws IOException { final String [ ] parts = splitToken ( token ) ; final JWTParser converter = new JWTParser ( ) ; header = converter . parseHeader ( Utils . base64Decode ( parts [ 0 ] ) ) ; payload = converter . parsePayload ( Utils . base64Decode ( parts [ 1 ] ) ) ; signature = parts [ 2 ] ; }
public String getAlgorithm ( ) { return header . getAlgorithm ( ) ; }
public String getType ( ) { return header . getType ( ) ; }
public String getContentType ( ) { return header . getContentType ( ) ; }
public String getIssuer ( ) { return payload . getIssuer ( ) ; }
public String getSubject ( ) { return payload . getSubject ( ) ; }
public String [ ] getAudience ( ) { return payload . getAudience ( ) ; }
public Date getExpiresAt ( ) { return payload . getExpiresAt ( ) ; }
public Date getNotBefore ( ) { return payload . getNotBefore ( ) ; }
public Date getIssuedAt ( ) { return payload . getIssuedAt ( ) ; }
public String getId ( ) { return payload . getId ( ) ; }
public Claim getClaim ( @NotNull String name ) { return payload . getClaim ( name ) ; }
public Boolean asBoolean ( ) { return isNull ( ) ? null : data . asBoolean ( ) ; }
public Integer asInt ( ) { return isNull ( ) ? null : data . asInt ( ) ; }
public Double asDouble ( ) { return isNull ( ) ? null : data . asDouble ( ) ; }
public String asString ( ) { return isNull ( ) ? null : data . asText ( ) ; }
public Date asDate ( ) { if ( isNull ( ) ) { return null ; } long seconds = data . asLong ( ) ; return new Date ( seconds * 1000 ) ; }
public < T > T [ ] asArray ( Class < T > tClazz ) throws Exception { if ( data . isNull ( ) | | ! data . isArray ( ) ) { return ( T [ ] ) Array . newInstance ( tClazz , 0 ) ; } ObjectMapper mapper = new ObjectMapper ( ) ; T [ ] arr = ( T [ ] ) Array . newInstance ( tClazz , data . size ( ) ) ; for ( int i = 0 ; i < data . size ( ) ; i + + ) { arr [ i ] = mapper . treeToValue ( data . get ( i ) , tClazz ) ; } return arr ; }
public < T > List < T > asList ( Class < T > tClazz ) throws Exception { if ( data . isNull ( ) | | ! data . isArray ( ) ) { return new ArrayList < > ( 0 ) ; } ObjectMapper mapper = new ObjectMapper ( ) ; List < T > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < data . size ( ) ; i + + ) { list . add ( mapper . treeToValue ( data . get ( i ) , tClazz ) ) ; } return list ; }
public static Claim extractClaim ( @NotNull String claimName , @NotNull Map < String , JsonNode > tree ) { JsonNode node = tree . get ( claimName ) ; return claimFromNode ( node ) ; }
public static Claim claimFromNode ( JsonNode node ) { if ( node = = null | | node . isMissingNode ( ) ) { return new MissingClaim ( ) ; } if ( node . isObject ( ) & & node . size ( ) = = 0 ) { return new NullClaim ( ) ; } return new ClaimImpl ( node ) ; }
public HeaderImpl deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { Map < String , JsonNode > tree = p . getCodec ( ) . readValue ( p , new TypeReference < Map < String , JsonNode > > ( ) { } ) ; if ( tree = = null ) { throw new JWTException ( " Null map " ) ; } return new HeaderImpl ( tree ) ; }
public String getAlgorithm ( ) { return extractClaim ( ALGORITHM , tree ) . asString ( ) ; }
public String getType ( ) { return extractClaim ( TYPE , tree ) . asString ( ) ; }
public String getContentType ( ) { return extractClaim ( CONTENT_TYPE , tree ) . asString ( ) ; }
public Header parseHeader ( String json ) throws IOException { return mapper . readValue ( json , Header . class ) ; }
private void addDeserializers ( ObjectMapper mapper ) { SimpleModule module = new SimpleModule ( ) ; module . addDeserializer ( Payload . class , new PayloadDeserializer ( ) ) ; module . addDeserializer ( Header . class , new HeaderDeserializer ( ) ) ; mapper . registerModule ( module ) ; }
static ObjectMapper getDefaultObjectMapper ( ) { ObjectMapper mapper = new ObjectMapper ( ) ; mapper . disable ( SerializationFeature . FAIL_ON_EMPTY_BEANS ) ; mapper . setSerializationInclusion ( JsonInclude . Include . NON_EMPTY ) ; return mapper ; }
public Boolean asBoolean ( ) { return null ; }
public < T > T [ ] asArray ( Class < T > tClazz ) throws Exception { return ( T [ ] ) Array . newInstance ( tClazz , 0 ) ; }
public < T > List < T > asList ( Class < T > tClazz ) throws Exception { return new ArrayList < > ( ) ; }
public String getIssuer ( ) { return extractClaim ( ISSUER , tree ) . asString ( ) ; }
public String getSubject ( ) { return extractClaim ( SUBJECT , tree ) . asString ( ) ; }
public String [ ] getAudience ( ) { try { return extractClaim ( AUDIENCE , tree ) . asArray ( String . class ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return new String [ ] { } ; }
public Date getExpiresAt ( ) { return extractClaim ( EXPIRES_AT , tree ) . asDate ( ) ; }
public Date getNotBefore ( ) { return extractClaim ( NOT_BEFORE , tree ) . asDate ( ) ; }
public Date getIssuedAt ( ) { return extractClaim ( ISSUED_AT , tree ) . asDate ( ) ; }
public String getId ( ) { return extractClaim ( JWT_ID , tree ) . asString ( ) ; }
public Claim getClaim ( @NotNull String name ) { return extractClaim ( name , tree ) ; }
boolean isMissing ( ) ; boolean isNull ( ) ; /** * Get this Claim as a Boolean. * If the value isn't of type Boolean or it can't be converted to a Boolean, null will be returned. * * @return the value as a Boolean or null. */ @Nullable Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ @Nullable Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
boolean isNull ( ) ; /** * Get this Claim as a Boolean. * If the value isn't of type Boolean or it can't be converted to a Boolean, null will be returned. * * @return the value as a Boolean or null. */ @Nullable Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ @Nullable Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ @Nullable Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws Exception ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws Exception ; }
String getAlgorithm ( ) ; @Nullable String getType ( ) ; @Nullable String getContentType ( ) ; }
String getType ( ) ; @Nullable String getContentType ( ) ; }
Payload parsePayload ( String json ) throws IOException ; Header parseHeader ( String json ) throws IOException ; }
public void setUp ( ) throws Exception { } @Test public void getHeader ( ) throws Exception { } @Test public void getSubject ( ) throws Exception { JWTDecoder jwt = new JWTDecoder ( " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ " ) ; assertThat ( jwt . getSubject ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getSubject ( ) , is ( " 1234567890 " ) ) ; } @Test public void getSignature ( ) throws Exception { } }
public void getHeader ( ) throws Exception { } @Test public void getSubject ( ) throws Exception { JWTDecoder jwt = new JWTDecoder ( " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ " ) ; assertThat ( jwt . getSubject ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getSubject ( ) , is ( " 1234567890 " ) ) ; } @Test public void getSignature ( ) throws Exception { } }
public void getSubject ( ) throws Exception { JWTDecoder jwt = new JWTDecoder ( " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ " ) ; assertThat ( jwt . getSubject ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getSubject ( ) , is ( " 1234567890 " ) ) ; }
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; UserPojo userPojo = ( UserPojo ) o ; return id = = userPojo . id & & ( name ! = null ? name . equals ( userPojo . name ) : userPojo . name = = null ) ; }
public void setId ( int id ) { this . id = id ; }
public void setUp ( ) throws Exception { mapper = getDefaultObjectMapper ( ) ; }
public void shouldGetBooleanValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( true ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asBoolean ( ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asBoolean ( ) , is ( true ) ) ; }
public void shouldGetNullBooleanIfNotPrimitiveValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( new Object ( ) ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asBoolean ( ) , is ( nullValue ( ) ) ) ; }
public void shouldGetIntValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( 123 ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asInt ( ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asInt ( ) , is ( 123 ) ) ; }
public void shouldGetNullIntIfNotPrimitiveValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( new Object ( ) ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asInt ( ) , is ( nullValue ( ) ) ) ; }
public void shouldGetDoubleValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( 1.5 ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asDouble ( ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asDouble ( ) , is ( 1.5 ) ) ; }
public void shouldGetNullDoubleIfNotPrimitiveValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( new Object ( ) ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asDouble ( ) , is ( nullValue ( ) ) ) ; }
public void shouldGetDateValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( " 1476824844 " ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asDate ( ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asDate ( ) , is ( new Date ( 1476824844L * 1000 ) ) ) ; }
public void shouldGetNullDateIfNotPrimitiveValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( new Object ( ) ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asDate ( ) , is ( nullValue ( ) ) ) ; }
public void shouldGetStringValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( " string " ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asString ( ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asString ( ) , is ( " string " ) ) ; }
public void shouldGetNullStringIfNotPrimitiveValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( new Object ( ) ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asString ( ) , is ( nullValue ( ) ) ) ; }
public void shouldGetArrayValueOfCustomClass ( ) throws Exception { JsonNode value = mapper . valueToTree ( new UserPojo [ ] { new UserPojo ( " George " , 1 ) , new UserPojo ( " Mark " , 2 ) } ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asArray ( UserPojo . class ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asArray ( UserPojo . class ) , is ( arrayContaining ( new UserPojo ( " George " , 1 ) , new UserPojo ( " Mark " , 2 ) ) ) ) ; }
public void shouldGetArrayValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( new String [ ] { " string1 " , " string2 " } ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asArray ( String . class ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asArray ( String . class ) , is ( arrayContaining ( " string1 " , " string2 " ) ) ) ; }
public void shouldGetEmptyArrayIfNullValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( null ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asArray ( String . class ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asArray ( String . class ) , is ( IsArrayWithSize . < String > emptyArray ( ) ) ) ; }
public void shouldGetEmptyArrayIfNonArrayValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( 1 ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asArray ( String . class ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asArray ( String . class ) , is ( IsArrayWithSize . < String > emptyArray ( ) ) ) ; }
public void shouldThrowIfArrayClassMismatch ( ) throws Exception { JsonNode value = mapper . valueToTree ( new String [ ] { " keys " , " values " } ) ; Claim claim = claimFromNode ( value ) ; exception . expect ( Exception . class ) ; claim . asArray ( UserPojo . class ) ; }
public void shouldGetListValueOfCustomClass ( ) throws Exception { JsonNode value = mapper . valueToTree ( Arrays . asList ( new UserPojo ( " George " , 1 ) , new UserPojo ( " Mark " , 2 ) ) ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asList ( UserPojo . class ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asList ( UserPojo . class ) , is ( hasItems ( new UserPojo ( " George " , 1 ) , new UserPojo ( " Mark " , 2 ) ) ) ) ; }
public void shouldGetListValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( Arrays . asList ( " string1 " , " string2 " ) ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asList ( String . class ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asList ( String . class ) , is ( hasItems ( " string1 " , " string2 " ) ) ) ; }
public void shouldGetEmptyListIfNullValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( null ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asList ( String . class ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asList ( String . class ) , is ( IsEmptyCollection . emptyCollectionOf ( String . class ) ) ) ; }
public void shouldGetEmptyListIfNonArrayValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( 1 ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asList ( String . class ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asList ( String . class ) , is ( IsEmptyCollection . emptyCollectionOf ( String . class ) ) ) ; }
public void shouldThrowIfListClassMismatch ( ) throws Exception { JsonNode value = mapper . valueToTree ( new String [ ] { " keys " , " values " } ) ; Claim claim = claimFromNode ( value ) ; exception . expect ( Exception . class ) ; claim . asList ( UserPojo . class ) ; }
public void setUp ( ) throws Exception { } @Test public void shouldGetDefaultObjectMapper ( ) throws Exception { ObjectMapper mapper = getDefaultObjectMapper ( ) ; assertThat ( mapper , is ( notNullValue ( ) ) ) ; assertThat ( mapper , is ( instanceOf ( ObjectMapper . class ) ) ) ; assertThat ( mapper . isEnabled ( SerializationFeature . FAIL_ON_EMPTY_BEANS ) , is ( false ) ) ; } @Test public void extractClaim ( ) throws Exception { } @Test public void shouldGenerateNullClaimFromNullNode ( ) throws Exception { Claim claim = null ; assertThat ( claim , is ( notNullValue ( ) ) ) ; assertThat ( claim , is ( instanceOf ( NullClaim . class ) ) ) ; } @Test public void shouldGenerateMissingClaimFromMissingNode ( ) throws Exception { } @Test public void shouldGenerateValidClaimFromJsonNode ( ) throws Exception { } }
public void shouldGetDefaultObjectMapper ( ) throws Exception { ObjectMapper mapper = getDefaultObjectMapper ( ) ; assertThat ( mapper , is ( notNullValue ( ) ) ) ; assertThat ( mapper , is ( instanceOf ( ObjectMapper . class ) ) ) ; assertThat ( mapper . isEnabled ( SerializationFeature . FAIL_ON_EMPTY_BEANS ) , is ( false ) ) ; }
public void extractClaim ( ) throws Exception { } @Test public void shouldGenerateNullClaimFromNullNode ( ) throws Exception { Claim claim = null ; assertThat ( claim , is ( notNullValue ( ) ) ) ; assertThat ( claim , is ( instanceOf ( NullClaim . class ) ) ) ; } @Test public void shouldGenerateMissingClaimFromMissingNode ( ) throws Exception { } @Test public void shouldGenerateValidClaimFromJsonNode ( ) throws Exception { } }
public void shouldGenerateNullClaimFromNullNode ( ) throws Exception { Claim claim = null ; assertThat ( claim , is ( notNullValue ( ) ) ) ; assertThat ( claim , is ( instanceOf ( NullClaim . class ) ) ) ; }
public void shouldGenerateMissingClaimFromMissingNode ( ) throws Exception { } @Test public void shouldGenerateValidClaimFromJsonNode ( ) throws Exception { } }
public void shouldGenerateValidClaimFromJsonNode ( ) throws Exception { } }
public static JWT decode ( String jwt ) { return new JWTDecoder ( jwt ) ; }
private void parseToken ( String token ) throws JWTException { final String [ ] parts = splitToken ( token ) ; final JWTParser converter = new JWTParser ( ) ; header = converter . parseHeader ( base64Decode ( parts [ 0 ] ) ) ; payload = converter . parsePayload ( base64Decode ( parts [ 1 ] ) ) ; signature = parts [ 2 ] ; }
public boolean isExpired ( ) { //TODO: Add advanced validation return false; }
static String base64Decode ( String string ) throws JWTException { String decoded ; try { decoded = StringUtils . newStringUtf8 ( Base64 . decodeBase64 ( string ) ) ; } catch ( NullPointerException e ) { throw new JWTException ( " Received bytes didn't correspond to a valid Base64 encoded string. " , e ) ; } return decoded ; }
static String base64Encode ( String string ) throws JWTException { String encoded ; try { encoded = StringUtils . newStringUtf8 ( Base64 . encodeBase64 ( string . getBytes ( ) , false , true ) ) ; } catch ( NullPointerException e ) { throw new JWTException ( " Received bytes didn't correspond to a valid Base64 encoded string. " , e ) ; } return encoded ; }
public boolean isNull ( ) { return data . isNull ( ) | | data . isObject ( ) & & data . size ( ) = = 0 ; }
public < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException { if ( data . isNull ( ) | | ! data . isArray ( ) ) { return ( T [ ] ) Array . newInstance ( tClazz , 0 ) ; } ObjectMapper mapper = new ObjectMapper ( ) ; T [ ] arr = ( T [ ] ) Array . newInstance ( tClazz , data . size ( ) ) ; for ( int i = 0 ; i < data . size ( ) ; i + + ) { try { arr [ i ] = mapper . treeToValue ( data . get ( i ) , tClazz ) ; } catch ( JsonProcessingException e ) { throw new JWTException ( " Couldn't map the Claim's array contents to " + tClazz . getSimpleName ( ) , e ) ; } } return arr ; }
public < T > List < T > asList ( Class < T > tClazz ) throws JWTException { if ( data . isNull ( ) | | ! data . isArray ( ) ) { return new ArrayList < > ( 0 ) ; } ObjectMapper mapper = new ObjectMapper ( ) ; List < T > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < data . size ( ) ; i + + ) { try { list . add ( mapper . treeToValue ( data . get ( i ) , tClazz ) ) ; } catch ( JsonProcessingException e ) { throw new JWTException ( " Couldn't map the Claim's array contents to " + tClazz . getSimpleName ( ) , e ) ; } } return list ; }
public static Claim claimFromNode ( JsonNode node ) { if ( node = = null | | node . isMissingNode ( ) ) { return new MissingClaim ( ) ; } return new ClaimImpl ( node ) ; }
public Payload parsePayload ( String json ) throws JWTException { return convertFromJSON ( json , Payload . class ) ; }
public Header parseHeader ( String json ) throws JWTException { return convertFromJSON ( json , Header . class ) ; }
< T > T convertFromJSON ( String json , Class < T > tClazz ) throws JWTException { JWTException exception = new JWTException ( String . format ( " The string '%s' doesn't have a valid JSON format. " , json ) ) ; if ( json = = null | | ! json . startsWith ( " { " ) | | ! json . endsWith ( " } " ) ) { throw exception ; } try { return mapper . readValue ( json , tClazz ) ;
public < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException { throw new JWTException ( " Missing Claim " ) ; }
public < T > List < T > asList ( Class < T > tClazz ) throws JWTException { throw new JWTException ( " Missing Claim " ) ; }
public String [ ] getAudience ( ) { JsonNode audNode = tree . get ( AUDIENCE ) ; if ( audNode = = null | | audNode . isNull ( ) ) { return new String [ ] { } ; } if ( audNode . isTextual ( ) & & ! audNode . asText ( ) . isEmpty ( ) ) { return new String [ ] { audNode . asText ( ) } ; } Claim claim = claimFromNode ( audNode ) ; try { return claim . asArray ( String . class ) ;
boolean isMissing ( ) ; boolean isNull ( ) ; /** * Get this Claim as a Boolean. * If the value isn't of type Boolean or it can't be converted to a Boolean, null will be returned. * * @return the value as a Boolean or null. */ @Nullable Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ @Nullable Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
boolean isNull ( ) ; /** * Get this Claim as a Boolean. * If the value isn't of type Boolean or it can't be converted to a Boolean, null will be returned. * * @return the value as a Boolean or null. */ @Nullable Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ @Nullable Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ @Nullable Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ @Nullable Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ @Nullable String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ @Nullable Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
< T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
< T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
String getSignature ( ) ; //TODO replace with advanced validations boolean isExpired(); }
Payload parsePayload ( String json ) throws JWTException ; Header parseHeader ( String json ) throws JWTException ; }
public void getSubject ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ " ) ; assertThat ( jwt . getSubject ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getSubject ( ) , is ( " 1234567890 " ) ) ; }
public void shouldThrowIfLessThan3Parts ( ) throws Exception { exception . expect ( JWTException . class ) ; exception . expectMessage ( " The token was expected to have 3 parts, but got 2. " ) ; JWTDecoder . decode ( " two.parts " ) ; }
public void shouldThrowIfMoreThan3Parts ( ) throws Exception { exception . expect ( JWTException . class ) ; exception . expectMessage ( " The token was expected to have 3 parts, but got 4. " ) ; JWTDecoder . decode ( " this.has.four.parts " ) ; }
public void shouldThrowIfPayloadHasInvalidJSONFormat ( ) throws Exception { String validJson = " {} " ; String invalidJson = " {}}{ " ; exception . expect ( JWTException . class ) ; exception . expectMessage ( String . format ( " The string '%s' doesn't have a valid JSON format. " , invalidJson ) ) ; customJWT ( validJson , invalidJson , " signature " ) ; }
public void shouldThrowIfHeaderHasInvalidJSONFormat ( ) throws Exception { String validJson = " {} " ; String invalidJson = " {}}{ " ; exception . expect ( JWTException . class ) ; exception . expectMessage ( String . format ( " The string '%s' doesn't have a valid JSON format. " , invalidJson ) ) ; customJWT ( invalidJson , validJson , " signature " ) ; }
public void shouldGetStringToken ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.e30.XmNK3GpH3Ys_7wsYBfq4C3M6goz71I7dTgUkuIa5lyQ " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . toString ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . toString ( ) , is ( " eyJhbGciOiJIUzI1NiJ9.e30.XmNK3GpH3Ys_7wsYBfq4C3M6goz71I7dTgUkuIa5lyQ " ) ) ; }
public void shouldGetHeader ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.e30.XmNK3GpH3Ys_7wsYBfq4C3M6goz71I7dTgUkuIa5lyQ " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getAlgorithm ( ) , is ( " HS256 " ) ) ; }
public void shouldGetSignature ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.e30.XmNK3GpH3Ys_7wsYBfq4C3M6goz71I7dTgUkuIa5lyQ " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getSignature ( ) , is ( " XmNK3GpH3Ys_7wsYBfq4C3M6goz71I7dTgUkuIa5lyQ " ) ) ; }
public void shouldGetIssuer ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJKb2huIERvZSJ9.SgXosfRR_IwCgHq5lF3tlM-JHtpucWCRSaVuoHTbWbQ " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getIssuer ( ) , is ( " John Doe " ) ) ; }
public void shouldGetSubject ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJUb2szbnMifQ.RudAxkslimoOY3BLl2Ghny3BrUKu9I1ZrXzCZGDJtNs " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getSubject ( ) , is ( " Tok3ns " ) ) ; }
public void shouldGetArrayAudience ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOlsiSG9wZSIsIlRyYXZpcyIsIlNvbG9tb24iXX0.Tm4W8WnfPjlmHSmKFakdij0on2rWPETpoM7Sh0u6-S4 " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getAudience ( ) , is ( arrayWithSize ( 3 ) ) ) ; assertThat ( jwt . getAudience ( ) , is ( arrayContaining ( " Hope " , " Travis " , " Solomon " ) ) ) ; }
public void shouldGetStringAudience ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJKYWNrIFJleWVzIn0.a4I9BBhPt1OB1GW67g2P1bEHgi6zgOjGUL4LvhE9Dgc " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getAudience ( ) , is ( arrayWithSize ( 1 ) ) ) ; assertThat ( jwt . getAudience ( ) , is ( arrayContaining ( " Jack Reyes " ) ) ) ; }
public void shouldGetExpirationTime ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJleHAiOiIxNDc2NzI3MDg2In0.XwZztHlQwnAgmnQvrcWXJloLOUaLZGiY0HOXJCKRaks " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getExpiresAt ( ) , is ( instanceOf ( Date . class ) ) ) ; long ms = 1476727086L * 1000 ; Date expectedDate = new Date ( ms ) ; assertThat ( jwt . getExpiresAt ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getExpiresAt ( ) , is ( equalTo ( expectedDate ) ) ) ; }
public void shouldGetNotBefore ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJuYmYiOiIxNDc2NzI3MDg2In0.pi3Fi3oFiXk5A5AetDdL0hjVx_rt6F5r_YiG6HoCYDw " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getNotBefore ( ) , is ( instanceOf ( Date . class ) ) ) ; long ms = 1476727086L * 1000 ; Date expectedDate = new Date ( ms ) ; assertThat ( jwt . getNotBefore ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getNotBefore ( ) , is ( equalTo ( expectedDate ) ) ) ; }
public void shouldGetIssuedAt ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJpYXQiOiIxNDc2NzI3MDg2In0.u6BxwrO7S0sqDY8-1cUOLzU2uejAJBzQQF8g_o5BAgo " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getIssuedAt ( ) , is ( instanceOf ( Date . class ) ) ) ; long ms = 1476727086L * 1000 ; Date expectedDate = new Date ( ms ) ; assertThat ( jwt . getIssuedAt ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getIssuedAt ( ) , is ( equalTo ( expectedDate ) ) ) ; }
public void shouldGetId ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiIxMjM0NTY3ODkwIn0.m3zgEfVUFOd-CvL3xG5BuOWLzb0zMQZCqiVNQQOPOvA " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getId ( ) , is ( " 1234567890 " ) ) ; }
public void shouldBeExpired ( ) throws Exception { long pastSeconds = System . currentTimeMillis ( ) / 1000 ; long futureSeconds = ( System . currentTimeMillis ( ) + 10000 ) / 1000 ; JWT issuedAndExpiresInTheFuture = customTimeJWT ( futureSeconds , futureSeconds ) ; assertTrue ( issuedAndExpiresInTheFuture . isExpired ( ) ) ; JWT issuedInTheFuture = customTimeJWT ( futureSeconds , null ) ; assertTrue ( issuedInTheFuture . isExpired ( ) ) ; JWT issuedAndExpiresInThePast = customTimeJWT ( pastSeconds , pastSeconds ) ; assertTrue ( issuedAndExpiresInThePast . isExpired ( ) ) ; JWT expiresInThePast = customTimeJWT ( null , pastSeconds ) ; assertTrue ( expiresInThePast . isExpired ( ) ) ; JWT issuedInTheFutureExpiresInThePast = customTimeJWT ( futureSeconds , pastSeconds ) ; assertTrue ( issuedInTheFutureExpiresInThePast . isExpired ( ) ) ; }
public void shouldNotBeExpired ( ) throws Exception { long pastSeconds = System . currentTimeMillis ( ) / 1000 ; long futureSeconds = ( System . currentTimeMillis ( ) + 10000 ) / 1000 ; JWT missingDates = customTimeJWT ( null , null ) ; assertFalse ( missingDates . isExpired ( ) ) ; JWT issuedInThePastExpiresInTheFuture = customTimeJWT ( pastSeconds , futureSeconds ) ; assertFalse ( issuedInThePastExpiresInTheFuture . isExpired ( ) ) ; JWT issuedInThePast = customTimeJWT ( pastSeconds , null ) ; assertFalse ( issuedInThePast . isExpired ( ) ) ; JWT expiresInTheFuture = customTimeJWT ( null , futureSeconds ) ; assertFalse ( expiresInTheFuture . isExpired ( ) ) ; }
public void shouldGetMissingClaimIfClaimDoesNotExist ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.e30.K17vlwhE8FCMShdl1_65jEYqsQqBOVMPUU9IgG-QlTM " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getClaim ( " notExisting " ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getClaim ( " notExisting " ) , is ( instanceOf ( MissingClaim . class ) ) ) ; }
public void shouldGetValidClaim ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJvYmplY3QiOnsibmFtZSI6ImpvaG4ifX0.lrU1gZlOdlmTTeZwq0VI-pZx2iV46UWYd5-lCjy6-c4 " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getClaim ( " object " ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getClaim ( " object " ) , is ( instanceOf ( Claim . class ) ) ) ; }
public void shouldGetNullClaimIfClaimValueIsNull ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJvYmplY3QiOnt9fQ.d3nUeeL_69QsrHL0ZWij612LHEQxD8EZg1rNoY3a4aI " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getClaim ( " object " ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getClaim ( " object " ) . isNull ( ) , is ( true ) ) ; }
private JWT customTimeJWT ( @Nullable Long iat , @Nullable Long exp ) { String header = base64Encode ( " {} " ) ; StringBuilder bodyBuilder = new StringBuilder ( " { " ) ; if ( iat ! = null ) { bodyBuilder . append ( " \" iat \" : \" " ) . append ( iat . longValue ( ) ) . append ( " \" " ) ; } if ( exp ! = null ) { if ( iat ! = null ) { bodyBuilder . append ( " , " ) ; } bodyBuilder . append ( " \" exp \" : \" " ) . append ( exp . longValue ( ) ) . append ( " \" " ) ; } bodyBuilder . append ( " } " ) ; String body = base64Encode ( bodyBuilder . toString ( ) ) ; String signature = " sign " ; return JWTDecoder . decode ( String . format ( " %s.%s.%s " , header , body , signature ) ) ; }
private JWT customJWT ( String jsonHeader , String jsonPayload , String signature ) { String header = base64Encode ( jsonHeader ) ; String body = base64Encode ( jsonPayload ) ; return JWTDecoder . decode ( String . format ( " %s.%s.%s " , header , body , signature ) ) ; }
public void shouldThrowIfArrayClassMismatch ( ) throws Exception { JsonNode value = mapper . valueToTree ( new String [ ] { " keys " , " values " } ) ; Claim claim = claimFromNode ( value ) ; exception . expect ( JWTException . class ) ; claim . asArray ( UserPojo . class ) ; }
public void shouldThrowIfListClassMismatch ( ) throws Exception { JsonNode value = mapper . valueToTree ( new String [ ] { " keys " , " values " } ) ; Claim claim = claimFromNode ( value ) ; exception . expect ( JWTException . class ) ; claim . asList ( UserPojo . class ) ; }
public void shouldReturnMissingClaimWhenParsingNullValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( null ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim , is ( notNullValue ( ) ) ) ; assertThat ( claim , is ( instanceOf ( MissingClaim . class ) ) ) ; assertThat ( claim . isMissing ( ) , is ( true ) ) ; }
public void shouldReturnValidButNullClaimIfTreeIsEmpty ( ) throws Exception { JsonNode value = mapper . valueToTree ( new Object ( ) ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim , is ( notNullValue ( ) ) ) ; assertThat ( claim , is ( instanceOf ( ClaimImpl . class ) ) ) ; assertThat ( claim . isNull ( ) , is ( true ) ) ; }
public void setUp ( ) throws Exception { parser = new JWTParser ( ) ; }
public void shouldAddDeserializers ( ) throws Exception { ObjectMapper mapper = mock ( ObjectMapper . class ) ; new JWTParser ( mapper ) ; verify ( mapper ) . registerModule ( any ( Module . class ) ) ; }
public void shouldParsePayload ( ) throws Exception { ObjectMapper mapper = mock ( ObjectMapper . class ) ; JWTParser parser = new JWTParser ( mapper ) ; parser . parsePayload ( " {} " ) ; verify ( mapper ) . readValue ( " {} " , Payload . class ) ; }
public void shouldThrowOnInvalidPayload ( ) throws Exception { String jsonPayload = " {{ " ; exception . expect ( JWTException . class ) ; exception . expectMessage ( String . format ( " The string '%s' doesn't have a valid JSON format. " , jsonPayload ) ) ; Payload payload = parser . parsePayload ( jsonPayload ) ; assertThat ( payload , is ( nullValue ( ) ) ) ; }
public void shouldParseHeader ( ) throws Exception { ObjectMapper mapper = mock ( ObjectMapper . class ) ; JWTParser parser = new JWTParser ( mapper ) ; parser . parseHeader ( " {} " ) ; verify ( mapper ) . readValue ( " {} " , Header . class ) ; }
public void shouldThrowOnInvalidHeader ( ) throws Exception { String jsonHeader = " }} " ; exception . expect ( JWTException . class ) ; exception . expectMessage ( String . format ( " The string '%s' doesn't have a valid JSON format. " , jsonHeader ) ) ; Header header = parser . parseHeader ( jsonHeader ) ; assertThat ( header , is ( nullValue ( ) ) ) ; }
public void shouldConvertFromValidJSON ( ) throws Exception { String json = " {} " ; Object object = parser . convertFromJSON ( json , Object . class ) ; assertThat ( object , is ( notNullValue ( ) ) ) ; }
public void shouldThrowWhenConvertingIfNullJson ( ) throws Exception { exception . expect ( JWTException . class ) ; exception . expectMessage ( " The string 'null' doesn't have a valid JSON format. " ) ; String json = null ; Object object = parser . convertFromJSON ( json , Object . class ) ; assertThat ( object , is ( nullValue ( ) ) ) ; }
public void shouldThrowWhenConvertingFromInvalidJson ( ) throws Exception { exception . expect ( JWTException . class ) ; exception . expectMessage ( " The string '}{' doesn't have a valid JSON format. " ) ; String json = " }{ " ; Object object = parser . convertFromJSON ( json , Object . class ) ; assertThat ( object , is ( nullValue ( ) ) ) ; }
public Boolean asBoolean ( ) { return isNull ( ) | | ! data . isBoolean ( ) ? null : data . asBoolean ( ) ; }
public Integer asInt ( ) { return isNull ( ) | | ! data . isNumber ( ) ? null : data . asInt ( ) ; }
public Double asDouble ( ) { return isNull ( ) | | ! data . isNumber ( ) ? null : data . asDouble ( ) ; }
public String asString ( ) { return isNull ( ) | | ! data . isTextual ( ) ? null : data . asText ( ) ; }
public Date asDate ( ) { if ( isNull ( ) | | ! data . canConvertToLong ( ) ) { return null ; } long seconds = data . asLong ( ) ; return new Date ( seconds * 1000 ) ; }
public void shouldGetNullBooleanIfNotBooleanValue ( ) throws Exception { JsonNode objectValue = mapper . valueToTree ( new Object ( ) ) ; assertThat ( claimFromNode ( objectValue ) . asBoolean ( ) , is ( nullValue ( ) ) ) ; JsonNode stringValue = mapper . valueToTree ( " boolean " ) ; assertThat ( claimFromNode ( stringValue ) . asBoolean ( ) , is ( nullValue ( ) ) ) ; }
public void shouldGetNullIntIfNotIntValue ( ) throws Exception { JsonNode objectValue = mapper . valueToTree ( new Object ( ) ) ; assertThat ( claimFromNode ( objectValue ) . asInt ( ) , is ( nullValue ( ) ) ) ; JsonNode stringValue = mapper . valueToTree ( " 123 " ) ; assertThat ( claimFromNode ( stringValue ) . asInt ( ) , is ( nullValue ( ) ) ) ; }
public void shouldGetNullDoubleIfNotDoubleValue ( ) throws Exception { JsonNode objectValue = mapper . valueToTree ( new Object ( ) ) ; assertThat ( claimFromNode ( objectValue ) . asDouble ( ) , is ( nullValue ( ) ) ) ; JsonNode stringValue = mapper . valueToTree ( " 123.23 " ) ; assertThat ( claimFromNode ( stringValue ) . asDouble ( ) , is ( nullValue ( ) ) ) ; }
public void shouldGetDateValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( 1476824844L ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asDate ( ) , is ( notNullValue ( ) ) ) ; assertThat ( claim . asDate ( ) , is ( new Date ( 1476824844L * 1000 ) ) ) ; }
public void shouldGetNullDateIfNotDateValue ( ) throws Exception { JsonNode objectValue = mapper . valueToTree ( new Object ( ) ) ; assertThat ( claimFromNode ( objectValue ) . asDate ( ) , is ( nullValue ( ) ) ) ; JsonNode stringValue = mapper . valueToTree ( " 1476824844 " ) ; assertThat ( claimFromNode ( stringValue ) . asDate ( ) , is ( nullValue ( ) ) ) ; }
public void shouldGetNullStringIfNotStringValue ( ) throws Exception { JsonNode objectValue = mapper . valueToTree ( new Object ( ) ) ; assertThat ( claimFromNode ( objectValue ) . asString ( ) , is ( nullValue ( ) ) ) ; JsonNode intValue = mapper . valueToTree ( 12345 ) ; assertThat ( claimFromNode ( intValue ) . asString ( ) , is ( nullValue ( ) ) ) ; }
public < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException { return null ; }
public < T > List < T > asList ( Class < T > tClazz ) throws JWTException { return null ; }
public Boolean asBoolean ( ) { return ! data . isBoolean ( ) ? null : data . asBoolean ( ) ; }
public Integer asInt ( ) { return ! data . isNumber ( ) ? null : data . asInt ( ) ; }
public Double asDouble ( ) { return ! data . isNumber ( ) ? null : data . asDouble ( ) ; }
public String asString ( ) { return ! data . isTextual ( ) ? null : data . asText ( ) ; }
public Date asDate ( ) { if ( ! data . canConvertToLong ( ) ) { return null ; } long seconds = data . asLong ( ) ; return new Date ( seconds * 1000 ) ; }
public < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException { if ( ! data . isArray ( ) ) { return null ; } ObjectMapper mapper = new ObjectMapper ( ) ; T [ ] arr = ( T [ ] ) Array . newInstance ( tClazz , data . size ( ) ) ; for ( int i = 0 ; i < data . size ( ) ; i + + ) { try { arr [ i ] = mapper . treeToValue ( data . get ( i ) , tClazz ) ; } catch ( JsonProcessingException e ) { throw new JWTException ( " Couldn't map the Claim's array contents to " + tClazz . getSimpleName ( ) , e ) ; } } return arr ; }
public < T > List < T > asList ( Class < T > tClazz ) throws JWTException { if ( ! data . isArray ( ) ) { return null ; } ObjectMapper mapper = new ObjectMapper ( ) ; List < T > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < data . size ( ) ; i + + ) { try { list . add ( mapper . treeToValue ( data . get ( i ) , tClazz ) ) ; } catch ( JsonProcessingException e ) { throw new JWTException ( " Couldn't map the Claim's array contents to " + tClazz . getSimpleName ( ) , e ) ; } } return list ; }
public static Claim claimFromNode ( JsonNode node ) { if ( node = = null | | node . isNull ( ) | | node . isMissingNode ( ) ) { return new BaseClaim ( ) ; } return new ClaimImpl ( node ) ; }
public void shouldGetExpirationTime ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0NzY3MjcwODZ9.L9dcPHEDQew2u9MkDCORFkfDGcSOsgoPqNY-LUMLEHg " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getExpiresAt ( ) , is ( instanceOf ( Date . class ) ) ) ; long ms = 1476727086L * 1000 ; Date expectedDate = new Date ( ms ) ; assertThat ( jwt . getExpiresAt ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getExpiresAt ( ) , is ( equalTo ( expectedDate ) ) ) ; }
public void shouldGetNotBefore ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJuYmYiOjE0NzY3MjcwODZ9.tkpD3iCPQPVqjnjpDVp2bJMBAgpVCG9ZjlBuMitass0 " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getNotBefore ( ) , is ( instanceOf ( Date . class ) ) ) ; long ms = 1476727086L * 1000 ; Date expectedDate = new Date ( ms ) ; assertThat ( jwt . getNotBefore ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getNotBefore ( ) , is ( equalTo ( expectedDate ) ) ) ; }
public void shouldGetIssuedAt ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE0NzY3MjcwODZ9.KPjGoW665E8V5_27Jugab8qSTxLk2cgquhPCBfAP0_w " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getIssuedAt ( ) , is ( instanceOf ( Date . class ) ) ) ; long ms = 1476727086L * 1000 ; Date expectedDate = new Date ( ms ) ; assertThat ( jwt . getIssuedAt ( ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getIssuedAt ( ) , is ( equalTo ( expectedDate ) ) ) ; }
public void shouldGetMissingClaimIfClaimDoesNotExist ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.e30.K17vlwhE8FCMShdl1_65jEYqsQqBOVMPUU9IgG-QlTM " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getClaim ( " notExisting " ) , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getClaim ( " notExisting " ) , is ( instanceOf ( BaseClaim . class ) ) ) ; }
public void shouldGetNullArrayIfNullValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( null ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asArray ( String . class ) , is ( nullValue ( ) ) ) ; }
public void shouldGetNullArrayIfNonArrayValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( 1 ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asArray ( String . class ) , is ( nullValue ( ) ) ) ; }
public void shouldGetNullListIfNullValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( null ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asList ( String . class ) , is ( nullValue ( ) ) ) ; }
public void shouldGetNullListIfNonArrayValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( 1 ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim . asList ( String . class ) , is ( nullValue ( ) ) ) ; }
public void shouldReturnBaseClaimWhenParsingNullValue ( ) throws Exception { JsonNode value = mapper . valueToTree ( null ) ; Claim claim = claimFromNode ( value ) ; assertThat ( claim , is ( notNullValue ( ) ) ) ; assertThat ( claim , is ( instanceOf ( BaseClaim . class ) ) ) ; assertThat ( claim . isNull ( ) , is ( true ) ) ; }
public Payload deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { Map < String , JsonNode > tree = p . getCodec ( ) . readValue ( p , new TypeReference < Map < String , JsonNode > > ( ) { } ) ; if ( tree = = null ) { throw new JWTException ( " Null map " ) ; } String issuer = removeString ( tree , Claims . ISSUER ) ; String subject = removeString ( tree , Claims . SUBJECT ) ; String [ ] audience = removeStringOrArray ( tree , Claims . AUDIENCE ) ; Date expiresAt = removeDate ( tree , Claims . EXPIRES_AT ) ; Date notBefore = removeDate ( tree , Claims . NOT_BEFORE ) ; Date issuedAt = removeDate ( tree , Claims . ISSUED_AT ) ; String jwtId = removeString ( tree , Claims . JWT_ID ) ; return new PayloadImpl ( issuer , subject , audience , expiresAt , notBefore , issuedAt , jwtId , tree ) ; }
private String [ ] removeStringOrArray ( Map < String , JsonNode > tree , String claimName ) { JsonNode node = tree . remove ( claimName ) ; if ( node = = null | | node . isNull ( ) | | ! ( node . isArray ( ) | | node . isTextual ( ) ) ) { return null ; } if ( node . isTextual ( ) & & ! node . asText ( ) . isEmpty ( ) ) { return new String [ ] { node . asText ( ) } ; } ObjectMapper mapper = new ObjectMapper ( ) ; String [ ] arr = new String [ node . size ( ) ] ; for ( int i = 0 ; i < node . size ( ) ; i + + ) { try { arr [ i ] = mapper . treeToValue ( node . get ( i ) , String . class ) ; } catch ( JsonProcessingException e ) { throw new JWTException ( " Couldn't map the Claim's array contents to String " , e ) ; } } return arr ; }
private Date removeDate ( Map < String , JsonNode > tree , String claimName ) { JsonNode node = tree . remove ( claimName ) ; if ( node = = null | | node . isNull ( ) | | ! node . canConvertToLong ( ) ) { return null ; } final long ms = node . asLong ( ) * 1000 ; return new Date ( ms ) ; }
private String removeString ( Map < String , JsonNode > tree , String claimName ) { JsonNode node = tree . remove ( claimName ) ; if ( node = = null | | node . isNull ( ) ) { return null ; } return node . asText ( null ) ; }
public String getIssuer ( ) { return issuer ; }
public String getSubject ( ) { return subject ; }
public String [ ] getAudience ( ) { return audience ; }
public Date getExpiresAt ( ) { return expiresAt ; }
public Date getNotBefore ( ) { return notBefore ; }
public Date getIssuedAt ( ) { return issuedAt ; }
public Claim getClaim ( @NotNull String name ) { return extractClaim ( name , extras ) ; }
String getIssuer ( ) ; /** * Get the value of the "sub" claim, or null if it's not available. * * @return the Subject value or null. */ @Nullable String getSubject ( ) ; /** * Get the value of the "aud" claim, or null if it's not available. * * @return the Audience value or null. */ @Nullable String [ ] getAudience ( ) ; /** * Get the value of the "exp" claim, or null if it's not available. * * @return the Expiration Time value or null. */ @Nullable Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ @Nullable Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ @Nullable Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable Claim getClaim ( @NotNull String name ) ; }
String getSubject ( ) ; /** * Get the value of the "aud" claim, or null if it's not available. * * @return the Audience value or null. */ @Nullable String [ ] getAudience ( ) ; /** * Get the value of the "exp" claim, or null if it's not available. * * @return the Expiration Time value or null. */ @Nullable Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ @Nullable Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ @Nullable Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable Claim getClaim ( @NotNull String name ) ; }
String [ ] getAudience ( ) ; /** * Get the value of the "exp" claim, or null if it's not available. * * @return the Expiration Time value or null. */ @Nullable Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ @Nullable Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ @Nullable Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable Claim getClaim ( @NotNull String name ) ; }
Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ @Nullable Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ @Nullable Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable Claim getClaim ( @NotNull String name ) ; }
Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ @Nullable Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable Claim getClaim ( @NotNull String name ) ; }
Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ @Nullable String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable Claim getClaim ( @NotNull String name ) ; }
String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ @Nullable Claim getClaim ( @NotNull String name ) ; }
public static JWTVerifier init ( ) { return new JWTVerifier ( ) ; }
public JWTVerifier withIssuer ( String issuer ) { requireClaim ( Claims . ISSUER , issuer ) ; return this ; }
public JWTVerifier withSubject ( String subject ) { requireClaim ( Claims . SUBJECT , subject ) ; return this ; }
public JWTVerifier withAudience ( String [ ] audience ) { requireClaim ( Claims . AUDIENCE , audience ) ; return this ; }
public JWTVerifier withExpiresAt ( Date expiresAt ) { requireClaim ( Claims . EXPIRES_AT , expiresAt ) ; return this ; }
public JWTVerifier withNotBefore ( Date notBefore ) { requireClaim ( Claims . NOT_BEFORE , notBefore ) ; return this ; }
public JWTVerifier withIssuedAt ( Date issuedAt ) { requireClaim ( Claims . ISSUED_AT , issuedAt ) ; return this ; }
public JWTVerifier withJWTId ( String jwtId ) { requireClaim ( Claims . JWT_ID , jwtId ) ; return this ; }
public JWT verify ( String jwt ) throws JWTException { JWT decode = JWTDecoder . decode ( jwt ) ; verifyClaims ( decode , claims ) ; return decode ; }
private void verifyClaims ( JWT jwt , Map < String , Object > claims ) { for ( Map . Entry < String , Object > entry : claims . entrySet ( ) ) { assertValidClaim ( jwt , entry . getKey ( ) , entry . getValue ( ) ) ;
private void assertValidClaim ( JWT jwt , String claimName , Object expectedValue ) { boolean isValid ; if ( Claims . AUDIENCE . equals ( claimName ) ) { isValid = Arrays . equals ( jwt . getAudience ( ) , ( String [ ] ) expectedValue ) ; } else if ( Claims . NOT_BEFORE . equals ( claimName ) | | Claims . EXPIRES_AT . equals ( claimName ) | | Claims . ISSUED_AT . equals ( claimName ) ) { Date dateValue = ( Date ) expectedValue ; isValid = dateValue . equals ( jwt . getClaim ( claimName ) . asDate ( ) ) ; } else { String stringValue = ( String ) expectedValue ; isValid = stringValue . equals ( jwt . getClaim ( claimName ) . asString ( ) ) ; } if ( ! isValid ) { throw new InvalidClaimException ( String . format ( " The Claim '%s' value doesn't match the required one. " , claimName ) ) ;
private void requireClaim ( String name , Object value ) { if ( value = = null ) { claims . remove ( name ) ; return ; } claims . put ( name , value ) ; }
public Payload deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { Map < String , JsonNode > tree = p . getCodec ( ) . readValue ( p , new TypeReference < Map < String , JsonNode > > ( ) { } ) ; if ( tree = = null ) { throw new JWTException ( " Null map " ) ; } String issuer = getString ( tree , Claims . ISSUER ) ; String subject = getString ( tree , Claims . SUBJECT ) ; String [ ] audience = getStringOrArray ( tree , Claims . AUDIENCE ) ; Date expiresAt = getDate ( tree , Claims . EXPIRES_AT ) ; Date notBefore = getDate ( tree , Claims . NOT_BEFORE ) ; Date issuedAt = getDate ( tree , Claims . ISSUED_AT ) ; String jwtId = getString ( tree , Claims . JWT_ID ) ; return new PayloadImpl ( issuer , subject , audience , expiresAt , notBefore , issuedAt , jwtId , tree ) ; }
private String [ ] getStringOrArray ( Map < String , JsonNode > tree , String claimName ) { JsonNode node = tree . get ( claimName ) ; if ( node = = null | | node . isNull ( ) | | ! ( node . isArray ( ) | | node . isTextual ( ) ) ) { return null ; } if ( node . isTextual ( ) & & ! node . asText ( ) . isEmpty ( ) ) { return new String [ ] { node . asText ( ) } ; } ObjectMapper mapper = new ObjectMapper ( ) ; String [ ] arr = new String [ node . size ( ) ] ; for ( int i = 0 ; i < node . size ( ) ; i + + ) { try { arr [ i ] = mapper . treeToValue ( node . get ( i ) , String . class ) ; } catch ( JsonProcessingException e ) { throw new JWTException ( " Couldn't map the Claim's array contents to String " , e ) ; } } return arr ; }
private Date getDate ( Map < String , JsonNode > tree , String claimName ) { JsonNode node = tree . get ( claimName ) ; if ( node = = null | | node . isNull ( ) | | ! node . canConvertToLong ( ) ) { return null ; } final long ms = node . asLong ( ) * 1000 ; return new Date ( ms ) ; }
private String getString ( Map < String , JsonNode > tree , String claimName ) { JsonNode node = tree . get ( claimName ) ; if ( node = = null | | node . isNull ( ) ) { return null ; } return node . asText ( null ) ; }
public void shouldValidateIssuer ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( ) . withIssuer ( " auth0 " ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidIssuer ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'iss' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( ) . withIssuer ( " invalid " )
public void shouldValidateSubject ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.Rq8IxqeX7eA6GgYxlcHdPFVRNFFZc5rEI3MQTZZbK3I " ; JWT jwt = JWTVerifier . init ( ) . withSubject ( " 1234567890 " ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidSubject ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'sub' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.Rq8IxqeX7eA6GgYxlcHdPFVRNFFZc5rEI3MQTZZbK3I " ; JWTVerifier . init ( ) . withSubject ( " invalid " )
public void shouldValidateAudience ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJNYXJrIn0.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( ) . withAudience ( new String [ ] { " Mark " } ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; String tokenArr = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsiTWFyayIsIkRhdmlkIl19.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwtArr = JWTVerifier . init ( ) . withAudience ( new String [ ] { " Mark " , " David " } ) . verify ( tokenArr ) ; assertThat ( jwtArr , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidAudience ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'aud' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.Rq8IxqeX7eA6GgYxlcHdPFVRNFFZc5rEI3MQTZZbK3I " ; JWTVerifier . init ( ) . withAudience ( new String [ ] { " nope " } )
public void shouldValidateExpiresAt ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( ) . withExpiresAt ( new Date ( 1477592000 ) ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidExpiresAt ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'exp' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( ) . withExpiresAt ( new Date ( ) )
public void shouldValidateNotBefore ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( ) . withNotBefore ( new Date ( 1477592000 ) ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidNotBefore ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'nbf' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( ) . withNotBefore ( new Date ( ) )
public void shouldValidateIssuedAt ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( ) . withIssuedAt ( new Date ( 1477592000 ) ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidIssuedAt ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'iat' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( ) . withIssuedAt ( new Date ( ) )
public void shouldValidateJWTId ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJqd3RfaWRfMTIzIn0.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( ) . withJWTId ( " jwt_id_123 " ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidJWTId ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'jti' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJqd3RfaWRfMTIzIn0.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( ) . withJWTId ( " invalid " )
public void shouldSkipClaimValidationsIfNoClaimsRequired ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
private void parseToken ( String token ) throws JWTException { final String [ ] parts = Utils . splitToken ( token ) ; final JWTParser converter = new JWTParser ( ) ; header = converter . parseHeader ( base64Decode ( parts [ 0 ] ) ) ; payload = converter . parsePayload ( base64Decode ( parts [ 1 ] ) ) ; signature = parts [ 2 ] ; }
public Algorithm getAlgorithm ( ) { return header . getAlgorithm ( ) ; }
public static String base64Decode ( String string ) throws JWTException { String decoded ; try { decoded = StringUtils . newStringUtf8 ( Base64 . decodeBase64 ( string ) ) ; } catch ( NullPointerException e ) { throw new JWTException ( " Received bytes didn't correspond to a valid Base64 encoded string. " , e ) ; } return decoded ; }
public static String base64Encode ( String string ) throws JWTException { String encoded ; try { encoded = StringUtils . newStringUtf8 ( Base64 . encodeBase64 ( string . getBytes ( ) , false , true ) ) ; } catch ( NullPointerException e ) { throw new JWTException ( " Received bytes didn't correspond to a valid Base64 encoded string. " , e ) ; } return encoded ; }
public static boolean verifyHS ( String [ ] jwtParts , String secret , Algorithm algorithm ) throws NoSuchAlgorithmException , InvalidKeyException { if ( secret = = null ) { throw new IllegalArgumentException ( " The Secret cannot be null " ) ; } if ( algorithm ! = Algorithm . HS256 & & algorithm ! = Algorithm . HS384 & & algorithm ! = Algorithm . HS512 ) { throw new IllegalArgumentException ( " The Algorithm must be one of HS256, HS384, or HS512. " ) ; } Mac mac = Mac . getInstance ( algorithm . toString ( ) ) ; mac . init ( new SecretKeySpec ( secret . getBytes ( ) , algorithm . toString ( ) ) ) ; String message = String . format ( " %s.%s " , jwtParts [ 0 ] , jwtParts [ 1 ] ) ; byte [ ] result = mac . doFinal ( message . getBytes ( ) ) ; return MessageDigest . isEqual ( result , Base64 . decodeBase64 ( jwtParts [ 2 ] ) ) ; }
public static String [ ] splitToken ( String token ) { String [ ] parts = token . split ( " \\ . " ) ; if ( parts . length ! = 3 ) { throw new JWTException ( String . format ( " The token was expected to have 3 parts, but got %s. " , parts . length ) ) ; } return parts ; }
public String toString ( ) { return description ; }
public static Algorithm parseFrom ( String algorithmName ) { try { return Algorithm . valueOf ( algorithmName ) ;
public Algorithm getAlgorithm ( ) { String alg = extractClaim ( ALGORITHM , tree ) . asString ( ) ; return Algorithm . parseFrom ( alg ) ; }
public static JWTVerifier init ( Algorithm algorithm , String secret ) throws IllegalArgumentException { if ( algorithm = = null ) { throw new IllegalArgumentException ( " The Algorithm cannot be null. " ) ; } switch ( algorithm ) { case HS256 : case HS384 : case HS512 : if ( secret = = null ) { throw new IllegalArgumentException ( String . format ( " You can't use the %s algorithm without providing a valid Secret. " , algorithm . name ( ) ) ) ; } break ; default : } return new JWTVerifier ( algorithm , secret ) ; }
public JWT verify ( String token ) throws JWTException { JWT jwt = JWTDecoder . decode ( token ) ; verifyClaims ( jwt , claims ) ; verifyAlgorithm ( jwt , algorithm ) ; verifySignature ( Utils . splitToken ( token ) ) ; return jwt ; }
private void verifySignature ( String [ ] parts ) { switch ( algorithm ) { case HS256 :
private void verifyAlgorithm ( JWT jwt , Algorithm expectedAlgorithm ) throws AlgorithmMismatchException , IllegalArgumentException { if ( ! expectedAlgorithm . equals ( jwt . getAlgorithm ( ) ) ) { throw new AlgorithmMismatchException ( " The provided Algorithm doesn't match the one defined in the JWT's Header. " ) ;
Algorithm getAlgorithm ( ) ; @Nullable String getType ( ) ; @Nullable String getContentType ( ) ; }
public void shouldGetHeader ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.e30.XmNK3GpH3Ys_7wsYBfq4C3M6goz71I7dTgUkuIa5lyQ " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getAlgorithm ( ) , is ( Algorithm . HS256 ) ) ; }
public void shouldDecodeBase64 ( ) throws Exception { String source = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 " ; String result = Utils . base64Decode ( source ) ; assertThat ( result , is ( notNullValue ( ) ) ) ; assertThat ( result , is ( " { \" alg \" : \" HS256 \" , \" typ \" : \" JWT \" } " ) ) ; }
public void shouldEncodeBase64 ( ) throws Exception { String source = " { \" alg \" : \" HS256 \" , \" typ \" : \" JWT \" } " ; String result = Utils . base64Encode ( source ) ; assertThat ( result , is ( notNullValue ( ) ) ) ; assertThat ( result , is ( " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 " ) ) ; }
public void shouldPassHS256Verification ( ) throws Exception { String jwt = " eyJhbGciOiJIUzI1NiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mZ0m_N1J4PgeqWmi903JuUoDRZDBPB7HwkS4nVyWH1M " ; assertTrue ( Utils . verifyHS ( jwt . split ( " \\ . " ) , " secret " , Algorithm . HS256 ) ) ; }
public void shouldFailHS256VerificationWithInvalidSecret ( ) throws Exception { String jwt = " eyJhbGciOiJIUzI1NiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mZ0m_N1J4PgeqWmi903JuUoDRZDBPB7HwkS4nVyWH1M " ; assertFalse ( Utils . verifyHS ( jwt . split ( " \\ . " ) , " not_real_secret " , Algorithm . HS256 ) ) ; }
public void shouldThrowHS256VerificationWithNullSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Secret cannot be null " ) ; String jwt = " eyJhbGciOiJIUzI1NiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mZ0m_N1J4PgeqWmi903JuUoDRZDBPB7HwkS4nVyWH1M " ; Utils . verifyHS ( jwt . split ( " \\ . " ) , null , Algorithm . HS256 ) ; }
public void shouldPassHS384Verification ( ) throws Exception { String jwt = " eyJhbGciOiJIUzM4NCIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.uztpK_wUMYJhrRv8SV-1LU4aPnwl-EM1q-wJnqgyb5DHoDteP6lN_gE1xnZJH5vw " ; assertTrue ( Utils . verifyHS ( jwt . split ( " \\ . " ) , " secret " , Algorithm . HS384 ) ) ; }
public void shouldFailHS384VerificationWithInvalidSecret ( ) throws Exception { String jwt = " eyJhbGciOiJIUzM4NCIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.uztpK_wUMYJhrRv8SV-1LU4aPnwl-EM1q-wJnqgyb5DHoDteP6lN_gE1xnZJH5vw " ; assertFalse ( Utils . verifyHS ( jwt . split ( " \\ . " ) , " not_real_secret " , Algorithm . HS384 ) ) ; }
public void shouldThrowHS384VerificationWithNullSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Secret cannot be null " ) ; String jwt = " eyJhbGciOiJIUzM4NCIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.uztpK_wUMYJhrRv8SV-1LU4aPnwl-EM1q-wJnqgyb5DHoDteP6lN_gE1xnZJH5vw " ; Utils . verifyHS ( jwt . split ( " \\ . " ) , null , Algorithm . HS384 ) ; }
public void shouldPassHS512Verification ( ) throws Exception { String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; assertTrue ( Utils . verifyHS ( jwt . split ( " \\ . " ) , " secret " , Algorithm . HS512 ) ) ; }
public void shouldFailHS512VerificationWithInvalidSecret ( ) throws Exception { String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; assertFalse ( Utils . verifyHS ( jwt . split ( " \\ . " ) , " not_real_secret " , Algorithm . HS512 ) ) ; }
public void shouldThrowHS512VerificationWithNullSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Secret cannot be null " ) ; String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; Utils . verifyHS ( jwt . split ( " \\ . " ) , null , Algorithm . HS512 ) ; }
public void shouldThrowWhenAlgorithmIsNotHS ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm must be one of HS256, HS384, or HS512. " ) ; String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; Utils . verifyHS ( jwt . split ( " \\ . " ) , " secret " , Algorithm . none ) ; }
public void shouldThrowWhenAlgorithmIsNull ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm must be one of HS256, HS384, or HS512. " ) ; String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; Utils . verifyHS ( jwt . split ( " \\ . " ) , " secret " , null ) ; }
public void shouldThrowWhenInitializedWithoutAlgorithm ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm cannot be null " ) ; JWTVerifier . init ( null , " secret " ) ; }
public void shouldThrowWhenInitializedWithHS256AlgorithmWithoutSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " You can't use the HS256 algorithm without providing a valid Secret. " ) ; JWTVerifier . init ( Algorithm . HS256 , null ) ; }
public void shouldThrowWhenInitializedWithHS384AlgorithmWithoutSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " You can't use the HS384 algorithm without providing a valid Secret. " ) ; JWTVerifier . init ( Algorithm . HS384 , null ) ; }
public void shouldThrowWhenInitializedWithHS512AlgorithmWithoutSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " You can't use the HS512 algorithm without providing a valid Secret. " ) ; JWTVerifier . init ( Algorithm . HS512 , null ) ; }
public void shouldValidateIssuer ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withIssuer ( " auth0 " ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidIssuer ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'iss' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withIssuer ( " invalid " )
public void shouldValidateSubject ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.Rq8IxqeX7eA6GgYxlcHdPFVRNFFZc5rEI3MQTZZbK3I " ; JWT jwt = JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withSubject ( " 1234567890 " ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidSubject ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'sub' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.Rq8IxqeX7eA6GgYxlcHdPFVRNFFZc5rEI3MQTZZbK3I " ; JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withSubject ( " invalid " )
public void shouldValidateAudience ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJNYXJrIn0.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withAudience ( new String [ ] { " Mark " } ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; String tokenArr = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsiTWFyayIsIkRhdmlkIl19.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwtArr = JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withAudience ( new String [ ] { " Mark " , " David " } ) . verify ( tokenArr ) ; assertThat ( jwtArr , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidAudience ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'aud' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.Rq8IxqeX7eA6GgYxlcHdPFVRNFFZc5rEI3MQTZZbK3I " ; JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withAudience ( new String [ ] { " nope " } )
public void shouldValidateExpiresAt ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withExpiresAt ( new Date ( 1477592000 ) ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidExpiresAt ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'exp' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withExpiresAt ( new Date ( ) )
public void shouldValidateNotBefore ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withNotBefore ( new Date ( 1477592000 ) ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidNotBefore ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'nbf' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withNotBefore ( new Date ( ) )
public void shouldValidateIssuedAt ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withIssuedAt ( new Date ( 1477592000 ) ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidIssuedAt ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'iat' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withIssuedAt ( new Date ( ) )
public void shouldValidateJWTId ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJqd3RfaWRfMTIzIn0.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withJWTId ( " jwt_id_123 " ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidJWTId ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'jti' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJqd3RfaWRfMTIzIn0.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( Algorithm . HS256 , " secret " ) . withJWTId ( " invalid " )
public void shouldSkipClaimValidationsIfNoClaimsRequired ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( Algorithm . HS256 , " secret " ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public static String [ ] splitToken ( String token ) { String [ ] parts = token . split ( " \\ . " ) ; if ( parts . length = = 2 & & token . endsWith ( " . " ) ) { //Tokens with alg='none' have empty String as Signature. parts = new String[]{parts[0], parts[1], ""}; } if (parts.length != 3) { throw new JWTException(String.format("The token was expected to have 3 parts, but got %s.", parts.length)); } return parts; }
public static JWTVerifier init ( ) throws IllegalArgumentException { return init ( Algorithm . none , null ) ; }
public static JWTVerifier init ( Algorithm algorithm , String secret ) throws IllegalArgumentException { if ( algorithm = = null ) { throw new IllegalArgumentException ( " The Algorithm cannot be null. " ) ; } switch ( algorithm ) { case HS256 : case HS384 : case HS512 : if ( secret = = null ) { throw new IllegalArgumentException ( String . format ( " You can't use the %s algorithm without providing a valid Secret. " , algorithm . name ( ) ) ) ; } break ; case none : if ( secret ! = null ) { throw new IllegalArgumentException ( " You can't use the Algorithm 'none' with a non-null Secret. " ) ; } default : } return new JWTVerifier ( algorithm , secret ) ; }
public void shouldSplitToken ( ) throws Exception { String token = " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJhdXRoMCJ9.W1mx_Y0hbAMbPmfW9whT605AAcxB7REFuJiDAHk2Sdc " ; String [ ] parts = Utils . splitToken ( token ) ; assertThat ( parts , is ( notNullValue ( ) ) ) ; assertThat ( parts , is ( arrayWithSize ( 3 ) ) ) ; assertThat ( parts [ 0 ] , is ( " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0 " ) ) ; assertThat ( parts [ 1 ] , is ( " eyJpc3MiOiJhdXRoMCJ9 " ) ) ; assertThat ( parts [ 2 ] , is ( " W1mx_Y0hbAMbPmfW9whT605AAcxB7REFuJiDAHk2Sdc " ) ) ; }
public void shouldSplitTokenWithEmptySignature ( ) throws Exception { String token = " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJhdXRoMCJ9. " ; String [ ] parts = Utils . splitToken ( token ) ; assertThat ( parts , is ( notNullValue ( ) ) ) ; assertThat ( parts , is ( arrayWithSize ( 3 ) ) ) ; assertThat ( parts [ 0 ] , is ( " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0 " ) ) ; assertThat ( parts [ 1 ] , is ( " eyJpc3MiOiJhdXRoMCJ9 " ) ) ; assertThat ( parts [ 2 ] , is ( isEmptyString ( ) ) ) ; }
public void shouldThrowOnSplitTokenWithMoreThan3Parts ( ) throws Exception { exception . expect ( JWTException . class ) ; exception . expectMessage ( " The token was expected to have 3 parts, but got 4. " ) ; String token = " this.has.four.parts " ; Utils . splitToken ( token ) ; }
public void shouldThrowOnSplitTokenWithLessThan3Parts ( ) throws Exception { exception . expect ( JWTException . class ) ; exception . expectMessage ( " The token was expected to have 3 parts, but got 2. " ) ; String token = " two.parts " ; Utils . splitToken ( token ) ; }
public void shouldAcceptNoneAlgorithmWhenUsingDefaultConstructor ( ) throws Exception { String token = " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJhdXRoMCJ9. " ; JWT jwt = JWTVerifier . init ( ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldAcceptNoneAlgorithm ( ) throws Exception { String token = " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJhdXRoMCJ9. " ; JWT jwt = JWTVerifier . init ( Algorithm . none , null ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowWhenUsingNoneAlgorithmAndPassingASecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " You can't use the Algorithm 'none' with a non-null Secret. " ) ; String token = " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJhdXRoMCJ9. " ; JWTVerifier . init ( Algorithm . none , " something " ) . verify ( token ) ;
public Claim getClaim ( String name ) { return payload . getClaim ( name ) ; }
public static Claim extractClaim ( String claimName , Map < String , JsonNode > tree ) { JsonNode node = tree . get ( claimName ) ; return claimFromNode ( node ) ; }
public Claim getClaim ( String name ) { return extractClaim ( name , tree ) ; }
boolean isNull ( ) ; /** * Get this Claim as a Boolean. * If the value isn't of type Boolean or it can't be converted to a Boolean, null will be returned. * * @return the value as a Boolean or null. */ Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
Boolean asBoolean ( ) ; /** * Get this Claim as an Integer. * If the value isn't of type Integer or it can't be converted to an Integer, null will be returned. * * @return the value as an Integer or null. */ Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
Integer asInt ( ) ; /** * Get this Claim as a Double. * If the value isn't of type Double or it can't be converted to a Double, null will be returned. * * @return the value as a Double or null. */ Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
Double asDouble ( ) ; /** * Get this Claim as a String. * If the value isn't of type String or it can't be converted to a String, null will be returned. * * @return the value as a String or null. */ String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
String asString ( ) ; /** * Get this Claim as a Date. * If the value can't be converted to a Date, null will be returned. * * @return the value as a Date or null. */ Date asDate ( ) ; /** * Get this Claim as an Array of type T. * If the value isn't an Array, an empty Array will be returned. * * @return the value as an Array or an empty Array. * @throws Exception if the values inside the Array can't be converted to a class T. */ < T > T [ ] asArray ( Class < T > tClazz ) throws JWTException ; /** * Get this Claim as a List of type T. * If the value isn't an Array, an empty List will be returned. * * @return the value as a List or an empty List. * @throws Exception if the values inside the List can't be converted to a class T. */ < T > List < T > asList ( Class < T > tClazz ) throws JWTException ; }
Algorithm getAlgorithm ( ) ; String getType ( ) ; String getContentType ( ) ; }
String getIssuer ( ) ; /** * Get the value of the "sub" claim, or null if it's not available. * * @return the Subject value or null. */ String getSubject ( ) ; /** * Get the value of the "aud" claim, or null if it's not available. * * @return the Audience value or null. */ String [ ] getAudience ( ) ; /** * Get the value of the "exp" claim, or null if it's not available. * * @return the Expiration Time value or null. */ Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ Claim getClaim ( String name ) ; }
String getSubject ( ) ; /** * Get the value of the "aud" claim, or null if it's not available. * * @return the Audience value or null. */ String [ ] getAudience ( ) ; /** * Get the value of the "exp" claim, or null if it's not available. * * @return the Expiration Time value or null. */ Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ Claim getClaim ( String name ) ; }
String [ ] getAudience ( ) ; /** * Get the value of the "exp" claim, or null if it's not available. * * @return the Expiration Time value or null. */ Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ Claim getClaim ( String name ) ; }
Date getExpiresAt ( ) ; /** * Get the value of the "nbf" claim, or null if it's not available. * * @return the Not Before value or null. */ Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ Claim getClaim ( String name ) ; }
Date getNotBefore ( ) ; /** * Get the value of the "iat" claim, or null if it's not available. * * @return the Issued At value or null. */ Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ Claim getClaim ( String name ) ; }
Date getIssuedAt ( ) ; /** * Get the value of the "jti" claim, or null if it's not available. * * @return the Payload ID value or null. */ String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ Claim getClaim ( String name ) ; }
String getId ( ) ; /** * Get a Private Claim given it's name. If the Claim wasn't specified in the Payload payload, null will be returned. * * @param name the name of the Claim to retrieve. * @return the Claim if found or null. */ Claim getClaim ( String name ) ; }
private JWT customTimeJWT ( Long iat , Long exp ) { String header = base64Encode ( " {} " ) ; StringBuilder bodyBuilder = new StringBuilder ( " { " ) ; if ( iat ! = null ) { bodyBuilder . append ( " \" iat \" : \" " ) . append ( iat . longValue ( ) ) . append ( " \" " ) ; } if ( exp ! = null ) { if ( iat ! = null ) { bodyBuilder . append ( " , " ) ; } bodyBuilder . append ( " \" exp \" : \" " ) . append ( exp . longValue ( ) ) . append ( " \" " ) ; } bodyBuilder . append ( " } " ) ; String body = base64Encode ( bodyBuilder . toString ( ) ) ; String signature = " sign " ; return JWTDecoder . decode ( String . format ( " %s.%s.%s " , header , body , signature ) ) ; }
public static boolean verifyRS ( String [ ] jwtParts , PublicKey publicKey , Algorithm algorithm ) throws InvalidKeyException , NoSuchAlgorithmException , SignatureException { if ( publicKey = = null ) { throw new IllegalArgumentException ( " The PublicKey cannot be null " ) ; } if ( algorithm ! = Algorithm . RS256 & & algorithm ! = Algorithm . RS384 & & algorithm ! = Algorithm . RS512 ) { throw new IllegalArgumentException ( " The Algorithm must be one of RS256, RS384, or RS512. " ) ; } final String content = String . format ( " %s.%s " , jwtParts [ 0 ] , jwtParts [ 1 ] ) ; Signature s = Signature . getInstance ( algorithm . toString ( ) ) ; s . initVerify ( publicKey ) ; s . update ( content . getBytes ( ) ) ; return s . verify ( Base64 . decodeBase64 ( jwtParts [ 2 ] ) ) ; }
public static JWTVerifier init ( Algorithm algorithm , String secret ) throws IllegalArgumentException { if ( algorithm = = null ) { throw new IllegalArgumentException ( " The Algorithm cannot be null. " ) ; } switch ( algorithm ) { case HS256 : case HS384 : case HS512 : if ( secret = = null ) { throw new IllegalArgumentException ( String . format ( " You can't use the %s algorithm without providing a valid Secret. " , algorithm . name ( ) ) ) ; } break ; case none : if ( secret ! = null ) { throw new IllegalArgumentException ( " You can't use the Algorithm 'none' with a non-null Secret. " ) ; } default : } return new JWTVerifier ( algorithm , secret , null ) ; }
public static byte [ ] parsePEMFile ( File pemFile ) throws IOException { if ( ! pemFile . isFile ( ) | | ! pemFile . exists ( ) ) { throw new FileNotFoundException ( String . format ( " The file '%s' doesn't exist. " , pemFile . getAbsolutePath ( ) ) ) ; } PemReader reader = new PemReader ( new FileReader ( pemFile ) ) ; PemObject pemObject = reader . readPemObject ( ) ; return pemObject . getContent ( ) ; }
public static PublicKey getPublicKey ( byte [ ] keyBytes , String algorithm ) { PublicKey publicKey = null ; try { KeyFactory kf = KeyFactory . getInstance ( algorithm ) ; EncodedKeySpec keySpec = new X509EncodedKeySpec ( keyBytes ) ; publicKey = kf . generatePublic ( keySpec ) ; } catch ( NoSuchAlgorithmException e ) { System . out . println ( " Could not reconstruct the public key, the given algorithm oculd not be found. " ) ; } catch ( InvalidKeySpecException e ) { System . out . println ( " Could not reconstruct the public key " ) ; } return publicKey ; }
public void shouldThrowWhenHSAlgorithmIsNull ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm must be one of HS256, HS384, or HS512. " ) ; String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; Utils . verifyHS ( jwt . split ( " \\ . " ) , " secret " , null ) ; }
public void shouldPassRS256Verification ( ) throws Exception { PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; assertTrue ( Utils . verifyRS ( jwt . split ( " \\ . " ) , key , Algorithm . RS256 ) ) ; }
public void shouldFailRS256VerificationWithInvalidPublicKey ( ) throws Exception { PublicKey key = readInvalidPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; assertFalse ( Utils . verifyRS ( jwt . split ( " \\ . " ) , key , Algorithm . RS256 ) ) ; }
public void shouldThrowRS256VerificationWithNullPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The PublicKey cannot be null " ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; ; Utils . verifyRS ( jwt . split ( " \\ . " ) , null , Algorithm . RS256 ) ; }
public void shouldPassRS384Verification ( ) throws Exception { PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.TZlWjXObwGSQOiu2oMq8kiKz0_BR7bbBddNL6G8eZ_GoR82BXOZDqNrQr7lb_M-78XGBguWLWNIdYhzgxOUL9EoCJlrqVm9s9vo6G8T1sj1op-4TbjXZ61TwIvrJee9BvPLdKUJ9_fp1Js5kl6yXkst40Th8Auc5as4n49MLkipjpEhKDKaENKHpSubs1ripSz8SCQZSofeTM_EWVwSw7cpiM8Fy8jOPvWG8Xz4-e3ODFowvHVsDcONX_4FTMNbeRqDuHq2ZhCJnEfzcSJdrve_5VD5fM1LperBVslTrOxIgClOJ3RmM7-WnaizJrWP3D6Z9OLxPxLhM6-jx6tcxEw " ; assertTrue ( Utils . verifyRS ( jwt . split ( " \\ . " ) , key , Algorithm . RS384 ) ) ; }
public void shouldFailRS384VerificationWithInvalidPublicKey ( ) throws Exception { PublicKey key = readInvalidPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.TZlWjXObwGSQOiu2oMq8kiKz0_BR7bbBddNL6G8eZ_GoR82BXOZDqNrQr7lb_M-78XGBguWLWNIdYhzgxOUL9EoCJlrqVm9s9vo6G8T1sj1op-4TbjXZ61TwIvrJee9BvPLdKUJ9_fp1Js5kl6yXkst40Th8Auc5as4n49MLkipjpEhKDKaENKHpSubs1ripSz8SCQZSofeTM_EWVwSw7cpiM8Fy8jOPvWG8Xz4-e3ODFowvHVsDcONX_4FTMNbeRqDuHq2ZhCJnEfzcSJdrve_5VD5fM1LperBVslTrOxIgClOJ3RmM7-WnaizJrWP3D6Z9OLxPxLhM6-jx6tcxEw " ; assertFalse ( Utils . verifyRS ( jwt . split ( " \\ . " ) , key , Algorithm . RS384 ) ) ; }
public void shouldThrowRS384VerificationWithNullPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The PublicKey cannot be null " ) ; String jwt = " eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.TZlWjXObwGSQOiu2oMq8kiKz0_BR7bbBddNL6G8eZ_GoR82BXOZDqNrQr7lb_M-78XGBguWLWNIdYhzgxOUL9EoCJlrqVm9s9vo6G8T1sj1op-4TbjXZ61TwIvrJee9BvPLdKUJ9_fp1Js5kl6yXkst40Th8Auc5as4n49MLkipjpEhKDKaENKHpSubs1ripSz8SCQZSofeTM_EWVwSw7cpiM8Fy8jOPvWG8Xz4-e3ODFowvHVsDcONX_4FTMNbeRqDuHq2ZhCJnEfzcSJdrve_5VD5fM1LperBVslTrOxIgClOJ3RmM7-WnaizJrWP3D6Z9OLxPxLhM6-jx6tcxEw " ; ; Utils . verifyRS ( jwt . split ( " \\ . " ) , null , Algorithm . RS384 ) ; }
public void shouldPassRS512Verification ( ) throws Exception { PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mvL5LoMyIrWYjk5umEXZTmbyIrkbbcVPUkvdGZbu0qFBxGOf0nXP5PZBvPcOu084lvpwVox5n3VaD4iqzW-PsJyvKFgi5TnwmsbKchAp7JexQEsQOnTSGcfRqeUUiBZqRQdYsho71oAB3T4FnalDdFEpM-fztcZY9XqKyayqZLreTeBjqJm4jfOWH7KfGBHgZExQhe96NLq1UA9eUyQwdOA1Z0SgXe4Ja5PxZ6Fm37KnVDtDlNnY4JAAGFo6y74aGNnp_BKgpaVJCGFu1f1S5xCQ1HSvs8ZSdVWs5NgawW3wRd0kRt_GJ_Y3mIwiF4qUyHWGtsSHu_qjVdCTtbFyow " ; assertTrue ( Utils . verifyRS ( jwt . split ( " \\ . " ) , key , Algorithm . RS512 ) ) ; }
public void shouldFailRS512VerificationWithInvalidPublicKey ( ) throws Exception { PublicKey key = readInvalidPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mvL5LoMyIrWYjk5umEXZTmbyIrkbbcVPUkvdGZbu0qFBxGOf0nXP5PZBvPcOu084lvpwVox5n3VaD4iqzW-PsJyvKFgi5TnwmsbKchAp7JexQEsQOnTSGcfRqeUUiBZqRQdYsho71oAB3T4FnalDdFEpM-fztcZY9XqKyayqZLreTeBjqJm4jfOWH7KfGBHgZExQhe96NLq1UA9eUyQwdOA1Z0SgXe4Ja5PxZ6Fm37KnVDtDlNnY4JAAGFo6y74aGNnp_BKgpaVJCGFu1f1S5xCQ1HSvs8ZSdVWs5NgawW3wRd0kRt_GJ_Y3mIwiF4qUyHWGtsSHu_qjVdCTtbFyow " ; assertFalse ( Utils . verifyRS ( jwt . split ( " \\ . " ) , key , Algorithm . RS512 ) ) ; }
public void shouldThrowRS512VerificationWithNullPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The PublicKey cannot be null " ) ; String jwt = " eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mvL5LoMyIrWYjk5umEXZTmbyIrkbbcVPUkvdGZbu0qFBxGOf0nXP5PZBvPcOu084lvpwVox5n3VaD4iqzW-PsJyvKFgi5TnwmsbKchAp7JexQEsQOnTSGcfRqeUUiBZqRQdYsho71oAB3T4FnalDdFEpM-fztcZY9XqKyayqZLreTeBjqJm4jfOWH7KfGBHgZExQhe96NLq1UA9eUyQwdOA1Z0SgXe4Ja5PxZ6Fm37KnVDtDlNnY4JAAGFo6y74aGNnp_BKgpaVJCGFu1f1S5xCQ1HSvs8ZSdVWs5NgawW3wRd0kRt_GJ_Y3mIwiF4qUyHWGtsSHu_qjVdCTtbFyow " ; ; Utils . verifyRS ( jwt . split ( " \\ . " ) , null , Algorithm . RS512 ) ; }
public void shouldThrowWhenAlgorithmIsNotRS ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm must be one of RS256, RS384, or RS512. " ) ; PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; Utils . verifyRS ( jwt . split ( " \\ . " ) , key , Algorithm . none ) ; }
public void shouldThrowWhenRSAlgorithmIsNull ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm must be one of RS256, RS384, or RS512. " ) ; PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; Utils . verifyRS ( jwt . split ( " \\ . " ) , key , null ) ; }
private PublicKey readPublicKey ( ) throws IOException { byte [ ] bytes = PemUtils . parsePEMFile ( new File ( PUBLIC_KEY_FILE ) ) ; return PemUtils . getPublicKey ( bytes , " RSA " ) ; }
private PublicKey readInvalidPublicKey ( ) throws IOException { byte [ ] bytes = PemUtils . parsePEMFile ( new File ( INVALID_PUBLIC_KEY_FILE ) ) ; return PemUtils . getPublicKey ( bytes , " RSA " ) ; }
public void shouldReadPemFile ( ) throws Exception { File pemFile = new File ( PUBLIC_KEY_FILE ) ; byte [ ] bytes = PemUtils . parsePEMFile ( pemFile ) ; PublicKey rsaKey = PemUtils . getPublicKey ( bytes , " RSA " ) ; String stringValue = new String ( rsaKey . getEncoded ( ) , StandardCharsets . UTF_8 ) ; Assert . assertThat ( stringValue , is ( PUBLIC_KEY_CONTENT ) ) ; }
public static boolean verifyHS ( HSAlgorithm algorithm , String [ ] jwtParts , String secret ) throws NoSuchAlgorithmException , InvalidKeyException { if ( secret = = null ) { throw new IllegalArgumentException ( " The Secret cannot be null " ) ; } if ( algorithm = = null ) { throw new IllegalArgumentException ( " The Algorithm must be one of HS256, HS384, or HS512. " ) ; } Mac mac = Mac . getInstance ( algorithm . describe ( ) ) ; mac . init ( new SecretKeySpec ( secret . getBytes ( ) , algorithm . describe ( ) ) ) ; String message = String . format ( " %s.%s " , jwtParts [ 0 ] , jwtParts [ 1 ] ) ; byte [ ] result = mac . doFinal ( message . getBytes ( ) ) ; return MessageDigest . isEqual ( result , Base64 . decodeBase64 ( jwtParts [ 2 ] ) ) ; }
public static boolean verifyRS ( RSAlgorithm algorithm , String [ ] jwtParts , PublicKey publicKey ) throws InvalidKeyException , NoSuchAlgorithmException , SignatureException { if ( publicKey = = null ) { throw new IllegalArgumentException ( " The PublicKey cannot be null " ) ; } if ( algorithm = = null ) { throw new IllegalArgumentException ( " The Algorithm must be one of RS256, RS384, or RS512. " ) ; } final String content = String . format ( " %s.%s " , jwtParts [ 0 ] , jwtParts [ 1 ] ) ; Signature s = Signature . getInstance ( algorithm . describe ( ) ) ; s . initVerify ( publicKey ) ; s . update ( content . getBytes ( ) ) ; return s . verify ( Base64 . decodeBase64 ( jwtParts [ 2 ] ) ) ; }
public String describe ( ) { return description ; }
public static Algorithm resolveFrom ( String name ) { try { return valueOf ( name ) ;
public Algorithm getAlgorithm ( ) { String alg = extractClaim ( ALGORITHM , tree ) . asString ( ) ; return parseFrom ( alg ) ; }
private Algorithm parseFrom ( String algorithmName ) { Algorithm algorithm = RSAlgorithm . resolveFrom ( algorithmName ) ; if ( algorithm = = null ) { algorithm = HSAlgorithm . resolveFrom ( algorithmName ) ; } if ( algorithm = = null ) { algorithm = NoneAlgorithm . resolveFrom ( algorithmName ) ; } return algorithm ; }
public static JWTVerifier init ( ) throws IllegalArgumentException { return init ( none , null , null ) ; }
public static JWTVerifier init ( HSAlgorithm algorithm , String secret ) throws IllegalArgumentException { return init ( algorithm , null , secret ) ; }
public static JWTVerifier init ( RSAlgorithm algorithm , PublicKey publicKey ) throws IllegalArgumentException { return init ( algorithm , publicKey , null ) ; }
private static JWTVerifier init ( Algorithm algorithm , PublicKey publicKey , String secret ) throws IllegalArgumentException { if ( algorithm = = null ) { throw new IllegalArgumentException ( " The Algorithm cannot be null. " ) ; } if ( algorithm instanceof HSAlgorithm & & secret = = null ) { throw new IllegalArgumentException ( String . format ( " You can't use the %s algorithm without providing a valid Secret. " , algorithm . name ( ) ) ) ; } if ( algorithm instanceof RSAlgorithm & & publicKey = = null ) { throw new IllegalArgumentException ( String . format ( " You can't use the %s algorithm without providing a valid PublicKey. " , algorithm . name ( ) ) ) ; } return new JWTVerifier ( algorithm , secret , publicKey ) ; }
public JWT verify ( String token ) throws JWTException { JWT jwt = JWTDecoder . decode ( token ) ; verifyAlgorithm ( jwt , algorithm ) ; verifySignature ( Utils . splitToken ( token ) ) ; verifyClaims ( jwt , claims ) ; return jwt ; }
private void verifySignature ( String [ ] parts ) { if ( algorithm instanceof HSAlgorithm ) { try {
public void shouldGetHeader ( ) throws Exception { JWT jwt = JWTDecoder . decode ( " eyJhbGciOiJIUzI1NiJ9.e30.XmNK3GpH3Ys_7wsYBfq4C3M6goz71I7dTgUkuIa5lyQ " ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; assertThat ( jwt . getAlgorithm ( ) , is ( HSAlgorithm . HS256 ) ) ; }
public void shouldPassHS256Verification ( ) throws Exception { String jwt = " eyJhbGciOiJIUzI1NiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mZ0m_N1J4PgeqWmi903JuUoDRZDBPB7HwkS4nVyWH1M " ; assertTrue ( Utils . verifyHS ( HSAlgorithm . HS256 , jwt . split ( " \\ . " ) , " secret " ) ) ; }
public void shouldFailHS256VerificationWithInvalidSecret ( ) throws Exception { String jwt = " eyJhbGciOiJIUzI1NiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mZ0m_N1J4PgeqWmi903JuUoDRZDBPB7HwkS4nVyWH1M " ; assertFalse ( Utils . verifyHS ( HSAlgorithm . HS256 , jwt . split ( " \\ . " ) , " not_real_secret " ) ) ; }
public void shouldThrowHS256VerificationWithNullSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Secret cannot be null " ) ; String jwt = " eyJhbGciOiJIUzI1NiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mZ0m_N1J4PgeqWmi903JuUoDRZDBPB7HwkS4nVyWH1M " ; Utils . verifyHS ( HSAlgorithm . HS256 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldPassHS384Verification ( ) throws Exception { String jwt = " eyJhbGciOiJIUzM4NCIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.uztpK_wUMYJhrRv8SV-1LU4aPnwl-EM1q-wJnqgyb5DHoDteP6lN_gE1xnZJH5vw " ; assertTrue ( Utils . verifyHS ( HSAlgorithm . HS384 , jwt . split ( " \\ . " ) , " secret " ) ) ; }
public void shouldFailHS384VerificationWithInvalidSecret ( ) throws Exception { String jwt = " eyJhbGciOiJIUzM4NCIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.uztpK_wUMYJhrRv8SV-1LU4aPnwl-EM1q-wJnqgyb5DHoDteP6lN_gE1xnZJH5vw " ; assertFalse ( Utils . verifyHS ( HSAlgorithm . HS384 , jwt . split ( " \\ . " ) , " not_real_secret " ) ) ; }
public void shouldThrowHS384VerificationWithNullSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Secret cannot be null " ) ; String jwt = " eyJhbGciOiJIUzM4NCIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.uztpK_wUMYJhrRv8SV-1LU4aPnwl-EM1q-wJnqgyb5DHoDteP6lN_gE1xnZJH5vw " ; Utils . verifyHS ( HSAlgorithm . HS384 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldPassHS512Verification ( ) throws Exception { String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; assertTrue ( Utils . verifyHS ( HSAlgorithm . HS512 , jwt . split ( " \\ . " ) , " secret " ) ) ; }
public void shouldFailHS512VerificationWithInvalidSecret ( ) throws Exception { String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; assertFalse ( Utils . verifyHS ( HSAlgorithm . HS512 , jwt . split ( " \\ . " ) , " not_real_secret " ) ) ; }
public void shouldThrowHS512VerificationWithNullSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Secret cannot be null " ) ; String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; Utils . verifyHS ( HSAlgorithm . HS512 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldThrowWhenHSAlgorithmIsNull ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm must be one of HS256, HS384, or HS512. " ) ; String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; Utils . verifyHS ( null , jwt . split ( " \\ . " ) , " secret " ) ; }
public void shouldPassRS256Verification ( ) throws Exception { PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; assertTrue ( Utils . verifyRS ( RSAlgorithm . RS256 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldFailRS256VerificationWithInvalidPublicKey ( ) throws Exception { PublicKey key = readInvalidPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; assertFalse ( Utils . verifyRS ( RSAlgorithm . RS256 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldThrowRS256VerificationWithNullPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The PublicKey cannot be null " ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; Utils . verifyRS ( RSAlgorithm . RS256 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldPassRS384Verification ( ) throws Exception { PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.TZlWjXObwGSQOiu2oMq8kiKz0_BR7bbBddNL6G8eZ_GoR82BXOZDqNrQr7lb_M-78XGBguWLWNIdYhzgxOUL9EoCJlrqVm9s9vo6G8T1sj1op-4TbjXZ61TwIvrJee9BvPLdKUJ9_fp1Js5kl6yXkst40Th8Auc5as4n49MLkipjpEhKDKaENKHpSubs1ripSz8SCQZSofeTM_EWVwSw7cpiM8Fy8jOPvWG8Xz4-e3ODFowvHVsDcONX_4FTMNbeRqDuHq2ZhCJnEfzcSJdrve_5VD5fM1LperBVslTrOxIgClOJ3RmM7-WnaizJrWP3D6Z9OLxPxLhM6-jx6tcxEw " ; assertTrue ( Utils . verifyRS ( RSAlgorithm . RS384 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldFailRS384VerificationWithInvalidPublicKey ( ) throws Exception { PublicKey key = readInvalidPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.TZlWjXObwGSQOiu2oMq8kiKz0_BR7bbBddNL6G8eZ_GoR82BXOZDqNrQr7lb_M-78XGBguWLWNIdYhzgxOUL9EoCJlrqVm9s9vo6G8T1sj1op-4TbjXZ61TwIvrJee9BvPLdKUJ9_fp1Js5kl6yXkst40Th8Auc5as4n49MLkipjpEhKDKaENKHpSubs1ripSz8SCQZSofeTM_EWVwSw7cpiM8Fy8jOPvWG8Xz4-e3ODFowvHVsDcONX_4FTMNbeRqDuHq2ZhCJnEfzcSJdrve_5VD5fM1LperBVslTrOxIgClOJ3RmM7-WnaizJrWP3D6Z9OLxPxLhM6-jx6tcxEw " ; assertFalse ( Utils . verifyRS ( RSAlgorithm . RS384 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldThrowRS384VerificationWithNullPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The PublicKey cannot be null " ) ; String jwt = " eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.TZlWjXObwGSQOiu2oMq8kiKz0_BR7bbBddNL6G8eZ_GoR82BXOZDqNrQr7lb_M-78XGBguWLWNIdYhzgxOUL9EoCJlrqVm9s9vo6G8T1sj1op-4TbjXZ61TwIvrJee9BvPLdKUJ9_fp1Js5kl6yXkst40Th8Auc5as4n49MLkipjpEhKDKaENKHpSubs1ripSz8SCQZSofeTM_EWVwSw7cpiM8Fy8jOPvWG8Xz4-e3ODFowvHVsDcONX_4FTMNbeRqDuHq2ZhCJnEfzcSJdrve_5VD5fM1LperBVslTrOxIgClOJ3RmM7-WnaizJrWP3D6Z9OLxPxLhM6-jx6tcxEw " ; Utils . verifyRS ( RSAlgorithm . RS384 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldPassRS512Verification ( ) throws Exception { PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mvL5LoMyIrWYjk5umEXZTmbyIrkbbcVPUkvdGZbu0qFBxGOf0nXP5PZBvPcOu084lvpwVox5n3VaD4iqzW-PsJyvKFgi5TnwmsbKchAp7JexQEsQOnTSGcfRqeUUiBZqRQdYsho71oAB3T4FnalDdFEpM-fztcZY9XqKyayqZLreTeBjqJm4jfOWH7KfGBHgZExQhe96NLq1UA9eUyQwdOA1Z0SgXe4Ja5PxZ6Fm37KnVDtDlNnY4JAAGFo6y74aGNnp_BKgpaVJCGFu1f1S5xCQ1HSvs8ZSdVWs5NgawW3wRd0kRt_GJ_Y3mIwiF4qUyHWGtsSHu_qjVdCTtbFyow " ; assertTrue ( Utils . verifyRS ( RSAlgorithm . RS512 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldFailRS512VerificationWithInvalidPublicKey ( ) throws Exception { PublicKey key = readInvalidPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mvL5LoMyIrWYjk5umEXZTmbyIrkbbcVPUkvdGZbu0qFBxGOf0nXP5PZBvPcOu084lvpwVox5n3VaD4iqzW-PsJyvKFgi5TnwmsbKchAp7JexQEsQOnTSGcfRqeUUiBZqRQdYsho71oAB3T4FnalDdFEpM-fztcZY9XqKyayqZLreTeBjqJm4jfOWH7KfGBHgZExQhe96NLq1UA9eUyQwdOA1Z0SgXe4Ja5PxZ6Fm37KnVDtDlNnY4JAAGFo6y74aGNnp_BKgpaVJCGFu1f1S5xCQ1HSvs8ZSdVWs5NgawW3wRd0kRt_GJ_Y3mIwiF4qUyHWGtsSHu_qjVdCTtbFyow " ; assertFalse ( Utils . verifyRS ( RSAlgorithm . RS512 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldThrowRS512VerificationWithNullPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The PublicKey cannot be null " ) ; String jwt = " eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mvL5LoMyIrWYjk5umEXZTmbyIrkbbcVPUkvdGZbu0qFBxGOf0nXP5PZBvPcOu084lvpwVox5n3VaD4iqzW-PsJyvKFgi5TnwmsbKchAp7JexQEsQOnTSGcfRqeUUiBZqRQdYsho71oAB3T4FnalDdFEpM-fztcZY9XqKyayqZLreTeBjqJm4jfOWH7KfGBHgZExQhe96NLq1UA9eUyQwdOA1Z0SgXe4Ja5PxZ6Fm37KnVDtDlNnY4JAAGFo6y74aGNnp_BKgpaVJCGFu1f1S5xCQ1HSvs8ZSdVWs5NgawW3wRd0kRt_GJ_Y3mIwiF4qUyHWGtsSHu_qjVdCTtbFyow " ; Utils . verifyRS ( RSAlgorithm . RS512 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldThrowWhenRSAlgorithmIsNull ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm must be one of RS256, RS384, or RS512. " ) ; PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; Utils . verifyRS ( null , jwt . split ( " \\ . " ) , key ) ; }
public void shouldThrowWhenInitializedWithSecretButWithoutAlgorithm ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm cannot be null " ) ; JWTVerifier . init ( null , " secret " ) ; }
public void shouldThrowWhenInitializedWithPublicKeyButWithoutRSAlgorithm ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm cannot be null " ) ; PublicKey key = mock ( PublicKey . class ) ; JWTVerifier . init ( null , key ) ; }
public void shouldThrowWhenInitializedWithHS256AlgorithmWithoutSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " You can't use the HS256 algorithm without providing a valid Secret. " ) ; JWTVerifier . init ( HSAlgorithm . HS256 , null ) ; }
public void shouldThrowWhenInitializedWithHS384AlgorithmWithoutSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " You can't use the HS384 algorithm without providing a valid Secret. " ) ; JWTVerifier . init ( HSAlgorithm . HS384 , null ) ; }
public void shouldThrowWhenInitializedWithHS512AlgorithmWithoutSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " You can't use the HS512 algorithm without providing a valid Secret. " ) ; JWTVerifier . init ( HSAlgorithm . HS512 , null ) ; }
public void shouldThrowWhenInitializedWithRS256AlgorithmWithoutPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " You can't use the RS256 algorithm without providing a valid PublicKey. " ) ; JWTVerifier . init ( RSAlgorithm . RS256 , null ) ; }
public void shouldThrowWhenInitializedWithRS384AlgorithmWithoutPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " You can't use the RS384 algorithm without providing a valid PublicKey. " ) ; JWTVerifier . init ( RSAlgorithm . RS384 , null ) ; }
public void shouldThrowWhenInitializedWithRS512AlgorithmWithoutPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " You can't use the RS512 algorithm without providing a valid PublicKey. " ) ; JWTVerifier . init ( RSAlgorithm . RS512 , null ) ; }
public void shouldValidateIssuer ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withIssuer ( " auth0 " ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidIssuer ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'iss' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withIssuer ( " invalid " )
public void shouldValidateSubject ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.Rq8IxqeX7eA6GgYxlcHdPFVRNFFZc5rEI3MQTZZbK3I " ; JWT jwt = JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withSubject ( " 1234567890 " ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidSubject ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'sub' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.Rq8IxqeX7eA6GgYxlcHdPFVRNFFZc5rEI3MQTZZbK3I " ; JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withSubject ( " invalid " )
public void shouldValidateAudience ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJNYXJrIn0.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withAudience ( new String [ ] { " Mark " } ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; String tokenArr = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsiTWFyayIsIkRhdmlkIl19.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwtArr = JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withAudience ( new String [ ] { " Mark " , " David " } ) . verify ( tokenArr ) ; assertThat ( jwtArr , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidAudience ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'aud' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.Rq8IxqeX7eA6GgYxlcHdPFVRNFFZc5rEI3MQTZZbK3I " ; JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withAudience ( new String [ ] { " nope " } )
public void shouldValidateExpiresAt ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withExpiresAt ( new Date ( 1477592000 ) ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidExpiresAt ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'exp' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withExpiresAt ( new Date ( ) )
public void shouldValidateNotBefore ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withNotBefore ( new Date ( 1477592000 ) ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidNotBefore ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'nbf' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withNotBefore ( new Date ( ) )
public void shouldValidateIssuedAt ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withIssuedAt ( new Date ( 1477592000 ) ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidIssuedAt ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'iat' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0Nzc1OTJ9.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withIssuedAt ( new Date ( ) )
public void shouldValidateJWTId ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJqd3RfaWRfMTIzIn0.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withJWTId ( " jwt_id_123 " ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
public void shouldThrowOnInvalidJWTId ( ) throws Exception { exception . expect ( InvalidClaimException . class ) ; exception . expectMessage ( " The Claim 'jti' value doesn't match the required one. " ) ; String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJqd3RfaWRfMTIzIn0.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . withJWTId ( " invalid " )
public void shouldSkipClaimValidationsIfNoClaimsRequired ( ) throws Exception { String token = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.MT8JrEvIB69bH5W9RUR2ap-H3e69fM7LEQCiZF-7FbI " ; JWT jwt = JWTVerifier . init ( HSAlgorithm . HS256 , " secret " ) . verify ( token ) ; assertThat ( jwt , is ( notNullValue ( ) ) ) ; }
private void parseToken ( String token ) throws JWTException { final String [ ] parts = SignUtils . splitToken ( token ) ; final JWTParser converter = new JWTParser ( ) ; header = converter . parseHeader ( base64Decode ( parts [ 0 ] ) ) ; payload = converter . parsePayload ( base64Decode ( parts [ 1 ] ) ) ; signature = parts [ 2 ] ; }
public JWTVerifier withIssuer ( String issuer ) { requireClaim ( PublicClaims . ISSUER , issuer ) ; return this ; }
public JWTVerifier withSubject ( String subject ) { requireClaim ( PublicClaims . SUBJECT , subject ) ; return this ; }
public JWTVerifier withAudience ( String [ ] audience ) { requireClaim ( PublicClaims . AUDIENCE , audience ) ; return this ; }
public JWTVerifier withExpiresAt ( Date expiresAt ) { requireClaim ( PublicClaims . EXPIRES_AT , expiresAt ) ; return this ; }
public JWTVerifier withNotBefore ( Date notBefore ) { requireClaim ( PublicClaims . NOT_BEFORE , notBefore ) ; return this ; }
public JWTVerifier withIssuedAt ( Date issuedAt ) { requireClaim ( PublicClaims . ISSUED_AT , issuedAt ) ; return this ; }
public JWTVerifier withJWTId ( String jwtId ) { requireClaim ( PublicClaims . JWT_ID , jwtId ) ; return this ; }
public JWT verify ( String token ) throws JWTException { JWT jwt = JWTDecoder . decode ( token ) ; verifyAlgorithm ( jwt , algorithm ) ; verifySignature ( SignUtils . splitToken ( token ) ) ; verifyClaims ( jwt , claims ) ; return jwt ; }
private void assertValidClaim ( JWT jwt , String claimName , Object expectedValue ) { boolean isValid ; if ( PublicClaims . AUDIENCE . equals ( claimName ) ) { isValid = Arrays . equals ( jwt . getAudience ( ) , ( String [ ] ) expectedValue ) ; } else if ( PublicClaims . NOT_BEFORE . equals ( claimName ) | | PublicClaims . EXPIRES_AT . equals ( claimName ) | | PublicClaims . ISSUED_AT . equals ( claimName ) ) { Date dateValue = ( Date ) expectedValue ; isValid = dateValue . equals ( jwt . getClaim ( claimName ) . asDate ( ) ) ; } else { String stringValue = ( String ) expectedValue ; isValid = stringValue . equals ( jwt . getClaim ( claimName ) . asString ( ) ) ; } if ( ! isValid ) { throw new InvalidClaimException ( String . format ( " The Claim '%s' value doesn't match the required one. " , claimName ) ) ;
static String [ ] splitToken ( String token ) { String [ ] parts = token . split ( " \\ . " ) ; if ( parts . length = = 2 & & token . endsWith ( " . " ) ) { //Tokens with alg='none' have empty String as Signature. parts = new String[]{parts[0], parts[1], ""}; } if (parts.length != 3) { throw new JWTException(String.format("The token was expected to have 3 parts, but got %s.", parts.length)); } return parts; }
static boolean verifyHS ( HSAlgorithm algorithm , String [ ] jwtParts , String secret ) throws NoSuchAlgorithmException , InvalidKeyException { if ( secret = = null ) { throw new IllegalArgumentException ( " The Secret cannot be null " ) ; } if ( algorithm = = null ) { throw new IllegalArgumentException ( " The Algorithm must be one of HS256, HS384, or HS512. " ) ; } Mac mac = Mac . getInstance ( algorithm . describe ( ) ) ; mac . init ( new SecretKeySpec ( secret . getBytes ( ) , algorithm . describe ( ) ) ) ; String message = String . format ( " %s.%s " , jwtParts [ 0 ] , jwtParts [ 1 ] ) ; byte [ ] result = mac . doFinal ( message . getBytes ( ) ) ; return MessageDigest . isEqual ( result , Base64 . decodeBase64 ( jwtParts [ 2 ] ) ) ; }
static boolean verifyRS ( RSAlgorithm algorithm , String [ ] jwtParts , PublicKey publicKey ) throws InvalidKeyException , NoSuchAlgorithmException , SignatureException { if ( publicKey = = null ) { throw new IllegalArgumentException ( " The PublicKey cannot be null " ) ; } if ( algorithm = = null ) { throw new IllegalArgumentException ( " The Algorithm must be one of RS256, RS384, or RS512. " ) ; } final String content = String . format ( " %s.%s " , jwtParts [ 0 ] , jwtParts [ 1 ] ) ; Signature s = Signature . getInstance ( algorithm . describe ( ) ) ; s . initVerify ( publicKey ) ; s . update ( content . getBytes ( ) ) ; return s . verify ( Base64 . decodeBase64 ( jwtParts [ 2 ] ) ) ; }
public Payload deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { Map < String , JsonNode > tree = p . getCodec ( ) . readValue ( p , new TypeReference < Map < String , JsonNode > > ( ) { } ) ; if ( tree = = null ) { throw new JWTException ( " Null map " ) ; } String issuer = getString ( tree , PublicClaims . ISSUER ) ; String subject = getString ( tree , PublicClaims . SUBJECT ) ; String [ ] audience = getStringOrArray ( tree , PublicClaims . AUDIENCE ) ; Date expiresAt = getDate ( tree , PublicClaims . EXPIRES_AT ) ; Date notBefore = getDate ( tree , PublicClaims . NOT_BEFORE ) ; Date issuedAt = getDate ( tree , PublicClaims . ISSUED_AT ) ; String jwtId = getString ( tree , PublicClaims . JWT_ID ) ; return new PayloadImpl ( issuer , subject , audience , expiresAt , notBefore , issuedAt , jwtId , tree ) ; }
static byte [ ] parsePEMFile ( File pemFile ) throws IOException { if ( ! pemFile . isFile ( ) | | ! pemFile . exists ( ) ) { throw new FileNotFoundException ( String . format ( " The file '%s' doesn't exist. " , pemFile . getAbsolutePath ( ) ) ) ; } PemReader reader = new PemReader ( new FileReader ( pemFile ) ) ; PemObject pemObject = reader . readPemObject ( ) ; return pemObject . getContent ( ) ; }
static PublicKey getPublicKey ( byte [ ] keyBytes , String algorithm ) { PublicKey publicKey = null ; try { KeyFactory kf = KeyFactory . getInstance ( algorithm ) ; EncodedKeySpec keySpec = new X509EncodedKeySpec ( keyBytes ) ; publicKey = kf . generatePublic ( keySpec ) ; } catch ( NoSuchAlgorithmException e ) { System . out . println ( " Could not reconstruct the public key, the given algorithm could not be found. " ) ; } catch ( InvalidKeySpecException e ) { System . out . println ( " Could not reconstruct the public key " ) ; } return publicKey ; }
public void shouldSplitToken ( ) throws Exception { String token = " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJhdXRoMCJ9.W1mx_Y0hbAMbPmfW9whT605AAcxB7REFuJiDAHk2Sdc " ; String [ ] parts = SignUtils . splitToken ( token ) ; assertThat ( parts , is ( notNullValue ( ) ) ) ; assertThat ( parts , is ( arrayWithSize ( 3 ) ) ) ; assertThat ( parts [ 0 ] , is ( " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0 " ) ) ; assertThat ( parts [ 1 ] , is ( " eyJpc3MiOiJhdXRoMCJ9 " ) ) ; assertThat ( parts [ 2 ] , is ( " W1mx_Y0hbAMbPmfW9whT605AAcxB7REFuJiDAHk2Sdc " ) ) ; }
public void shouldSplitTokenWithEmptySignature ( ) throws Exception { String token = " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJhdXRoMCJ9. " ; String [ ] parts = SignUtils . splitToken ( token ) ; assertThat ( parts , is ( notNullValue ( ) ) ) ; assertThat ( parts , is ( arrayWithSize ( 3 ) ) ) ; assertThat ( parts [ 0 ] , is ( " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0 " ) ) ; assertThat ( parts [ 1 ] , is ( " eyJpc3MiOiJhdXRoMCJ9 " ) ) ; assertThat ( parts [ 2 ] , is ( isEmptyString ( ) ) ) ; }
public void shouldThrowOnSplitTokenWithMoreThan3Parts ( ) throws Exception { exception . expect ( JWTException . class ) ; exception . expectMessage ( " The token was expected to have 3 parts, but got 4. " ) ; String token = " this.has.four.parts " ; SignUtils . splitToken ( token ) ; }
public void shouldThrowOnSplitTokenWithLessThan3Parts ( ) throws Exception { exception . expect ( JWTException . class ) ; exception . expectMessage ( " The token was expected to have 3 parts, but got 2. " ) ; String token = " two.parts " ; SignUtils . splitToken ( token ) ; }
public void shouldDecodeBase64 ( ) throws Exception { String source = " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 " ; String result = SignUtils . base64Decode ( source ) ; assertThat ( result , is ( notNullValue ( ) ) ) ; assertThat ( result , is ( " { \" alg \" : \" HS256 \" , \" typ \" : \" JWT \" } " ) ) ; }
public void shouldEncodeBase64 ( ) throws Exception { String source = " { \" alg \" : \" HS256 \" , \" typ \" : \" JWT \" } " ; String result = SignUtils . base64Encode ( source ) ; assertThat ( result , is ( notNullValue ( ) ) ) ; assertThat ( result , is ( " eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 " ) ) ; }
public void shouldPassHS256Verification ( ) throws Exception { String jwt = " eyJhbGciOiJIUzI1NiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mZ0m_N1J4PgeqWmi903JuUoDRZDBPB7HwkS4nVyWH1M " ; assertTrue ( SignUtils . verifyHS ( HSAlgorithm . HS256 , jwt . split ( " \\ . " ) , " secret " ) ) ; }
public void shouldFailHS256VerificationWithInvalidSecret ( ) throws Exception { String jwt = " eyJhbGciOiJIUzI1NiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mZ0m_N1J4PgeqWmi903JuUoDRZDBPB7HwkS4nVyWH1M " ; assertFalse ( SignUtils . verifyHS ( HSAlgorithm . HS256 , jwt . split ( " \\ . " ) , " not_real_secret " ) ) ; }
public void shouldThrowHS256VerificationWithNullSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Secret cannot be null " ) ; String jwt = " eyJhbGciOiJIUzI1NiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mZ0m_N1J4PgeqWmi903JuUoDRZDBPB7HwkS4nVyWH1M " ; SignUtils . verifyHS ( HSAlgorithm . HS256 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldPassHS384Verification ( ) throws Exception { String jwt = " eyJhbGciOiJIUzM4NCIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.uztpK_wUMYJhrRv8SV-1LU4aPnwl-EM1q-wJnqgyb5DHoDteP6lN_gE1xnZJH5vw " ; assertTrue ( SignUtils . verifyHS ( HSAlgorithm . HS384 , jwt . split ( " \\ . " ) , " secret " ) ) ; }
public void shouldFailHS384VerificationWithInvalidSecret ( ) throws Exception { String jwt = " eyJhbGciOiJIUzM4NCIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.uztpK_wUMYJhrRv8SV-1LU4aPnwl-EM1q-wJnqgyb5DHoDteP6lN_gE1xnZJH5vw " ; assertFalse ( SignUtils . verifyHS ( HSAlgorithm . HS384 , jwt . split ( " \\ . " ) , " not_real_secret " ) ) ; }
public void shouldThrowHS384VerificationWithNullSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Secret cannot be null " ) ; String jwt = " eyJhbGciOiJIUzM4NCIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.uztpK_wUMYJhrRv8SV-1LU4aPnwl-EM1q-wJnqgyb5DHoDteP6lN_gE1xnZJH5vw " ; SignUtils . verifyHS ( HSAlgorithm . HS384 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldPassHS512Verification ( ) throws Exception { String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; assertTrue ( SignUtils . verifyHS ( HSAlgorithm . HS512 , jwt . split ( " \\ . " ) , " secret " ) ) ; }
public void shouldFailHS512VerificationWithInvalidSecret ( ) throws Exception { String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; assertFalse ( SignUtils . verifyHS ( HSAlgorithm . HS512 , jwt . split ( " \\ . " ) , " not_real_secret " ) ) ; }
public void shouldThrowHS512VerificationWithNullSecret ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Secret cannot be null " ) ; String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; SignUtils . verifyHS ( HSAlgorithm . HS512 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldThrowWhenHSAlgorithmIsNull ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm must be one of HS256, HS384, or HS512. " ) ; String jwt = " eyJhbGciOiJIUzUxMiIsImN0eSI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.VUo2Z9SWDV-XcOc_Hr6Lff3vl7L9e5Vb8ThXpmGDFjHxe3Dr1ZBmUChYF-xVA7cAdX1P_D4ZCUcsv3IefpVaJw " ; SignUtils . verifyHS ( null , jwt . split ( " \\ . " ) , " secret " ) ; }
public void shouldPassRS256Verification ( ) throws Exception { PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; assertTrue ( SignUtils . verifyRS ( RSAlgorithm . RS256 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldFailRS256VerificationWithInvalidPublicKey ( ) throws Exception { PublicKey key = readInvalidPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; assertFalse ( SignUtils . verifyRS ( RSAlgorithm . RS256 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldThrowRS256VerificationWithNullPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The PublicKey cannot be null " ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; SignUtils . verifyRS ( RSAlgorithm . RS256 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldPassRS384Verification ( ) throws Exception { PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.TZlWjXObwGSQOiu2oMq8kiKz0_BR7bbBddNL6G8eZ_GoR82BXOZDqNrQr7lb_M-78XGBguWLWNIdYhzgxOUL9EoCJlrqVm9s9vo6G8T1sj1op-4TbjXZ61TwIvrJee9BvPLdKUJ9_fp1Js5kl6yXkst40Th8Auc5as4n49MLkipjpEhKDKaENKHpSubs1ripSz8SCQZSofeTM_EWVwSw7cpiM8Fy8jOPvWG8Xz4-e3ODFowvHVsDcONX_4FTMNbeRqDuHq2ZhCJnEfzcSJdrve_5VD5fM1LperBVslTrOxIgClOJ3RmM7-WnaizJrWP3D6Z9OLxPxLhM6-jx6tcxEw " ; assertTrue ( SignUtils . verifyRS ( RSAlgorithm . RS384 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldFailRS384VerificationWithInvalidPublicKey ( ) throws Exception { PublicKey key = readInvalidPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.TZlWjXObwGSQOiu2oMq8kiKz0_BR7bbBddNL6G8eZ_GoR82BXOZDqNrQr7lb_M-78XGBguWLWNIdYhzgxOUL9EoCJlrqVm9s9vo6G8T1sj1op-4TbjXZ61TwIvrJee9BvPLdKUJ9_fp1Js5kl6yXkst40Th8Auc5as4n49MLkipjpEhKDKaENKHpSubs1ripSz8SCQZSofeTM_EWVwSw7cpiM8Fy8jOPvWG8Xz4-e3ODFowvHVsDcONX_4FTMNbeRqDuHq2ZhCJnEfzcSJdrve_5VD5fM1LperBVslTrOxIgClOJ3RmM7-WnaizJrWP3D6Z9OLxPxLhM6-jx6tcxEw " ; assertFalse ( SignUtils . verifyRS ( RSAlgorithm . RS384 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldThrowRS384VerificationWithNullPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The PublicKey cannot be null " ) ; String jwt = " eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.TZlWjXObwGSQOiu2oMq8kiKz0_BR7bbBddNL6G8eZ_GoR82BXOZDqNrQr7lb_M-78XGBguWLWNIdYhzgxOUL9EoCJlrqVm9s9vo6G8T1sj1op-4TbjXZ61TwIvrJee9BvPLdKUJ9_fp1Js5kl6yXkst40Th8Auc5as4n49MLkipjpEhKDKaENKHpSubs1ripSz8SCQZSofeTM_EWVwSw7cpiM8Fy8jOPvWG8Xz4-e3ODFowvHVsDcONX_4FTMNbeRqDuHq2ZhCJnEfzcSJdrve_5VD5fM1LperBVslTrOxIgClOJ3RmM7-WnaizJrWP3D6Z9OLxPxLhM6-jx6tcxEw " ; SignUtils . verifyRS ( RSAlgorithm . RS384 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldPassRS512Verification ( ) throws Exception { PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mvL5LoMyIrWYjk5umEXZTmbyIrkbbcVPUkvdGZbu0qFBxGOf0nXP5PZBvPcOu084lvpwVox5n3VaD4iqzW-PsJyvKFgi5TnwmsbKchAp7JexQEsQOnTSGcfRqeUUiBZqRQdYsho71oAB3T4FnalDdFEpM-fztcZY9XqKyayqZLreTeBjqJm4jfOWH7KfGBHgZExQhe96NLq1UA9eUyQwdOA1Z0SgXe4Ja5PxZ6Fm37KnVDtDlNnY4JAAGFo6y74aGNnp_BKgpaVJCGFu1f1S5xCQ1HSvs8ZSdVWs5NgawW3wRd0kRt_GJ_Y3mIwiF4qUyHWGtsSHu_qjVdCTtbFyow " ; assertTrue ( SignUtils . verifyRS ( RSAlgorithm . RS512 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldFailRS512VerificationWithInvalidPublicKey ( ) throws Exception { PublicKey key = readInvalidPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mvL5LoMyIrWYjk5umEXZTmbyIrkbbcVPUkvdGZbu0qFBxGOf0nXP5PZBvPcOu084lvpwVox5n3VaD4iqzW-PsJyvKFgi5TnwmsbKchAp7JexQEsQOnTSGcfRqeUUiBZqRQdYsho71oAB3T4FnalDdFEpM-fztcZY9XqKyayqZLreTeBjqJm4jfOWH7KfGBHgZExQhe96NLq1UA9eUyQwdOA1Z0SgXe4Ja5PxZ6Fm37KnVDtDlNnY4JAAGFo6y74aGNnp_BKgpaVJCGFu1f1S5xCQ1HSvs8ZSdVWs5NgawW3wRd0kRt_GJ_Y3mIwiF4qUyHWGtsSHu_qjVdCTtbFyow " ; assertFalse ( SignUtils . verifyRS ( RSAlgorithm . RS512 , jwt . split ( " \\ . " ) , key ) ) ; }
public void shouldThrowRS512VerificationWithNullPublicKey ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The PublicKey cannot be null " ) ; String jwt = " eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.mvL5LoMyIrWYjk5umEXZTmbyIrkbbcVPUkvdGZbu0qFBxGOf0nXP5PZBvPcOu084lvpwVox5n3VaD4iqzW-PsJyvKFgi5TnwmsbKchAp7JexQEsQOnTSGcfRqeUUiBZqRQdYsho71oAB3T4FnalDdFEpM-fztcZY9XqKyayqZLreTeBjqJm4jfOWH7KfGBHgZExQhe96NLq1UA9eUyQwdOA1Z0SgXe4Ja5PxZ6Fm37KnVDtDlNnY4JAAGFo6y74aGNnp_BKgpaVJCGFu1f1S5xCQ1HSvs8ZSdVWs5NgawW3wRd0kRt_GJ_Y3mIwiF4qUyHWGtsSHu_qjVdCTtbFyow " ; SignUtils . verifyRS ( RSAlgorithm . RS512 , jwt . split ( " \\ . " ) , null ) ; }
public void shouldThrowWhenRSAlgorithmIsNull ( ) throws Exception { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " The Algorithm must be one of RS256, RS384, or RS512. " ) ; PublicKey key = readPublicKey ( ) ; String jwt = " eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoMCJ9.dxXF3MdsyW-AuvwJpaQtrZ33fAde9xWxpLIg9cO2tMLH2GSRNuLAe61KsJusZhqZB9Iy7DvflcmRz-9OZndm6cj_ThGeJH2LLc90K83UEvvRPo8l85RrQb8PcanxCgIs2RcZOLygERizB3pr5icGkzR7R2y6zgNCjKJ5_NJ6EiZsGN6_nc2PRK_DbyY-Wn0QDxIxKoA5YgQJ9qafe7IN980pXvQv2Z62c3XR8dYuaXBqhthBj-AbaFHEpZapN-V-TmuLNzR2MCB6Xr7BYMuCaqWf_XU8og4XNe8f_8w9Wv5vvgqMM1KhqVpG5VdMJv4o_L4NoCROHhtUQSLRh2M9cA " ; SignUtils . verifyRS ( null , jwt . split ( " \\ . " ) , key ) ; }
public static void block ( ConditionSpecification conditionSpecification ) throws Exception { block ( defaultTimeout = = null ? forever ( ) : defaultTimeout , conditionSpecification ) ; }
public static void block ( long timeout , TimeUnit unit , ConditionSpecification conditionSpecification ) throws Exception { block ( duration ( timeout , unit ) , conditionSpecification ) ; }
public static void block ( DurationSpecification duration , ConditionSpecification conditionSpecification ) throws Exception { block ( duration , conditionSpecification , null ) ; }
public static void block ( ConditionSpecification conditionSpecification , PollSpecification pollSpecification ) throws Exception { block ( forever ( ) , conditionSpecification , pollSpecification ) ; }
public static void block ( long timeout , TimeUnit unit , ConditionSpecification conditionSpecification , PollSpecification pollSpecification ) throws Exception { block ( duration ( timeout , unit ) , conditionSpecification , pollSpecification ) ; }
public static void block ( DurationSpecification duration , ConditionSpecification conditionSpecification , PollSpecification pollSpecification ) throws Exception { await ( duration , conditionSpecification , pollSpecification ) . join ( ) ; }
public static SynchronizerOperation await ( long timeout , TimeUnit unit , ConditionSpecification conditionSpecification ) { return await ( duration ( timeout , unit ) , conditionSpecification ) ; }
public static SynchronizerOperation await ( ConditionSpecification conditionSpecification ) { return await ( defaultTimeout = = null ? forever ( ) : defaultTimeout , conditionSpecification ) ; }
public static SynchronizerOperation await ( DurationSpecification duration , ConditionSpecification conditionSpecification ) { return await ( duration , conditionSpecification , null ) ; }
public static SynchronizerOperation await ( long timeout , TimeUnit unit , ConditionSpecification conditionSpecification , PollSpecification pollSpecification ) { return await ( duration ( timeout , unit ) , conditionSpecification , pollSpecification ) ; }
public static SynchronizerOperation await ( ConditionSpecification conditionSpecification , PollSpecification pollSpecification ) { return await ( forever ( ) , conditionSpecification , pollSpecification ) ; }
public static SynchronizerOperation await ( DurationSpecification duration , ConditionSpecification conditionSpecification , PollSpecification pollSpecification ) { if ( pollSpecification = = null & & defaultPollSpecfication ! = null ) { pollSpecification = defaultPollSpecfication ; } if ( duration = = null & & defaultTimeout ! = null ) { duration = defaultTimeout ; } return new AwaitOperationImpl ( duration , conditionSpecification , pollSpecification ) ; }
public static void setDefaultPollInterval ( long pollInterval , TimeUnit unit ) { defaultPollSpecfication = new PollSpecificationImpl ( pollInterval , unit ) ; }
public static void setDefaultTimeout ( long timeout , TimeUnit unit ) { defaultTimeout = duration ( timeout , unit ) ; }
public static void setDefaultPollInterval ( PollSpecification pollSpecification ) { defaultPollSpecfication = pollSpecification ; }
public static void setDefaultTimeout ( DurationSpecification defaultTimeout ) { Synchronizer . defaultTimeout = defaultTimeout ; }
public void run ( ) { try { if ( specification . isConditionSatisified ( ) ) {
public void join ( ) throws Exception { try { final long timeout = maxWaitTime . getValue ( ) ;
public void uncaughtException ( Thread thread , Throwable throwable ) { if ( throwable instanceof Exception ) { exception = ( Exception ) throwable ;
public SynchronizerOperation andCatchAllUncaughtExceptions ( ) { Thread . setDefaultUncaughtExceptionHandler ( this ) ; return this ; }
public boolean isConditionSatisified ( ) throws Exception { return matcher . matches ( condition . condition ( ) ) ; }
public DurationSpecification getPollInterval ( ) { return duration ; }
public TimeUnit getTimeUnit ( ) { return duration . getTimeUnit ( ) ; }
public long getValue ( ) { return duration . getValue ( ) ; }
BlockingSupportedOperation andCatchAllUncaughtExceptions ( ) ; }
public DurationSpecification getPollInterval ( ) { return spec . getPollInterval ( ) ; }
public static PollSpecification withPollInterval ( long time , TimeUnit unit ) { return new PollSpecificationImpl ( time , unit ) ; }
public static PollSpecification withPollInterval ( PollSpecification pollInterval ) { if ( pollInterval = = null ) { throw new IllegalArgumentException ( " pollInterval cannot be null " ) ; } return pollInterval ; }
public static DurationSpecification duration ( long time , TimeUnit unit ) { return new DurationSpecificationImpl ( time , unit ) ; }
public static DurationSpecification atMost ( DurationSpecification duration ) { if ( duration = = null ) { throw new IllegalArgumentException ( " duration cannot be null " ) ; } return duration ; }
public static DurationSpecification atMost ( long time , TimeUnit unit ) { return new DurationSpecificationImpl ( time , unit ) ; }
public static DurationSpecification forever ( ) { return new ForeverImpl ( ) ; }
public static < T > ConditionSpecification until ( Condition < T > condition , Matcher < T > matcher ) { return new ConditionSpecificationImpl < T > ( condition , matcher ) ; }
public static ConditionSpecification until ( ConditionSpecification conditionSpecification ) { return conditionSpecification ; }
public void setup ( ) { fakeRepository = new FakeRepositoryImpl ( ) ; }
public void foreverConditionSpecificationWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( fakeRepositoryValueEqualsOne ( ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void blockOperationBlocksAutomatically ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; block ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void blockOperationSupportsSpecifyingPollSpecification ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; block ( until ( fakeRepositoryValueEqualsOne ( ) ) , withPollInterval ( 20 , TimeUnit . MILLISECONDS ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void blockOperationSupportsSpecifyingPollIntervalDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; block ( until ( fakeRepositoryValueEqualsOne ( ) ) , PollInterval . TWO_HUNDRED_MILLISECONDS ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollIntervalDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) , PollInterval . TWO_HUNDRED_MILLISECONDS ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollIntervalAndDurationDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( Duration . ONE_SECOND , until ( fakeRepositoryValueEqualsOne ( ) ) , PollInterval . TWO_HUNDRED_MILLISECONDS ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void blockOperationSupportsSpecifyingDurationDirectly ( ) throws Exception { block ( Duration . ONE_HUNDRED_MILLISECONDS , until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingDurationDirectly ( ) throws Exception { await ( Duration . ONE_HUNDRED_MILLISECONDS , until ( fakeRepositoryValueEqualsOne ( ) ) , PollInterval . ONE_HUNDRED_MILLISECONDS ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void blockOperationSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; block ( until ( fakeRepositoryValueEqualsOne ( ) ) , withPollInterval ( ONE_HUNDRED_MILLISECONDS ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollSpecification ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( valueCondition ( ) , greaterThan ( 0 ) ) , withPollInterval ( 20 , TimeUnit . MILLISECONDS ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( valueCondition ( ) , greaterThan ( 0 ) ) , withPollInterval ( ONE_HUNDRED_MILLISECONDS ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( duration ( 20 , TimeUnit . MILLISECONDS ) ) ; try { await ( until ( valueCondition ( ) , greaterThan ( 0 ) ) ) . join ( ) ;
public void blockOperationSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( duration ( 20 , TimeUnit . MILLISECONDS ) ) ; try { block ( until ( valueCondition ( ) , greaterThan ( 0 ) ) ) ;
public void foreverConditionSpecificationUsingUntilWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionWithHamcrestMatchersWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( valueCondition ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void specifyingDefaultPollIntervalImpactsAllSubsequentUndefinedPollIntervalStatements ( ) throws Exception { Synchronizer . setDefaultPollInterval ( 20 , TimeUnit . MILLISECONDS ) ; try { new Asynch ( fakeRepository ) . perform ( ) ;
public void conditionBreaksAfterDurationTimeout ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( 200 , TimeUnit . MILLISECONDS , until ( valueCondition ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeoutWhenUsingAtMost ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( atMost ( 200 , TimeUnit . MILLISECONDS ) , until ( valueCondition ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenSetToCatchAllUncaughtExceptions ( ) throws Exception { BlockingSupportedOperation operation = await ( until ( valueCondition ( ) , equalTo ( 1 ) ) ) . andCatchAllUncaughtExceptions ( ) ; new ExceptionThrowingAsynch ( ) . perform ( ) ; operation . join ( ) ; }
public void exceptionsInConditionsArePropagatedToAwaitingThreadAndBreaksForeverBlock ( ) throws Exception { final ExceptionThrowingFakeRepository repository = new ExceptionThrowingFakeRepository ( ) ; new Asynch ( repository ) . perform ( ) ; await ( until ( new FakeRepositoryValue ( repository ) , equalTo ( 1 ) ) ) . join ( ) ; }
private ConditionSpecification fakeRepositoryValueEqualsOne ( ) { return new FakeRepositoryEqualsOne ( fakeRepository ) ; }
private Condition < Integer > valueCondition ( ) { return new FakeRepositoryValue ( fakeRepository ) ; }
public void perform ( ) { Thread thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Thread . sleep ( 600 ) ; repository . setValue ( 1 ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } } ) ; thread . start ( ) ; }
public void perform ( ) { Thread thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Thread . sleep ( 600 ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } throw new IllegalStateException ( " Illegal state! " ) ; } } ) ; thread . start ( ) ; }
public void run ( ) { try { Thread . sleep ( 600 ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } throw new IllegalStateException ( " Illegal state! " ) ; }
public int getValue ( ) { throw new IllegalStateException ( " illegal " ) ; }
public boolean isConditionSatisified ( ) { return repository . getValue ( ) = = 1 ; }
public void setValue ( int value ) { this . value = value ; }
public Integer condition ( ) { return repository . getValue ( ) ; }
public static void reset ( ) { defaultPollInterval = Duration . FIVE_HUNDRED_MILLISECONDS ; defaultTimeout = null ; }
public static void block ( Duration duration , ConditionSpecification conditionSpecification ) throws Exception { block ( duration , conditionSpecification , null ) ; }
public static void block ( ConditionSpecification conditionSpecification , Duration pollInterval ) throws Exception { block ( forever ( ) , conditionSpecification , pollInterval ) ; }
public static void block ( long timeout , TimeUnit unit , ConditionSpecification conditionSpecification , Duration pollInterval ) throws Exception { block ( duration ( timeout , unit ) , conditionSpecification , pollInterval ) ; }
public static void block ( Duration duration , ConditionSpecification conditionSpecification , Duration pollInterval ) throws Exception { await ( duration , conditionSpecification , pollInterval ) . join ( ) ; }
public static SynchronizerOperation await ( Duration duration , ConditionSpecification conditionSpecification ) { return await ( duration , conditionSpecification , null ) ; }
public static SynchronizerOperation await ( long timeout , TimeUnit unit , ConditionSpecification conditionSpecification , Duration pollInterval ) { return await ( duration ( timeout , unit ) , conditionSpecification , pollInterval ) ; }
public static SynchronizerOperation await ( ConditionSpecification conditionSpecification , Duration pollInterval ) { return await ( forever ( ) , conditionSpecification , pollInterval ) ; }
public static SynchronizerOperation await ( Duration duration , ConditionSpecification conditionSpecification , Duration pollInterval ) { if ( pollInterval = = null ) { pollInterval = defaultPollInterval ; } if ( duration = = null ) { duration = defaultTimeout ; } return new AwaitOperationImpl ( duration , conditionSpecification , pollInterval ) ; }
public static void setDefaultPollInterval ( long pollInterval , TimeUnit unit ) { defaultPollInterval = new Duration ( pollInterval , unit ) ; }
public static void setDefaultPollInterval ( Duration pollInterval ) { if ( pollInterval = = null ) { throw new IllegalArgumentException ( " You must specify a poll interval (was null). " ) ; } defaultPollInterval = pollInterval ; }
public static void setDefaultTimeout ( Duration defaultTimeout ) { Synchronizer . defaultTimeout = defaultTimeout ; }
public static Duration withPollInterval ( long time , TimeUnit unit ) { return new Duration ( time , unit ) ; }
public static Duration withPollInterval ( Duration pollInterval ) { if ( pollInterval = = null ) { throw new IllegalArgumentException ( " pollInterval cannot be null " ) ; } return pollInterval ; }
public static Duration duration ( long time , TimeUnit unit ) { return new Duration ( time , unit ) ; }
public static Duration atMost ( Duration duration ) { if ( duration = = null ) { throw new IllegalArgumentException ( " duration cannot be null " ) ; } return duration ; }
public static Duration atMost ( long time , TimeUnit unit ) { return new Duration ( time , unit ) ; }
public static Duration forever ( ) { return Duration . FOREVER ; }
public static < T > ConditionSpecification until ( final Condition < T > condition , final Matcher < T > matcher ) { if ( condition = = null ) { throw new IllegalArgumentException ( " You must specify a condition (was null). " ) ; } if ( matcher = = null ) { throw new IllegalArgumentException ( " You must specify a matcher (was null). " ) ; } return new ConditionSpecification ( ) { @Override
public boolean isConditionSatisified ( ) throws Exception { return matcher . matches ( condition . condition ( ) ) ; }
public void setup ( ) { fakeRepository = new FakeRepositoryImpl ( ) ; Synchronizer . reset ( ) ; }
public void blockOperationSupportsSpecifyingPollIntervalDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; block ( until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollIntervalDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollIntervalAndDurationDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( Duration . ONE_SECOND , until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingDurationDirectly ( ) throws Exception { await ( Duration . ONE_HUNDRED_MILLISECONDS , until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . ONE_HUNDRED_MILLISECONDS ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void blockOperationSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; block ( until ( fakeRepositoryValueEqualsOne ( ) ) , withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( valueCondition ( ) , greaterThan ( 0 ) ) , withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void specifyingDefaultPollIntervalImpactsAllSubsequentUndefinedPollIntervalStatements ( ) throws Exception { Synchronizer . setDefaultPollInterval ( 20 , TimeUnit . MILLISECONDS ) ; new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( valueCondition ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public static void reset ( ) { defaultPollInterval = Duration . FIVE_HUNDRED_MILLISECONDS ; defaultTimeout = Duration . FOREVER ; }
public static void block ( ConditionSpecification conditionSpecification ) throws Exception { block ( defaultTimeout , conditionSpecification ) ; }
public static void block ( ConditionSpecification conditionSpecification , Duration pollInterval ) throws Exception { block ( defaultTimeout , conditionSpecification , pollInterval ) ; }
public static SynchronizerOperation await ( ConditionSpecification conditionSpecification ) { return await ( defaultTimeout , conditionSpecification ) ; }
public static SynchronizerOperation await ( ConditionSpecification conditionSpecification , Duration pollInterval ) { return await ( defaultTimeout , conditionSpecification , pollInterval ) ; }
public static void setDefaultTimeout ( Duration defaultTimeout ) { if ( defaultTimeout = = null ) { throw new IllegalArgumentException ( " You must specify a default timeout (was null). " ) ; } Synchronizer . defaultTimeout = defaultTimeout ; }
public void awaitOperationSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( duration ( 20 , TimeUnit . MILLISECONDS ) ) ; await ( until ( valueCondition ( ) , greaterThan ( 0 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void blockOperationSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( duration ( 20 , TimeUnit . MILLISECONDS ) ) ; block ( until ( valueCondition ( ) , greaterThan ( 0 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public static < T > ConditionSpecification until ( final Supplier < T > supplier , final Matcher < T > matcher ) { if ( supplier = = null ) { throw new IllegalArgumentException ( " You must specify a supplier (was null). " ) ; } if ( matcher = = null ) { throw new IllegalArgumentException ( " You must specify a matcher (was null). " ) ; } return new ConditionSpecification ( ) { @Override
public boolean isConditionSatisified ( ) throws Exception { return matcher . matches ( supplier . get ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollSpecification ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( value ( ) , greaterThan ( 0 ) ) , withPollInterval ( 20 , TimeUnit . MILLISECONDS ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( value ( ) , greaterThan ( 0 ) ) , withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( duration ( 20 , TimeUnit . MILLISECONDS ) ) ; await ( until ( value ( ) , greaterThan ( 0 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void blockOperationSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( duration ( 20 , TimeUnit . MILLISECONDS ) ) ; block ( until ( value ( ) , greaterThan ( 0 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionWithHamcrestMatchersWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( value ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void specifyingDefaultPollIntervalImpactsAllSubsequentUndefinedPollIntervalStatements ( ) throws Exception { Synchronizer . setDefaultPollInterval ( 20 , TimeUnit . MILLISECONDS ) ; new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( value ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeout ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( 200 , TimeUnit . MILLISECONDS , until ( value ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeoutWhenUsingAtMost ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( atMost ( 200 , TimeUnit . MILLISECONDS ) , until ( value ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenSetToCatchAllUncaughtExceptions ( ) throws Exception { BlockingSupportedOperation operation = await ( until ( value ( ) , equalTo ( 1 ) ) ) . andCatchAllUncaughtExceptions ( ) ; new ExceptionThrowingAsynch ( ) . perform ( ) ; operation . join ( ) ; }
private Supplier < Integer > value ( ) { return new FakeRepositoryValue ( fakeRepository ) ; }
public static void block ( Condition condition ) throws Exception { block ( defaultTimeout , condition ) ; }
public static void block ( long timeout , TimeUnit unit , Condition condition ) throws Exception { block ( duration ( timeout , unit ) , condition ) ; }
public static void block ( Duration duration , Condition condition ) throws Exception { block ( duration , condition , null ) ; }
public static void block ( Condition condition , Duration pollInterval ) throws Exception { block ( defaultTimeout , condition , pollInterval ) ; }
public static void block ( long timeout , TimeUnit unit , Condition condition , Duration pollInterval ) throws Exception { block ( duration ( timeout , unit ) , condition , pollInterval ) ; }
public static void block ( Duration duration , Condition condition , Duration pollInterval ) throws Exception { await ( duration , condition , pollInterval ) . join ( ) ; }
public static SynchronizerOperation await ( long timeout , TimeUnit unit , Condition condition ) { return await ( duration ( timeout , unit ) , condition ) ; }
public static SynchronizerOperation await ( Condition condition ) { return await ( defaultTimeout , condition ) ; }
public static SynchronizerOperation await ( Duration duration , Condition condition ) { return await ( duration , condition , null ) ; }
public static SynchronizerOperation await ( long timeout , TimeUnit unit , Condition condition , Duration pollInterval ) { return await ( duration ( timeout , unit ) , condition , pollInterval ) ; }
public static SynchronizerOperation await ( Condition condition , Duration pollInterval ) { return await ( defaultTimeout , condition , pollInterval ) ; }
public static SynchronizerOperation await ( Duration duration , Condition condition , Duration pollInterval ) { if ( pollInterval = = null ) { pollInterval = defaultPollInterval ; } if ( duration = = null ) { duration = defaultTimeout ; } return new AwaitOperationImpl ( duration , condition , pollInterval ) ; }
public void run ( ) { try { if ( specification . evaluate ( ) ) {
public static < T > Condition until ( final Supplier < T > supplier , final Matcher < T > matcher ) { if ( supplier = = null ) { throw new IllegalArgumentException ( " You must specify a supplier (was null). " ) ; } if ( matcher = = null ) { throw new IllegalArgumentException ( " You must specify a matcher (was null). " ) ; } return new Condition ( ) { @Override
public boolean evaluate ( ) throws Exception { return matcher . matches ( supplier . get ( ) ) ; }
public static Condition until ( Condition condition ) { return condition ; }
private Condition fakeRepositoryValueEqualsOne ( ) { return new FakeRepositoryEqualsOne ( fakeRepository ) ; }
public boolean evaluate ( ) { return repository . getValue ( ) = = 1 ; }
public void run ( ) { try { if ( condition . evaluate ( ) ) {
public static void catchUncaughtExceptions ( ) { defaultCatchUncaughtExceptions = true ; }
public static void reset ( ) { defaultPollInterval = Duration . FIVE_HUNDRED_MILLISECONDS ; defaultTimeout = Duration . FOREVER ; defaultCatchUncaughtExceptions = false ; Thread . setDefaultUncaughtExceptionHandler ( null ) ; }
public static void block ( Duration duration , Condition condition , Duration pollInterval ) throws Exception { SynchronizerOperation operation = await ( duration , condition , pollInterval ) ; if ( defaultCatchUncaughtExceptions ) { operation . andCatchAllUncaughtExceptions ( ) ; } operation . join ( ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockAlsoForBlockWhenSetToCatchAllUncaughtExceptions ( ) throws Exception { Synchronizer . catchUncaughtExceptions ( ) ; new ExceptionThrowingAsynch ( ) . perform ( ) ; block ( until ( value ( ) , equalTo ( 1 ) ) ) ; }
public void catchUncaughtExceptionsIsReset ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; block ( Duration . ONE_SECOND , until ( value ( ) , equalTo ( 1 ) ) ) ; }
public static void await ( Condition condition ) throws Exception { await ( defaultTimeout , condition ) ; }
public static void await ( long timeout , TimeUnit unit , Condition condition ) throws Exception { await ( duration ( timeout , unit ) , condition ) ; }
public static void await ( Duration duration , Condition condition ) throws Exception { await ( duration , condition , null ) ; }
public static void await ( Condition condition , Duration pollInterval ) throws Exception { await ( defaultTimeout , condition , pollInterval ) ; }
public static void await ( long timeout , TimeUnit unit , Condition condition , Duration pollInterval ) throws Exception { await ( duration ( timeout , unit ) , condition , pollInterval ) ; }
public static void await ( Duration duration , Condition condition , Duration pollInterval ) throws Exception { SynchronizerOperation operation = defineCondition ( duration , condition , pollInterval ) ; if ( defaultCatchUncaughtExceptions ) { operation . andCatchAllUncaughtExceptions ( ) ; } operation . join ( ) ; }
public static SynchronizerOperation defineCondition ( long timeout , TimeUnit unit , Condition condition ) { return defineCondition ( duration ( timeout , unit ) , condition ) ; }
public static SynchronizerOperation defineCondition ( Condition condition ) { return defineCondition ( defaultTimeout , condition ) ; }
public static SynchronizerOperation defineCondition ( Duration duration , Condition condition ) { return defineCondition ( duration , condition , null ) ; }
public static SynchronizerOperation defineCondition ( long timeout , TimeUnit unit , Condition condition , Duration pollInterval ) { return defineCondition ( duration ( timeout , unit ) , condition , pollInterval ) ; }
public static SynchronizerOperation defineCondition ( Condition condition , Duration pollInterval ) { return defineCondition ( defaultTimeout , condition , pollInterval ) ; }
public static SynchronizerOperation defineCondition ( Duration duration , Condition condition , Duration pollInterval ) { if ( pollInterval = = null ) { pollInterval = defaultPollInterval ; } if ( duration = = null ) { duration = defaultTimeout ; } return new AwaitOperationImpl ( duration , condition , pollInterval ) ; }
public static < T > Condition until ( final Supplier < T > supplier , final Matcher < T > matcher ) { if ( supplier = = null ) { throw new IllegalArgumentException ( " You must specify a supplier (was null). " ) ; } if ( matcher = = null ) { throw new IllegalArgumentException ( " You must specify a matcher (was null). " ) ; } return new Condition ( ) { @Override
public boolean evaluate ( ) throws Exception { return matcher . matches ( supplier . get ( ) ) ; }
public void foreverConditionSpecificationWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; defineCondition ( fakeRepositoryValueEqualsOne ( ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void blockOperationBlocksAutomatically ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void blockOperationSupportsSpecifyingPollSpecification ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) , withPollInterval ( 20 , TimeUnit . MILLISECONDS ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void blockOperationSupportsSpecifyingPollIntervalDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollIntervalDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; defineCondition ( until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollIntervalAndDurationDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; defineCondition ( Duration . ONE_SECOND , until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingDurationDirectly ( ) throws Exception { await ( Duration . ONE_HUNDRED_MILLISECONDS , until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void defineConditionSupportsSpecifyingDurationDirectly ( ) throws Exception { defineCondition ( Duration . ONE_HUNDRED_MILLISECONDS , until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . ONE_HUNDRED_MILLISECONDS ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) , withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void defineConditionSupportsSpecifyingPollSpecification ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; defineCondition ( until ( value ( ) , greaterThan ( 0 ) ) , withPollInterval ( 20 , TimeUnit . MILLISECONDS ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void defineConditionSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; defineCondition ( until ( value ( ) , greaterThan ( 0 ) ) , withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void defineConditionSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( duration ( 20 , TimeUnit . MILLISECONDS ) ) ; defineCondition ( until ( value ( ) , greaterThan ( 0 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( duration ( 20 , TimeUnit . MILLISECONDS ) ) ; await ( until ( value ( ) , greaterThan ( 0 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionSpecificationUsingUntilWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; defineCondition ( until ( fakeRepositoryValueEqualsOne ( ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionWithHamcrestMatchersWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; defineCondition ( until ( value ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void specifyingDefaultPollIntervalImpactsAllSubsequentUndefinedPollIntervalStatements ( ) throws Exception { Synchronizer . setDefaultPollInterval ( 20 , TimeUnit . MILLISECONDS ) ; new Asynch ( fakeRepository ) . perform ( ) ; defineCondition ( until ( value ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeout ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; defineCondition ( 200 , TimeUnit . MILLISECONDS , until ( value ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeoutWhenUsingAtMost ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; defineCondition ( atMost ( 200 , TimeUnit . MILLISECONDS ) , until ( value ( ) , equalTo ( 1 ) ) ) . join ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenSetToCatchAllUncaughtExceptions ( ) throws Exception { BlockingSupportedOperation operation = defineCondition ( until ( value ( ) , equalTo ( 1 ) ) ) . andCatchAllUncaughtExceptions ( ) ; new ExceptionThrowingAsynch ( ) . perform ( ) ; operation . join ( ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockAlsoForBlockWhenSetToCatchAllUncaughtExceptions ( ) throws Exception { Synchronizer . catchUncaughtExceptions ( ) ; new ExceptionThrowingAsynch ( ) . perform ( ) ; await ( until ( value ( ) , equalTo ( 1 ) ) ) ; }
public void catchUncaughtExceptionsIsReset ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; await ( Duration . ONE_SECOND , until ( value ( ) , equalTo ( 1 ) ) ) ; }
public void exceptionsInConditionsArePropagatedToAwaitingThreadAndBreaksForeverBlock ( ) throws Exception { final ExceptionThrowingFakeRepository repository = new ExceptionThrowingFakeRepository ( ) ; new Asynch ( repository ) . perform ( ) ; defineCondition ( until ( new FakeRepositoryValue ( repository ) , equalTo ( 1 ) ) ) . join ( ) ; }
public static void catchUncaughtExceptions ( ) { defaultCatchUncaughtExceptions = true ; }
public static void reset ( ) { defaultPollInterval = Duration . FIVE_HUNDRED_MILLISECONDS ; defaultTimeout = Duration . FOREVER ; defaultCatchUncaughtExceptions = false ; Thread . setDefaultUncaughtExceptionHandler ( null ) ; }
public static void await ( ConditionEvaluator condition ) throws Exception { await ( defaultTimeout , condition ) ; }
public static void await ( long timeout , TimeUnit unit , ConditionEvaluator condition ) throws Exception { await ( duration ( timeout , unit ) , condition ) ; }
public static void await ( Duration duration , ConditionEvaluator condition ) throws Exception { await ( duration , condition , null ) ; }
public static void await ( ConditionEvaluator condition , Duration pollInterval ) throws Exception { await ( defaultTimeout , condition , pollInterval ) ; }
public static void await ( long timeout , TimeUnit unit , ConditionEvaluator conditionEvaluator , Duration pollInterval ) throws Exception { await ( duration ( timeout , unit ) , conditionEvaluator , pollInterval ) ; }
public static void await ( Duration duration , ConditionEvaluator conditionEvaluator , Duration pollInterval ) throws Exception { await ( condition ( duration , conditionEvaluator , pollInterval ) ) ; }
public static void await ( Condition condition ) throws Exception { if ( condition = = null ) { throw new IllegalArgumentException ( " Condition cannot be null " ) ; } if ( defaultCatchUncaughtExceptions ) { condition . andCatchAllUncaughtExceptions ( ) ; } condition . await ( ) ; }
public static Condition condition ( long timeout , TimeUnit unit , ConditionEvaluator condition ) { return condition ( duration ( timeout , unit ) , condition ) ; }
public static Condition condition ( ConditionEvaluator condition ) { return condition ( defaultTimeout , condition ) ; }
public static Condition condition ( Duration duration , ConditionEvaluator conditionEvaluator ) { return condition ( duration , conditionEvaluator , null ) ; }
public static Condition condition ( long timeout , TimeUnit unit , ConditionEvaluator conditionEvaluator , Duration pollInterval ) { return condition ( duration ( timeout , unit ) , conditionEvaluator , pollInterval ) ; }
public static Condition condition ( ConditionEvaluator conditionEvaluator , Duration pollInterval ) { return condition ( defaultTimeout , conditionEvaluator , pollInterval ) ; }
public static Condition condition ( Duration duration , ConditionEvaluator conditionEvaluator , Duration pollInterval ) { if ( pollInterval = = null ) { pollInterval = defaultPollInterval ; } if ( duration = = null ) { duration = defaultTimeout ; } return new AwaitConditionImpl ( duration , conditionEvaluator , pollInterval ) ; }
public static void setDefaultPollInterval ( Duration pollInterval ) { if ( pollInterval = = null ) { throw new IllegalArgumentException ( " You must specify a poll interval (was null). " ) ; } defaultPollInterval = pollInterval ; }
public static void setDefaultTimeout ( Duration defaultTimeout ) { if ( defaultTimeout = = null ) { throw new IllegalArgumentException ( " You must specify a default timeout (was null). " ) ; } Synchronizer . defaultTimeout = defaultTimeout ; }
public void run ( ) { try { if ( condition . evaluate ( ) ) {
public void await ( ) throws Exception { try { final long timeout = maxWaitTime . getValue ( ) ;
public void uncaughtException ( Thread thread , Throwable throwable ) { if ( throwable instanceof Exception ) { exception = ( Exception ) throwable ;
public Condition andCatchAllUncaughtExceptions ( ) { Thread . setDefaultUncaughtExceptionHandler ( this ) ; return this ; }
public static < T > ConditionEvaluator until ( final Supplier < T > supplier , final Matcher < T > matcher ) { if ( supplier = = null ) { throw new IllegalArgumentException ( " You must specify a supplier (was null). " ) ; } if ( matcher = = null ) { throw new IllegalArgumentException ( " You must specify a matcher (was null). " ) ; } return new ConditionEvaluator ( ) { @Override
public static ConditionEvaluator until ( ConditionEvaluator condition ) { return condition ; }
AwaitSupportedCondition andCatchAllUncaughtExceptions ( ) ; }
public void foreverConditionSpecificationWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; condition ( fakeRepositoryValueEqualsOne ( ) ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationBlocksAutomatically ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollSpecification ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) , withPollInterval ( 20 , TimeUnit . MILLISECONDS ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollIntervalDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionSupportsSpecifyingPollIntervalDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; condition ( until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionSupportsSpecifyingPollIntervalAndDurationDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; condition ( Duration . ONE_SECOND , until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void defineConditionSupportsSpecifyingDurationDirectly ( ) throws Exception { condition ( Duration . ONE_HUNDRED_MILLISECONDS , until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . ONE_HUNDRED_MILLISECONDS ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void defineConditionSupportsSpecifyingPollSpecification ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; condition ( until ( value ( ) , greaterThan ( 0 ) ) , withPollInterval ( 20 , TimeUnit . MILLISECONDS ) ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void defineConditionSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; condition ( until ( value ( ) , greaterThan ( 0 ) ) , withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void defineConditionSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( duration ( 20 , TimeUnit . MILLISECONDS ) ) ; condition ( until ( value ( ) , greaterThan ( 0 ) ) ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionSpecificationUsingUntilWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; condition ( until ( fakeRepositoryValueEqualsOne ( ) ) ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitCanWaitOnCondition ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( condition ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionWithHamcrestMatchersWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; condition ( until ( value ( ) , equalTo ( 1 ) ) ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void specifyingDefaultPollIntervalImpactsAllSubsequentUndefinedPollIntervalStatements ( ) throws Exception { Synchronizer . setDefaultPollInterval ( 20 , TimeUnit . MILLISECONDS ) ; new Asynch ( fakeRepository ) . perform ( ) ; condition ( until ( value ( ) , equalTo ( 1 ) ) ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeout ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; condition ( 200 , TimeUnit . MILLISECONDS , until ( value ( ) , equalTo ( 1 ) ) ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeoutWhenUsingAtMost ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; condition ( atMost ( 200 , TimeUnit . MILLISECONDS ) , until ( value ( ) , equalTo ( 1 ) ) ) . await ( ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenSetToCatchAllUncaughtExceptions ( ) throws Exception { AwaitSupportedCondition operation = condition ( until ( value ( ) , equalTo ( 1 ) ) ) . andCatchAllUncaughtExceptions ( ) ; new ExceptionThrowingAsynch ( ) . perform ( ) ; operation . await ( ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockAlsoForBlockWhenSetToCatchAllUncaughtExceptions ( ) throws Exception { Synchronizer . catchUncaughtExceptions ( ) ; new ExceptionThrowingAsynch ( ) . perform ( ) ; await ( until ( value ( ) , equalTo ( 1 ) ) ) ; }
public void exceptionsInConditionsArePropagatedToAwaitingThreadAndBreaksForeverBlock ( ) throws Exception { final ExceptionThrowingFakeRepository repository = new ExceptionThrowingFakeRepository ( ) ; new Asynch ( repository ) . perform ( ) ; condition ( until ( new FakeRepositoryValue ( repository ) , equalTo ( 1 ) ) ) . await ( ) ; }
private ConditionEvaluator fakeRepositoryValueEqualsOne ( ) { return new FakeRepositoryEqualsOne ( fakeRepository ) ; }
public T get ( ) throws Exception { return ( T ) method . invoke ( target , args ) ; }
public static < S > S callTo ( S service ) { Object proxy = Proxy . newProxyInstance ( Thread . currentThread ( ) . getContextClassLoader ( ) , service . getClass ( ) . getInterfaces ( ) , new InvocationHandler ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { lastMethod = method ; lastArgs = args ; return makeReturnValueFor ( method . getReturnType ( ) ) ; } } ) ; lastTarget = service ; return ( S ) proxy ; }
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { lastMethod = method ; lastArgs = args ; return makeReturnValueFor ( method . getReturnType ( ) ) ; }
private static Object makeReturnValueFor ( Class < ? > returnType ) { return 0 ; }
public static < T > ConditionEvaluator until ( T ignore , final Matcher < T > matcher ) { return until ( new MethodCaller < T > ( lastTarget , lastMethod , lastArgs ) , matcher ) ; }
public void awaitUsingProxy ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( callTo ( fakeRepository ) . getValue ( ) , greaterThan ( 0 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
private static Condition condition ( Duration duration , ConditionEvaluator conditionEvaluator , Duration pollInterval ) { if ( pollInterval = = null ) { pollInterval = defaultPollInterval ; } if ( duration = = null ) { duration = defaultTimeout ; } return new AwaitConditionImpl ( duration , conditionEvaluator , pollInterval ) ; }
public static < S > S callTo ( S service ) { Object proxy = Proxy . newProxyInstance ( Thread . currentThread ( ) . getContextClassLoader ( ) , service . getClass ( ) . getInterfaces ( ) , new InvocationHandler ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { lastMethod = method ; lastArgs = args ; return TypeUtils . getDefaultValue ( method . getReturnType ( ) ) ; } } ) ; lastTarget = service ; return ( S ) proxy ; }
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { lastMethod = method ; lastArgs = args ; return TypeUtils . getDefaultValue ( method . getReturnType ( ) ) ; }
public void foreverConditionSpecificationWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( fakeRepositoryValueEqualsOne ( ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionSupportsSpecifyingPollIntervalAndDurationDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( Duration . ONE_SECOND , until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void defineConditionSupportsSpecifyingDurationDirectly ( ) throws Exception { await ( Duration . ONE_HUNDRED_MILLISECONDS , until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . ONE_HUNDRED_MILLISECONDS ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionSpecificationUsingUntilWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionWithHamcrestMatchersWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( value ( ) , equalTo ( 1 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void specifyingDefaultPollIntervalImpactsAllSubsequentUndefinedPollIntervalStatements ( ) throws Exception { Synchronizer . setDefaultPollInterval ( 20 , TimeUnit . MILLISECONDS ) ; new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( value ( ) , equalTo ( 1 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeout ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( 200 , TimeUnit . MILLISECONDS , until ( value ( ) , equalTo ( 1 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeoutWhenUsingAtMost ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( atMost ( 200 , TimeUnit . MILLISECONDS ) , until ( value ( ) , equalTo ( 1 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenSetToCatchAllUncaughtExceptions ( ) throws Exception { catchUncaughtExceptions ( ) ; new ExceptionThrowingAsynch ( ) . perform ( ) ; await ( until ( value ( ) , equalTo ( 1 ) ) ) ; }
public void exceptionsInConditionsArePropagatedToAwaitingThreadAndBreaksForeverBlock ( ) throws Exception { final ExceptionThrowingFakeRepository repository = new ExceptionThrowingFakeRepository ( ) ; new Asynch ( repository ) . perform ( ) ; await ( until ( new FakeRepositoryValue ( repository ) , equalTo ( 1 ) ) ) ; }
public static void await ( Duration duration , ConditionEvaluator conditionEvaluator , Duration pollInterval ) throws Exception { Condition condition = condition ( duration , conditionEvaluator , pollInterval ) ; if ( defaultCatchUncaughtExceptions ) { condition . andCatchAllUncaughtExceptions ( ) ; } condition . await ( ) ; }
public T call ( ) throws Exception { return ( T ) method . invoke ( target , args ) ; }
public static < T > ConditionEvaluator until ( final Callable < T > supplier , final Matcher < T > matcher ) { if ( supplier = = null ) { throw new IllegalArgumentException ( " You must specify a supplier (was null). " ) ; } if ( matcher = = null ) { throw new IllegalArgumentException ( " You must specify a matcher (was null). " ) ; } return new ConditionEvaluator ( ) { @Override
public boolean evaluate ( ) throws Exception { return matcher . matches ( supplier . call ( ) ) ; }
public static Object getDefaultValue ( Class < ? > type ) { return getDefaultValue ( type . getName ( ) ) ; }
public static Object getDefaultValue ( String fullyQualifiedTypeName ) { if ( fullyQualifiedTypeName = = null ) { // Void return "";
private Callable < Integer > value ( ) { return new FakeRepositoryValue ( fakeRepository ) ; }
public Integer call ( ) throws Exception { return repository . getValue ( ) ; }
public static void await ( Callable < Boolean > condition ) throws Exception { await ( defaultTimeout , condition ) ; }
public static void await ( long timeout , TimeUnit unit , Callable < Boolean > condition ) throws Exception { await ( duration ( timeout , unit ) , condition ) ; }
public static void await ( Duration duration , Callable < Boolean > condition ) throws Exception { await ( duration , condition , defaultPollInterval ) ; }
public static void await ( Callable < Boolean > condition , Duration pollInterval ) throws Exception { await ( defaultTimeout , condition , pollInterval ) ; }
public static void await ( long timeout , TimeUnit unit , Callable < Boolean > conditionEvaluator , Duration pollInterval ) throws Exception { await ( duration ( timeout , unit ) , conditionEvaluator , pollInterval ) ; }
public static void await ( Duration duration , Callable < Boolean > conditionEvaluator , Duration pollInterval ) throws Exception { new ConditionFactory ( duration , pollInterval , defaultCatchUncaughtExceptions ) . await ( conditionEvaluator ) ; }
public static ConditionFactory catchingUncaughExceptions ( ) { return new ConditionFactory ( defaultTimeout , defaultPollInterval , true ) ; }
public static ConditionFactory withPollInterval ( long time , TimeUnit unit ) { return new ConditionFactory ( defaultTimeout , new Duration ( time , unit ) , defaultCatchUncaughtExceptions ) ; }
public static ConditionFactory withPollInterval ( Duration pollInterval ) { return new ConditionFactory ( defaultTimeout , pollInterval , defaultCatchUncaughtExceptions ) ; }
public static ConditionFactory withTimeout ( Duration timeout ) { return new ConditionFactory ( timeout , defaultPollInterval , defaultCatchUncaughtExceptions ) ; }
public void run ( ) { try { if ( condition . call ( ) ) {
public ConditionFactory andTimeout ( Duration timeout ) { return new ConditionFactory ( timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory andPollInterval ( Duration pollInterval ) { return new ConditionFactory ( timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory andCatchUncaughtExceptions ( ) { return new ConditionFactory ( timeout , pollInterval , true ) ; }
public void await ( Callable < Boolean > conditionEvaluator ) throws Exception { AwaitConditionImpl condition = new AwaitConditionImpl ( timeout , conditionEvaluator , pollInterval ) ; if ( catchUncaughtExceptions ) { condition . andCatchAllUncaughtExceptions ( ) ; } condition . await ( ) ; }
public Boolean call ( ) throws Exception { return matcher . matches ( supplier . call ( ) ) ; }
public static Callable < Boolean > until ( Callable < Boolean > condition ) { return condition ; }
public void awaitUsingCallTo ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( callTo ( fakeRepository ) . getValue ( ) , greaterThan ( 0 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollSpecification ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; withPollInterval ( 20 , TimeUnit . MILLISECONDS ) . await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; withPollInterval ( 20 , TimeUnit . MILLISECONDS ) . await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) . await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenCatchingAllUncaughtExceptions ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; catchingUncaughExceptions ( ) . await ( until ( value ( ) , equalTo ( 1 ) ) ) ; }
public Boolean call ( ) { return repository . getValue ( ) = = 1 ; }
public static ConditionFactory block ( ) { return new ConditionFactory ( defaultTimeout , defaultTimeout , defaultCatchUncaughtExceptions ) ; }
public static ConditionFactory waitAtMost ( Duration timeout ) { return new ConditionFactory ( timeout , defaultPollInterval , defaultCatchUncaughtExceptions ) ; }
public ConditionFactory waitAtMost ( Duration timeout ) { return new ConditionFactory ( timeout , pollInterval , catchUncaughtExceptions ) ; }
public < T > void until ( T ignore , final Matcher < T > matcher ) throws Exception { await ( ConditionOptions . until ( ignore , matcher ) ) ; }
public < T > void until ( final Callable < T > supplier , final Matcher < T > matcher ) throws Exception { await ( ConditionOptions . until ( supplier , matcher ) ) ; }
public void waitAtMostWorks ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) . waitAtMost ( Duration . ONE_SECOND ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; waitAtMost ( Duration . ONE_SECOND ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; }
public static ConditionFactory await ( ) { return new ConditionFactory ( defaultTimeout , defaultTimeout , defaultCatchUncaughtExceptions ) ; }
public ConditionFactory atMost ( Duration timeout ) { return new ConditionFactory ( timeout , pollInterval , catchUncaughtExceptions ) ; }
public void waitAtMostWorks ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) . atMost ( Duration . ONE_SECOND ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; waitAtMost ( Duration . ONE_SECOND ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; await ( ) . atMost ( Duration . ONE_SECOND ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; await ( ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; }
public static void catchUncaughtExceptions ( ) { defaultCatchUncaughtExceptions = true ; }
public static void reset ( ) { defaultPollInterval = Duration . FIVE_HUNDRED_MILLISECONDS ; defaultTimeout = Duration . FOREVER ; defaultCatchUncaughtExceptions = false ; Thread . setDefaultUncaughtExceptionHandler ( null ) ; }
public static void await ( Callable < Boolean > condition ) throws Exception { await ( defaultTimeout , condition ) ; }
public static void await ( long timeout , TimeUnit unit , Callable < Boolean > condition ) throws Exception { await ( duration ( timeout , unit ) , condition ) ; }
public static void await ( Duration duration , Callable < Boolean > condition ) throws Exception { await ( duration , condition , defaultPollInterval ) ; }
public static void await ( Callable < Boolean > condition , Duration pollInterval ) throws Exception { await ( defaultTimeout , condition , pollInterval ) ; }
public static void await ( long timeout , TimeUnit unit , Callable < Boolean > conditionEvaluator , Duration pollInterval ) throws Exception { await ( duration ( timeout , unit ) , conditionEvaluator , pollInterval ) ; }
public static void await ( Duration duration , Callable < Boolean > conditionEvaluator , Duration pollInterval ) throws Exception { new ConditionFactory ( duration , pollInterval , defaultCatchUncaughtExceptions ) . await ( conditionEvaluator ) ; }
public static ConditionFactory await ( ) { return new ConditionFactory ( defaultTimeout , defaultTimeout , defaultCatchUncaughtExceptions ) ; }
public static ConditionFactory catchingUncaughExceptions ( ) { return new ConditionFactory ( defaultTimeout , defaultPollInterval , true ) ; }
public static ConditionFactory withPollInterval ( long time , TimeUnit unit ) { return new ConditionFactory ( defaultTimeout , new Duration ( time , unit ) , defaultCatchUncaughtExceptions ) ; }
public static ConditionFactory withPollInterval ( Duration pollInterval ) { return new ConditionFactory ( defaultTimeout , pollInterval , defaultCatchUncaughtExceptions ) ; }
public static ConditionFactory withTimeout ( Duration timeout ) { return new ConditionFactory ( timeout , defaultPollInterval , defaultCatchUncaughtExceptions ) ; }
public static ConditionFactory withTimeout ( long timeout , TimeUnit timeUnit ) { return new ConditionFactory ( new Duration ( timeout , timeUnit ) , defaultPollInterval , defaultCatchUncaughtExceptions ) ;
public static ConditionFactory waitAtMost ( Duration timeout ) { return new ConditionFactory ( timeout , defaultPollInterval , defaultCatchUncaughtExceptions ) ; }
public static void setDefaultPollInterval ( long pollInterval , TimeUnit unit ) { defaultPollInterval = new Duration ( pollInterval , unit ) ; }
public static void setDefaultTimeout ( long timeout , TimeUnit unit ) { defaultTimeout = duration ( timeout , unit ) ; }
public static void setDefaultPollInterval ( Duration pollInterval ) { if ( pollInterval = = null ) { throw new IllegalArgumentException ( " You must specify a poll interval (was null). " ) ; } defaultPollInterval = pollInterval ; }
public static void setDefaultTimeout ( Duration defaultTimeout ) { if ( defaultTimeout = = null ) { throw new IllegalArgumentException ( " You must specify a default timeout (was null). " ) ; } Synchronizer . defaultTimeout = defaultTimeout ; }
public void run ( ) { try { if ( condition . call ( ) ) {
public void await ( ) throws Exception { try { final long timeout = maxWaitTime . getValue ( ) ;
public Condition andCatchAllUncaughtExceptions ( ) { Thread . setDefaultUncaughtExceptionHandler ( this ) ; return this ; }
public ConditionFactory andTimeout ( Duration timeout ) { return new ConditionFactory ( timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory atMost ( Duration timeout ) { return new ConditionFactory ( timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory andPollInterval ( Duration pollInterval ) { return new ConditionFactory ( timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory andTimeout ( long timeout , TimeUnit unit ) { return new ConditionFactory ( new Duration ( timeout , unit ) , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory atMost ( long timeout , TimeUnit unit ) { return new ConditionFactory ( new Duration ( timeout , unit ) , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory andPollInterval ( long pollInterval , TimeUnit unit ) { return new ConditionFactory ( timeout , new Duration ( pollInterval , unit ) , catchUncaughtExceptions ) ; }
public ConditionFactory andCatchUncaughtExceptions ( ) { return new ConditionFactory ( timeout , pollInterval , true ) ; }
public void await ( Callable < Boolean > conditionEvaluator ) throws Exception { AwaitConditionImpl condition = new AwaitConditionImpl ( timeout , conditionEvaluator , pollInterval ) ; if ( catchUncaughtExceptions ) { condition . andCatchAllUncaughtExceptions ( ) ; } condition . await ( ) ; }
public < T > void until ( T ignore , final Matcher < T > matcher ) throws Exception { await ( ConditionOptions . until ( ignore , matcher ) ) ; }
public < T > void until ( final Callable < T > supplier , final Matcher < T > matcher ) throws Exception { await ( ConditionOptions . until ( supplier , matcher ) ) ; }
public static Duration duration ( long time , TimeUnit unit ) { return new Duration ( time , unit ) ; }
public static Duration atMost ( Duration duration ) { if ( duration = = null ) { throw new IllegalArgumentException ( " duration cannot be null " ) ; } return duration ; }
public static Duration atMost ( long time , TimeUnit unit ) { return new Duration ( time , unit ) ; }
public static Duration forever ( ) { return Duration . FOREVER ; }
public T call ( ) throws Exception { return ( T ) method . invoke ( target , args ) ; }
public static < S > S callTo ( S service ) { Object proxy = Proxy . newProxyInstance ( Thread . currentThread ( ) . getContextClassLoader ( ) , service . getClass ( ) . getInterfaces ( ) , new InvocationHandler ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { lastMethod = method ; lastArgs = args ; return TypeUtils . getDefaultValue ( method . getReturnType ( ) ) ; } } ) ; lastTarget = service ; return ( S ) proxy ; }
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { lastMethod = method ; lastArgs = args ; return TypeUtils . getDefaultValue ( method . getReturnType ( ) ) ; }
public static < T > ConditionEvaluator until ( T ignore , final Matcher < T > matcher ) { return until ( new MethodCaller < T > ( lastTarget , lastMethod , lastArgs ) , matcher ) ; }
public static < T > ConditionEvaluator until ( final Callable < T > supplier , final Matcher < T > matcher ) { if ( supplier = = null ) { throw new IllegalArgumentException ( " You must specify a supplier (was null). " ) ; } if ( matcher = = null ) { throw new IllegalArgumentException ( " You must specify a matcher (was null). " ) ; } return new ConditionEvaluator ( ) { @Override
public Boolean call ( ) throws Exception { return matcher . matches ( supplier . call ( ) ) ; }
public static Callable < Boolean > until ( Callable < Boolean > condition ) { return condition ; }
public void setup ( ) { fakeRepository = new FakeRepositoryImpl ( ) ; Synchronizer . reset ( ) ; }
public void awaitUsingCallTo ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( callTo ( fakeRepository ) . getValue ( ) , greaterThan ( 0 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionSpecificationWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( fakeRepositoryValueEqualsOne ( ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationBlocksAutomatically ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollSpecification ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; withPollInterval ( 20 , TimeUnit . MILLISECONDS ) . await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; withPollInterval ( 20 , TimeUnit . MILLISECONDS ) . await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollIntervalDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionSupportsSpecifyingPollIntervalAndDurationDirectly ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( Duration . ONE_SECOND , until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . TWO_HUNDRED_MILLISECONDS ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingDurationDirectly ( ) throws Exception { await ( Duration . ONE_HUNDRED_MILLISECONDS , until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void defineConditionSupportsSpecifyingDurationDirectly ( ) throws Exception { await ( Duration . ONE_HUNDRED_MILLISECONDS , until ( fakeRepositoryValueEqualsOne ( ) ) , Duration . ONE_HUNDRED_MILLISECONDS ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) . await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( duration ( 20 , TimeUnit . MILLISECONDS ) ) ; await ( until ( value ( ) , greaterThan ( 0 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionSpecificationUsingUntilWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( fakeRepositoryValueEqualsOne ( ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionWithHamcrestMatchersWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( value ( ) , equalTo ( 1 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void specifyingDefaultPollIntervalImpactsAllSubsequentUndefinedPollIntervalStatements ( ) throws Exception { Synchronizer . setDefaultPollInterval ( 20 , TimeUnit . MILLISECONDS ) ; new Asynch ( fakeRepository ) . perform ( ) ; await ( until ( value ( ) , equalTo ( 1 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeout ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( 200 , TimeUnit . MILLISECONDS , until ( value ( ) , equalTo ( 1 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeoutWhenUsingAtMost ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( atMost ( 200 , TimeUnit . MILLISECONDS ) , until ( value ( ) , equalTo ( 1 ) ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenSetToCatchAllUncaughtExceptions ( ) throws Exception { catchUncaughtExceptions ( ) ; new ExceptionThrowingAsynch ( ) . perform ( ) ; await ( until ( value ( ) , equalTo ( 1 ) ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenCatchingAllUncaughtExceptions ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; catchingUncaughExceptions ( ) . await ( until ( value ( ) , equalTo ( 1 ) ) ) ; }
public void catchUncaughtExceptionsIsReset ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; await ( Duration . ONE_SECOND , until ( value ( ) , equalTo ( 1 ) ) ) ; }
public void waitAtMostWorks ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) . atMost ( Duration . ONE_SECOND ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; waitAtMost ( Duration . ONE_SECOND ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; await ( ) . atMost ( Duration . ONE_SECOND ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; await ( ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; }
public void exceptionsInConditionsArePropagatedToAwaitingThreadAndBreaksForeverBlock ( ) throws Exception { final ExceptionThrowingFakeRepository repository = new ExceptionThrowingFakeRepository ( ) ; new Asynch ( repository ) . perform ( ) ; await ( until ( new FakeRepositoryValue ( repository ) , equalTo ( 1 ) ) ) ; }
public void awaitWithTimeout ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; withTimeout ( 1 , SECONDS ) . await ( until ( callTo ( fakeRepository ) . getValue ( ) , greaterThan ( 0 ) ) ) ; }
private ConditionEvaluator fakeRepositoryValueEqualsOne ( ) { return new FakeRepositoryEqualsOne ( fakeRepository ) ; }
private Callable < Integer > value ( ) { return new FakeRepositoryValue ( fakeRepository ) ; }
public Integer call ( ) throws Exception { return repository . getValue ( ) ; }
public static ConditionFactory await ( ) { return new ConditionFactory ( defaultTimeout , defaultPollInterval , defaultCatchUncaughtExceptions ) ; }
public static ConditionFactory catchingUncaughtExceptions ( ) { return new ConditionFactory ( defaultTimeout , defaultPollInterval , true ) ; }
public static void setDefaultTimeout ( long timeout , TimeUnit unit ) { defaultTimeout = new Duration ( timeout , unit ) ; }
public ConditionFactory forever ( ) { return new ConditionFactory ( Duration . FOREVER , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory await ( ) throws Exception { return this ; }
public ConditionFactory and ( ) throws Exception { return this ; }
public < T > void until ( T ignore , final Matcher < T > matcher ) throws Exception { until ( new MethodCaller < T > ( lastTarget , lastMethod , lastArgs ) , matcher ) ; }
public < T > void until ( final Callable < T > supplier , final Matcher < T > matcher ) throws Exception { if ( supplier = = null ) { throw new IllegalArgumentException ( " You must specify a supplier (was null). " ) ; } if ( matcher = = null ) { throw new IllegalArgumentException ( " You must specify a matcher (was null). " ) ; } until ( new ConditionEvaluator ( ) { @Override
public < T > void until ( Callable < Boolean > conditionEvaluator ) throws Exception { AwaitConditionImpl condition = new AwaitConditionImpl ( timeout , conditionEvaluator , pollInterval ) ; if ( catchUncaughtExceptions ) { condition . andCatchAllUncaughtExceptions ( ) ; } condition . await ( ) ; }
public void awaitUsingCallTo ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . until ( callTo ( fakeRepository ) . getValue ( ) , greaterThan ( 0 ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationBlocksAutomatically ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . until ( fakeRepositoryValueEqualsOne ( ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollSpecification ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; withPollInterval ( 20 , TimeUnit . MILLISECONDS ) . await ( ) . until ( fakeRepositoryValueEqualsOne ( ) ) ; withPollInterval ( 20 , TimeUnit . MILLISECONDS ) . await ( ) . until ( fakeRepositoryValueEqualsOne ( ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) . await ( ) . until ( fakeRepositoryValueEqualsOne ( ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( 20 , TimeUnit . MILLISECONDS ) ; await ( ) . until ( value ( ) , greaterThan ( 0 ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionSpecificationUsingUntilWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . until ( fakeRepositoryValueEqualsOne ( ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionWithHamcrestMatchersWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . until ( value ( ) , equalTo ( 1 ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void specifyingDefaultPollIntervalImpactsAllSubsequentUndefinedPollIntervalStatements ( ) throws Exception { Synchronizer . setDefaultPollInterval ( 20 , TimeUnit . MILLISECONDS ) ; new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . until ( value ( ) , equalTo ( 1 ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeout ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . atMost ( 200 , TimeUnit . MILLISECONDS ) . until ( value ( ) , equalTo ( 1 ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenSetToCatchAllUncaughtExceptions ( ) throws Exception { catchUncaughtExceptions ( ) ; new ExceptionThrowingAsynch ( ) . perform ( ) ; await ( ) . until ( value ( ) , equalTo ( 1 ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenCatchingAllUncaughtExceptions ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; catchingUncaughtExceptions ( ) . and ( ) . await ( ) . forever ( ) . until ( value ( ) , equalTo ( 1 ) ) ; }
public void catchUncaughtExceptionsIsReset ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; await ( ) . atMost ( Duration . ONE_SECOND ) . until ( value ( ) , equalTo ( 1 ) ) ; }
public void exceptionsInConditionsArePropagatedToAwaitingThreadAndBreaksForeverBlock ( ) throws Exception { final ExceptionThrowingFakeRepository repository = new ExceptionThrowingFakeRepository ( ) ; new Asynch ( repository ) . perform ( ) ; await ( ) . until ( new FakeRepositoryValue ( repository ) , equalTo ( 1 ) ) ; }
public void awaitWithTimeout ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; withTimeout ( 1 , SECONDS ) . await ( ) . until ( callTo ( fakeRepository ) . getValue ( ) , greaterThan ( 0 ) ) ; }
public static ConditionFactory await ( ) { return await ( null ) ; }
public static ConditionFactory await ( String alias ) { return new ConditionFactory ( alias , defaultTimeout , defaultPollInterval , defaultCatchUncaughtExceptions ) ; }
public static ConditionFactory catchingUncaughtExceptions ( ) { return new ConditionFactory ( defaultTimeout , defaultPollInterval , true ) ; }
public static ConditionFactory withTimeout ( long timeout , TimeUnit timeUnit ) { return new ConditionFactory ( new Duration ( timeout , timeUnit ) , defaultPollInterval , defaultCatchUncaughtExceptions ) ;
public static void setDefaultTimeout ( long timeout , TimeUnit unit ) { defaultTimeout = new Duration ( timeout , unit ) ; }
public ConditionFactory andWithTimeout ( Duration timeout ) { return new ConditionFactory ( alias , timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory atMost ( Duration timeout ) { return new ConditionFactory ( alias , timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory forever ( ) { return new ConditionFactory ( alias , Duration . FOREVER , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory andWithPollInterval ( Duration pollInterval ) { return new ConditionFactory ( alias , timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory andWithTimeout ( long timeout , TimeUnit unit ) { return new ConditionFactory ( alias , new Duration ( timeout , unit ) , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory atMost ( long timeout , TimeUnit unit ) { return new ConditionFactory ( alias , new Duration ( timeout , unit ) , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory andWithPollInterval ( long pollInterval , TimeUnit unit ) { return new ConditionFactory ( alias , timeout , new Duration ( pollInterval , unit ) , catchUncaughtExceptions ) ; }
public ConditionFactory andCatchUncaughtExceptions ( ) { return new ConditionFactory ( alias , timeout , pollInterval , true ) ; }
public ConditionFactory await ( ) throws Exception { return this ; }
public ConditionFactory await ( String alias ) throws Exception { return new ConditionFactory ( alias , timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory and ( ) throws Exception { return this ; }
public static < S > S callTo ( S service ) { Object proxy = Proxy . newProxyInstance ( Thread . currentThread ( ) . getContextClassLoader ( ) , service . getClass ( ) . getInterfaces ( ) , new InvocationHandler ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { lastMethod = method ; lastArgs = args ; return TypeUtils . getDefaultValue ( method . getReturnType ( ) ) ; } } ) ; lastTarget = service ; return ( S ) proxy ; }
public < T > void until ( T ignore , final Matcher < T > matcher ) throws Exception { until ( new MethodCaller < T > ( lastTarget , lastMethod , lastArgs ) , matcher ) ; }
public < T > void until ( final Callable < T > supplier , final Matcher < T > matcher ) throws Exception { if ( supplier = = null ) { throw new IllegalArgumentException ( " You must specify a supplier (was null). " ) ; } if ( matcher = = null ) { throw new IllegalArgumentException ( " You must specify a matcher (was null). " ) ; } until ( new ConditionEvaluator ( ) { public Boolean call ( ) throws Exception {
public < T > void until ( Callable < Boolean > conditionEvaluator ) throws Exception { AwaitConditionImpl condition = new AwaitConditionImpl ( alias , timeout , conditionEvaluator , pollInterval ) ; if ( catchUncaughtExceptions ) { condition . andCatchAllUncaughtExceptions ( ) ; } condition . await ( ) ; }
public void awaitUsingCallTo ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . until ( callTo ( fakeRepository ) . getValue ( ) , greaterThan ( 0 ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationBlocksAutomatically ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . until ( fakeRepositoryValueEqualsOne ( ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollSpecification ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; withPollInterval ( 20 , TimeUnit . MILLISECONDS ) . await ( ) . until ( fakeRepositoryValueEqualsOne ( ) ) ; withPollInterval ( 20 , TimeUnit . MILLISECONDS ) . await ( ) . until ( fakeRepositoryValueEqualsOne ( ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsSpecifyingPollInterval ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) . await ( ) . until ( fakeRepositoryValueEqualsOne ( ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void awaitOperationSupportsDefaultTimeout ( ) throws Exception { Synchronizer . setDefaultTimeout ( 20 , TimeUnit . MILLISECONDS ) ; await ( ) . until ( value ( ) , greaterThan ( 0 ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionSpecificationUsingUntilWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . until ( fakeRepositoryValueEqualsOne ( ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void foreverConditionWithHamcrestMatchersWithDirectBlock ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . until ( value ( ) , equalTo ( 1 ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void specifyingDefaultPollIntervalImpactsAllSubsequentUndefinedPollIntervalStatements ( ) throws Exception { Synchronizer . setDefaultPollInterval ( 20 , TimeUnit . MILLISECONDS ) ; new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . until ( value ( ) , equalTo ( 1 ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void conditionBreaksAfterDurationTimeout ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; await ( ) . atMost ( 200 , TimeUnit . MILLISECONDS ) . until ( value ( ) , equalTo ( 1 ) ) ; assertEquals ( 1 , fakeRepository . getValue ( ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenSetToCatchAllUncaughtExceptions ( ) throws Exception { catchUncaughtExceptions ( ) ; new ExceptionThrowingAsynch ( ) . perform ( ) ; await ( ) . until ( value ( ) , equalTo ( 1 ) ) ; }
public void uncaughtExceptionsArePropagatedToAwaitingThreadAndBreaksForeverBlockWhenCatchingAllUncaughtExceptions ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; catchingUncaughtExceptions ( ) . and ( ) . await ( ) . forever ( ) . until ( value ( ) , equalTo ( 1 ) ) ; }
public void catchUncaughtExceptionsIsReset ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; await ( ) . atMost ( Duration . ONE_SECOND ) . until ( value ( ) , equalTo ( 1 ) ) ; }
public void waitAtMostWorks ( ) throws Exception { new ExceptionThrowingAsynch ( ) . perform ( ) ; withPollInterval ( Duration . ONE_HUNDRED_MILLISECONDS ) . atMost ( Duration . ONE_SECOND ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; waitAtMost ( Duration . ONE_SECOND ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; await ( ) . atMost ( Duration . ONE_SECOND ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; await ( ) . until ( callTo ( fakeRepository ) . getValue ( ) , equalTo ( 1 ) ) ; }
public void exceptionsInConditionsArePropagatedToAwaitingThreadAndBreaksForeverBlock ( ) throws Exception { final ExceptionThrowingFakeRepository repository = new ExceptionThrowingFakeRepository ( ) ; new Asynch ( repository ) . perform ( ) ; await ( ) . until ( new FakeRepositoryValue ( repository ) , equalTo ( 1 ) ) ; }
public void awaitWithTimeout ( ) throws Exception { new Asynch ( fakeRepository ) . perform ( ) ; withTimeout ( 1 , SECONDS ) . await ( ) . until ( callTo ( fakeRepository ) . getValue ( ) , greaterThan ( 0 ) ) ; }
public void awaitWithAliasDisplaysAliasWhenTimeoutExceptionOccurs ( ) throws Exception { String alias = " test " ; exception . expect ( TimeoutException . class ) ; exception . expectMessage ( alias ) ; await ( alias ) . atMost ( 20 , MILLISECONDS ) . until ( value ( ) , greaterThan ( 0 ) ) ; }
public Integer call ( ) throws Exception { return repository . getValue ( ) ; }
public static void doNotCatchUncaughtExceptions ( ) { defaultCatchUncaughtExceptions = false ; }
public void testUsingCallable ( ) throws Exception { final CounterService service = new CounterServiceImpl ( ) ; service . run ( ) ; await ( ) . until ( new Callable < Boolean > ( ) { public Boolean call ( ) throws Exception {
public Boolean call ( ) throws Exception { return service . getCount ( ) = = 1 ; }
public void testUsingCallTo ( ) throws Exception { final CounterService service = new CounterServiceImpl ( ) ; service . run ( ) ; await ( ) . until ( callTo ( service ) . getCount ( ) , is ( equalTo ( 1 ) ) ) ; }
public void testUsingGreaterThan ( ) throws Exception { final CounterService service = new CounterServiceImpl ( ) ; service . run ( ) ; await ( ) . until ( callTo ( service ) . getCount ( ) , greaterThan ( 2 ) ) ; }
public void testCrash ( ) throws Exception { final CounterService service = new CounterServiceImpl ( new IllegalArgumentException ( ) ) ; service . run ( ) ; await ( ) . until ( callTo ( service ) . getCount ( ) , is ( equalTo ( 1 ) ) ) ; }
int getCount ( ) ; } class CounterServiceImpl implements CounterService { private volatile int count = 0 ; private final RuntimeException exception ; public CounterServiceImpl ( ) { this . exception = null ; } public CounterServiceImpl ( RuntimeException exception ) { this . exception = exception ; } public void run ( ) { new Thread ( new Runnable ( ) { @Override public void run ( ) { try { for ( int indx = 0 ; indx < 5 ; indx + + ) { Thread . sleep ( 1000 ) ; if ( exception ! = null ) { throw exception ; } count + = 1 ; } } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } } ) . start ( ) ; } @Override public int getCount ( ) { return count ; } }
public void run ( ) { new Thread ( new Runnable ( ) { @Override
public void run ( ) { try { for ( int indx = 0 ; indx < 5 ; indx + + ) {
public ConditionFactory andWithTimeout ( Duration timeout ) { return new ConditionFactory ( alias , timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory atMost ( Duration timeout ) { return new ConditionFactory ( alias , timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory forever ( ) { return new ConditionFactory ( alias , Duration . FOREVER , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory andWithPollInterval ( Duration pollInterval ) { return new ConditionFactory ( alias , timeout , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory andWithTimeout ( long timeout , TimeUnit unit ) { return new ConditionFactory ( alias , new Duration ( timeout , unit ) , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory atMost ( long timeout , TimeUnit unit ) { return new ConditionFactory ( alias , new Duration ( timeout , unit ) , pollInterval , catchUncaughtExceptions ) ; }
public ConditionFactory andWithPollInterval ( long pollInterval , TimeUnit unit ) { return new ConditionFactory ( alias , timeout , new Duration ( pollInterval , unit ) , catchUncaughtExceptions ) ; }
public ConditionFactory andCatchUncaughtExceptions ( ) { return new ConditionFactory ( alias , timeout , pollInterval , true ) ; }
public ConditionFactory await ( String alias ) throws Exception { return new ConditionFactory ( alias , timeout , pollInterval , catchUncaughtExceptions ) ; }
public static < S > S callTo ( S service ) { return ( S ) ProxyCreator . create ( service ) ; }
public < T > void until ( T ignore , final Matcher < T > matcher ) throws Exception { until ( new MethodCaller < T > ( ProxyState . getLastTarget ( ) , ProxyState . getLastMethod ( ) , ProxyState . getLastArgs ( ) ) , matcher ) ;
public < T > void until ( final Callable < T > supplier , final Matcher < T > matcher ) throws Exception { if ( supplier = = null ) { throw new IllegalArgumentException ( " You must specify a supplier (was null). " ) ; } if ( matcher = = null ) { throw new IllegalArgumentException ( " You must specify a matcher (was null). " ) ; } until ( new ConditionEvaluator ( ) { public Boolean call ( ) throws Exception {
public < T > void until ( Callable < Boolean > conditionEvaluator ) throws Exception { AwaitConditionImpl condition = new AwaitConditionImpl ( alias , timeout , conditionEvaluator , pollInterval ) ; if ( catchUncaughtExceptions ) { condition . andCatchAllUncaughtExceptions ( ) ; } condition . await ( ) ; }
public static Object create ( Object target ) { Object proxy = null ; Class < ? extends Object > targetClass = target . getClass ( ) ; if ( Modifier . isFinal ( targetClass . getModifiers ( ) ) ) { if ( targetClassHasInterfaces ( targetClass ) ) { // TODO Issue warning? proxy = createInterfaceProxy(targetClass); } else { throw new CannotCreateProxyException( String .format( "Cannot create a proxy for class '%s' because it is final and doesn't implement any interfaces.", targetClass.getName())); } } else { proxy = createCGLibProxy(targetClass); } ProxyState.setLastTarget(target); return proxy; }
private static Object createCGLibProxy ( Class < ? extends Object > targetClass ) { Object proxy ; // Create CGLib Method interceptor MethodInterceptor interceptor = new MethodInterceptor() { public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { return callReceived(method, args); } }; // Create the proxy Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(targetClass); enhancer.setCallbackType(interceptor.getClass()); Class<?> proxiedClass = enhancer.createClass(); Enhancer.registerCallbacks(proxiedClass, new Callback[] { interceptor }); // Instantiate the proxied class Objenesis objenesis = new ObjenesisStd(); proxy = objenesis.newInstance(proxiedClass); return proxy; }
public Object intercept ( Object obj , Method method , Object [ ] args , MethodProxy proxy ) throws Throwable { return callReceived ( method , args ) ; }
private static Object createInterfaceProxy ( Class < ? > targetClass ) { return Proxy . newProxyInstance ( Thread . currentThread ( ) . getContextClassLoader ( ) , getInterfaceHierarchy ( targetClass ) , new InvocationHandler ( ) {
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { return callReceived ( method , args ) ; }
private static boolean targetClassHasInterfaces ( Class < ? extends Object > targetClass ) { Class < ? > [ ] interfaces = getInterfaceHierarchy ( targetClass ) ; return interfaces ! = null & & interfaces . length > = 1 ; }
private static Class < ? > [ ] getInterfaceHierarchy ( Class < ? extends Object > targetClass ) { if ( targetClass = = null | | targetClass . equals ( Object . class ) ) { return new Class < ? > [ 0 ] ; } Set < Class < ? > > interfaces = new HashSet < Class < ? > > ( ) ; interfaces . addAll ( Arrays . asList ( ( ( Class < ? > ) targetClass ) . getInterfaces ( ) ) ) ; interfaces . addAll ( Arrays . asList ( getInterfaceHierarchy ( ( ( Class < ? > ) targetClass ) . getSuperclass ( ) ) ) ) ; return interfaces . toArray ( new Class < ? > [ interfaces . size ( ) ] ) ; }
private static Object callReceived ( Method method , Object [ ] args ) { ProxyState . setLastMethod ( method ) ; ProxyState . setLastArgs ( args ) ; return TypeUtils . getDefaultValue ( method . getReturnType ( ) ) ; }
public static Object getLastTarget ( ) { return lastTarget ; }
public static void setLastTarget ( Object lastTarget ) { ProxyState . lastTarget = lastTarget ; }
public static Method getLastMethod ( ) { return lastMethod ; }
public static void setLastMethod ( Method lastMethod ) { ProxyState . lastMethod = lastMethod ; }
public static Object [ ] getLastArgs ( ) { return lastArgs ; }
public static void setLastArgs ( Object [ ] lastArgs ) { ProxyState . lastArgs = lastArgs ; }
void setCheckpoint ( String shardId , String checkpointValue , String concurrencyToken ) throws KinesisClientLibException ; /** * Get the current checkpoint stored for the specified shard. Useful for checking that the parent shard * has been completely processed before we start processing the child shard. * * @param shardId Current checkpoint for this shard is fetched * @return Current checkpoint for this shard, null if there is no record for this shard. * @throws KinesisClientLibException Thrown if we are unable to fetch the checkpoint */ String getCheckpoint ( String shardId ) throws KinesisClientLibException ; }
String getCheckpoint ( String shardId ) throws KinesisClientLibException ; }
void initialize ( String shardId ) ; /** * Process data records. The Amazon Kinesis Client Library will invoke this method to deliver data records to the * application. * Upon fail over, the new instance will get records with sequence number > checkpoint position * for each partition key. * * @param records Data records to be processed * @param checkpointer RecordProcessor should use this instance to checkpoint their progress. */ void processRecords ( List < Record > records , IRecordProcessorCheckpointer checkpointer ) ; /** * Invoked by the Amazon Kinesis Client Library to indicate it will no longer send data records to this * RecordProcessor instance. The reason parameter indicates: * a/ ShutdownReason.TERMINATE - The shard has been closed and there will not be any more records to process. The * record processor should checkpoint (after doing any housekeeping) to acknowledge that it has successfully * completed processing all records in this shard. * b/ ShutdownReason.ZOMBIE: A fail over has occurred and a different record processor is (or will be) responsible * for processing records. * * @param checkpointer RecordProcessor should use this instance to checkpoint. * @param reason Reason for the shutdown (ShutdownReason.TERMINATE indicates the shard is closed and there are no * more records to process. Shutdown.ZOMBIE indicates a fail over has occurred). */ void shutdown ( IRecordProcessorCheckpointer checkpointer , ShutdownReason reason ) ; }
void processRecords ( List < Record > records , IRecordProcessorCheckpointer checkpointer ) ; /** * Invoked by the Amazon Kinesis Client Library to indicate it will no longer send data records to this * RecordProcessor instance. The reason parameter indicates: * a/ ShutdownReason.TERMINATE - The shard has been closed and there will not be any more records to process. The * record processor should checkpoint (after doing any housekeeping) to acknowledge that it has successfully * completed processing all records in this shard. * b/ ShutdownReason.ZOMBIE: A fail over has occurred and a different record processor is (or will be) responsible * for processing records. * * @param checkpointer RecordProcessor should use this instance to checkpoint. * @param reason Reason for the shutdown (ShutdownReason.TERMINATE indicates the shard is closed and there are no * more records to process. Shutdown.ZOMBIE indicates a fail over has occurred). */ void shutdown ( IRecordProcessorCheckpointer checkpointer , ShutdownReason reason ) ; }
void shutdown ( IRecordProcessorCheckpointer checkpointer , ShutdownReason reason ) ; }
void checkpoint ( ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException ; }
public TaskResult call ( ) { Exception exception = null ; try { boolean blockedOnParentShard = false ; for ( String shardId : shardInfo . getParentShardIds ( ) ) { KinesisClientLease lease = leaseManager . getLease ( shardId ) ; if ( lease ! = null ) { String checkpoint = lease . getCheckpoint ( ) ; if ( ( checkpoint = = null ) | | ( ! checkpoint . equals ( SentinelCheckpoint . SHARD_END . toString ( ) ) ) ) { LOG . debug ( " Shard " + shardId + " is not yet done. Its current checkpoint is " + checkpoint ) ; blockedOnParentShard = true ; exception = new BlockedOnParentShardException ( " Parent shard not yet done " ) ; break ; } else { LOG . debug ( " Shard " + shardId + " has been completely processed. " ) ; } } else { LOG . info ( " No lease found for shard " + shardId + " . Not blocking on completion of this shard. " ) ; } } if ( ! blockedOnParentShard ) { LOG . info ( " No need to block on parents " + shardInfo . getParentShardIds ( ) + " of shard " + shardInfo . getShardId ( ) ) ; return new TaskResult ( null ) ; } } catch ( Exception e ) { LOG . error ( " Caught exception when checking for parent shard checkpoint " , e ) ; exception = e ; } try { Thread . sleep ( parentShardPollIntervalMillis ) ; } catch ( InterruptedException e ) { LOG . error ( " Sleep interrupted when waiting on parent shard(s) of " + shardInfo . getShardId ( ) , e ) ; } return new TaskResult ( exception ) ; }
public TaskType getTaskType ( ) { return taskType ; }
TaskResult call ( ) ; /** * @return TaskType */ TaskType getTaskType ( ) ; }
public TaskResult call ( ) { boolean applicationException = false ; Exception exception = null ; try { LOG . debug ( " Initializing ShardId " + shardInfo . getShardId ( ) ) ; String initialCheckpoint = checkpoint . getCheckpoint ( shardInfo . getShardId ( ) ) ; dataFetcher . initialize ( initialCheckpoint ) ; recordProcessorCheckpointer . setSequenceNumber ( initialCheckpoint ) ; try { LOG . debug ( " Calling the record processor initialize(). " ) ; recordProcessor . initialize ( shardInfo . getShardId ( ) ) ; LOG . debug ( " Record processor initialize() completed. " ) ; } catch ( Exception e ) { applicationException = true ; throw e ; } return new TaskResult ( null ) ; } catch ( Exception e ) { if ( applicationException ) { LOG . error ( " Application initialize() threw exception: " , e ) ; } else { LOG . error ( " Caught exception: " , e ) ; } exception = e ; // backoff if we encounter an exception. try { Thread.sleep(this.backoffTimeMillis); } catch (InterruptedException ie) { LOG.debug("Interrupted sleep", ie); } } return new TaskResult(exception); }
private void checkIsValuePositive ( String key , long value ) { if ( value < = 0 ) { throw new IllegalArgumentException ( " Value of " + key
private ClientConfiguration checkAndAppendKinesisClientLibUserAgent ( ClientConfiguration config ) { String existingUserAgent = config . getUserAgent ( ) ; if ( existingUserAgent . equals ( ClientConfiguration . DEFAULT_USER_AGENT ) ) { existingUserAgent = applicationName ; } if ( ! existingUserAgent . contains ( KINESIS_CLIENT_LIB_USER_AGENT ) ) { existingUserAgent + = " , " + KINESIS_CLIENT_LIB_USER_AGENT ; } config . setUserAgent ( existingUserAgent ) ; return config ; }
public String getApplicationName ( ) { return applicationName ; }
public long getFailoverTimeMillis ( ) { return failoverTimeMillis ; }
public AWSCredentialsProvider getKinesisCredentialsProvider ( ) { return kinesisCredentialsProvider ; }
public AWSCredentialsProvider getDynamoDBCredentialsProvider ( ) { return dynamoDBCredentialsProvider ; }
public AWSCredentialsProvider getCloudWatchCredentialsProvider ( ) { return cloudWatchCredentialsProvider ; }
public String getWorkerIdentifier ( ) { return workerIdentifier ; }
public long getShardSyncIntervalMillis ( ) { return shardSyncIntervalMillis ; }
public int getMaxRecords ( ) { return maxRecords ; }
public long getIdleTimeBetweenReadsInMillis ( ) { return idleTimeBetweenReadsInMillis ; }
boolean shouldCallProcessRecordsEvenForEmptyRecordList ( ) { return callProcessRecordsEvenForEmptyRecordList ; }
public long getEpsilonMillis ( ) { return EPSILON_MS ; }
public String getStreamName ( ) { return streamName ; }
public String getKinesisEndpoint ( ) { return kinesisEndpoint ; }
public InitialPositionInStream getInitialPositionInStream ( ) { return initialPositionInStream ; }
public long getParentShardPollIntervalMillis ( ) { return parentShardPollIntervalMillis ; }
public ClientConfiguration getKinesisClientConfiguration ( ) { return kinesisClientConfig ; }
public ClientConfiguration getDynamoDBClientConfiguration ( ) { return dynamoDBClientConfig ; }
public ClientConfiguration getCloudWatchClientConfiguration ( ) { return cloudWatchClientConfig ; }
public long getTaskBackoffTimeMillis ( ) { return taskBackoffTimeMillis ; }
public long getMetricsBufferTimeMillis ( ) { return metricsBufferTimeMillis ; }
public int getMetricsMaxQueueSize ( ) { return metricsMaxQueueSize ; }
public boolean shouldCleanupLeasesUponShardCompletion ( ) { return cleanupLeasesUponShardCompletion ; }
public KinesisClientLibConfiguration withKinesisEndpoint ( String kinesisEndpoint ) { this . kinesisEndpoint = kinesisEndpoint ; return this ; }
public KinesisClientLibConfiguration withInitialPositionInStream ( InitialPositionInStream initialPositionInStream ) { this . initialPositionInStream = initialPositionInStream ; return this ; }
public KinesisClientLibConfiguration withFailoverTimeMillis ( long failoverTimeMillis ) { checkIsValuePositive ( " FailoverTimeMillis " , failoverTimeMillis ) ; this . failoverTimeMillis = failoverTimeMillis ; return this ; }
public KinesisClientLibConfiguration withShardSyncIntervalMillis ( long shardSyncIntervalMillis ) { checkIsValuePositive ( " ShardSyncIntervalMillis " , shardSyncIntervalMillis ) ; this . shardSyncIntervalMillis = shardSyncIntervalMillis ; return this ; }
public KinesisClientLibConfiguration withMaxRecords ( int maxRecords ) { checkIsValuePositive ( " MaxRecords " , ( long ) maxRecords ) ; this . maxRecords = maxRecords ; return this ; }
public KinesisClientLibConfiguration withIdleTimeBetweenReadsInMillis ( long idleTimeBetweenReadsInMillis ) { checkIsValuePositive ( " IdleTimeBetweenReadsInMillis " , idleTimeBetweenReadsInMillis ) ; this . idleTimeBetweenReadsInMillis = idleTimeBetweenReadsInMillis ; return this ; }
public KinesisClientLibConfiguration withCallProcessRecordsEvenForEmptyRecordList ( boolean callProcessRecordsEvenForEmptyRecordList ) { this . callProcessRecordsEvenForEmptyRecordList = callProcessRecordsEvenForEmptyRecordList ; return this ; }
public KinesisClientLibConfiguration withParentShardPollIntervalMillis ( long parentShardPollIntervalMillis ) { checkIsValuePositive ( " ParentShardPollIntervalMillis " , parentShardPollIntervalMillis ) ; this . parentShardPollIntervalMillis = parentShardPollIntervalMillis ; return this ; }
public KinesisClientLibConfiguration withCleanupLeasesUponShardCompletion ( boolean cleanupLeasesUponShardCompletion ) { this . cleanupLeasesUponShardCompletion = cleanupLeasesUponShardCompletion ; return this ; }
public KinesisClientLibConfiguration withCommonClientConfig ( ClientConfiguration clientConfig ) { ClientConfiguration tempClientConfig = checkAndAppendKinesisClientLibUserAgent ( clientConfig ) ; this . kinesisClientConfig = tempClientConfig ; this . dynamoDBClientConfig = tempClientConfig ; this . cloudWatchClientConfig = tempClientConfig ; return this ; }
public KinesisClientLibConfiguration withKinesisClientConfig ( ClientConfiguration kinesisClientConfig ) { this . kinesisClientConfig = checkAndAppendKinesisClientLibUserAgent ( kinesisClientConfig ) ; return this ; }
public KinesisClientLibConfiguration withDynamoDBClientConfig ( ClientConfiguration dynamoDBClientConfig ) { this . dynamoDBClientConfig = checkAndAppendKinesisClientLibUserAgent ( dynamoDBClientConfig ) ; return this ; }
public KinesisClientLibConfiguration withCloudWatchClientConfig ( ClientConfiguration cloudWatchClientConfig ) { this . cloudWatchClientConfig = checkAndAppendKinesisClientLibUserAgent ( cloudWatchClientConfig ) ; return this ; }
public KinesisClientLibConfiguration withUserAgent ( String userAgent ) { String customizedUserAgent = userAgent + " , " + KINESIS_CLIENT_LIB_USER_AGENT ; this . kinesisClientConfig . setUserAgent ( customizedUserAgent ) ; this . dynamoDBClientConfig . setUserAgent ( customizedUserAgent ) ; this . cloudWatchClientConfig . setUserAgent ( customizedUserAgent ) ; return this ; }
public KinesisClientLibConfiguration withTaskBackoffTimeMillis ( long taskBackoffTimeMillis ) { checkIsValuePositive ( " TaskBackoffTimeMillis " , taskBackoffTimeMillis ) ; this . taskBackoffTimeMillis = taskBackoffTimeMillis ; return this ; }
public KinesisClientLibConfiguration withMetricsBufferTimeMillis ( long metricsBufferTimeMillis ) { checkIsValuePositive ( " MetricsBufferTimeMillis " , metricsBufferTimeMillis ) ; this . metricsBufferTimeMillis = metricsBufferTimeMillis ; return this ; }
public KinesisClientLibConfiguration withMetricsMaxQueueSize ( int metricsMaxQueueSize ) { checkIsValuePositive ( " MetricsMaxQueueSize " , ( long ) metricsMaxQueueSize ) ; this . metricsMaxQueueSize = metricsMaxQueueSize ; return this ; }
boolean setCheckpoint ( String shardId , String checkpoint , UUID concurrencyToken ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { KinesisClientLease lease = getCurrentlyHeldLease ( shardId ) ; if ( lease = = null ) { LOG . info ( String . format ( " Worker %s could not update checkpoint for shard %s because it does not hold the lease " , getWorkerIdentifier ( ) , shardId ) ) ; return false ; } lease . setCheckpoint ( checkpoint ) ; lease . setOwnerSwitchesSinceCheckpoint ( 0 L ) ; return updateLease ( lease , concurrencyToken ) ; }
public void setCheckpoint ( String shardId , String checkpointValue , String concurrencyToken ) throws KinesisClientLibException { try { boolean wasSuccessful = setCheckpoint ( shardId , checkpointValue , UUID . fromString ( concurrencyToken ) ) ;
public String getCheckpoint ( String shardId ) throws KinesisClientLibException { try { return leaseManager . getLease ( shardId ) . getCheckpoint ( ) ;
public List < ShardInfo > getCurrentAssignments ( ) { List < ShardInfo > assignments = new LinkedList < ShardInfo > ( ) ; Collection < KinesisClientLease > leases = getAssignments ( ) ; if ( ( leases ! = null ) & & ( ! leases . isEmpty ( ) ) ) { for ( KinesisClientLease lease : leases ) { Set < String > parentShardIds = lease . getParentShardIds ( ) ; ShardInfo assignment = new ShardInfo ( lease . getLeaseKey ( ) , lease . getConcurrencyToken ( ) . toString ( ) , parentShardIds ) ; assignments . add ( assignment ) ; } } return assignments ; }
void initialize ( ) throws ProvisionedThroughputException , DependencyException , IllegalStateException { final boolean newTableCreated = leaseManager . createLeaseTableIfNotExists ( initialLeaseTableReadCapacity , initialLeaseTableWriteCapacity ) ; if ( newTableCreated ) { LOG . info ( " Created new lease table for coordinator " ) ; } // Need to wait for table in active state. final long secondsBetweenPolls = 10L; final long timeoutSeconds = 600L; final boolean isTableActive = leaseManager.waitUntilLeaseTableExists(secondsBetweenPolls, timeoutSeconds); if (!isTableActive) { throw new DependencyException(new IllegalStateException("Creating table timeout"));
void runLeaseTaker ( ) throws DependencyException , InvalidStateException { super . runTaker ( ) ; }
void runLeaseRenewer ( ) throws DependencyException , InvalidStateException { super . runRenewer ( ) ; }
ILeaseManager < KinesisClientLease > getLeaseManager ( ) { return leaseManager ; }
public List < Record > getRecords ( int maxRecords ) { if ( ! isInitialized ) { throw new IllegalArgumentException ( " KinesisDataFetcher.getRecords called before initialization. " ) ; } List < Record > records = null ; GetRecordsResult response = null ; if ( nextIterator ! = null ) { try { response = kinesisProxy . get ( nextIterator , maxRecords ) ; records = response . getRecords ( ) ; nextIterator = response . getNextShardIterator ( ) ; } catch ( ResourceNotFoundException e ) { LOG . info ( " Caught ResourceNotFoundException when fetching records for shard " + shardId ) ; nextIterator = null ; } if ( nextIterator = = null ) { isShardEndReached = true ; } } else { isShardEndReached = true ; } return records ; }
public void initialize ( String initialCheckpoint ) { LOG . info ( " Initializing shard " + shardId + " with " + initialCheckpoint ) ; advanceIteratorAfter ( initialCheckpoint ) ; isInitialized = true ; }
private void advanceIteratorAfterSequenceNumber ( String sequenceNumber ) { nextIterator = getIterator ( ShardIteratorType . AFTER_SEQUENCE_NUMBER . toString ( ) , sequenceNumber ) ; }
void advanceIteratorAfter ( String sequenceNumber ) { if ( sequenceNumber = = null ) { throw new IllegalArgumentException ( " SequenceNumber should not be null: shardId " + shardId ) ; } else if ( sequenceNumber . equals ( SentinelCheckpoint . LATEST . toString ( ) ) ) { nextIterator = getIterator ( ShardIteratorType . LATEST . toString ( ) , null ) ; } else if ( sequenceNumber . equals ( SentinelCheckpoint . TRIM_HORIZON . toString ( ) ) ) { nextIterator = getIterator ( ShardIteratorType . TRIM_HORIZON . toString ( ) , null ) ; } else if ( sequenceNumber . equals ( SentinelCheckpoint . SHARD_END . toString ( ) ) ) { nextIterator = null ; } else { advanceIteratorAfterSequenceNumber ( sequenceNumber ) ; } if ( nextIterator = = null ) { isShardEndReached = true ;
private String getIterator ( String iteratorType , String sequenceNumber ) { String iterator = null ; try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Calling getIterator for " + shardId + " , iterator type " + iteratorType + " and sequence number " + sequenceNumber ) ; } iterator = kinesisProxy . getIterator ( shardId , iteratorType , sequenceNumber ) ; } catch ( ResourceNotFoundException e ) { LOG . info ( " Caught ResourceNotFoundException when getting an iterator for shard " + shardId , e ) ; } return iterator ; }
protected boolean isShardEndReached ( ) { return isShardEndReached ; }
String getNextIterator ( ) { return nextIterator ; }
public TaskResult call ( ) { String taskName = other . getClass ( ) . getSimpleName ( ) ; MetricsHelper . startScope ( factory , taskName ) ; long startTimeMillis = System . currentTimeMillis ( ) ; TaskResult result = other . call ( ) ; MetricsHelper . addSuccessAndLatency ( null , startTimeMillis , result . getException ( ) = = null ) ; MetricsHelper . endScope ( ) ; return result ; }
public TaskType getTaskType ( ) { return other . getTaskType ( ) ; }
private String getMaxSequenceNumber ( IMetricsScope scope , List < Record > records ) { scope . addData ( RECORDS_PROCESSED_METRIC , records . size ( ) , StandardUnit . Count ) ; ListIterator < Record > recordIterator = records . listIterator ( ) ; BigInteger maxSequenceNumber = BigInteger . ZERO ; while ( recordIterator . hasNext ( ) ) { Record record = recordIterator . next ( ) ; BigInteger sequenceNumber = new BigInteger ( record . getSequenceNumber ( ) ) ; if ( maxSequenceNumber . compareTo ( sequenceNumber ) < 0 ) { maxSequenceNumber = sequenceNumber ; } scope . addData ( DATA_BYTES_PROCESSED_METRIC , record . getData ( ) . limit ( ) , StandardUnit . Bytes ) ; } return maxSequenceNumber . toString ( ) ; }
private List < Record > getRecords ( ) throws KinesisClientLibException { int maxRecords = streamConfig . getMaxRecords ( ) ; try { return dataFetcher . getRecords ( maxRecords ) ;
public synchronized void checkpoint ( ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException { advancePosition ( ) ; }
String getLastCheckpointValue ( ) { return lastCheckpointValue ; }
synchronized String getSequenceNumber ( ) { return sequenceNumber ; }
synchronized void setSequenceNumber ( String sequenceNumber ) { this . sequenceNumber = sequenceNumber ; }
void advancePosition ( ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException { try { checkpoint . setCheckpoint ( shardInfo . getShardId ( ) , sequenceNumber , shardInfo . getConcurrencyToken ( ) ) ;
synchronized boolean consumeShard ( ) { return checkAndSubmitNextTask ( ) ; }
synchronized boolean beginShutdown ( ) { if ( currentState ! = ShardConsumerState . SHUTDOWN_COMPLETE ) { markForShutdown ( ShutdownReason . ZOMBIE ) ; checkAndSubmitNextTask ( ) ; } return isShutdown ( ) ; }
synchronized void markForShutdown ( ShutdownReason reason ) { beginShutdown = true ; // ShutdownReason.ZOMBIE takes precedence over TERMINATE (we won't be able to save checkpoint at end of shard) if ((shutdownReason == null) || (shutdownReason == ShutdownReason.TERMINATE)) { shutdownReason = reason;
boolean isShutdown ( ) { return currentState = = ShardConsumerState . SHUTDOWN_COMPLETE ; }
ShutdownReason getShutdownReason ( ) { return shutdownReason ; }
private ITask getNextTask ( ) { ITask nextTask = null ; switch ( currentState ) { case WAITING_ON_PARENT_SHARDS : nextTask = new BlockOnParentShardTask ( shardInfo , leaseManager , parentShardPollIntervalMillis ) ; break ; case INITIALIZING : nextTask = new InitializeTask ( shardInfo , recordProcessor , checkpoint , recordProcessorCheckpointer , dataFetcher , taskBackoffTimeMillis ) ; break ; case PROCESSING : nextTask = new ProcessTask ( shardInfo , streamConfig , recordProcessor , recordProcessorCheckpointer , dataFetcher , taskBackoffTimeMillis ) ; break ; case SHUTTING_DOWN : nextTask = new ShutdownTask ( shardInfo , recordProcessor , recordProcessorCheckpointer , shutdownReason , streamConfig . getStreamProxy ( ) , streamConfig . getInitialPositionInStream ( ) , cleanupLeasesOfCompletedShards , leaseManager , taskBackoffTimeMillis ) ; break ; case SHUTDOWN_COMPLETE : break ; default : break ; } if ( nextTask = = null ) { return null ;
void updateState ( boolean taskCompletedSuccessfully ) { switch ( currentState ) { case WAITING_ON_PARENT_SHARDS :
ShardConsumerState getCurrentState ( ) { return currentState ; }
protected String getShardId ( ) { return shardId ; }
protected String getConcurrencyToken ( ) { return concurrencyToken ; }
protected List < String > getParentShardIds ( ) { return new LinkedList < String > ( parentShardIds ) ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( concurrencyToken = = null ) ? 0 : concurrencyToken . hashCode ( ) ) ; result = prime * result + ( ( parentShardIds = = null ) ? 0 : parentShardIds . hashCode ( ) ) ; result = prime * result + ( ( shardId = = null ) ? 0 : shardId . hashCode ( ) ) ; return result ; }
public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null ) { return false ; } if ( getClass ( ) ! = obj . getClass ( ) ) { return false ; } ShardInfo other = ( ShardInfo ) obj ; if ( concurrencyToken = = null ) { if ( other . concurrencyToken ! = null ) { return false ; } } else if ( ! concurrencyToken . equals ( other . concurrencyToken ) ) { return false ; } if ( parentShardIds = = null ) { if ( other . parentShardIds ! = null ) { return false ; } } else if ( ! parentShardIds . equals ( other . parentShardIds ) ) { return false ; } if ( shardId = = null ) { if ( other . shardId ! = null ) { return false ; } } else if ( ! shardId . equals ( other . shardId ) ) { return false ; } return true ; }
public TaskResult call ( ) { Exception exception = null ; try { ShardSyncer . checkAndCreateLeasesForNewShards ( kinesisProxy , leaseManager , initialPosition , cleanupLeasesUponShardCompletion ) ; if ( shardSyncTaskIdleTimeMillis > 0 ) { Thread . sleep ( shardSyncTaskIdleTimeMillis ) ; } } catch ( Exception e ) { LOG . error ( " Caught exception while sync'ing Kinesis shards and leases " , e ) ; exception = e ; } return new TaskResult ( exception ) ; }
synchronized boolean syncShardAndLeaseInfo ( Set < String > closedShardIds ) { return checkAndSubmitNextTask ( closedShardIds ) ; }
private synchronized boolean checkAndSubmitNextTask ( Set < String > closedShardIds ) { boolean submittedNewTask = false ; if ( ( future = = null ) | | future . isCancelled ( ) | | future . isDone ( ) ) { if ( ( future ! = null ) & & future . isDone ( ) ) { try { TaskResult result = future . get ( ) ; if ( result . getException ( ) ! = null ) { LOG . error ( " Caught exception running " + currentTask . getTaskType ( ) + " task: " , result . getException ( ) ) ; } } catch ( InterruptedException | ExecutionException e ) { LOG . warn ( currentTask . getTaskType ( ) + " task encountered exception. " , e ) ; } } currentTask = new MetricsCollectingTaskDecorator ( new ShardSyncTask ( kinesisProxy , leaseManager , initialPositionInStream , cleanupLeasesUponShardCompletion , shardSyncIdleTimeMillis ) , metricsFactory ) ; future = executorService . submit ( currentTask ) ; submittedNewTask = true ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Submitted new " + currentTask . getTaskType ( ) + " task. " ) ; } } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Previous " + currentTask . getTaskType ( ) + " task still pending. Not submitting new task. " ) ; } } return submittedNewTask ; }
static synchronized void bootstrapShardLeases ( IKinesisProxy kinesisProxy , ILeaseManager < KinesisClientLease > leaseManager , InitialPositionInStream initialPositionInStream , boolean cleanupLeasesOfCompletedShards ) throws DependencyException , InvalidStateException , ProvisionedThroughputException , KinesisClientLibIOException { syncShardLeases ( kinesisProxy , leaseManager , initialPositionInStream , cleanupLeasesOfCompletedShards ) ; }
static synchronized void checkAndCreateLeasesForNewShards ( IKinesisProxy kinesisProxy , ILeaseManager < KinesisClientLease > leaseManager , InitialPositionInStream initialPositionInStream , boolean cleanupLeasesOfCompletedShards ) throws DependencyException , InvalidStateException , ProvisionedThroughputException , KinesisClientLibIOException { syncShardLeases ( kinesisProxy , leaseManager , initialPositionInStream , cleanupLeasesOfCompletedShards ) ; }
private static synchronized void syncShardLeases ( IKinesisProxy kinesisProxy , ILeaseManager < KinesisClientLease > leaseManager , InitialPositionInStream initialPosition , boolean cleanupLeasesOfCompletedShards ) throws DependencyException , InvalidStateException , ProvisionedThroughputException , KinesisClientLibIOException { List < Shard > shards = getShardList ( kinesisProxy ) ; LOG . debug ( " Num shards: " + shards . size ( ) ) ; Map < String , Shard > shardIdToShardMap = constructShardIdToShardMap ( shards ) ; Map < String , Set < String > > shardIdToChildShardIdsMap = constructShardIdToChildShardIdsMap ( shardIdToShardMap ) ; assertAllParentShardsAreClosed ( shardIdToChildShardIdsMap , shardIdToShardMap ) ; List < KinesisClientLease > currentLeases = leaseManager . listLeases ( ) ; List < KinesisClientLease > newLeasesToCreate = determineNewLeasesToCreate ( shards , currentLeases , initialPosition ) ; LOG . debug ( " Num new leases to create: " + newLeasesToCreate . size ( ) ) ; for ( KinesisClientLease lease : newLeasesToCreate ) { long startTimeMillis = System . currentTimeMillis ( ) ; boolean success = false ; try { leaseManager . createLeaseIfNotExists ( lease ) ; success = true ; } finally { MetricsHelper . addSuccessAndLatency ( " CreateLease " , startTimeMillis , success ) ; } } List < KinesisClientLease > trackedLeases = new ArrayList < > ( ) ; if ( currentLeases ! = null ) { trackedLeases . addAll ( currentLeases ) ; } trackedLeases . addAll ( newLeasesToCreate ) ; cleanupGarbageLeases ( shards , trackedLeases , kinesisProxy , leaseManager ) ; if ( cleanupLeasesOfCompletedShards ) { cleanupLeasesOfFinishedShards ( currentLeases ,
private static void assertAllParentShardsAreClosed ( Map < String , Set < String > > shardIdToChildShardIdsMap , Map < String , Shard > shardIdToShardMap ) throws KinesisClientLibIOException { for ( String parentShardId : shardIdToChildShardIdsMap . keySet ( ) ) { Shard parentShard = shardIdToShardMap . get ( parentShardId ) ;
static Map < String , KinesisClientLease > constructShardIdToKCLLeaseMap ( List < KinesisClientLease > trackedLeaseList ) { Map < String , KinesisClientLease > trackedLeasesMap = new HashMap < > ( ) ; for ( KinesisClientLease lease : trackedLeaseList ) { trackedLeasesMap . put ( lease . getLeaseKey ( ) , lease ) ; } return trackedLeasesMap ; }
static synchronized void assertClosedShardsAreCoveredOrAbsent ( Map < String , Shard > shardIdToShardMap , Map < String , Set < String > > shardIdToChildShardIdsMap , Set < String > shardIdsOfClosedShards ) throws KinesisClientLibIOException { String exceptionMessageSuffix = " This can happen if we constructed the list of shards " + " while a reshard operation was in progress. " ; for ( String shardId : shardIdsOfClosedShards ) { Shard shard = shardIdToShardMap . get ( shardId ) ;
private static synchronized void assertHashRangeOfClosedShardIsCovered ( Shard closedShard , Map < String , Shard > shardIdToShardMap , Set < String > childShardIds ) throws KinesisClientLibIOException { BigInteger startingHashKeyOfClosedShard = new BigInteger ( closedShard . getHashKeyRange ( ) . getStartingHashKey ( ) ) ; BigInteger endingHashKeyOfClosedShard = new BigInteger ( closedShard . getHashKeyRange ( ) . getEndingHashKey ( ) ) ; BigInteger minStartingHashKeyOfChildren = null ; BigInteger maxEndingHashKeyOfChildren = null ; for ( String childShardId : childShardIds ) { Shard childShard = shardIdToShardMap . get ( childShardId ) ; BigInteger startingHashKey = new BigInteger ( childShard . getHashKeyRange ( ) . getStartingHashKey ( ) ) ; if ( ( minStartingHashKeyOfChildren = = null ) | | ( startingHashKey . compareTo ( minStartingHashKeyOfChildren ) < 0 ) ) { minStartingHashKeyOfChildren = startingHashKey ; } BigInteger endingHashKey = new BigInteger ( childShard . getHashKeyRange ( ) . getEndingHashKey ( ) ) ; if ( ( maxEndingHashKeyOfChildren = = null ) | | ( endingHashKey . compareTo ( maxEndingHashKeyOfChildren ) > 0 ) ) { maxEndingHashKeyOfChildren = endingHashKey ; } } if ( ( minStartingHashKeyOfChildren = = null ) | | ( maxEndingHashKeyOfChildren = = null ) | | ( minStartingHashKeyOfChildren . compareTo ( startingHashKeyOfClosedShard ) > 0 )
static Map < String , Set < String > > constructShardIdToChildShardIdsMap ( Map < String , Shard > shardIdToShardMap ) { Map < String , Set < String > > shardIdToChildShardIdsMap = new HashMap < > ( ) ; for ( Map . Entry < String , Shard > entry : shardIdToShardMap . entrySet ( ) ) { String shardId = entry . getKey ( ) ; Shard shard = entry . getValue ( ) ; String parentShardId = shard . getParentShardId ( ) ; if ( ( parentShardId ! = null ) & & ( shardIdToShardMap . containsKey ( parentShardId ) ) ) { Set < String > childShardIds = shardIdToChildShardIdsMap . get ( parentShardId ) ; if ( childShardIds = = null ) { childShardIds = new HashSet < String > ( ) ; shardIdToChildShardIdsMap . put ( parentShardId , childShardIds ) ; } childShardIds . add ( shardId ) ; } String adjacentParentShardId = shard . getAdjacentParentShardId ( ) ; if ( ( adjacentParentShardId ! = null ) & & ( shardIdToShardMap . containsKey ( adjacentParentShardId ) ) ) { Set < String > childShardIds = shardIdToChildShardIdsMap . get ( adjacentParentShardId ) ; if ( childShardIds = = null ) { childShardIds = new HashSet < String > ( ) ; shardIdToChildShardIdsMap . put ( adjacentParentShardId , childShardIds ) ; } childShardIds . add ( shardId ) ; } } return shardIdToChildShardIdsMap ; }
private static List < Shard > getShardList ( IKinesisProxy kinesisProxy ) throws KinesisClientLibIOException { List < Shard > shards = kinesisProxy . getShardList ( ) ; if ( shards = = null ) { throw new KinesisClientLibIOException ( " Stream is not in ACTIVE OR UPDATING state - will retry getting the shard list. " ) ; } return shards ; }
static List < KinesisClientLease > determineNewLeasesToCreate ( List < Shard > shards , List < KinesisClientLease > currentLeases , InitialPositionInStream initialPosition ) { Map < String , KinesisClientLease > shardIdToNewLeaseMap = new HashMap < String , KinesisClientLease > ( ) ; Map < String , Shard > shardIdToShardMapOfAllKinesisShards = constructShardIdToShardMap ( shards ) ; Set < String > shardIdsOfCurrentLeases = new HashSet < String > ( ) ; for ( KinesisClientLease lease : currentLeases ) { shardIdsOfCurrentLeases . add ( lease . getLeaseKey ( ) ) ; LOG . debug ( " Existing lease: " + lease ) ; } List < Shard > openShards = getOpenShards ( shards ) ; Map < String , Boolean > memoizationContext = new HashMap < > ( ) ; // Iterate over the open shards and find those that don't have any lease entries. for (Shard shard : openShards) { String shardId = shard.getShardId(); LOG.debug("Evaluating leases for open shard " + shardId + " and its ancestors."); if (shardIdsOfCurrentLeases.contains(shardId)) { LOG.debug("Lease for shardId " + shardId + " already exists. Not creating a lease"); } else { LOG.debug("Need to create a lease for shardId " + shardId); KinesisClientLease newLease = newKCLLease(shard); boolean isDescendant = checkIfDescendantAndAddNewLeasesForAncestors(shardId, initialPosition, shardIdsOfCurrentLeases, shardIdToShardMapOfAllKinesisShards, shardIdToNewLeaseMap, memoizationContext); if (isDescendant) { newLease.setCheckpoint(SentinelCheckpoint.TRIM_HORIZON.toString()); } else { newLease.setCheckpoint(convertToCheckpoint(initialPosition)); } LOG.debug("Set checkpoint of " + newLease.getLeaseKey() + " to " + newLease.getCheckpoint()); shardIdToNewLeaseMap.put(shardId, newLease); } } List<KinesisClientLease> newLeasesToCreate = new ArrayList<KinesisClientLease>(); newLeasesToCreate.addAll(shardIdToNewLeaseMap.values()); Comparator<? super KinesisClientLease> startingSequenceNumberComparator = new StartingSequenceNumberAndShardIdBasedComparator(shardIdToShardMapOfAllKinesisShards); Collections.sort(newLeasesToCreate, startingSequenceNumberComparator); return newLeasesToCreate; }
static Set < String > getParentShardIds ( Shard shard , Map < String , Shard > shardIdToShardMapOfAllKinesisShards ) { Set < String > parentShardIds = new HashSet < String > ( 2 ) ; String parentShardId = shard . getParentShardId ( ) ; if ( ( parentShardId ! = null ) & & shardIdToShardMapOfAllKinesisShards . containsKey ( parentShardId ) ) { parentShardIds . add ( parentShardId ) ; } String adjacentParentShardId = shard . getAdjacentParentShardId ( ) ; if ( ( adjacentParentShardId ! = null ) & & shardIdToShardMapOfAllKinesisShards . containsKey ( adjacentParentShardId ) ) { parentShardIds . add ( adjacentParentShardId ) ; } return parentShardIds ; }
private static void cleanupGarbageLeases ( List < Shard > shards , List < KinesisClientLease > trackedLeases , IKinesisProxy kinesisProxy , ILeaseManager < KinesisClientLease > leaseManager ) throws KinesisClientLibIOException , DependencyException , InvalidStateException , ProvisionedThroughputException { Set < String > kinesisShards = new HashSet < > ( ) ; for ( Shard shard : shards ) { kinesisShards . add ( shard . getShardId ( ) ) ; } // Check if there are leases for non-existent shards List<KinesisClientLease> garbageLeases = new ArrayList<>(); for (KinesisClientLease lease : trackedLeases) { if (isCandidateForCleanup(lease, kinesisShards)) { garbageLeases.add(lease); } } if (!garbageLeases.isEmpty()) { LOG.info("Found " + garbageLeases.size()
static boolean isCandidateForCleanup ( KinesisClientLease lease , Set < String > currentKinesisShardIds ) throws KinesisClientLibIOException { boolean isCandidateForCleanup = true ; if ( currentKinesisShardIds . contains ( lease . getLeaseKey ( ) ) ) { isCandidateForCleanup = false ; } else { LOG . info ( " Found lease for non-existent shard: " + lease . getLeaseKey ( ) + " . Checking its parent shards " ) ; Set < String > parentShardIds = lease . getParentShardIds ( ) ; for ( String parentShardId : parentShardIds ) { // Throw an exception if the parent shard exists (but the child does not). // This may be a (rare) race condition between fetching the shard list and Kinesis expiring shards. if (currentKinesisShardIds.contains(parentShardId)) { String message = "Parent shard " + parentShardId + " exists but not the child shard " + lease.getLeaseKey(); LOG.info(message); throw new KinesisClientLibIOException(message); } } } return isCandidateForCleanup; }
private static synchronized void cleanupLeasesOfFinishedShards ( Collection < KinesisClientLease > currentLeases , Map < String , Shard > shardIdToShardMap , Map < String , Set < String > > shardIdToChildShardIdsMap , List < KinesisClientLease > trackedLeases , ILeaseManager < KinesisClientLease > leaseManager ) throws DependencyException , InvalidStateException , ProvisionedThroughputException , KinesisClientLibIOException { Set < String > shardIdsOfClosedShards = new HashSet < > ( ) ; List < KinesisClientLease > leasesOfClosedShards = new ArrayList < > ( ) ; for ( KinesisClientLease lease : currentLeases ) { if ( lease . getCheckpoint ( ) . equals ( SentinelCheckpoint . SHARD_END . toString ( ) ) ) { shardIdsOfClosedShards . add ( lease . getLeaseKey ( ) ) ; leasesOfClosedShards . add ( lease ) ; } } if ( ! leasesOfClosedShards . isEmpty ( ) ) { assertClosedShardsAreCoveredOrAbsent ( shardIdToShardMap ,
static synchronized void cleanupLeaseForClosedShard ( String closedShardId , Set < String > childShardIds , Map < String , KinesisClientLease > trackedLeases , ILeaseManager < KinesisClientLease > leaseManager ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { KinesisClientLease leaseForClosedShard = trackedLeases . get ( closedShardId ) ; List < KinesisClientLease > childShardLeases = new ArrayList < > ( ) ; for ( String childShardId : childShardIds ) { KinesisClientLease childLease = trackedLeases . get ( childShardId ) ; if ( childLease ! = null ) { childShardLeases . add ( childLease ) ; } } if ( ( leaseForClosedShard ! = null ) & & ( leaseForClosedShard . getCheckpoint ( ) . equals ( SentinelCheckpoint . SHARD_END . toString ( ) ) )
static KinesisClientLease newKCLLease ( Shard shard ) { KinesisClientLease newLease = new KinesisClientLease ( ) ; newLease . setLeaseKey ( shard . getShardId ( ) ) ; List < String > parentShardIds = new ArrayList < String > ( 2 ) ; if ( shard . getParentShardId ( ) ! = null ) { parentShardIds . add ( shard . getParentShardId ( ) ) ; } if ( shard . getAdjacentParentShardId ( ) ! = null ) { parentShardIds . add ( shard . getAdjacentParentShardId ( ) ) ; } newLease . setParentShardIds ( parentShardIds ) ; newLease . setOwnerSwitchesSinceCheckpoint ( 0 L ) ; return newLease ; }
static Map < String , Shard > constructShardIdToShardMap ( List < Shard > shards ) { Map < String , Shard > shardIdToShardMap = new HashMap < String , Shard > ( ) ; for ( Shard shard : shards ) { shardIdToShardMap . put ( shard . getShardId ( ) , shard ) ; } return shardIdToShardMap ; }
static List < Shard > getOpenShards ( List < Shard > allShards ) { List < Shard > openShards = new ArrayList < Shard > ( ) ; for ( Shard shard : allShards ) { String endingSequenceNumber = shard . getSequenceNumberRange ( ) . getEndingSequenceNumber ( ) ; if ( endingSequenceNumber = = null ) { openShards . add ( shard ) ; LOG . debug ( " Found open shard: " + shard . getShardId ( ) ) ; } } return openShards ; }
private static String convertToCheckpoint ( InitialPositionInStream position ) { String checkpoint = null ; if ( position . equals ( InitialPositionInStream . TRIM_HORIZON ) ) { checkpoint = SentinelCheckpoint . TRIM_HORIZON . toString ( ) ; } else if ( position . equals ( InitialPositionInStream . LATEST ) ) { checkpoint = SentinelCheckpoint . LATEST . toString ( ) ; } return checkpoint ; }
public int compare ( KinesisClientLease lease1 , KinesisClientLease lease2 ) { int result = 0 ; String shardId1 = lease1 . getLeaseKey ( ) ; String shardId2 = lease2 . getLeaseKey ( ) ; Shard shard1 = shardIdToShardMap . get ( shardId1 ) ; Shard shard2 = shardIdToShardMap . get ( shardId2 ) ; // If we found shards for the two leases, use comparison of the starting sequence numbers if ((shard1 != null) && (shard2 != null)) { BigInteger sequenceNumber1 = new BigInteger(shard1.getSequenceNumberRange().getStartingSequenceNumber()); BigInteger sequenceNumber2 = new BigInteger(shard2.getSequenceNumberRange().getStartingSequenceNumber()); result = sequenceNumber1.compareTo(sequenceNumber2); } if (result == 0) { result = shardId1.compareTo(shardId2); } return result; }
public TaskResult call ( ) { Exception exception = null ; boolean applicationException = false ; try { // If we reached end of the shard, set sequence number to SHARD_END. if (reason == ShutdownReason.TERMINATE) { recordProcessorCheckpointer.setSequenceNumber(SentinelCheckpoint.SHARD_END.toString()); } LOG.debug("Invoking shutdown() for shard " + shardInfo.getShardId() + ", concurrencyToken " + shardInfo.getConcurrencyToken() + ". Shutdown reason: " + reason); try { recordProcessor.shutdown(recordProcessorCheckpointer, reason); String lastCheckpointValue = recordProcessorCheckpointer.getLastCheckpointValue(); if (reason == ShutdownReason.TERMINATE) { if ((lastCheckpointValue == null) || (!lastCheckpointValue.equals(SentinelCheckpoint.SHARD_END.toString()))) { throw new IllegalArgumentException("Application didn't checkpoint at end of shard " + shardInfo.getShardId()); } } LOG.debug("Record processor completed shutdown() for shard " + shardInfo.getShardId()); } catch (Exception e) { applicationException = true; throw e; } if (reason == ShutdownReason.TERMINATE) { LOG.debug("Looking for child shards of shard " + shardInfo.getShardId()); // create leases for the child shards ShardSyncer.checkAndCreateLeasesForNewShards(kinesisProxy, leaseManager, initialPositionInStream, cleanupLeasesOfCompletedShards); LOG.debug("Finished checking for child shards of shard " + shardInfo.getShardId()); } return new TaskResult(null); } catch (Exception e) { if (applicationException) { LOG.error("Application exception. ", e); } else { LOG.error("Caught exception: ", e); } exception = e; // backoff if we encounter an exception. try { Thread.sleep(this.backoffTimeMillis); } catch (InterruptedException ie) { LOG.debug("Interrupted sleep", ie); } } return new TaskResult(exception); }
IKinesisProxy getStreamProxy ( ) { return streamProxy ; }
long getIdleTimeInMilliseconds ( ) { return idleTimeInMilliseconds ; }
InitialPositionInStream getInitialPositionInStream ( ) { return initialPositionInStream ; }
protected boolean isShardEndReached ( ) { return shardEndReached ; }
protected void setShardEndReached ( boolean shardEndReached ) { this . shardEndReached = shardEndReached ; }
public Exception getException ( ) { return exception ; }
public void run ( ) { try { initialize ( ) ; LOG . info ( " Initialization complete. Starting worker loop. " ) ; } catch ( RuntimeException e1 ) { LOG . error ( " Unable to initialize after " + MAX_INITIALIZATION_ATTEMPTS + " attempts. Shutting down. " , e1 ) ; shutdown ( ) ; } while ( ! shutdown ) { try { boolean foundCompletedShard = false ; Set < String > assignedShardIds = new HashSet < String > ( ) ; for ( ShardInfo shardInfo : getShardInfoForAssignments ( ) ) { ShardConsumer shardConsumer = createOrGetShardConsumer ( shardInfo , recordProcessorFactory ) ; if ( shardConsumer . isShutdown ( ) & & shardConsumer . getShutdownReason ( ) . equals ( ShutdownReason . TERMINATE ) ) { foundCompletedShard = true ; } else { shardConsumer . consumeShard ( ) ; } assignedShardIds . add ( shardInfo . getShardId ( ) ) ; } if ( foundCompletedShard ) { controlServer . syncShardAndLeaseInfo ( null ) ; } // clean up shard consumers for unassigned shards cleanupShardConsumers(assignedShardIds); wlog.info("Sleeping ..."); Thread.sleep(idleTimeInMilliseconds); } catch (Exception e) { LOG.error(String.format("Worker.run caught exception, sleeping for %s milli seconds!", String.valueOf(idleTimeInMilliseconds)), e); try { Thread.sleep(idleTimeInMilliseconds); } catch (InterruptedException ex) { LOG.info("Worker: sleep interrupted after catching exception ", ex); } } wlog.resetInfoLogging(); } LOG.info("Stopping LeaseCoordinator."); leaseCoordinator.stop(); }
private void initialize ( ) { boolean isDone = false ; Exception lastException = null ; for ( int i = 0 ; ( ! isDone ) & & ( i < MAX_INITIALIZATION_ATTEMPTS ) ; i + + ) { try { LOG . info ( " Initialization attempt " + ( i + 1 ) ) ; LOG . info ( " Initializing LeaseCoordinator " ) ; leaseCoordinator . initialize ( ) ; LOG . info ( " Syncing Kinesis shard info " ) ; ShardSyncTask shardSyncTask = new ShardSyncTask ( streamConfig . getStreamProxy ( ) , leaseCoordinator . getLeaseManager ( ) , initialPosition , cleanupLeasesUponShardCompletion , 0 L ) ; TaskResult result = new MetricsCollectingTaskDecorator ( shardSyncTask , metricsFactory ) . call ( ) ; if ( result . getException ( ) = = null ) { if ( ! leaseCoordinator . isRunning ( ) ) { LOG . info ( " Starting LeaseCoordinator " ) ; leaseCoordinator . start ( ) ; } else { LOG . info ( " LeaseCoordinator is already running. No need to start it. " ) ; } isDone = true ; } else { lastException = result . getException ( ) ; } } catch ( LeasingException e ) { LOG . error ( " Caught exception when initializing LeaseCoordinator " , e ) ; lastException = e ; } catch ( Exception e ) { lastException = e ; } try { Thread . sleep ( parentShardPollIntervalMillis ) ; } catch ( InterruptedException e ) { LOG . debug ( " Sleep interrupted while initializing worker. " ) ; } } if ( ! isDone ) { throw new RuntimeException ( lastException ) ;
private void cleanupShardConsumers ( Set < String > assignedShardIds ) { for ( String shardId : shardIdShardConsumerMap . keySet ( ) ) { if ( ! assignedShardIds . contains ( shardId ) ) {
private List < ShardInfo > getShardInfoForAssignments ( ) { List < ShardInfo > assignedStreamShards = leaseCoordinator . getCurrentAssignments ( ) ; if ( ( assignedStreamShards ! = null ) & & ( ! assignedStreamShards . isEmpty ( ) ) ) { if ( wlog . isInfoEnabled ( ) ) { StringBuilder builder = new StringBuilder ( ) ; boolean firstItem = true ; for ( ShardInfo shardInfo : assignedStreamShards ) { if ( ! firstItem ) { builder . append ( " , " ) ; } builder . append ( shardInfo . getShardId ( ) ) ; firstItem = false ; } wlog . info ( " Current stream shard assignments: " + builder . toString ( ) ) ; } } else { wlog . info ( " No activities assigned " ) ; } return assignedStreamShards ; }
public void shutdown ( ) { this . shutdown = true ; }
ShardConsumer createOrGetShardConsumer ( ShardInfo shardInfo , IRecordProcessorFactory factory ) { synchronized ( shardIdShardConsumerMap ) { String shardId = shardInfo . getShardId ( ) ;
public void debug ( Object message , Throwable t ) { LOG . debug ( message , t ) ; }
public void info ( Object message ) { if ( this . isInfoEnabled ( ) ) { LOG . info ( message ) ;
public void infoForce ( Object message ) { LOG . info ( message ) ; }
public void warn ( Object message ) { LOG . warn ( message ) ; }
public void error ( Object message , Throwable t ) { LOG . error ( message , t ) ; }
private boolean isInfoEnabled ( ) { return infoReporting ; }
private void resetInfoLogging ( ) { if ( infoReporting ) { // We just logged at INFO level for a pass through worker loop
GetRecordsResult get ( String shardIterator , int maxRecords ) throws ResourceNotFoundException , InvalidArgumentException , ExpiredIteratorException ; /** * Fetch information about stream. Useful for fetching the list of shards in a stream. * * @param startShardId exclusive start shardId - used when paginating the list of shards. * @return DescribeStreamOutput object containing a description of the stream. * @throws ResourceNotFoundException The Kinesis stream was not found */ DescribeStreamResult getStreamInfo ( String startShardId ) throws ResourceNotFoundException ; /** * Fetch the shardIds of all shards in the stream. * * @return Set of all shardIds * @throws ResourceNotFoundException If the specified Kinesis stream was not found */ Set < String > getAllShardIds ( ) throws ResourceNotFoundException ; /** * Fetch all the shards defined for the stream (e.g. obtained via calls to the DescribeStream API). * This can be used to discover new shards and consume data from them. * * @return List of all shards in the Kinesis stream. * @throws ResourceNotFoundException The Kinesis stream was not found. */ List < Shard > getShardList ( ) throws ResourceNotFoundException ; /** * Fetch a shard iterator from the specified position in the shard. * * @param shardId Shard id * @param iteratorEnum one of: TRIM_HORIZON, LATEST, AT_SEQUENCE_NUMBER, AFTER_SEQUENCE_NUMBER * @param sequenceNumber the sequence number - must be null unless iteratorEnum is AT_SEQUENCE_NUMBER or * AFTER_SEQUENCE_NUMBER * @return shard iterator which can be used to read data from Kinesis. * @throws ResourceNotFoundException The Kinesis stream or shard was not found * @throws InvalidArgumentException Invalid input parameters */ String getIterator ( String shardId , String iteratorEnum , String sequenceNumber ) throws ResourceNotFoundException , InvalidArgumentException ; /** * @param sequenceNumberForOrdering (optional) used for record ordering * @param explicitHashKey optionally supplied transformation of partitionkey * @param partitionKey for this record * @param data payload * @return PutRecordResult (contains the Kinesis sequence number of the record). * @throws ResourceNotFoundException The Kinesis stream was not found. * @throws InvalidArgumentException InvalidArgumentException. */ PutRecordResult put ( String sequenceNumberForOrdering , String explicitHashKey , String partitionKey , ByteBuffer data ) throws ResourceNotFoundException , InvalidArgumentException ; }
DescribeStreamResult getStreamInfo ( String startShardId ) throws ResourceNotFoundException ; /** * Fetch the shardIds of all shards in the stream. * * @return Set of all shardIds * @throws ResourceNotFoundException If the specified Kinesis stream was not found */ Set < String > getAllShardIds ( ) throws ResourceNotFoundException ; /** * Fetch all the shards defined for the stream (e.g. obtained via calls to the DescribeStream API). * This can be used to discover new shards and consume data from them. * * @return List of all shards in the Kinesis stream. * @throws ResourceNotFoundException The Kinesis stream was not found. */ List < Shard > getShardList ( ) throws ResourceNotFoundException ; /** * Fetch a shard iterator from the specified position in the shard. * * @param shardId Shard id * @param iteratorEnum one of: TRIM_HORIZON, LATEST, AT_SEQUENCE_NUMBER, AFTER_SEQUENCE_NUMBER * @param sequenceNumber the sequence number - must be null unless iteratorEnum is AT_SEQUENCE_NUMBER or * AFTER_SEQUENCE_NUMBER * @return shard iterator which can be used to read data from Kinesis. * @throws ResourceNotFoundException The Kinesis stream or shard was not found * @throws InvalidArgumentException Invalid input parameters */ String getIterator ( String shardId , String iteratorEnum , String sequenceNumber ) throws ResourceNotFoundException , InvalidArgumentException ; /** * @param sequenceNumberForOrdering (optional) used for record ordering * @param explicitHashKey optionally supplied transformation of partitionkey * @param partitionKey for this record * @param data payload * @return PutRecordResult (contains the Kinesis sequence number of the record). * @throws ResourceNotFoundException The Kinesis stream was not found. * @throws InvalidArgumentException InvalidArgumentException. */ PutRecordResult put ( String sequenceNumberForOrdering , String explicitHashKey , String partitionKey , ByteBuffer data ) throws ResourceNotFoundException , InvalidArgumentException ; }
Set < String > getAllShardIds ( ) throws ResourceNotFoundException ; /** * Fetch all the shards defined for the stream (e.g. obtained via calls to the DescribeStream API). * This can be used to discover new shards and consume data from them. * * @return List of all shards in the Kinesis stream. * @throws ResourceNotFoundException The Kinesis stream was not found. */ List < Shard > getShardList ( ) throws ResourceNotFoundException ; /** * Fetch a shard iterator from the specified position in the shard. * * @param shardId Shard id * @param iteratorEnum one of: TRIM_HORIZON, LATEST, AT_SEQUENCE_NUMBER, AFTER_SEQUENCE_NUMBER * @param sequenceNumber the sequence number - must be null unless iteratorEnum is AT_SEQUENCE_NUMBER or * AFTER_SEQUENCE_NUMBER * @return shard iterator which can be used to read data from Kinesis. * @throws ResourceNotFoundException The Kinesis stream or shard was not found * @throws InvalidArgumentException Invalid input parameters */ String getIterator ( String shardId , String iteratorEnum , String sequenceNumber ) throws ResourceNotFoundException , InvalidArgumentException ; /** * @param sequenceNumberForOrdering (optional) used for record ordering * @param explicitHashKey optionally supplied transformation of partitionkey * @param partitionKey for this record * @param data payload * @return PutRecordResult (contains the Kinesis sequence number of the record). * @throws ResourceNotFoundException The Kinesis stream was not found. * @throws InvalidArgumentException InvalidArgumentException. */ PutRecordResult put ( String sequenceNumberForOrdering , String explicitHashKey , String partitionKey , ByteBuffer data ) throws ResourceNotFoundException , InvalidArgumentException ; }
List < Shard > getShardList ( ) throws ResourceNotFoundException ; /** * Fetch a shard iterator from the specified position in the shard. * * @param shardId Shard id * @param iteratorEnum one of: TRIM_HORIZON, LATEST, AT_SEQUENCE_NUMBER, AFTER_SEQUENCE_NUMBER * @param sequenceNumber the sequence number - must be null unless iteratorEnum is AT_SEQUENCE_NUMBER or * AFTER_SEQUENCE_NUMBER * @return shard iterator which can be used to read data from Kinesis. * @throws ResourceNotFoundException The Kinesis stream or shard was not found * @throws InvalidArgumentException Invalid input parameters */ String getIterator ( String shardId , String iteratorEnum , String sequenceNumber ) throws ResourceNotFoundException , InvalidArgumentException ; /** * @param sequenceNumberForOrdering (optional) used for record ordering * @param explicitHashKey optionally supplied transformation of partitionkey * @param partitionKey for this record * @param data payload * @return PutRecordResult (contains the Kinesis sequence number of the record). * @throws ResourceNotFoundException The Kinesis stream was not found. * @throws InvalidArgumentException InvalidArgumentException. */ PutRecordResult put ( String sequenceNumberForOrdering , String explicitHashKey , String partitionKey , ByteBuffer data ) throws ResourceNotFoundException , InvalidArgumentException ; }
String getIterator ( String shardId , String iteratorEnum , String sequenceNumber ) throws ResourceNotFoundException , InvalidArgumentException ; /** * @param sequenceNumberForOrdering (optional) used for record ordering * @param explicitHashKey optionally supplied transformation of partitionkey * @param partitionKey for this record * @param data payload * @return PutRecordResult (contains the Kinesis sequence number of the record). * @throws ResourceNotFoundException The Kinesis stream was not found. * @throws InvalidArgumentException InvalidArgumentException. */ PutRecordResult put ( String sequenceNumberForOrdering , String explicitHashKey , String partitionKey , ByteBuffer data ) throws ResourceNotFoundException , InvalidArgumentException ; }
PutRecordResult put ( String sequenceNumberForOrdering , String explicitHashKey , String partitionKey , ByteBuffer data ) throws ResourceNotFoundException , InvalidArgumentException ; }
public GetRecordsResult get ( String shardIterator , int maxRecords ) throws ResourceNotFoundException , InvalidArgumentException , ExpiredIteratorException { final GetRecordsRequest getRecordsRequest = new GetRecordsRequest ( ) ; getRecordsRequest . setRequestCredentials ( credentialsProvider . getCredentials ( ) ) ; getRecordsRequest . setShardIterator ( shardIterator ) ; getRecordsRequest . setLimit ( maxRecords ) ; final GetRecordsResult response = client . getRecords ( getRecordsRequest ) ; return response ;
public DescribeStreamResult getStreamInfo ( String startShardId ) throws ResourceNotFoundException , LimitExceededException { final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest ( ) ; describeStreamRequest . setRequestCredentials ( credentialsProvider . getCredentials ( ) ) ; describeStreamRequest . setStreamName ( streamName ) ; describeStreamRequest . setExclusiveStartShardId ( startShardId ) ; DescribeStreamResult response = null ; int remainingRetryTimes = this . maxDescribeStreamRetryAttempts ; // Call DescribeStream, with backoff and retries (if we get LimitExceededException). while ((remainingRetryTimes >= 0) && (response == null)) { try { response = client.describeStream(describeStreamRequest); } catch (LimitExceededException le) { LOG.info("Got LimitExceededException when describing stream " + streamName + ". Backing off for " + this.describeStreamBackoffTimeInMillis + " millis."); try { Thread.sleep(this.describeStreamBackoffTimeInMillis); } catch (InterruptedException ie) { LOG.debug("Stream " + streamName + " : Sleep was interrupted ", ie); } } remainingRetryTimes--; } if (StreamStatus.ACTIVE.toString().equals(response.getStreamDescription().getStreamStatus()) || StreamStatus.UPDATING.toString().equals(response.getStreamDescription().getStreamStatus())) {
public List < Shard > getShardList ( ) { List < Shard > result = new ArrayList < Shard > ( ) ; DescribeStreamResult response = null ; String lastShardId = null ; do { response = getStreamInfo ( lastShardId ) ; if ( response = = null ) { /* * If getStreamInfo ever returns null, we should bail and return null. This indicates the stream is not * in ACTIVE or UPDATING state and we may not have accurate/consistent information about the stream. */ return null ; } else { List < Shard > shards = response . getStreamDescription ( ) . getShards ( ) ; result . addAll ( shards ) ; lastShardId = shards . get ( shards . size ( ) - 1 ) . getShardId ( ) ; } } while ( response . getStreamDescription ( ) . isHasMoreShards ( ) ) ; return result ; }
public Set < String > getAllShardIds ( ) throws ResourceNotFoundException { List < Shard > shards = getShardList ( ) ; if ( shards = = null ) { return null ;
public String getIterator ( String shardId , String iteratorType , String sequenceNumber ) { final GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest ( ) ; getShardIteratorRequest . setRequestCredentials ( credentialsProvider . getCredentials ( ) ) ; getShardIteratorRequest . setStreamName ( streamName ) ; getShardIteratorRequest . setShardId ( shardId ) ; getShardIteratorRequest . setShardIteratorType ( iteratorType ) ; getShardIteratorRequest . setStartingSequenceNumber ( sequenceNumber ) ; final GetShardIteratorResult response = client . getShardIterator ( getShardIteratorRequest ) ; return response . getShardIterator ( ) ; }
public PutRecordResult put ( String exclusiveMinimumSequenceNumber , String explicitHashKey , String partitionKey , ByteBuffer data ) throws ResourceNotFoundException , InvalidArgumentException { final PutRecordRequest putRecordRequest = new PutRecordRequest ( ) ; putRecordRequest . setRequestCredentials ( credentialsProvider . getCredentials ( ) ) ; putRecordRequest . setStreamName ( streamName ) ; putRecordRequest . setSequenceNumberForOrdering ( exclusiveMinimumSequenceNumber ) ; putRecordRequest . setExplicitHashKey ( explicitHashKey ) ; putRecordRequest . setPartitionKey ( partitionKey ) ; putRecordRequest . setData ( data ) ; final PutRecordResult response = client . putRecord ( putRecordRequest ) ; return response ; }
public IKinesisProxy getProxy ( String streamName ) { return new KinesisProxy ( streamName , credentialProvider ,
public GetRecordsResult get ( String shardIterator , int maxRecords ) throws ResourceNotFoundException , InvalidArgumentException , ExpiredIteratorException { long startTime = System . currentTimeMillis ( ) ; boolean success = false ; try { GetRecordsResult response = other . get ( shardIterator , maxRecords ) ;
public DescribeStreamResult getStreamInfo ( String startingShardId ) throws ResourceNotFoundException { long startTime = System . currentTimeMillis ( ) ; boolean success = false ; try { DescribeStreamResult response = other . getStreamInfo ( startingShardId ) ;
public Set < String > getAllShardIds ( ) throws ResourceNotFoundException { long startTime = System . currentTimeMillis ( ) ; boolean success = false ; try { Set < String > response = other . getAllShardIds ( ) ;
public String getIterator ( String shardId , String iteratorEnum , String sequenceNumber ) throws ResourceNotFoundException , InvalidArgumentException { long startTime = System . currentTimeMillis ( ) ; boolean success = false ; try { String response = other . getIterator ( shardId , iteratorEnum , sequenceNumber ) ;
public List < Shard > getShardList ( ) throws ResourceNotFoundException { long startTime = System . currentTimeMillis ( ) ; boolean success = false ; try { List < Shard > response = other . getShardList ( ) ;
public PutRecordResult put ( String sequenceNumberForOrdering , String explicitHashKey , String partitionKey , ByteBuffer data ) throws ResourceNotFoundException , InvalidArgumentException { long startTime = System . currentTimeMillis ( ) ; boolean success = false ; try { PutRecordResult response = other . put ( sequenceNumberForOrdering , explicitHashKey , partitionKey , data ) ;
public < T extends Lease > void update ( T other ) { super . update ( other ) ; if ( ! ( other instanceof KinesisClientLease ) ) { throw new IllegalArgumentException ( " Must pass KinesisClientLease object to KinesisClientLease.update(Lease) " ) ; } KinesisClientLease casted = ( KinesisClientLease ) other ; // Do not update ownerSwitchesSinceCheckpoint here - that field is maintained by the leasing library. setCheckpoint(casted.checkpoint); setParentShardIds(casted.parentShardIds); }
public String getCheckpoint ( ) { return checkpoint ; }
public Long getOwnerSwitchesSinceCheckpoint ( ) { return ownerSwitchesSinceCheckpoint ; }
public Set < String > getParentShardIds ( ) { return new HashSet < String > ( parentShardIds ) ; }
public void setCheckpoint ( String checkpoint ) { verifyNotNull ( checkpoint , " Checkpoint should not be null " ) ; this . checkpoint = checkpoint ; }
public void setOwnerSwitchesSinceCheckpoint ( Long ownerSwitchesSinceCheckpoint ) { verifyNotNull ( ownerSwitchesSinceCheckpoint , " ownerSwitchesSinceCheckpoint should not be null " ) ; this . ownerSwitchesSinceCheckpoint = ownerSwitchesSinceCheckpoint ; }
public void setParentShardIds ( Collection < String > parentShardIds ) { verifyNotNull ( parentShardIds , " parentShardIds should not be null " ) ; this . parentShardIds . clear ( ) ; this . parentShardIds . addAll ( parentShardIds ) ; }
private void verifyNotNull ( Object object , String message ) { if ( object = = null ) { throw new IllegalArgumentException ( message ) ;
public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( checkpoint = = null ) ? 0 : checkpoint . hashCode ( ) ) ; result = prime * result + ( ( ownerSwitchesSinceCheckpoint = = null ) ? 0 : ownerSwitchesSinceCheckpoint . hashCode ( ) ) ; result = prime * result + ( ( parentShardIds = = null ) ? 0 : parentShardIds . hashCode ( ) ) ; return result ; }
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; KinesisClientLease other = ( KinesisClientLease ) obj ; if ( checkpoint = = null ) { if ( other . checkpoint ! = null ) return false ; } else if ( ! checkpoint . equals ( other . checkpoint ) ) return false ; if ( ownerSwitchesSinceCheckpoint = = null ) { if ( other . ownerSwitchesSinceCheckpoint ! = null ) return false ; } else if ( ! ownerSwitchesSinceCheckpoint . equals ( other . ownerSwitchesSinceCheckpoint ) ) return false ; if ( parentShardIds = = null ) { if ( other . parentShardIds ! = null ) return false ; } else if ( ! parentShardIds . equals ( other . parentShardIds ) ) return false ; return true ; }
public < T extends Lease > T copy ( ) { return ( T ) new KinesisClientLease ( this ) ; }
public boolean takeLease ( KinesisClientLease lease , String newOwner ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { String oldOwner = lease . getLeaseOwner ( ) ; boolean result = super . takeLease ( lease , newOwner ) ; if ( oldOwner ! = null & & ! oldOwner . equals ( newOwner ) ) { lease . setOwnerSwitchesSinceCheckpoint ( lease . getOwnerSwitchesSinceCheckpoint ( ) + 1 ) ; } return result ; }
public String getCheckpoint ( String shardId ) throws ProvisionedThroughputException , InvalidStateException , DependencyException { String checkpoint = null ; KinesisClientLease lease = getLease ( shardId ) ; if ( lease ! = null ) { checkpoint = lease . getCheckpoint ( ) ; } return checkpoint ; }
public Map < String , AttributeValue > toDynamoRecord ( KinesisClientLease lease ) { Map < String , AttributeValue > result = baseSerializer . toDynamoRecord ( lease ) ; result . put ( OWNER_SWITCHES_KEY , DynamoUtils . createAttributeValue ( lease . getOwnerSwitchesSinceCheckpoint ( ) ) ) ; result . put ( CHECKPOINT_KEY , DynamoUtils . createAttributeValue ( lease . getCheckpoint ( ) ) ) ; if ( lease . getParentShardIds ( ) ! = null & & ! lease . getParentShardIds ( ) . isEmpty ( ) ) { result . put ( PARENT_SHARD_ID_KEY , DynamoUtils . createAttributeValue ( lease . getParentShardIds ( ) ) ) ; } return result ; }
public KinesisClientLease fromDynamoRecord ( Map < String , AttributeValue > dynamoRecord ) { KinesisClientLease result = ( KinesisClientLease ) baseSerializer . fromDynamoRecord ( dynamoRecord ) ; result . setOwnerSwitchesSinceCheckpoint ( DynamoUtils . safeGetLong ( dynamoRecord , OWNER_SWITCHES_KEY ) ) ; result . setCheckpoint ( DynamoUtils . safeGetString ( dynamoRecord , CHECKPOINT_KEY ) ) ; result . setParentShardIds ( DynamoUtils . safeGetSS ( dynamoRecord , PARENT_SHARD_ID_KEY ) ) ; return result ; }
public Map < String , AttributeValue > getDynamoHashKey ( KinesisClientLease lease ) { return baseSerializer . getDynamoHashKey ( lease ) ; }
public Map < String , AttributeValue > getDynamoHashKey ( String shardId ) { return baseSerializer . getDynamoHashKey ( shardId ) ; }
public Map < String , ExpectedAttributeValue > getDynamoLeaseCounterExpectation ( KinesisClientLease lease ) { return baseSerializer . getDynamoLeaseCounterExpectation ( lease ) ; }
public Map < String , ExpectedAttributeValue > getDynamoLeaseOwnerExpectation ( KinesisClientLease lease ) { return baseSerializer . getDynamoLeaseOwnerExpectation ( lease ) ; }
public Map < String , ExpectedAttributeValue > getDynamoNonexistantExpectation ( ) { return baseSerializer . getDynamoNonexistantExpectation ( ) ; }
public Map < String , AttributeValueUpdate > getDynamoLeaseCounterUpdate ( KinesisClientLease lease ) { return baseSerializer . getDynamoLeaseCounterUpdate ( lease ) ; }
public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( KinesisClientLease lease , String newOwner ) { Map < String , AttributeValueUpdate > result = baseSerializer . getDynamoTakeLeaseUpdate ( lease , newOwner ) ; Long ownerSwitchesSinceCheckpoint = lease . getOwnerSwitchesSinceCheckpoint ( ) ; String oldOwner = lease . getLeaseOwner ( ) ; if ( oldOwner ! = null & & ! oldOwner . equals ( newOwner ) ) { ownerSwitchesSinceCheckpoint + + ; } result . put ( OWNER_SWITCHES_KEY , new AttributeValueUpdate ( DynamoUtils . createAttributeValue ( ownerSwitchesSinceCheckpoint ) , AttributeAction . PUT ) ) ; return result ; }
public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( KinesisClientLease lease ) { return baseSerializer . getDynamoEvictLeaseUpdate ( lease ) ; }
public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( KinesisClientLease lease ) { Map < String , AttributeValueUpdate > result = baseSerializer . getDynamoUpdateLeaseUpdate ( lease ) ; result . put ( CHECKPOINT_KEY , new AttributeValueUpdate ( DynamoUtils . createAttributeValue ( lease . getCheckpoint ( ) ) , AttributeAction . PUT ) ) ; result . put ( OWNER_SWITCHES_KEY , new AttributeValueUpdate ( DynamoUtils . createAttributeValue ( lease . getOwnerSwitchesSinceCheckpoint ( ) ) , AttributeAction . PUT ) ) ; return result ; }
public Collection < KeySchemaElement > getKeySchema ( ) { return baseSerializer . getKeySchema ( ) ; }
public Collection < AttributeDefinition > getAttributeDefinitions ( ) { return baseSerializer . getAttributeDefinitions ( ) ; }
public String getLeaseKey ( ) { return leaseKey ; }
public Long getLeaseCounter ( ) { return leaseCounter ; }
public String getLeaseOwner ( ) { return leaseOwner ; }
public UUID getConcurrencyToken ( ) { return concurrencyToken ; }
public Long getLastCounterIncrementNanos ( ) { return lastCounterIncrementNanos ; }
public boolean isExpired ( long leaseDurationNanos , long asOfNanos ) { if ( lastCounterIncrementNanos = = null ) { return true ; } long age = asOfNanos - lastCounterIncrementNanos ; // see comment on MAX_ABS_AGE_NANOS if (Math.abs(age) > MAX_ABS_AGE_NANOS) { return true;
public void setLastCounterIncrementNanos ( Long lastCounterIncrementNanos ) { this . lastCounterIncrementNanos = lastCounterIncrementNanos ; }
public void setConcurrencyToken ( UUID concurrencyToken ) { verifyNotNull ( concurrencyToken , " concurencyToken cannot be null " ) ; this . concurrencyToken = concurrencyToken ; }
public void setLeaseKey ( String leaseKey ) { if ( this . leaseKey ! = null ) { throw new IllegalArgumentException ( " LeaseKey is immutable once set " ) ; } verifyNotNull ( leaseKey , " LeaseKey cannot be set to null " ) ; this . leaseKey = leaseKey ; }
public void setLeaseCounter ( Long leaseCounter ) { verifyNotNull ( leaseCounter , " leaseCounter must not be null " ) ; this . leaseCounter = leaseCounter ; }
public void setLeaseOwner ( String leaseOwner ) { this . leaseOwner = leaseOwner ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( leaseCounter = = null ) ? 0 : leaseCounter . hashCode ( ) ) ; result = prime * result + ( ( leaseOwner = = null ) ? 0 : leaseOwner . hashCode ( ) ) ; result = prime * result + ( ( leaseKey = = null ) ? 0 : leaseKey . hashCode ( ) ) ; return result ; }
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; Lease other = ( Lease ) obj ; if ( leaseCounter = = null ) { if ( other . leaseCounter ! = null ) return false ; } else if ( ! leaseCounter . equals ( other . leaseCounter ) ) return false ; if ( leaseOwner = = null ) { if ( other . leaseOwner ! = null ) return false ; } else if ( ! leaseOwner . equals ( other . leaseOwner ) ) return false ; if ( leaseKey = = null ) { if ( other . leaseKey ! = null ) return false ; } else if ( ! leaseKey . equals ( other . leaseKey ) ) return false ; return true ; }
public String toString ( ) { return new JSONObject ( this ) . toString ( ) ; }
public < T extends Lease > T copy ( ) { return ( T ) new Lease ( this ) ; }
public void run ( ) { try { runTaker ( ) ;
public void run ( ) { try { runRenewer ( ) ;
public void start ( ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { leaseRenewer . initialize ( ) ; // 2 because we know we'll have at most 2 concurrent tasks at a time. threadpool = Executors.newScheduledThreadPool(2); // Taker runs with fixed DELAY because we want it to run slower in the event of performance degredation. threadpool.scheduleWithFixedDelay(new TakerRunnable(), 0L, takerIntervalMillis, TimeUnit.MILLISECONDS); // Renewer runs at fixed INTERVAL because we want it to run at the same rate in the event of degredation. threadpool.scheduleAtFixedRate(new RenewerRunnable(), 0L, renewerIntervalMillis, TimeUnit.MILLISECONDS); running = true; }
protected void runTaker ( ) throws DependencyException , InvalidStateException { IMetricsScope scope = MetricsHelper . startScope ( metricsFactory , " TakeLeases " ) ; long startTime = System . currentTimeMillis ( ) ; boolean success = false ; try { Map < String , T > takenLeases = leaseTaker . takeLeases ( ) ;
protected void runRenewer ( ) throws DependencyException , InvalidStateException { IMetricsScope scope = MetricsHelper . startScope ( metricsFactory , " RenewAllLeases " ) ; long startTime = System . currentTimeMillis ( ) ; boolean success = false ; try { leaseRenewer . renewLeases ( ) ;
public Collection < T > getAssignments ( ) { return leaseRenewer . getCurrentlyHeldLeases ( ) . values ( ) ; }
public T getCurrentlyHeldLease ( String leaseKey ) { return leaseRenewer . getCurrentlyHeldLease ( leaseKey ) ; }
public String getWorkerIdentifier ( ) { return leaseTaker . getWorkerIdentifier ( ) ; }
public void stop ( ) { threadpool . shutdown ( ) ; try { if ( threadpool . awaitTermination ( STOP_WAIT_TIME_MILLIS , TimeUnit . MILLISECONDS ) ) { LOG . info ( String . format ( " Worker %s has successfully stopped lease-tracking threads " , leaseTaker . getWorkerIdentifier ( ) ) ) ; } else { threadpool . shutdownNow ( ) ; LOG . info ( String . format ( " Worker %s stopped lease-tracking threads %dms after stop " , leaseTaker . getWorkerIdentifier ( ) , STOP_WAIT_TIME_MILLIS ) ) ; } } catch ( InterruptedException e ) { LOG . debug ( " Encountered InterruptedException when awaiting threadpool termination " ) ; } leaseRenewer . clearCurrentlyHeldLeases ( ) ; running = false ; }
public boolean isRunning ( ) { return running ; }
public boolean updateLease ( T lease , UUID concurrencyToken ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { return leaseRenewer . updateLease ( lease , concurrencyToken ) ; }
public boolean createLeaseTableIfNotExists ( Long readCapacity , Long writeCapacity ) throws ProvisionedThroughputException , DependencyException { verifyNotNull ( readCapacity , " readCapacity cannot be null " ) ; verifyNotNull ( writeCapacity , " writeCapacity cannot be null " ) ; boolean tableDidNotExist = true ; CreateTableRequest request = new CreateTableRequest ( ) ; request . setTableName ( table ) ; request . setKeySchema ( serializer . getKeySchema ( ) ) ; request . setAttributeDefinitions ( serializer . getAttributeDefinitions ( ) ) ; ProvisionedThroughput throughput = new ProvisionedThroughput ( ) ; throughput . setReadCapacityUnits ( readCapacity ) ; throughput . setWriteCapacityUnits ( writeCapacity ) ; request . setProvisionedThroughput ( throughput ) ; try { dynamoDBClient . createTable ( request ) ; } catch ( ResourceInUseException e ) { tableDidNotExist = false ; LOG . info ( " Table " + table + " already exists. " ) ; } catch ( LimitExceededException e ) { throw new ProvisionedThroughputException ( " Capacity exceeded when creating table " + table , e ) ; } catch ( AmazonClientException e ) { throw new DependencyException ( e ) ; } return tableDidNotExist ; }
public boolean leaseTableExists ( ) throws DependencyException { DescribeTableRequest request = new DescribeTableRequest ( ) ; request . setTableName ( table ) ; DescribeTableResult result ; try { result = dynamoDBClient . describeTable ( request ) ; } catch ( ResourceNotFoundException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( " Got ResourceNotFoundException for table %s in leaseTableExists, returning false. " , table ) ) ; } return false ; } catch ( AmazonClientException e ) { throw new DependencyException ( e ) ; } String tableStatus = result . getTable ( ) . getTableStatus ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Lease table exists and is in status " + tableStatus ) ; } return TableStatus . ACTIVE . name ( ) . equals ( tableStatus ) ; }
public boolean waitUntilLeaseTableExists ( long secondsBetweenPolls , long timeoutSeconds ) throws DependencyException { long sleepTimeRemaining = timeoutSeconds * 1000 ; while ( ! leaseTableExists ( ) ) { if ( sleepTimeRemaining < = 0 ) { return false ; } long timeToSleepMillis = Math . min ( 1000 * secondsBetweenPolls , sleepTimeRemaining ) ; sleepTimeRemaining - = sleep ( timeToSleepMillis ) ; } return true ; }
long sleep ( long timeToSleepMillis ) { long startTime = System . currentTimeMillis ( ) ; try { Thread . sleep ( timeToSleepMillis ) ; } catch ( InterruptedException e ) { LOG . debug ( " Interrupted while sleeping " ) ; } return System . currentTimeMillis ( ) - startTime ; }
public List < T > listLeases ( ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { return list ( null ) ; }
List < T > list ( Integer limit ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Listing leases from table " + table ) ; } ScanRequest scanRequest = new ScanRequest ( ) ; scanRequest . setTableName ( table ) ; if ( limit ! = null ) { scanRequest . setLimit ( limit ) ; } try { ScanResult scanResult = dynamoDBClient . scan ( scanRequest ) ;
public boolean createLeaseIfNotExists ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { verifyNotNull ( lease , " lease cannot be null " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Creating lease " + lease ) ; } PutItemRequest request = new PutItemRequest ( ) ; request . setTableName ( table ) ; request . setItem ( serializer . toDynamoRecord ( lease ) ) ; request . setExpected ( serializer . getDynamoNonexistantExpectation ( ) ) ; try { dynamoDBClient . putItem ( request ) ; } catch ( ConditionalCheckFailedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Did not create lease " + lease + " because it already existed " ) ; } return false ; } catch ( AmazonClientException e ) { throw convertAndRethrowExceptions ( " create " , lease . getLeaseKey ( ) , e ) ; } return true ; }
public T getLease ( String leaseKey ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { verifyNotNull ( leaseKey , " leaseKey cannot be null " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Getting lease with key " + leaseKey ) ; } GetItemRequest request = new GetItemRequest ( ) ; request . setTableName ( table ) ; request . setKey ( serializer . getDynamoHashKey ( leaseKey ) ) ; request . setConsistentRead ( consistentReads ) ; try { GetItemResult result = dynamoDBClient . getItem ( request ) ;
public boolean renewLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { verifyNotNull ( lease , " lease cannot be null " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Renewing lease with key " + lease . getLeaseKey ( ) ) ; } UpdateItemRequest request = new UpdateItemRequest ( ) ; request . setTableName ( table ) ; request . setKey ( serializer . getDynamoHashKey ( lease ) ) ; request . setExpected ( serializer . getDynamoLeaseCounterExpectation ( lease ) ) ; request . setAttributeUpdates ( serializer . getDynamoLeaseCounterUpdate ( lease ) ) ; try { dynamoDBClient . updateItem ( request ) ; } catch ( ConditionalCheckFailedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Lease renewal failed for lease with key " + lease . getLeaseKey ( ) + " because the lease counter was not " + lease . getLeaseCounter ( ) ) ; } return false ; } catch ( AmazonClientException e ) { throw convertAndRethrowExceptions ( " renew " , lease . getLeaseKey ( ) , e ) ; } lease . setLeaseCounter ( lease . getLeaseCounter ( ) + 1 ) ; return true ; }
public boolean takeLease ( T lease , String owner ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { verifyNotNull ( lease , " lease cannot be null " ) ; verifyNotNull ( owner , " owner cannot be null " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( " Taking lease with shardId %s from %s to %s " , lease . getLeaseKey ( ) , lease . getLeaseOwner ( ) = = null ? " nobody " : lease . getLeaseOwner ( ) , owner ) ) ; } UpdateItemRequest request = new UpdateItemRequest ( ) ; request . setTableName ( table ) ; request . setKey ( serializer . getDynamoHashKey ( lease ) ) ; request . setExpected ( serializer . getDynamoLeaseCounterExpectation ( lease ) ) ; Map < String , AttributeValueUpdate > updates = serializer . getDynamoLeaseCounterUpdate ( lease ) ; updates . putAll ( serializer . getDynamoTakeLeaseUpdate ( lease , owner ) ) ; request . setAttributeUpdates ( updates ) ; try { dynamoDBClient . updateItem ( request ) ; } catch ( ConditionalCheckFailedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Lease renewal failed for lease with key " + lease . getLeaseKey ( ) + " because the lease counter was not " + lease . getLeaseCounter ( ) ) ; } return false ; } catch ( AmazonClientException e ) { throw convertAndRethrowExceptions ( " take " , lease . getLeaseKey ( ) , e ) ; } lease . setLeaseCounter ( lease . getLeaseCounter ( ) + 1 ) ; lease . setLeaseOwner ( owner ) ; return true ; }
public boolean evictLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { verifyNotNull ( lease , " lease cannot be null " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( " Voiding lease with shardId %s owned by %s " , lease . getLeaseKey ( ) , lease . getLeaseOwner ( ) ) ) ; } UpdateItemRequest request = new UpdateItemRequest ( ) ; request . setTableName ( table ) ; request . setKey ( serializer . getDynamoHashKey ( lease ) ) ; request . setExpected ( serializer . getDynamoLeaseOwnerExpectation ( lease ) ) ; Map < String , AttributeValueUpdate > updates = serializer . getDynamoLeaseCounterUpdate ( lease ) ; updates . putAll ( serializer . getDynamoEvictLeaseUpdate ( lease ) ) ; request . setAttributeUpdates ( updates ) ; try { dynamoDBClient . updateItem ( request ) ; } catch ( ConditionalCheckFailedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Lease eviction failed for lease with key " + lease . getLeaseKey ( ) + " because the lease owner was not " + lease . getLeaseOwner ( ) ) ; } return false ; } catch ( AmazonClientException e ) { throw convertAndRethrowExceptions ( " evict " , lease . getLeaseKey ( ) , e ) ; } lease . setLeaseOwner ( null ) ; lease . setLeaseCounter ( lease . getLeaseCounter ( ) + 1 ) ; return true ; }
public void deleteAll ( ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { List < T > allLeases = listLeases ( ) ; LOG . warn ( " Deleting " + allLeases . size ( ) + " items from table " + table ) ; for ( T lease : allLeases ) { DeleteItemRequest deleteRequest = new DeleteItemRequest ( ) ;
public void deleteLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { verifyNotNull ( lease , " lease cannot be null " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( " Deleting lease with shardId %s " , lease . getLeaseKey ( ) ) ) ; } DeleteItemRequest deleteRequest = new DeleteItemRequest ( ) ; deleteRequest . setTableName ( table ) ; deleteRequest . setKey ( serializer . getDynamoHashKey ( lease ) ) ; try { dynamoDBClient . deleteItem ( deleteRequest ) ;
public boolean updateLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { verifyNotNull ( lease , " lease cannot be null " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( " Updating lease %s " , lease ) ) ; } UpdateItemRequest request = new UpdateItemRequest ( ) ; request . setTableName ( table ) ; request . setKey ( serializer . getDynamoHashKey ( lease ) ) ; request . setExpected ( serializer . getDynamoLeaseCounterExpectation ( lease ) ) ; Map < String , AttributeValueUpdate > updates = serializer . getDynamoLeaseCounterUpdate ( lease ) ; updates . putAll ( serializer . getDynamoUpdateLeaseUpdate ( lease ) ) ; request . setAttributeUpdates ( updates ) ; try { dynamoDBClient . updateItem ( request ) ; } catch ( ConditionalCheckFailedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Lease update failed for lease with key " + lease . getLeaseKey ( ) + " because the lease counter was not " + lease . getLeaseCounter ( ) ) ; } return false ; } catch ( AmazonClientException e ) { throw convertAndRethrowExceptions ( " update " , lease . getLeaseKey ( ) , e ) ; } lease . setLeaseCounter ( lease . getLeaseCounter ( ) + 1 ) ; return true ; }
protected DependencyException convertAndRethrowExceptions ( String operation , String leaseKey , AmazonClientException e ) throws ProvisionedThroughputException , InvalidStateException { if ( e instanceof ProvisionedThroughputExceededException ) { throw new ProvisionedThroughputException ( e ) ;
public void renewLeases ( ) throws DependencyException , InvalidStateException { if ( LOG . isDebugEnabled ( ) ) { // Due to the eventually consistent nature of ConcurrentNavigableMap iterators, this log entry may become // inaccurate during iteration. LOG.debug(String.format("Worker %s holding %d leases: %s", workerIdentifier, ownedLeases.size(), ownedLeases)); } /* * We iterate in descending order here so that the synchronized(lease) inside renewLease doesn't "lead" calls * to getCurrentlyHeldLeases. They'll still cross paths, but they won't interleave their executions. */ int lostLeases = 0; for (T lease : ownedLeases.descendingMap().values()) { if (!renewLease(lease)) { lostLeases++; } } MetricsHelper.getMetricsScope().addData("LostLeases", lostLeases, StandardUnit.Count); MetricsHelper.getMetricsScope().addData("CurrentLeases", ownedLeases.size(), StandardUnit.Count); }
private boolean renewLease ( T lease ) throws DependencyException , InvalidStateException { String leaseKey = lease . getLeaseKey ( ) ; boolean success = false ; boolean renewedLease = false ; long startTime = System . currentTimeMillis ( ) ; try { for ( int i = 1 ; i < = RENEWAL_RETRIES ; i + + ) { try { synchronized ( lease ) { renewedLease = leaseManager . renewLease ( lease ) ; if ( renewedLease ) { lease . setLastCounterIncrementNanos ( System . nanoTime ( ) ) ; } } if ( renewedLease ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( " Worker %s successfully renewed lease with key %s " , workerIdentifier , leaseKey ) ) ; } } else { LOG . info ( String . format ( " Worker %s lost lease with key %s " , workerIdentifier , leaseKey ) ) ; ownedLeases . remove ( leaseKey ) ; } success = true ; break ; } catch ( ProvisionedThroughputException e ) { LOG . info ( String . format ( " Worker %s could not renew lease with key %s on try %d out of %d due to capacity " , workerIdentifier , leaseKey , i , RENEWAL_RETRIES ) ) ; } } } finally { MetricsHelper . addSuccessAndLatency ( " RenewLease " , startTime , success ) ; } return renewedLease ; }
public Map < String , T > getCurrentlyHeldLeases ( ) { Map < String , T > result = new HashMap < String , T > ( ) ; long now = System . nanoTime ( ) ; for ( String leaseKey : ownedLeases . keySet ( ) ) { T copy = getCopyOfHeldLease ( leaseKey , now ) ; if ( copy ! = null ) { result . put ( copy . getLeaseKey ( ) , copy ) ; } } return result ; }
public T getCurrentlyHeldLease ( String leaseKey ) { return getCopyOfHeldLease ( leaseKey , System . nanoTime ( ) ) ; }
private T getCopyOfHeldLease ( String leaseKey , long now ) { T authoritativeLease = ownedLeases . get ( leaseKey ) ; if ( authoritativeLease = = null ) { return null ;
public boolean updateLease ( T lease , UUID concurrencyToken ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { verifyNotNull ( lease , " lease cannot be null " ) ; verifyNotNull ( lease . getLeaseKey ( ) , " leaseKey cannot be null " ) ; verifyNotNull ( concurrencyToken , " concurrencyToken cannot be null " ) ; String leaseKey = lease . getLeaseKey ( ) ; T authoritativeLease = ownedLeases . get ( leaseKey ) ; if ( authoritativeLease = = null ) { LOG . info ( String . format ( " Worker %s could not update lease with key %s because it does not hold it " , workerIdentifier , leaseKey ) ) ; return false ; } /* * If the passed-in concurrency token doesn't match the concurrency token of the authoritative lease, it means * the lease was lost and regained between when the caller acquired his concurrency token and when the caller * called update. */ if ( ! authoritativeLease . getConcurrencyToken ( ) . equals ( concurrencyToken ) ) { LOG . info ( String . format ( " Worker %s refusing to update lease with key %s because " + " concurrency tokens don't match " , workerIdentifier , leaseKey ) ) ; return false ; } long startTime = System . currentTimeMillis ( ) ; boolean success = false ; try { synchronized ( authoritativeLease ) {
public void addLeasesToRenew ( Collection < T > newLeases ) { verifyNotNull ( newLeases , " newLeases cannot be null " ) ; for ( T lease : newLeases ) { if ( lease . getLastCounterIncrementNanos ( ) = = null ) {
public void clearCurrentlyHeldLeases ( ) { ownedLeases . clear ( ) ; }
public void initialize ( ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { Collection < T > leases = leaseManager . listLeases ( ) ; List < T > myLeases = new LinkedList < T > ( ) ; for ( T lease : leases ) { if ( workerIdentifier . equals ( lease . getLeaseOwner ( ) ) ) { LOG . info ( String . format ( " Worker %s found lease %s " , workerIdentifier , lease ) ) ; if ( renewLease ( lease ) ) { myLeases . add ( lease ) ; } } else { LOG . debug ( String . format ( " Worker %s ignoring lease %s " , workerIdentifier , lease ) ) ; } } addLeasesToRenew ( myLeases ) ; }
public Map < String , AttributeValue > toDynamoRecord ( Lease lease ) { Map < String , AttributeValue > result = new HashMap < String , AttributeValue > ( ) ; result . put ( LEASE_KEY_KEY , DynamoUtils . createAttributeValue ( lease . getLeaseKey ( ) ) ) ; result . put ( LEASE_COUNTER_KEY , DynamoUtils . createAttributeValue ( lease . getLeaseCounter ( ) ) ) ; if ( lease . getLeaseOwner ( ) ! = null ) { result . put ( LEASE_OWNER_KEY , DynamoUtils . createAttributeValue ( lease . getLeaseOwner ( ) ) ) ; } return result ; }
public Lease fromDynamoRecord ( Map < String , AttributeValue > dynamoRecord ) { Lease result ; try { result = clazz . newInstance ( ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( e ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } result . setLeaseKey ( DynamoUtils . safeGetString ( dynamoRecord , LEASE_KEY_KEY ) ) ; result . setLeaseOwner ( DynamoUtils . safeGetString ( dynamoRecord , LEASE_OWNER_KEY ) ) ; result . setLeaseCounter ( DynamoUtils . safeGetLong ( dynamoRecord , LEASE_COUNTER_KEY ) ) ; return result ; }
public Map < String , AttributeValue > getDynamoHashKey ( String leaseKey ) { Map < String , AttributeValue > result = new HashMap < String , AttributeValue > ( ) ; result . put ( LEASE_KEY_KEY , DynamoUtils . createAttributeValue ( leaseKey ) ) ; return result ; }
public Map < String , AttributeValue > getDynamoHashKey ( Lease lease ) { return getDynamoHashKey ( lease . getLeaseKey ( ) ) ; }
public Map < String , ExpectedAttributeValue > getDynamoLeaseCounterExpectation ( Lease lease ) { return getDynamoLeaseCounterExpectation ( lease . getLeaseCounter ( ) ) ; }
public Map < String , ExpectedAttributeValue > getDynamoLeaseCounterExpectation ( Long leaseCounter ) { Map < String , ExpectedAttributeValue > result = new HashMap < String , ExpectedAttributeValue > ( ) ; ExpectedAttributeValue eav = new ExpectedAttributeValue ( DynamoUtils . createAttributeValue ( leaseCounter ) ) ; result . put ( LEASE_COUNTER_KEY , eav ) ; return result ; }
public Map < String , ExpectedAttributeValue > getDynamoLeaseOwnerExpectation ( Lease lease ) { Map < String , ExpectedAttributeValue > result = new HashMap < String , ExpectedAttributeValue > ( ) ; ExpectedAttributeValue eav = null ; if ( lease . getLeaseOwner ( ) = = null ) { eav = new ExpectedAttributeValue ( false ) ; } else { new ExpectedAttributeValue ( DynamoUtils . createAttributeValue ( lease . getLeaseOwner ( ) ) ) ; } result . put ( LEASE_OWNER_KEY , eav ) ; return result ; }
public Map < String , ExpectedAttributeValue > getDynamoNonexistantExpectation ( ) { Map < String , ExpectedAttributeValue > result = new HashMap < String , ExpectedAttributeValue > ( ) ; ExpectedAttributeValue expectedAV = new ExpectedAttributeValue ( false ) ; result . put ( LEASE_KEY_KEY , expectedAV ) ; return result ; }
public Map < String , AttributeValueUpdate > getDynamoLeaseCounterUpdate ( Lease lease ) { return getDynamoLeaseCounterUpdate ( lease . getLeaseCounter ( ) ) ; }
public Map < String , AttributeValueUpdate > getDynamoLeaseCounterUpdate ( Long leaseCounter ) { Map < String , AttributeValueUpdate > result = new HashMap < String , AttributeValueUpdate > ( ) ; AttributeValueUpdate avu = new AttributeValueUpdate ( DynamoUtils . createAttributeValue ( leaseCounter + 1 ) , AttributeAction . PUT ) ; result . put ( LEASE_COUNTER_KEY , avu ) ; return result ; }
public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( Lease lease , String owner ) { Map < String , AttributeValueUpdate > result = new HashMap < String , AttributeValueUpdate > ( ) ; result . put ( LEASE_OWNER_KEY , new AttributeValueUpdate ( DynamoUtils . createAttributeValue ( owner ) , AttributeAction . PUT ) ) ; return result ; }
public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( Lease lease ) { Map < String , AttributeValueUpdate > result = new HashMap < String , AttributeValueUpdate > ( ) ; result . put ( LEASE_OWNER_KEY , new AttributeValueUpdate ( null , AttributeAction . DELETE ) ) ; return result ; }
public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( Lease lease ) { // There is no application-specific data in Lease - just return a map that increments the counter. return new HashMap<String, AttributeValueUpdate>(); }
public Collection < KeySchemaElement > getKeySchema ( ) { List < KeySchemaElement > keySchema = new ArrayList < KeySchemaElement > ( ) ; keySchema . add ( new KeySchemaElement ( ) . withAttributeName ( LEASE_KEY_KEY ) . withKeyType ( KeyType . HASH ) ) ; return keySchema ; }
public Collection < AttributeDefinition > getAttributeDefinitions ( ) { List < AttributeDefinition > definitions = new ArrayList < AttributeDefinition > ( ) ; definitions . add ( new AttributeDefinition ( ) . withAttributeName ( LEASE_KEY_KEY ) . withAttributeType ( ScalarAttributeType . S ) ) ; return definitions ; }
public Long call ( ) { return System . nanoTime ( ) ; }
public Map < String , T > takeLeases ( ) throws DependencyException , InvalidStateException { return takeLeases ( SYSTEM_CLOCK_CALLABLE ) ; }
static String stringJoin ( Collection < String > strings , String delimiter ) { StringBuilder builder = new StringBuilder ( ) ; boolean needDelimiter = false ; for ( String string : strings ) { if ( needDelimiter ) { builder . append ( delimiter ) ; } builder . append ( string ) ; needDelimiter = true ; } return builder . toString ( ) ; }
private void updateAllLeases ( Callable < Long > timeProvider ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { List < T > freshList = leaseManager . listLeases ( ) ; try { lastScanTimeNanos = timeProvider . call ( ) ; } catch ( Exception e ) { throw new DependencyException ( " Exception caught from timeProvider " , e ) ; } // This set will hold the lease keys not updated by the previous listLeases call. Set<String> notUpdated = new HashSet<String>(allLeases.keySet()); // Iterate over all leases, finding ones to try to acquire that haven't changed since the last iteration for (T lease : freshList) { String leaseKey = lease.getLeaseKey(); T oldLease = allLeases.get(leaseKey); allLeases.put(leaseKey, lease); notUpdated.remove(leaseKey); if (oldLease != null) { // If we've seen this lease before... if (oldLease.getLeaseCounter().equals(lease.getLeaseCounter())) { // ...and the counter hasn't changed, propagate the lastRenewalNanos time from the old lease lease.setLastCounterIncrementNanos(oldLease.getLastCounterIncrementNanos()); } else { // ...and the counter has changed, set lastRenewalNanos to the time of the scan. lease.setLastCounterIncrementNanos(lastScanTimeNanos); } } else { if (lease.getLeaseOwner() == null) { // if this new lease is unowned, it's never been renewed. lease.setLastCounterIncrementNanos(0L); if (LOG.isDebugEnabled()) { LOG.debug("Treating new lease with key " + leaseKey + " as never renewed because it is new and unowned."); } } else { // if this new lease is owned, treat it as renewed as of the scan lease.setLastCounterIncrementNanos(lastScanTimeNanos); if (LOG.isDebugEnabled()) { LOG.debug("Treating new lease with key " + leaseKey + " as recently renewed because it is new and owned."); } } } } // Remove dead leases from allLeases for (String key : notUpdated) { allLeases.remove(key);
private List < T > getExpiredLeases ( ) { List < T > expiredLeases = new ArrayList < T > ( ) ; for ( T lease : allLeases . values ( ) ) { if ( lease . isExpired ( leaseDurationNanos , lastScanTimeNanos ) ) { expiredLeases . add ( lease ) ; } } return expiredLeases ; }
private T chooseLeaseToSteal ( Map < String , Integer > leaseCounts , int needed , int target ) { Entry < String , Integer > mostLoadedWorker = null ; // Find the most loaded worker for (Entry<String, Integer> worker : leaseCounts.entrySet()) { if (mostLoadedWorker == null || mostLoadedWorker.getValue() < worker.getValue()) { mostLoadedWorker = worker; } } if (mostLoadedWorker.getValue() < target + (needed > 1 ? 0 : 1)) { if (LOG.isDebugEnabled()) { LOG.debug(String.format("Worker %s not stealing from most loaded worker %s. He has %d," + " target is %d, and I need %d", workerIdentifier, mostLoadedWorker.getKey(), mostLoadedWorker.getValue(), target, needed)); } return null; } String mostLoadedWorkerIdentifier = mostLoadedWorker.getKey(); List<T> candidates = new ArrayList<T>(); // Collect leases belonging to that worker for (T lease : allLeases.values()) { if (mostLoadedWorkerIdentifier.equals(lease.getLeaseOwner())) { candidates.add(lease); } } // Return a random one int randomIndex = random.nextInt(candidates.size()); return candidates.get(randomIndex); }
private Map < String , Integer > computeLeaseCounts ( List < T > expiredLeases ) { Map < String , Integer > leaseCounts = new HashMap < String , Integer > ( ) ; // Compute the number of leases per worker by looking through allLeases and ignoring leases that have expired. for (T lease : allLeases.values()) { if (!expiredLeases.contains(lease)) { String leaseOwner = lease.getLeaseOwner(); Integer oldCount = leaseCounts.get(leaseOwner); if (oldCount == null) { leaseCounts.put(leaseOwner, 1); } else { leaseCounts.put(leaseOwner, oldCount + 1); } } } // If I have no leases, I wasn't represented in leaseCounts. Let's fix that. Integer myCount = leaseCounts.get(workerIdentifier); if (myCount == null) { myCount = 0; leaseCounts.put(workerIdentifier, myCount); } return leaseCounts; }
public abstract String getCheckpoint ( String shardId ) throws ProvisionedThroughputException , InvalidStateException , DependencyException ; }
public boolean takeLease ( T lease , String owner ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; /** * Evict the current owner of lease by setting owner to null. Conditional on the owner in DynamoDB matching the owner of * the input. Mutates the lease counter and owner of the passed-in lease object after updating the record in DynamoDB. * * @param lease the lease to void * * @return true if eviction succeeded, false otherwise * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB update fails due to lack of capacity * @throws DependencyException if DynamoDB update fails in an unexpected way */ public boolean evictLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; /** * Delete the given lease from DynamoDB. Does nothing when passed a lease that does not exist in DynamoDB. * * @param lease the lease to delete * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB delete fails due to lack of capacity * @throws DependencyException if DynamoDB delete fails in an unexpected way */ public void deleteLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; /** * Delete all leases from DynamoDB. Useful for tools/utils and testing. * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB scan or delete fail due to lack of capacity * @throws DependencyException if DynamoDB scan or delete fail in an unexpected way */ public void deleteAll ( ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; /** * Update application-specific fields of the given lease in DynamoDB. Does not update fields managed by the leasing * library such as leaseCounter, leaseOwner, or leaseKey. Conditional on the leaseCounter in DynamoDB matching the * leaseCounter of the input. Increments the lease counter in DynamoDB so that updates can be contingent on other * updates. Mutates the lease counter of the passed-in lease object. * * @return true if update succeeded, false otherwise * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB update fails due to lack of capacity * @throws DependencyException if DynamoDB update fails in an unexpected way */ public boolean updateLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
public boolean evictLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; /** * Delete the given lease from DynamoDB. Does nothing when passed a lease that does not exist in DynamoDB. * * @param lease the lease to delete * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB delete fails due to lack of capacity * @throws DependencyException if DynamoDB delete fails in an unexpected way */ public void deleteLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; /** * Delete all leases from DynamoDB. Useful for tools/utils and testing. * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB scan or delete fail due to lack of capacity * @throws DependencyException if DynamoDB scan or delete fail in an unexpected way */ public void deleteAll ( ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; /** * Update application-specific fields of the given lease in DynamoDB. Does not update fields managed by the leasing * library such as leaseCounter, leaseOwner, or leaseKey. Conditional on the leaseCounter in DynamoDB matching the * leaseCounter of the input. Increments the lease counter in DynamoDB so that updates can be contingent on other * updates. Mutates the lease counter of the passed-in lease object. * * @return true if update succeeded, false otherwise * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB update fails due to lack of capacity * @throws DependencyException if DynamoDB update fails in an unexpected way */ public boolean updateLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
public void deleteLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; /** * Delete all leases from DynamoDB. Useful for tools/utils and testing. * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB scan or delete fail due to lack of capacity * @throws DependencyException if DynamoDB scan or delete fail in an unexpected way */ public void deleteAll ( ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; /** * Update application-specific fields of the given lease in DynamoDB. Does not update fields managed by the leasing * library such as leaseCounter, leaseOwner, or leaseKey. Conditional on the leaseCounter in DynamoDB matching the * leaseCounter of the input. Increments the lease counter in DynamoDB so that updates can be contingent on other * updates. Mutates the lease counter of the passed-in lease object. * * @return true if update succeeded, false otherwise * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB update fails due to lack of capacity * @throws DependencyException if DynamoDB update fails in an unexpected way */ public boolean updateLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
public void deleteAll ( ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; /** * Update application-specific fields of the given lease in DynamoDB. Does not update fields managed by the leasing * library such as leaseCounter, leaseOwner, or leaseKey. Conditional on the leaseCounter in DynamoDB matching the * leaseCounter of the input. Increments the lease counter in DynamoDB so that updates can be contingent on other * updates. Mutates the lease counter of the passed-in lease object. * * @return true if update succeeded, false otherwise * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB update fails due to lack of capacity * @throws DependencyException if DynamoDB update fails in an unexpected way */ public boolean updateLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
public boolean updateLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
public void initialize ( ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; /** * Attempt to renew all currently held leases. * * @throws DependencyException on unexpected DynamoDB failures * @throws InvalidStateException if lease table does not exist */ public void renewLeases ( ) throws DependencyException , InvalidStateException ; /** * @return currently held leases. Key is shardId, value is corresponding Lease object. A lease is currently held if * we successfully renewed it on the last run of renewLeases(). Lease objects returned are deep copies - * their lease counters will not tick. */ public Map < String , T > getCurrentlyHeldLeases ( ) ; /** * @param leaseKey key of the lease to retrieve * * @return a deep copy of a currently held lease, or null if we don't hold the lease */ public T getCurrentlyHeldLease ( String leaseKey ) ; /** * Adds leases to this LeaseRenewer's set of currently held leases. Leases must have lastRenewalNanos set to the * last time the lease counter was incremented before being passed to this method. * * @param newLeases new leases. */ public void addLeasesToRenew ( Collection < T > newLeases ) ; /** * Clears this LeaseRenewer's set of currently held leases. */ public void clearCurrentlyHeldLeases ( ) ; /** * Update application-specific fields in a currently held lease. Cannot be used to update internal fields such as * leaseCounter, leaseOwner, etc. Fails if we do not hold the lease, or if the concurrency token does not match * the concurrency token on the internal authoritative copy of the lease (ie, if we lost and re-acquired the lease). * * @param lease lease object containing updated data * @param concurrencyToken obtained by calling Lease.getConcurrencyToken for a currently held lease * * @return true if update succeeds, false otherwise * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB update fails due to lack of capacity * @throws DependencyException if DynamoDB update fails in an unexpected way */ boolean updateLease ( T lease , UUID concurrencyToken ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
public void renewLeases ( ) throws DependencyException , InvalidStateException ; /** * @return currently held leases. Key is shardId, value is corresponding Lease object. A lease is currently held if * we successfully renewed it on the last run of renewLeases(). Lease objects returned are deep copies - * their lease counters will not tick. */ public Map < String , T > getCurrentlyHeldLeases ( ) ; /** * @param leaseKey key of the lease to retrieve * * @return a deep copy of a currently held lease, or null if we don't hold the lease */ public T getCurrentlyHeldLease ( String leaseKey ) ; /** * Adds leases to this LeaseRenewer's set of currently held leases. Leases must have lastRenewalNanos set to the * last time the lease counter was incremented before being passed to this method. * * @param newLeases new leases. */ public void addLeasesToRenew ( Collection < T > newLeases ) ; /** * Clears this LeaseRenewer's set of currently held leases. */ public void clearCurrentlyHeldLeases ( ) ; /** * Update application-specific fields in a currently held lease. Cannot be used to update internal fields such as * leaseCounter, leaseOwner, etc. Fails if we do not hold the lease, or if the concurrency token does not match * the concurrency token on the internal authoritative copy of the lease (ie, if we lost and re-acquired the lease). * * @param lease lease object containing updated data * @param concurrencyToken obtained by calling Lease.getConcurrencyToken for a currently held lease * * @return true if update succeeds, false otherwise * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB update fails due to lack of capacity * @throws DependencyException if DynamoDB update fails in an unexpected way */ boolean updateLease ( T lease , UUID concurrencyToken ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
public Map < String , T > getCurrentlyHeldLeases ( ) ; /** * @param leaseKey key of the lease to retrieve * * @return a deep copy of a currently held lease, or null if we don't hold the lease */ public T getCurrentlyHeldLease ( String leaseKey ) ; /** * Adds leases to this LeaseRenewer's set of currently held leases. Leases must have lastRenewalNanos set to the * last time the lease counter was incremented before being passed to this method. * * @param newLeases new leases. */ public void addLeasesToRenew ( Collection < T > newLeases ) ; /** * Clears this LeaseRenewer's set of currently held leases. */ public void clearCurrentlyHeldLeases ( ) ; /** * Update application-specific fields in a currently held lease. Cannot be used to update internal fields such as * leaseCounter, leaseOwner, etc. Fails if we do not hold the lease, or if the concurrency token does not match * the concurrency token on the internal authoritative copy of the lease (ie, if we lost and re-acquired the lease). * * @param lease lease object containing updated data * @param concurrencyToken obtained by calling Lease.getConcurrencyToken for a currently held lease * * @return true if update succeeds, false otherwise * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB update fails due to lack of capacity * @throws DependencyException if DynamoDB update fails in an unexpected way */ boolean updateLease ( T lease , UUID concurrencyToken ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
public T getCurrentlyHeldLease ( String leaseKey ) ; /** * Adds leases to this LeaseRenewer's set of currently held leases. Leases must have lastRenewalNanos set to the * last time the lease counter was incremented before being passed to this method. * * @param newLeases new leases. */ public void addLeasesToRenew ( Collection < T > newLeases ) ; /** * Clears this LeaseRenewer's set of currently held leases. */ public void clearCurrentlyHeldLeases ( ) ; /** * Update application-specific fields in a currently held lease. Cannot be used to update internal fields such as * leaseCounter, leaseOwner, etc. Fails if we do not hold the lease, or if the concurrency token does not match * the concurrency token on the internal authoritative copy of the lease (ie, if we lost and re-acquired the lease). * * @param lease lease object containing updated data * @param concurrencyToken obtained by calling Lease.getConcurrencyToken for a currently held lease * * @return true if update succeeds, false otherwise * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB update fails due to lack of capacity * @throws DependencyException if DynamoDB update fails in an unexpected way */ boolean updateLease ( T lease , UUID concurrencyToken ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
public void addLeasesToRenew ( Collection < T > newLeases ) ; /** * Clears this LeaseRenewer's set of currently held leases. */ public void clearCurrentlyHeldLeases ( ) ; /** * Update application-specific fields in a currently held lease. Cannot be used to update internal fields such as * leaseCounter, leaseOwner, etc. Fails if we do not hold the lease, or if the concurrency token does not match * the concurrency token on the internal authoritative copy of the lease (ie, if we lost and re-acquired the lease). * * @param lease lease object containing updated data * @param concurrencyToken obtained by calling Lease.getConcurrencyToken for a currently held lease * * @return true if update succeeds, false otherwise * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB update fails due to lack of capacity * @throws DependencyException if DynamoDB update fails in an unexpected way */ boolean updateLease ( T lease , UUID concurrencyToken ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
public void clearCurrentlyHeldLeases ( ) ; /** * Update application-specific fields in a currently held lease. Cannot be used to update internal fields such as * leaseCounter, leaseOwner, etc. Fails if we do not hold the lease, or if the concurrency token does not match * the concurrency token on the internal authoritative copy of the lease (ie, if we lost and re-acquired the lease). * * @param lease lease object containing updated data * @param concurrencyToken obtained by calling Lease.getConcurrencyToken for a currently held lease * * @return true if update succeeds, false otherwise * * @throws InvalidStateException if lease table does not exist * @throws ProvisionedThroughputException if DynamoDB update fails due to lack of capacity * @throws DependencyException if DynamoDB update fails in an unexpected way */ boolean updateLease ( T lease , UUID concurrencyToken ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
boolean updateLease ( T lease , UUID concurrencyToken ) throws DependencyException , InvalidStateException , ProvisionedThroughputException ; }
public Map < String , AttributeValue > toDynamoRecord ( T lease ) ; /** * Construct a Lease object out of a DynamoDB record. * * @param dynamoRecord attribute value map from DynamoDB * @return a deserialized lease object representing the attribute value map */ public T fromDynamoRecord ( Map < String , AttributeValue > dynamoRecord ) ; /** * @param lease * @return the attribute value map representing a Lease's hash key given a Lease object. */ public Map < String , AttributeValue > getDynamoHashKey ( T lease ) ; /** * Special getDynamoHashKey implementation used by ILeaseManager.getLease(). * * @param leaseKey * @return the attribute value map representing a Lease's hash key given a string. */ public Map < String , AttributeValue > getDynamoHashKey ( String leaseKey ) ; /** * @param lease * @return the attribute value map asserting that a lease counter is what we expect. */ public Map < String , ExpectedAttributeValue > getDynamoLeaseCounterExpectation ( T lease ) ; /** * @param lease * @return the attribute value map asserting that the lease owner is what we expect. */ public Map < String , ExpectedAttributeValue > getDynamoLeaseOwnerExpectation ( T lease ) ; /** * @return the attribute value map asserting that a lease does not exist. */ public Map < String , ExpectedAttributeValue > getDynamoNonexistantExpectation ( ) ; /** * @param lease * @return the attribute value map that increments a lease counter */ public Map < String , AttributeValueUpdate > getDynamoLeaseCounterUpdate ( T lease ) ; /** * @param lease * @param newOwner * @return the attribute value map that takes a lease for a new owner */ public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( T lease , String newOwner ) ; /** * @param lease * @return the attribute value map that voids a lease */ public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( T lease ) ; /** * @param lease * @return the attribute value map that updates application-specific data for a lease and increments the lease * counter */ public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( T lease ) ; /** * @return the key schema for creating a DynamoDB table to store leases */ public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public T fromDynamoRecord ( Map < String , AttributeValue > dynamoRecord ) ; /** * @param lease * @return the attribute value map representing a Lease's hash key given a Lease object. */ public Map < String , AttributeValue > getDynamoHashKey ( T lease ) ; /** * Special getDynamoHashKey implementation used by ILeaseManager.getLease(). * * @param leaseKey * @return the attribute value map representing a Lease's hash key given a string. */ public Map < String , AttributeValue > getDynamoHashKey ( String leaseKey ) ; /** * @param lease * @return the attribute value map asserting that a lease counter is what we expect. */ public Map < String , ExpectedAttributeValue > getDynamoLeaseCounterExpectation ( T lease ) ; /** * @param lease * @return the attribute value map asserting that the lease owner is what we expect. */ public Map < String , ExpectedAttributeValue > getDynamoLeaseOwnerExpectation ( T lease ) ; /** * @return the attribute value map asserting that a lease does not exist. */ public Map < String , ExpectedAttributeValue > getDynamoNonexistantExpectation ( ) ; /** * @param lease * @return the attribute value map that increments a lease counter */ public Map < String , AttributeValueUpdate > getDynamoLeaseCounterUpdate ( T lease ) ; /** * @param lease * @param newOwner * @return the attribute value map that takes a lease for a new owner */ public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( T lease , String newOwner ) ; /** * @param lease * @return the attribute value map that voids a lease */ public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( T lease ) ; /** * @param lease * @return the attribute value map that updates application-specific data for a lease and increments the lease * counter */ public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( T lease ) ; /** * @return the key schema for creating a DynamoDB table to store leases */ public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public Map < String , AttributeValue > getDynamoHashKey ( T lease ) ; /** * Special getDynamoHashKey implementation used by ILeaseManager.getLease(). * * @param leaseKey * @return the attribute value map representing a Lease's hash key given a string. */ public Map < String , AttributeValue > getDynamoHashKey ( String leaseKey ) ; /** * @param lease * @return the attribute value map asserting that a lease counter is what we expect. */ public Map < String , ExpectedAttributeValue > getDynamoLeaseCounterExpectation ( T lease ) ; /** * @param lease * @return the attribute value map asserting that the lease owner is what we expect. */ public Map < String , ExpectedAttributeValue > getDynamoLeaseOwnerExpectation ( T lease ) ; /** * @return the attribute value map asserting that a lease does not exist. */ public Map < String , ExpectedAttributeValue > getDynamoNonexistantExpectation ( ) ; /** * @param lease * @return the attribute value map that increments a lease counter */ public Map < String , AttributeValueUpdate > getDynamoLeaseCounterUpdate ( T lease ) ; /** * @param lease * @param newOwner * @return the attribute value map that takes a lease for a new owner */ public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( T lease , String newOwner ) ; /** * @param lease * @return the attribute value map that voids a lease */ public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( T lease ) ; /** * @param lease * @return the attribute value map that updates application-specific data for a lease and increments the lease * counter */ public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( T lease ) ; /** * @return the key schema for creating a DynamoDB table to store leases */ public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public Map < String , AttributeValue > getDynamoHashKey ( String leaseKey ) ; /** * @param lease * @return the attribute value map asserting that a lease counter is what we expect. */ public Map < String , ExpectedAttributeValue > getDynamoLeaseCounterExpectation ( T lease ) ; /** * @param lease * @return the attribute value map asserting that the lease owner is what we expect. */ public Map < String , ExpectedAttributeValue > getDynamoLeaseOwnerExpectation ( T lease ) ; /** * @return the attribute value map asserting that a lease does not exist. */ public Map < String , ExpectedAttributeValue > getDynamoNonexistantExpectation ( ) ; /** * @param lease * @return the attribute value map that increments a lease counter */ public Map < String , AttributeValueUpdate > getDynamoLeaseCounterUpdate ( T lease ) ; /** * @param lease * @param newOwner * @return the attribute value map that takes a lease for a new owner */ public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( T lease , String newOwner ) ; /** * @param lease * @return the attribute value map that voids a lease */ public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( T lease ) ; /** * @param lease * @return the attribute value map that updates application-specific data for a lease and increments the lease * counter */ public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( T lease ) ; /** * @return the key schema for creating a DynamoDB table to store leases */ public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public Map < String , ExpectedAttributeValue > getDynamoLeaseCounterExpectation ( T lease ) ; /** * @param lease * @return the attribute value map asserting that the lease owner is what we expect. */ public Map < String , ExpectedAttributeValue > getDynamoLeaseOwnerExpectation ( T lease ) ; /** * @return the attribute value map asserting that a lease does not exist. */ public Map < String , ExpectedAttributeValue > getDynamoNonexistantExpectation ( ) ; /** * @param lease * @return the attribute value map that increments a lease counter */ public Map < String , AttributeValueUpdate > getDynamoLeaseCounterUpdate ( T lease ) ; /** * @param lease * @param newOwner * @return the attribute value map that takes a lease for a new owner */ public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( T lease , String newOwner ) ; /** * @param lease * @return the attribute value map that voids a lease */ public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( T lease ) ; /** * @param lease * @return the attribute value map that updates application-specific data for a lease and increments the lease * counter */ public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( T lease ) ; /** * @return the key schema for creating a DynamoDB table to store leases */ public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public Map < String , ExpectedAttributeValue > getDynamoLeaseOwnerExpectation ( T lease ) ; /** * @return the attribute value map asserting that a lease does not exist. */ public Map < String , ExpectedAttributeValue > getDynamoNonexistantExpectation ( ) ; /** * @param lease * @return the attribute value map that increments a lease counter */ public Map < String , AttributeValueUpdate > getDynamoLeaseCounterUpdate ( T lease ) ; /** * @param lease * @param newOwner * @return the attribute value map that takes a lease for a new owner */ public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( T lease , String newOwner ) ; /** * @param lease * @return the attribute value map that voids a lease */ public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( T lease ) ; /** * @param lease * @return the attribute value map that updates application-specific data for a lease and increments the lease * counter */ public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( T lease ) ; /** * @return the key schema for creating a DynamoDB table to store leases */ public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public Map < String , ExpectedAttributeValue > getDynamoNonexistantExpectation ( ) ; /** * @param lease * @return the attribute value map that increments a lease counter */ public Map < String , AttributeValueUpdate > getDynamoLeaseCounterUpdate ( T lease ) ; /** * @param lease * @param newOwner * @return the attribute value map that takes a lease for a new owner */ public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( T lease , String newOwner ) ; /** * @param lease * @return the attribute value map that voids a lease */ public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( T lease ) ; /** * @param lease * @return the attribute value map that updates application-specific data for a lease and increments the lease * counter */ public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( T lease ) ; /** * @return the key schema for creating a DynamoDB table to store leases */ public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public Map < String , AttributeValueUpdate > getDynamoLeaseCounterUpdate ( T lease ) ; /** * @param lease * @param newOwner * @return the attribute value map that takes a lease for a new owner */ public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( T lease , String newOwner ) ; /** * @param lease * @return the attribute value map that voids a lease */ public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( T lease ) ; /** * @param lease * @return the attribute value map that updates application-specific data for a lease and increments the lease * counter */ public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( T lease ) ; /** * @return the key schema for creating a DynamoDB table to store leases */ public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( T lease , String newOwner ) ; /** * @param lease * @return the attribute value map that voids a lease */ public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( T lease ) ; /** * @param lease * @return the attribute value map that updates application-specific data for a lease and increments the lease * counter */ public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( T lease ) ; /** * @return the key schema for creating a DynamoDB table to store leases */ public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public Map < String , AttributeValueUpdate > getDynamoEvictLeaseUpdate ( T lease ) ; /** * @param lease * @return the attribute value map that updates application-specific data for a lease and increments the lease * counter */ public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( T lease ) ; /** * @return the key schema for creating a DynamoDB table to store leases */ public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public Map < String , AttributeValueUpdate > getDynamoUpdateLeaseUpdate ( T lease ) ; /** * @return the key schema for creating a DynamoDB table to store leases */ public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public Collection < KeySchemaElement > getKeySchema ( ) ; /** * @return attribute definitions for creating a DynamoDB table to store leases */ public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public Collection < AttributeDefinition > getAttributeDefinitions ( ) ; }
public abstract Map < String , T > takeLeases ( ) throws DependencyException , InvalidStateException ; /** * @return workerIdentifier for this LeaseTaker */ public abstract String getWorkerIdentifier ( ) ; }
public static AttributeValue createAttributeValue ( Collection < String > collectionValue ) { if ( collectionValue = = null | | collectionValue . isEmpty ( ) ) { throw new IllegalArgumentException ( " Collection attributeValues cannot be null or empty. " ) ; } return new AttributeValue ( ) . withSS ( collectionValue ) ; }
public static AttributeValue createAttributeValue ( String stringValue ) { if ( stringValue = = null | | stringValue . isEmpty ( ) ) { throw new IllegalArgumentException ( " String attributeValues cannot be null or empty. " ) ; } return new AttributeValue ( ) . withS ( stringValue ) ; }
public static AttributeValue createAttributeValue ( Long longValue ) { if ( longValue = = null ) { throw new IllegalArgumentException ( " Number AttributeValues cannot be null. " ) ; } return new AttributeValue ( ) . withN ( longValue . toString ( ) ) ; }
public static Long safeGetLong ( Map < String , AttributeValue > dynamoRecord , String key ) { AttributeValue av = dynamoRecord . get ( key ) ; if ( av = = null ) { return null ;
public static String safeGetString ( Map < String , AttributeValue > dynamoRecord , String key ) { AttributeValue av = dynamoRecord . get ( key ) ; if ( av = = null ) { return null ;
public static List < String > safeGetSS ( Map < String , AttributeValue > dynamoRecord , String key ) { AttributeValue av = dynamoRecord . get ( key ) ; if ( av = = null ) { return new ArrayList < String > ( ) ;
protected String getKey ( String name ) { return name ; }
public void addData ( String name , double value , StandardUnit unit ) { addData ( getKey ( name ) , name , value , unit ) ; }
protected abstract KeyType getKey ( String name ) ; /** * Adds data points to an IMetricsScope. Multiple calls to IMetricsScopes that have the * same key will have their data accumulated. * * @param key * data point key * @param name * data point name * @param value * data point value * @param unit * data point unit */ public void addData ( KeyType key , String name , double value , StandardUnit unit ) { super . addData ( name , value , unit ) ; MetricDatum datum = data . get ( key ) ; if ( datum = = null ) { data . put ( key , new MetricDatum ( ) . withMetricName ( name ) . withUnit ( unit ) . withStatisticValues ( new StatisticSet ( ) . withMaximum ( value ) . withMinimum ( value ) . withSampleCount ( 1.0 ) . withSum ( value ) ) ) ; } else { if ( ! datum . getUnit ( ) . equals ( unit . name ( ) ) ) { throw new IllegalArgumentException ( " Cannot add to existing metric with different unit " ) ; } StatisticSet statistics = datum . getStatisticValues ( ) ; statistics . setMaximum ( Math . max ( value , statistics . getMaximum ( ) ) ) ; statistics . setMinimum ( Math . min ( value , statistics . getMinimum ( ) ) ) ; statistics . setSampleCount ( statistics . getSampleCount ( ) + 1 ) ; statistics . setSum ( statistics . getSum ( ) + value ) ; } } }
public void addData ( KeyType key , String name , double value , StandardUnit unit ) { super . addData ( name , value , unit ) ; MetricDatum datum = data . get ( key ) ; if ( datum = = null ) { data . put ( key ,
public int hashCode ( ) { return Objects . hash ( dimensions , metricName ) ; }
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; CWMetricKey other = ( CWMetricKey ) obj ; return Objects . equals ( other . dimensions , dimensions ) & & Objects . equals ( other . metricName , metricName ) ; }
public IMetricsScope createMetrics ( ) { return new CWMetricsScope ( runnable ) ; }
public void shutdown ( ) { runnable . shutdown ( ) ; }
public void addData ( String name , double value , StandardUnit unit ) { super . addData ( name , value , unit ) ; }
public void addDimension ( String name , String value ) { super . addDimension ( name , value ) ; }
public void end ( ) { super . end ( ) ; List < MetricDatumWithKey < CWMetricKey > > dataWithKeys = new ArrayList < MetricDatumWithKey < CWMetricKey > > ( ) ; for ( MetricDatum datum : data . values ( ) ) { datum . setDimensions ( getDimensions ( ) ) ; dataWithKeys . add ( new MetricDatumWithKey < CWMetricKey > ( new CWMetricKey ( datum ) , datum ) ) ; } publisher . enqueue ( dataWithKeys ) ; }
public void run ( ) { while ( ! shutdown ) { try { runOnce ( ) ; } catch ( Throwable t ) { LOG . error ( " Encountered throwable in CWPublisherRunable " , t ) ; } } LOG . info ( " CWPublication thread finished. " ) ; }
public void runOnce ( ) { List < MetricDatumWithKey < KeyType > > dataToPublish = null ; synchronized ( queue ) { /* * We should send if: * * it's been maxBufferTimeMillis since our last send * or if the queue contains > batchSize elements * or if we're shutting down */ long timeSinceFlush = Math . max ( 0 , getTime ( ) - lastFlushTime ) ; if ( timeSinceFlush > = bufferTimeMillis | | queue . size ( ) > = flushSize | | shuttingDown ) { dataToPublish = queue . drain ( flushSize ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( " Drained %d datums from queue " , dataToPublish . size ( ) ) ) ; } if ( shuttingDown ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( " Shutting down with %d datums left on the queue " , queue . size ( ) ) ) ; } // If we're shutting down, we successfully shut down only when the queue is empty. shutdown = queue.isEmpty(); } } else { long waitTime = bufferTimeMillis - timeSinceFlush; if (LOG.isDebugEnabled()) { LOG.debug(String.format("Waiting up to %dms for %d more datums to appear.", waitTime, flushSize - queue.size())); } try { // Wait for enqueues for up to maxBufferTimeMillis. queue.wait(waitTime); } catch (InterruptedException e) { } } } if (dataToPublish != null) { try {
long getTime ( ) { return System . currentTimeMillis ( ) ; }
public void shutdown ( ) { LOG . info ( " Shutting down CWPublication thread. " ) ; synchronized ( queue ) { shuttingDown = true ;
public boolean isShutdown ( ) { return shutdown ; }
public void enqueue ( Collection < MetricDatumWithKey < KeyType > > data ) { synchronized ( queue ) { if ( shuttingDown ) {
public void publishMetrics ( List < MetricDatumWithKey < CWMetricKey > > dataToPublish ) { for ( int startIndex = 0 ; startIndex < dataToPublish . size ( ) ; startIndex + = BATCH_SIZE ) { int endIndex = Math . min ( dataToPublish . size ( ) , startIndex + BATCH_SIZE ) ;
public void addDimension ( String name , String value ) { dimensions . add ( new Dimension ( ) . withName ( name ) . withValue ( value ) ) ; }
protected Set < Dimension > getDimensions ( ) { return dimensions ; }
public void addData ( String name , double value , StandardUnit unit ) { if ( ended ) { throw new IllegalArgumentException ( " Cannot call addData after calling IMetricsScope.end() " ) ;
public void addDimension ( String name , String value ) { super . addDimension ( name , value ) ; if ( ended ) { throw new IllegalArgumentException ( " Cannot call addDimension after calling IMetricsScope.end() " ) ;
public void end ( ) { if ( ended ) { throw new IllegalArgumentException ( " Cannot call IMetricsScope.end() more than once on the same instance " ) ; } ended = true ; }
public void publishMetrics ( List < MetricDatumWithKey < KeyType > > dataToPublish ) ; }
public IMetricsScope createMetrics ( ) { IMetricsScope otherScope = other . createMetrics ( ) ; interceptCreateMetrics ( otherScope ) ; return new InterceptingMetricsScope ( otherScope ) ; }
protected void interceptCreateMetrics ( IMetricsScope scope ) { // Default implementation does nothing; } protected void interceptAddData(String name, double value, StandardUnit unit, IMetricsScope scope) { scope.addData(name, value, unit); } protected void interceptAddDimension(String name, String value, IMetricsScope scope) { scope.addDimension(name, value); } protected void interceptEnd(IMetricsScope scope) { scope.end(); } private class InterceptingMetricsScope implements IMetricsScope { private IMetricsScope other; public InterceptingMetricsScope(IMetricsScope other) { this.other = other; } @Override public void addData(String name, double value, StandardUnit unit) { interceptAddData(name, value, unit, other); } @Override public void addDimension(String name, String value) { interceptAddDimension(name, value, other); } @Override public void end() { interceptEnd(other); } } }
protected void interceptAddData ( String name , double value , StandardUnit unit , IMetricsScope scope ) { scope . addData ( name , value , unit ) ; }
protected void interceptAddDimension ( String name , String value , IMetricsScope scope ) { scope . addDimension ( name , value ) ; }
protected void interceptEnd ( IMetricsScope scope ) { scope . end ( ) ; }
public void addData ( String name , double value , StandardUnit unit ) { interceptAddData ( name , value , unit , other ) ; }
public void addDimension ( String name , String value ) { interceptAddDimension ( name , value , other ) ; }
public void end ( ) { interceptEnd ( other ) ; }
public LogMetricsScope createMetrics ( ) { return new LogMetricsScope ( ) ; }
public void end ( ) { StringBuilder output = new StringBuilder ( ) ; output . append ( " Metrics: \ n " ) ; output . append ( " Dimensions: " ) ; boolean needsComma = false ; for ( Dimension dimension : getDimensions ( ) ) { output . append ( String . format ( " %s[%s: %s] " , needsComma ? " , " : " " , dimension . getName ( ) , dimension . getValue ( ) ) ) ; needsComma = true ; } output . append ( " \ n " ) ; for ( MetricDatum datum : data . values ( ) ) { StatisticSet statistics = datum . getStatisticValues ( ) ; output . append ( String . format ( " Name=%25s \ tMin=%.2f \ tMax=%.2f \ tCount=%.2f \ tSum=%.2f \ tAvg=%.2f \ tUnit=%s \ n " , datum . getMetricName ( ) , statistics . getMinimum ( ) , statistics . getMaximum ( ) , statistics . getSampleCount ( ) , statistics . getSum ( ) , statistics . getSum ( ) / statistics . getSampleCount ( ) , datum . getUnit ( ) ) ) ; } LOG . info ( output . toString ( ) ) ; }
public synchronized List < MetricDatumWithKey < KeyType > > drain ( int maxItems ) { List < MetricDatumWithKey < KeyType > > drainedItems = new ArrayList < MetricDatumWithKey < KeyType > > ( maxItems ) ; queue . drainTo ( drainedItems , maxItems ) ; for ( MetricDatumWithKey < KeyType > datumWithKey : drainedItems ) { map . remove ( datumWithKey . key ) ; } return drainedItems ; }
public synchronized boolean isEmpty ( ) { return queue . isEmpty ( ) ; }
public synchronized int size ( ) { return queue . size ( ) ; }
public synchronized boolean offer ( KeyType key , MetricDatum datum ) { MetricDatum old = map . get ( key ) ; if ( old = = null ) { boolean offered = queue . offer ( new MetricDatumWithKey < KeyType > ( key , datum ) ) ;
private void accumulate ( MetricDatum oldDatum , MetricDatum newDatum ) { if ( ! oldDatum . getUnit ( ) . equals ( newDatum . getUnit ( ) ) ) { throw new IllegalArgumentException ( " Unit mismatch for datum named " + oldDatum . getMetricName ( ) ) ; } StatisticSet oldStats = oldDatum . getStatisticValues ( ) ; StatisticSet newStats = newDatum . getStatisticValues ( ) ; oldStats . setSampleCount ( oldStats . getSampleCount ( ) + newStats . getSampleCount ( ) ) ; oldStats . setMaximum ( Math . max ( oldStats . getMaximum ( ) , newStats . getMaximum ( ) ) ) ; oldStats . setMinimum ( Math . min ( oldStats . getMinimum ( ) , newStats . getMinimum ( ) ) ) ; oldStats . setSum ( oldStats . getSum ( ) + newStats . getSum ( ) ) ; }
public int hashCode ( ) { return Objects . hash ( key , datum ) ; }
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; MetricDatumWithKey < ? > other = ( MetricDatumWithKey < ? > ) obj ; return Objects . equals ( other . key , key ) & & Objects . equals ( other . datum , datum ) ; }
public static IMetricsScope startScope ( IMetricsFactory factory ) { return startScope ( factory , null ) ; }
public static IMetricsScope startScope ( IMetricsFactory factory , String operation ) { IMetricsScope result = currentScope . get ( ) ; if ( result = = null ) { result = factory . createMetrics ( ) ; if ( operation ! = null ) { result . addDimension ( OPERATION_DIMENSION_NAME , operation ) ; } currentScope . set ( result ) ; referenceCount . set ( 1 ) ; } else { referenceCount . set ( referenceCount . get ( ) + 1 ) ; } return result ; }
public static IMetricsScope getMetricsScope ( ) { IMetricsScope result = currentScope . get ( ) ; if ( result = = null ) { LOG . warn ( String . format ( " No metrics scope set in thread %s, getMetricsScope returning NullMetricsScope. " ,
public static void addSuccessAndLatency ( long startTimeMillis , boolean success ) { addSuccessAndLatency ( null , startTimeMillis , success ) ; }
public static void addSuccessAndLatency ( String prefix , long startTimeMillis , boolean success ) { addSuccessAndLatencyPerShard ( null , prefix , startTimeMillis , success ) ; }
public static void addSuccessAndLatencyPerShard ( String shardId , String prefix , long startTimeMillis , boolean success ) { IMetricsScope scope = getMetricsScope ( ) ; String realPrefix = prefix = = null ? " " : prefix + SEP ; if ( shardId ! = null ) { scope . addDimension ( " ShardId " , shardId ) ; } scope . addData ( realPrefix + MetricsHelper . SUCCESS , success ? 1 : 0 , StandardUnit . Count ) ; scope . addData ( realPrefix + MetricsHelper . TIME , System . currentTimeMillis ( ) - startTimeMillis ,
public static void endScope ( ) { IMetricsScope scope = getMetricsScope ( ) ; if ( scope ! = null ) { Integer refCount = referenceCount . get ( ) ;
public IMetricsScope createMetrics ( ) { return SCOPE ; }
public void addData ( String name , double value , StandardUnit unit ) { } @Override public void addDimension ( String name , String value ) { } @Override public void end ( ) { } }
public void addDimension ( String name , String value ) { } @Override public void end ( ) { } }
public void addData ( String name , double value , StandardUnit unit ) ; /** * Adds a dimension that applies to all metrics in this IMetricsScope. * * @param name dimension name * @param value dimension value */ public void addDimension ( String name , String value ) ; /** * Flushes the data from this IMetricsScope and causes future calls to addData and addDimension to fail. */ public void end ( ) ; }
public void addDimension ( String name , String value ) ; /** * Flushes the data from this IMetricsScope and causes future calls to addData and addDimension to fail. */ public void end ( ) ; }
void checkpoint ( ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException ; /** * This method will checkpoint the progress at the provided sequenceNumber. This method is analogous to * {@link #checkpoint()} but provides the ability to specify the sequence number at which to * checkpoint. * * @param sequenceNumber A sequence number at which to checkpoint in this shard. Upon failover, * the Kinesis Client Library will start fetching records after this sequence number. * @throws ThrottlingException Can't store checkpoint. Can be caused by checkpointing too frequently. * Consider increasing the throughput/capacity of the checkpoint store or reducing checkpoint frequency. * @throws ShutdownException The record processor instance has been shutdown. Another instance may have * started processing some of these records already. * The application should abort processing via this RecordProcessor instance. * @throws InvalidStateException Can't store checkpoint. * Unable to store the checkpoint in the DynamoDB table (e.g. table doesn't exist). * @throws KinesisClientLibDependencyException Encountered an issue when storing the checkpoint. The application can * backoff and retry. * @throws IllegalArgumentException The sequence number is invalid for one of the following reasons: * 1.) It appears to be out of range, i.e. it is smaller than the last check point value, or larger than the * greatest sequence number seen by the associated record processor. * 2.) It is not a valid sequence number for a record in this shard. */ void checkpoint ( String sequenceNumber ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException , IllegalArgumentException ; }
void checkpoint ( String sequenceNumber ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException , IllegalArgumentException ; }
public int compare ( String first , String second ) { if ( ! isDigitsOrSentinelValue ( first ) | | ! isDigitsOrSentinelValue ( second ) ) { throw new IllegalArgumentException ( " Expected a sequence number or a sentinel checkpoint value but " + " received: first= " + first + " and second= " + second ) ; } // SHARD_END is the greatest if (SentinelCheckpoint.SHARD_END.toString().equals(first) && SentinelCheckpoint.SHARD_END.toString().equals(second)) { return 0; } else if (SentinelCheckpoint.SHARD_END.toString().equals(second)) { return -1; } else if (SentinelCheckpoint.SHARD_END.toString().equals(first)) { return 1; } // Compare other sentinel values and serial numbers after converting them to a big integer value return bigIntegerValue(first).compareTo(bigIntegerValue(second)); }
private static BigInteger bigIntegerValue ( String checkpointValue ) { if ( SequenceNumberValidator . isDigits ( checkpointValue ) ) { return new BigInteger ( checkpointValue ) ;
private static boolean isDigitsOrSentinelValue ( String string ) { return SequenceNumberValidator . isDigits ( string ) | | isSentinelValue ( string ) ; }
private static boolean isSentinelValue ( String string ) { try { SentinelCheckpoint . valueOf ( string ) ;
public TaskResult call ( ) { boolean applicationException = false ; Exception exception = null ; try { LOG . debug ( " Initializing ShardId " + shardInfo . getShardId ( ) ) ; String initialCheckpoint = checkpoint . getCheckpoint ( shardInfo . getShardId ( ) ) ; dataFetcher . initialize ( initialCheckpoint ) ; recordProcessorCheckpointer . setLargestPermittedCheckpointValue ( initialCheckpoint ) ; try { LOG . debug ( " Calling the record processor initialize(). " ) ; recordProcessor . initialize ( shardInfo . getShardId ( ) ) ; LOG . debug ( " Record processor initialize() completed. " ) ; } catch ( Exception e ) { applicationException = true ; throw e ; } return new TaskResult ( null ) ; } catch ( Exception e ) { if ( applicationException ) { LOG . error ( " Application initialize() threw exception: " , e ) ; } else { LOG . error ( " Caught exception: " , e ) ; } exception = e ; // backoff if we encounter an exception. try { Thread.sleep(this.backoffTimeMillis); } catch (InterruptedException ie) { LOG.debug("Interrupted sleep", ie); } } return new TaskResult(exception); }
private void checkIsRegionNameValid ( String regionNameToCheck ) { if ( regionNameToCheck ! = null & & RegionUtils . getRegion ( regionNameToCheck ) = = null ) { throw new IllegalArgumentException ( " The specified region name is not valid " ) ;
public boolean shouldValidateSequenceNumberBeforeCheckpointing ( ) { return validateSequenceNumberBeforeCheckpointing ; }
public String getRegionName ( ) { return regionName ; }
public KinesisClientLibConfiguration withCallProcessRecordsEvenForEmptyRecordList ( boolean callProcessRecordsEvenForEmptyRecordList ) { this . callProcessRecordsEvenForEmptyRecordList = callProcessRecordsEvenForEmptyRecordList ; return this ; }
public KinesisClientLibConfiguration withCleanupLeasesUponShardCompletion ( boolean cleanupLeasesUponShardCompletion ) { this . cleanupLeasesUponShardCompletion = cleanupLeasesUponShardCompletion ; return this ; }
public KinesisClientLibConfiguration withCommonClientConfig ( ClientConfiguration clientConfig ) { ClientConfiguration tempClientConfig = checkAndAppendKinesisClientLibUserAgent ( clientConfig ) ; this . kinesisClientConfig = tempClientConfig ; this . dynamoDBClientConfig = tempClientConfig ; this . cloudWatchClientConfig = tempClientConfig ; return this ; }
public KinesisClientLibConfiguration withKinesisClientConfig ( ClientConfiguration kinesisClientConfig ) { this . kinesisClientConfig = checkAndAppendKinesisClientLibUserAgent ( kinesisClientConfig ) ; return this ; }
public KinesisClientLibConfiguration withDynamoDBClientConfig ( ClientConfiguration dynamoDBClientConfig ) { this . dynamoDBClientConfig = checkAndAppendKinesisClientLibUserAgent ( dynamoDBClientConfig ) ; return this ; }
public KinesisClientLibConfiguration withCloudWatchClientConfig ( ClientConfiguration cloudWatchClientConfig ) { this . cloudWatchClientConfig = checkAndAppendKinesisClientLibUserAgent ( cloudWatchClientConfig ) ; return this ; }
public KinesisClientLibConfiguration withValidateSequenceNumberBeforeCheckpointing ( boolean validateSequenceNumberBeforeCheckpointing ) { this . validateSequenceNumberBeforeCheckpointing = validateSequenceNumberBeforeCheckpointing ; return this ; }
public KinesisClientLibConfiguration withRegionName ( String regionName ) { checkIsRegionNameValid ( regionName ) ; this . regionName = regionName ; return this ; }
public synchronized void checkpoint ( ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException { advancePosition ( this . largestPermittedCheckpointValue ) ; }
public synchronized void checkpoint ( String sequenceNumber ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException , IllegalArgumentException { // throws exception if sequence number shouldn't be checkpointed for this shard sequenceNumberValidator.validateSequenceNumber(sequenceNumber); /* * If there isn't a last checkpoint value, we only care about checking the upper bound. * If there is a last checkpoint value, we want to check both the lower and upper bound. */ if ((lastCheckpointValue == null || checkpointValueComparator.compare(lastCheckpointValue, sequenceNumber) <= 0)
synchronized String getLargestPermittedCheckpointValue ( ) { return largestPermittedCheckpointValue ; }
synchronized void setLargestPermittedCheckpointValue ( String checkpointValue ) { this . largestPermittedCheckpointValue = checkpointValue ; }
synchronized void setSequenceNumberAtShardEnd ( String sequenceNumber ) { this . sequenceNumberAtShardEnd = sequenceNumber ; }
void advancePosition ( String sequenceNumber ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException { String checkpointValue = sequenceNumber ; if ( sequenceNumberAtShardEnd ! = null & & sequenceNumberAtShardEnd . equals ( sequenceNumber ) ) { // If we are about to checkpoint the very last sequence number for this shard, we might as well // just checkpoint at SHARD_END checkpointValue = SentinelCheckpoint.SHARD_END.toString(); } // Don't checkpoint a value we already successfully checkpointed if (sequenceNumber != null && !sequenceNumber.equals(lastCheckpointValue)) { try {
void validateSequenceNumber ( String sequenceNumber ) throws IllegalArgumentException , ThrottlingException , KinesisClientLibDependencyException { if ( ! isDigits ( sequenceNumber ) ) { LOG . info ( " Sequence number must be numeric, but was " + sequenceNumber ) ; throw new IllegalArgumentException ( " Sequence number must be numeric, but was " + sequenceNumber ) ; } try { if ( validateWithGetIterator ) {
static boolean isDigits ( String string ) { if ( string = = null | | string . length ( ) = = 0 ) { return false ; } for ( int i = 0 ; i < string . length ( ) ; i + + ) { if ( ! Character . isDigit ( string . charAt ( i ) ) ) { return false ; } } return true ; }
public TaskResult call ( ) { Exception exception = null ; boolean applicationException = false ; try { // If we reached end of the shard, set sequence number to SHARD_END. if (reason == ShutdownReason.TERMINATE) { recordProcessorCheckpointer.setSequenceNumberAtShardEnd( recordProcessorCheckpointer.getLargestPermittedCheckpointValue()); recordProcessorCheckpointer.setLargestPermittedCheckpointValue(SentinelCheckpoint.SHARD_END.toString()); } LOG.debug("Invoking shutdown() for shard " + shardInfo.getShardId() + ", concurrencyToken " + shardInfo.getConcurrencyToken() + ". Shutdown reason: " + reason); try { recordProcessor.shutdown(recordProcessorCheckpointer, reason); String lastCheckpointValue = recordProcessorCheckpointer.getLastCheckpointValue(); if (reason == ShutdownReason.TERMINATE) { if ((lastCheckpointValue == null) || (!lastCheckpointValue.equals(SentinelCheckpoint.SHARD_END.toString()))) { throw new IllegalArgumentException("Application didn't checkpoint at end of shard " + shardInfo.getShardId()); } } LOG.debug("Record processor completed shutdown() for shard " + shardInfo.getShardId()); } catch (Exception e) { applicationException = true; throw e; } if (reason == ShutdownReason.TERMINATE) { LOG.debug("Looking for child shards of shard " + shardInfo.getShardId()); // create leases for the child shards ShardSyncer.checkAndCreateLeasesForNewShards(kinesisProxy, leaseManager, initialPositionInStream, cleanupLeasesOfCompletedShards); LOG.debug("Finished checking for child shards of shard " + shardInfo.getShardId()); } return new TaskResult(null); } catch (Exception e) { if (applicationException) { LOG.error("Application exception. ", e); } else { LOG.error("Caught exception: ", e); } exception = e; // backoff if we encounter an exception. try { Thread.sleep(this.backoffTimeMillis); } catch (InterruptedException ie) { LOG.debug("Interrupted sleep", ie); } } return new TaskResult(exception); }
boolean shouldValidateSequenceNumberBeforeCheckpointing ( ) { return validateSequenceNumberBeforeCheckpointing ; }
boolean isBeginShutdown ( ) { return beginShutdown ; }
public String toString ( ) { return " ShardInfo [shardId= " + shardId + " , concurrencyToken= " + concurrencyToken + " , parentShardIds= " + parentShardIds + " ] " ;
public void run ( ) { try { initialize ( ) ; LOG . info ( " Initialization complete. Starting worker loop. " ) ; } catch ( RuntimeException e1 ) { LOG . error ( " Unable to initialize after " + MAX_INITIALIZATION_ATTEMPTS + " attempts. Shutting down. " , e1 ) ; shutdown ( ) ; } while ( ! shutdown ) { try { boolean foundCompletedShard = false ; Set < ShardInfo > assignedShards = new HashSet < ShardInfo > ( ) ; for ( ShardInfo shardInfo : getShardInfoForAssignments ( ) ) { ShardConsumer shardConsumer = createOrGetShardConsumer ( shardInfo , recordProcessorFactory ) ; if ( shardConsumer . isShutdown ( ) & & shardConsumer . getShutdownReason ( ) . equals ( ShutdownReason . TERMINATE ) ) { foundCompletedShard = true ; } else { shardConsumer . consumeShard ( ) ; } assignedShards . add ( shardInfo ) ; } if ( foundCompletedShard ) { controlServer . syncShardAndLeaseInfo ( null ) ; } // clean up shard consumers for unassigned shards cleanupShardConsumers(assignedShards); wlog.info("Sleeping ..."); Thread.sleep(idleTimeInMilliseconds); } catch (Exception e) { LOG.error(String.format("Worker.run caught exception, sleeping for %s milli seconds!", String.valueOf(idleTimeInMilliseconds)), e); try { Thread.sleep(idleTimeInMilliseconds); } catch (InterruptedException ex) { LOG.info("Worker: sleep interrupted after catching exception ", ex); } } wlog.resetInfoLogging(); } LOG.info("Stopping LeaseCoordinator."); leaseCoordinator.stop(); }
void cleanupShardConsumers ( Set < ShardInfo > assignedShards ) { for ( ShardInfo shard : shardInfoShardConsumerMap . keySet ( ) ) { if ( ! assignedShards . contains ( shard ) ) {
ShardConsumer createOrGetShardConsumer ( ShardInfo shardInfo , IRecordProcessorFactory factory ) { synchronized ( shardInfoShardConsumerMap ) { ShardConsumer consumer = shardInfoShardConsumerMap . get ( shardInfo ) ;
public AWSCredentialsProvider decodeValue ( String value ) { if ( value ! = null ) { List < String > providerNames = getProviderNames ( value ) ;
public List < Class < AWSCredentialsProvider > > getSupportedTypes ( ) { return Arrays . asList ( AWSCredentialsProvider . class ) ; }
private static List < AWSCredentialsProvider > getValidCredentialsProviders ( List < String > providerNames ) { List < AWSCredentialsProvider > credentialsProviders = new ArrayList < AWSCredentialsProvider > ( ) ; for ( String providerName : providerNames ) { try { Class < ? > className = Class . forName ( providerName ) ; credentialsProviders . add ( ( AWSCredentialsProvider ) className . newInstance ( ) ) ; } catch ( Exception e ) { LOG . debug ( " Can't find any credentials provider matching " + providerName + " . " ) ; } } return credentialsProviders ; }
private static List < String > getProviderNames ( String property ) { // assume list delimiter is "," String[] elements = property.split(LIST_DELIMITER); List<String> result = new ArrayList<String>(); for (int i = 0; i < elements.length; i++) { String string = elements[i].trim(); if (!string.isEmpty()) { // find all possible names and add them to name list result.addAll(getPossibleFullClassNames(string)); } } return result; }
private static List < String > getPossibleFullClassNames ( String s ) { /* * We take care of three cases : * * 1. Customer provides a short name of common providers in com.amazonaws.auth package i.e. any classes * implementing the AWSCredentialsProvider interface: * http://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/auth/AWSCredentialsProvider.html * * 2. Customer provides a full name of common providers e.g. com.amazonaws.auth.ClasspathFileCredentialsProvider * * 3. Customer provides a custom credentials provider with full name of provider */ return Arrays . asList ( s , AUTH_PREFIX + s ) ; }
public Boolean decodeValue ( String value ) { return Boolean . parseBoolean ( value ) ; }
public List < Class < Boolean > > getSupportedTypes ( ) { return Arrays . asList ( boolean . class , Boolean . class ) ; }
public ClientConfiguration decodeValue ( String value ) { throw new UnsupportedOperationException ( " ClientConfiguration is currently not supported " ) ; }
public List < Class < ClientConfiguration > > getSupportedTypes ( ) { return Arrays . asList ( ClientConfiguration . class ) ; }
T decodeValue ( String propertyValue ) ; /** * Get a list of supported types for this class. * * @return list of supported classes. */ List < Class < T > > getSupportedTypes ( ) ; }
public InitialPositionInStream decodeValue ( String value ) { return InitialPositionInStream . valueOf ( value . toUpperCase ( ) ) ; }
public List < Class < InitialPositionInStream > > getSupportedTypes ( ) { return Arrays . asList ( InitialPositionInStream . class ) ; }
public Integer decodeValue ( String value ) { return Integer . parseInt ( value ) ; }
public List < Class < Integer > > getSupportedTypes ( ) { return Arrays . asList ( int . class , Integer . class ) ; }
public KinesisClientLibConfiguration getConfiguration ( Properties properties ) { // The three minimum required arguments for constructor are obtained first. They are all mandatory, all of them // should be provided. If any of these three failed to be set, program will fail. IPropertyValueDecoder<String> stringValueDecoder = new StringPropertyValueDecoder(); IPropertyValueDecoder<AWSCredentialsProvider> awsCPPropGetter = new AWSCredentialsProviderPropertyValueDecoder(); String applicationName = stringValueDecoder.decodeValue(properties.getProperty(PROP_APP_NAME)); String streamName = stringValueDecoder.decodeValue(properties.getProperty(PROP_STREAM_NAME)); AWSCredentialsProvider provider = awsCPPropGetter.decodeValue(properties.getProperty(PROP_CREDENTIALS_PROVIDER)); if (applicationName == null || applicationName.isEmpty()) { throw new IllegalArgumentException("Value of applicationName should be explicitly provided."); } if (streamName == null || streamName.isEmpty()) { throw new IllegalArgumentException("Value of streamName should be explicitly provided."); } // Allow customer not to provide workerId or to provide empty worker id. String workerId = stringValueDecoder.decodeValue(properties.getProperty(PROP_WORKER_ID)); if (workerId == null || workerId.isEmpty()) { workerId = UUID.randomUUID().toString(); LOG.info("Value of workerId is not provided in the properties. WorkerId is automatically " + "assigned as: " + workerId); } KinesisClientLibConfiguration config = new KinesisClientLibConfiguration(applicationName, streamName, provider, workerId); Set<String> requiredNames = new HashSet<String>(Arrays.asList(PROP_STREAM_NAME, PROP_APP_NAME, PROP_WORKER_ID, PROP_CREDENTIALS_PROVIDER)); // Set all the variables that are not used for constructor. for (Object keyObject : properties.keySet()) { String key = keyObject.toString(); if (!requiredNames.contains(key)) { withProperty(key, properties, config); } } return config; }
public KinesisClientLibConfiguration getConfiguration ( InputStream configStream ) { Properties properties = new Properties ( ) ; try { properties . load ( configStream ) ; } catch ( IOException e ) { String msg = " Could not load properties from the stream provided " ; throw new IllegalStateException ( msg , e ) ; } finally { try { configStream . close ( ) ; } catch ( IOException e ) { String msg = " Encountered error while trying to close properties file. " ; throw new IllegalStateException ( msg , e ) ; } } return getConfiguration ( properties ) ; }
private void withProperty ( String propertyKey , Properties properties , KinesisClientLibConfiguration config ) { if ( propertyKey . isEmpty ( ) ) { throw new IllegalArgumentException ( " The property can't be empty string " ) ; } // Assume that all the setters in KinesisClientLibConfiguration are in the following format // They all start with "with" followed by the variable name with first letter capitalized String targetMethodName = PREFIX + Character.toUpperCase(propertyKey.charAt(0)) + propertyKey.substring(1); String propertyValue = properties.getProperty(propertyKey); if (nameToMethods.containsKey(targetMethodName)) { for (Method method : nameToMethods.get(targetMethodName)) {
public Long decodeValue ( String value ) { return Long . parseLong ( value ) ; }
public List < Class < Long > > getSupportedTypes ( ) { return Arrays . asList ( long . class , Long . class ) ; }
public String decodeValue ( String value ) { // How to treat null or empty String should depend on those method who // uses the String value. Here just return the string as it is. if (value == null) { return null; } return value.trim(); }
public List < Class < String > > getSupportedTypes ( ) { return Arrays . asList ( String . class ) ; }
public TaskResult call ( ) { boolean applicationException = false ; Exception exception = null ; try { LOG . debug ( " Initializing ShardId " + shardInfo . getShardId ( ) ) ; String initialCheckpoint = checkpoint . getCheckpoint ( shardInfo . getShardId ( ) ) ; dataFetcher . initialize ( initialCheckpoint ) ; recordProcessorCheckpointer . setLargestPermittedCheckpointValue ( initialCheckpoint ) ; recordProcessorCheckpointer . setInitialCheckpointValue ( initialCheckpoint ) ; try { LOG . debug ( " Calling the record processor initialize(). " ) ; recordProcessor . initialize ( shardInfo . getShardId ( ) ) ; LOG . debug ( " Record processor initialize() completed. " ) ; } catch ( Exception e ) { applicationException = true ; throw e ; } return new TaskResult ( null ) ; } catch ( Exception e ) { if ( applicationException ) { LOG . error ( " Application initialize() threw exception: " , e ) ; } else { LOG . error ( " Caught exception: " , e ) ; } exception = e ; // backoff if we encounter an exception. try { Thread.sleep(this.backoffTimeMillis); } catch (InterruptedException ie) { LOG.debug("Interrupted sleep", ie); } } return new TaskResult(exception); }
public synchronized void checkpoint ( String sequenceNumber ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException , IllegalArgumentException { // throws exception if sequence number shouldn't be checkpointed for this shard sequenceNumberValidator.validateSequenceNumber(sequenceNumber); /* * If there isn't a last checkpoint value, we only care about checking the upper bound. * If there is a last checkpoint value, we want to check both the lower and upper bound. */ if ((checkpointValueComparator.compare(lastCheckpointValue, sequenceNumber) <= 0) && checkpointValueComparator.compare(sequenceNumber, largestPermittedCheckpointValue) <= 0) {
synchronized void setInitialCheckpointValue ( String initialCheckpoint ) { lastCheckpointValue = initialCheckpoint ; }
private static AmazonKinesisClient buildClientSettingEndpoint ( AWSCredentialsProvider credentialProvider , String endpoint , String serviceName , String regionId ) { AmazonKinesisClient client = new AmazonKinesisClient ( credentialProvider ) ; client . setEndpoint ( endpoint , serviceName , regionId ) ; return client ; }
private static AmazonKinesisClient buildClientSettingEndpoint ( AWSCredentialsProvider credentialProvider , ClientConfiguration clientConfig , String endpoint , String serviceName , String regionId ) { AmazonKinesisClient client = new AmazonKinesisClient ( credentialProvider , clientConfig ) ; client . setEndpoint ( endpoint , serviceName , regionId ) ; return client ; }
protected HandleLineResult < Boolean > handleLine ( String line ) { LOG . error ( " Received error line from subprocess [ " + line + " ] for shard " + getShardId ( ) ) ; System . err . println ( line ) ; return new HandleLineResult < Boolean > ( ) ; }
protected Boolean returnAfterException ( Exception e ) { return false ; }
protected Boolean returnAfterEndOfInput ( ) { return true ; }
public LineReaderTask < Boolean > initialize ( BufferedReader reader , String shardId ) { return initialize ( reader , shardId , " Draining STDERR for " + shardId ) ; }
protected HandleLineResult < Boolean > handleLine ( String line ) { LOG . info ( " Drained line for shard " + getShardId ( ) + " : " + line ) ; return new HandleLineResult < Boolean > ( ) ; }
protected Boolean returnAfterException ( Exception e ) { LOG . info ( " Encountered exception while draining STDOUT of child process for shard " + getShardId ( ) , e ) ; return false ; }
public LineReaderTask < Boolean > initialize ( BufferedReader reader , String shardId ) { return initialize ( reader , shardId , " Draining STDOUT for " + shardId ) ; }
static boolean isEmptyLine ( String line ) { return EMPTY_LINE . equals ( line ) ; }
protected HandleLineResult < Message > handleLine ( String line ) { try { /* * If the line is an empty line we don't bother logging anything because we expect the child process to be * nesting its messages between new lines, e.g. "\n<JSON message>\n". If there are no other entities writing * to the child process's STDOUT then this behavior will result in patterns like * "...\n<JSON message>\n\n<JSON message>\n..." which contains empty lines. */ if ( ! isEmptyLine ( line ) ) { return new HandleLineResult < Message > ( objectMapper . readValue ( line , Message . class ) ) ; } } catch ( IOException e ) { LOG . info ( " Skipping unexpected line on STDOUT for shard " + getShardId ( ) + " : " + line ) ; } return new HandleLineResult < Message > ( ) ; }
protected Message returnAfterException ( Exception e ) { throw new RuntimeException ( " Encountered an error while reading a line from STDIN for shard " + getShardId ( ) + " so won't be able to return a message. " , e ) ;
protected Message returnAfterEndOfInput ( ) { throw new RuntimeException ( " Reached end of STDIN of child process for shard " + getShardId ( ) + " so won't be able to return a message. " ) ;
public LineReaderTask < Message > initialize ( BufferedReader reader , String shardId ) { return initialize ( reader , shardId , " Reading next message from STDIN for " + shardId ) ; }
public T call ( ) throws Exception { String nextLine = null ; try { LOG . info ( " Starting: " + description ) ; while ( ( nextLine = reader . readLine ( ) ) ! = null ) { HandleLineResult < T > result = handleLine ( nextLine ) ; if ( result . hasReturnValue ( ) ) { return result . returnValue ( ) ; } } } catch ( IOException e ) { return returnAfterException ( e ) ; } LOG . info ( " Stopping: " + description ) ; return returnAfterEndOfInput ( ) ; }
protected abstract T returnAfterEndOfInput ( ) ; /** * Allows subclasses to provide more detailed logs. Specifically, this allows the drain tasks and GetNextMessageTask * to log which shard they're working on. * * @return The shard id */ public String getShardId ( ) { return this . shardId ; } /** * The description should be a string explaining what this particular LineReader class does. * * @return The description. */ public String getDescription ( ) { return this . description ; } /** * The result of a call to {@link LineReaderTask#handleLine(String)}. Allows implementations of that method to * indicate whether a particular invocation of that method produced a return for this task or not. If a return value * doesn't exist the {@link #call()} method will continue to the next line. * * @param <V> */ protected class HandleLineResult < V > { private boolean hasReturnValue ; private V returnValue ; HandleLineResult ( ) { this . hasReturnValue = false ; } HandleLineResult ( V returnValue ) { this . hasReturnValue = true ; this . returnValue = returnValue ; } boolean hasReturnValue ( ) { return this . hasReturnValue ; } V returnValue ( ) { if ( hasReturnValue ( ) ) { return this . returnValue ; } else { throw new RuntimeException ( " There was no value to return. " ) ; } } } /** * An initialization method allows us to delay setting the attributes of this class. Some of the attributes, stream * and shardId, are not known to the {@link MultiLangRecordProcessorFactory} when it constructs a * {@link MultiLangRecordProcessor} but are later determined when * {@link MultiLangRecordProcessor#initialize(String)} is called. So we follow a pattern where the attributes are * set inside this method instead of the constructor so that this object will be initialized when all its attributes * are known to the record processor. * * @param stream * @param shardId * @param description * @return */ protected LineReaderTask < T > initialize ( InputStream stream , String shardId , String description ) { return this . initialize ( new BufferedReader ( new InputStreamReader ( stream ) ) , shardId , description ) ; } /** * @param reader * @param shardId * @param description * @return */ protected LineReaderTask < T > initialize ( BufferedReader reader , String shardId , String description ) { this . reader = reader ; this . shardId = shardId ; this . description = description ; return this ; } }
public String getShardId ( ) { return this . shardId ; }
public String getDescription ( ) { return this . description ; }
boolean hasReturnValue ( ) { return this . hasReturnValue ; }
V returnValue ( ) { if ( hasReturnValue ( ) ) { return this . returnValue ;
protected LineReaderTask < T > initialize ( InputStream stream , String shardId , String description ) { return this . initialize ( new BufferedReader ( new InputStreamReader ( stream ) ) , shardId , description ) ; }
protected LineReaderTask < T > initialize ( BufferedReader reader , String shardId , String description ) { this . reader = reader ; this . shardId = shardId ; this . description = description ; return this ; }
Future < Message > getNextMessageFromSTDOUT ( ) { GetNextMessageTask getNextMessageTask = new GetNextMessageTask ( objectMapper ) ; getNextMessageTask . initialize ( reader , shardId ) ; return executorService . submit ( getNextMessageTask ) ; }
Future < Boolean > drainSTDOUT ( ) { DrainChildSTDOUTTask drainTask = new DrainChildSTDOUTTask ( ) ; drainTask . initialize ( reader , shardId ) ; return this . executorService . submit ( drainTask ) ; }
MessageReader initialize ( InputStream stream , String shardId , ObjectMapper objectMapper , ExecutorService executorService ) { return this . initialize ( new BufferedReader ( new InputStreamReader ( stream ) ) , shardId , objectMapper , executorService ) ;
MessageReader initialize ( BufferedReader reader , String shardId , ObjectMapper objectMapper , ExecutorService executorService ) { this . reader = reader ; this . shardId = shardId ; this . objectMapper = objectMapper ; this . executorService = executorService ; return this ; }
private Future < Boolean > writeMessageToOutput ( final String message ) throws IOException { Callable < Boolean > writeMessageToOutputTask = new Callable < Boolean > ( ) { public Boolean call ( ) throws Exception { try { /* * If the message size exceeds the size of the buffer, the write won't be guaranteed to be atomic, * so we synchronize on the writer to avoid interlaced lines from different calls to this method. */ synchronized ( writer ) { writer . write ( message , 0 , message . length ( ) ) ; writer . write ( System . lineSeparator ( ) , 0 , System . lineSeparator ( ) . length ( ) ) ; writer . flush ( ) ; } LOG . info ( " Message size == " + message . getBytes ( ) . length + " bytes for shard " + shardId ) ; } catch ( IOException e ) { open = false ; } return open ; } } ; if ( open ) { return this . executorService . submit ( writeMessageToOutputTask ) ;
public Boolean call ( ) throws Exception { try { /* * If the message size exceeds the size of the buffer, the write won't be guaranteed to be atomic, * so we synchronize on the writer to avoid interlaced lines from different calls to this method. */ synchronized ( writer ) { writer . write ( message , 0 , message . length ( ) ) ; writer . write ( System . lineSeparator ( ) , 0 , System . lineSeparator ( ) . length ( ) ) ; writer . flush ( ) ; } LOG . info ( " Message size == " + message . getBytes ( ) . length + " bytes for shard " + shardId ) ; } catch ( IOException e ) { open = false ; } return open ; }
private Future < Boolean > writeMessage ( Message message ) { LOG . info ( " Writing " + message . getClass ( ) . getSimpleName ( ) + " to child process for shard " + shardId ) ; try { String jsonText = objectMapper . writeValueAsString ( message ) ;
Future < Boolean > writeInitializeMessage ( String shardIdToWrite ) { return writeMessage ( new InitializeMessage ( shardIdToWrite ) ) ; }
Future < Boolean > writeProcessRecordsMessage ( List < Record > records ) { return writeMessage ( new ProcessRecordsMessage ( records ) ) ; }
Future < Boolean > writeShutdownMessage ( ShutdownReason reason ) { return writeMessage ( new ShutdownMessage ( reason ) ) ; }
Future < Boolean > writeCheckpointMessageWithError ( String sequenceNumber , Throwable throwable ) { return writeMessage ( new CheckpointMessage ( sequenceNumber , throwable ) ) ; }
void close ( ) throws IOException { open = false ; this . writer . close ( ) ; }
MessageWriter initialize ( OutputStream stream , String shardId , ObjectMapper objectMapper , ExecutorService executorService ) { return this . initialize ( new BufferedWriter ( new OutputStreamWriter ( stream ) ) , shardId , objectMapper , executorService ) ;
MessageWriter initialize ( BufferedWriter writer , String shardId , ObjectMapper objectMapper , ExecutorService executorService ) { this . writer = writer ; this . shardId = shardId ; this . objectMapper = objectMapper ; this . executorService = executorService ; return this ; }
static void printUsage ( PrintStream stream , String message ) { StringBuilder builder = new StringBuilder ( ) ; if ( message ! = null ) { builder . append ( message ) ; } builder . append ( String . format ( " java %s <properties file> " , MultiLangDaemon . class . getCanonicalName ( ) ) ) ; stream . println ( builder . toString ( ) ) ; }
static Properties loadProperties ( ClassLoader classLoader , String propertiesFileName ) throws IOException { Properties properties = new Properties ( ) ; try ( InputStream propertiesStream = classLoader . getResourceAsStream ( propertiesFileName ) ) { properties . load ( propertiesStream ) ;
static boolean validateProperties ( Properties properties ) { return properties ! = null & & properties . getProperty ( PROP_EXECUTABLE_NAME ) ! = null ; }
void prepare ( ) { // Ensure the JVM will refresh the cached IP values of AWS resources (e.g. service endpoints). java.security.Security.setProperty("networkaddress.cache.ttl", "60"); LOG.info("Using workerId: " + configuration.getWorkerIdentifier()); LOG.info("Using credentials with access key id: " + configuration.getKinesisCredentialsProvider().getCredentials().getAWSAccessKeyId()); StringBuilder userAgent = new StringBuilder(KinesisClientLibConfiguration.KINESIS_CLIENT_LIB_USER_AGENT); userAgent.append(" "); userAgent.append(USER_AGENT); userAgent.append("/"); userAgent.append(VERSION); if (processingLanguage != null) { userAgent.append(" "); userAgent.append(processingLanguage); } if (recordProcessorFactory.getCommandArray().length > 0) { userAgent.append(" "); userAgent.append(recordProcessorFactory.getCommandArray()[0]); } LOG.debug(String.format("User Agent string is: %s", userAgent.toString())); configuration.withUserAgent(userAgent.toString()); }
public Integer call ( ) throws Exception { prepare ( ) ; Worker worker = new Worker ( recordProcessorFactory , configuration , workerThreadPool ) ; int exitCode = 0 ; try { worker . run ( ) ; } catch ( Throwable t ) { LOG . error ( " Caught throwable while processing data. " , t ) ; exitCode = 1 ; } return exitCode ; }
private static int getMaxActiveThreads ( Properties properties ) { return Integer . parseInt ( properties . getProperty ( PROP_MAX_ACTIVE_THREADS , " 0 " ) ) ; }
private static ExecutorService getExecutorService ( Properties properties ) { int maxActiveThreads = getMaxActiveThreads ( properties ) ; LOG . debug ( String . format ( " Value for %s property is %d " , PROP_MAX_ACTIVE_THREADS , maxActiveThreads ) ) ; if ( maxActiveThreads < = 0 ) { LOG . info ( " Using a cached thread pool. " ) ;
public static void main ( String [ ] args ) { if ( args . length = = 0 ) { printUsage ( System . err , " You must provide a properties file " ) ; System . exit ( 1 ) ; } Properties properties = null ; try { properties = loadProperties ( Thread . currentThread ( ) . getContextClassLoader ( ) , args [ 0 ] ) ; } catch ( IOException e ) { printUsage ( System . err , " You must provide a properties file " ) ; System . exit ( 1 ) ; } if ( validateProperties ( properties ) ) { // Configuration KinesisClientLibConfiguration kinesisClientLibConfiguration = new KinesisClientLibConfigurator().getConfiguration(properties); String executableName = properties.getProperty(PROP_EXECUTABLE_NAME); ExecutorService executorService = getExecutorService(properties); // Factory MultiLangRecordProcessorFactory recordProcessorFactory = new MultiLangRecordProcessorFactory(executableName, executorService); // Daemon MultiLangDaemon daemon = new MultiLangDaemon(properties.getProperty(PROP_PROCESSING_LANGUAGE), kinesisClientLibConfiguration, recordProcessorFactory, executorService); LOG.info("Running " + kinesisClientLibConfiguration.getApplicationName() + " to process stream " + kinesisClientLibConfiguration.getStreamName() + " with executable " + executableName); Future<Integer> future = executorService.submit(daemon); try { System.exit(future.get()); } catch (InterruptedException | ExecutionException e) { LOG.error("Encountered an error while running daemon", e); } } else { printUsage(System.err, "Must provide an executable name in the properties file, " + "e.g. executableName = sampleapp.py"); } System.exit(1); }
boolean initialize ( ) { /* * Call and response to child process. */ Future < Boolean > writeFuture = messageWriter . writeInitializeMessage ( shardId ) ; return waitForStatusMessage ( InitializeMessage . ACTION , null , writeFuture ) ;
boolean processRecords ( List < Record > records , IRecordProcessorCheckpointer checkpointer ) { Future < Boolean > writeFuture = messageWriter . writeProcessRecordsMessage ( records ) ; return waitForStatusMessage ( ProcessRecordsMessage . ACTION , checkpointer , writeFuture ) ; }
boolean shutdown ( IRecordProcessorCheckpointer checkpointer , ShutdownReason reason ) { Future < Boolean > writeFuture = messageWriter . writeShutdownMessage ( reason ) ; return waitForStatusMessage ( ShutdownMessage . ACTION , checkpointer , writeFuture ) ; }
private boolean waitForStatusMessage ( String action , IRecordProcessorCheckpointer checkpointer , Future < Boolean > writeFuture ) { boolean statusWasCorrect = waitForStatusMessage ( action , checkpointer ) ; // Examine whether or not we failed somewhere along the line. try { boolean writerIsStillOpen = Boolean.valueOf(writeFuture.get());
private boolean waitForStatusMessage ( String action , IRecordProcessorCheckpointer checkpointer ) { StatusMessage statusMessage = null ; while ( statusMessage = = null ) { Future < Message > future = this . messageReader . getNextMessageFromSTDOUT ( ) ; try { Message message = future . get ( ) ; // Note that instanceof doubles as a check against a value being null if (message instanceof CheckpointMessage) { boolean checkpointWriteSucceeded = Boolean.valueOf(checkpoint((CheckpointMessage) message, checkpointer).get()); if (!checkpointWriteSucceeded) { return false; } } else if (message instanceof StatusMessage) { statusMessage = (StatusMessage) message; } } catch (InterruptedException e) { LOG.error(String.format("Interrupted while waiting for %s message for shard %s", action, shardId)); return false; } catch (ExecutionException e) { LOG.error(String.format("Failed to get status message for %s action for shard %s", action, shardId), e); return false; } } return this.validateStatusMessage(statusMessage, action); }
private boolean validateStatusMessage ( StatusMessage statusMessage , String action ) { LOG . info ( " Received response " + statusMessage + " from subprocess while waiting for " + action + " while processing shard " + shardId ) ; return ! ( statusMessage = = null | | statusMessage . getResponseFor ( ) = = null | | ! statusMessage . getResponseFor ( ) . equals ( action ) ) ;
private Future < Boolean > checkpoint ( CheckpointMessage checkpointMessage , IRecordProcessorCheckpointer checkpointer ) { String sequenceNumber = checkpointMessage . getCheckpoint ( ) ; try { if ( checkpointer ! = null ) {
public void initialize ( String shardIdToProcess ) { try { this . shardId = shardIdToProcess ;
public void processRecords ( List < Record > records , IRecordProcessorCheckpointer checkpointer ) { try { if ( ! protocol . processRecords ( records , checkpointer ) ) {
public void shutdown ( IRecordProcessorCheckpointer checkpointer , ShutdownReason reason ) { try { if ( ProcessState . ACTIVE . equals ( this . state ) ) {
private void childProcessShutdownSequence ( ) { try { /* * Close output stream to the child process. The child process should be reading off its stdin until it * receives EOF, closing the output stream should signal this and allow the child process to terminate. We * expect it to terminate immediately, but there is the possibility that the child process then begins to * write to its STDOUT and STDERR. */ if ( messageWriter . isOpen ( ) ) { messageWriter . close ( ) ; } } catch ( IOException e ) { LOG . error ( " Encountered exception while trying to close output stream. " , e ) ; } // We should drain the STDOUT and STDERR of the child process. If we don't, the child process might remain // blocked writing to a full pipe buffer. safelyWaitOnFuture(messageReader.drainSTDOUT(), "draining STDOUT"); safelyWaitOnFuture(stderrReadTask, "draining STDERR"); safelyCloseInputStream(process.getErrorStream(), "STDERR"); safelyCloseInputStream(process.getInputStream(), "STDOUT"); /* * By this point the threads handling reading off input streams are done, we do one last thing just to make sure * we don't leave the child process running. The process is expected to have exited by now, but we still make * sure that it exits before we finish. */ try { LOG.info("Child process exited with value: " + process.waitFor()); } catch (InterruptedException e) { LOG.error("Interrupted before process finished exiting. Attempting to kill process."); process.destroy(); } state = ProcessState.SHUTDOWN; }
private void safelyCloseInputStream ( InputStream inputStream , String name ) { try { inputStream . close ( ) ;
private void safelyWaitOnFuture ( Future < ? > future , String whatThisFutureIsDoing ) { try { future . get ( ) ;
private void stopProcessing ( String message , Throwable reason ) { try { LOG . error ( message , reason ) ; if ( ! state . equals ( ProcessState . SHUTDOWN ) ) { childProcessShutdownSequence ( ) ; } } catch ( Throwable t ) { LOG . error ( " Encountered error while trying to shutdown " , t ) ; } exit ( ) ; }
Process startProcess ( ) throws IOException { return this . processBuilder . start ( ) ; }
public IRecordProcessor createProcessor ( ) { LOG . debug ( String . format ( " Creating new record processor for client executable: %s " , command ) ) ; /* * Giving ProcessBuilder the command as an array of Strings allows users to specify command line arguments. */ return new MultiLangRecordProcessor ( new ProcessBuilder ( commandArray ) , executorService , this . objectMapper ) ; }
String [ ] getCommandArray ( ) { return commandArray ; }
public void setCheckpoint ( String checkpoint ) { this . checkpoint = checkpoint ; }
public void setError ( String error ) { this . error = error ; }
public String getShardId ( ) { return shardId ; }
public void setShardId ( String shardId ) { this . shardId = shardId ; }
public String getPartitionKey ( ) { return partitionKey ; }
public String getSequenceNumber ( ) { return sequenceNumber ; }
public void setData ( byte [ ] data ) { this . data = data ; }
public void setPartitionKey ( String partitionKey ) { this . partitionKey = partitionKey ; }
public void setSequenceNumber ( String sequenceNumber ) { this . sequenceNumber = sequenceNumber ; }
public JsonFriendlyRecord withData ( byte [ ] data ) { this . setData ( data ) ; return this ; }
public JsonFriendlyRecord withPartitionKey ( String partitionKey ) { this . setPartitionKey ( partitionKey ) ; return this ; }
public JsonFriendlyRecord withSequenceNumber ( String sequenceNumber ) { this . setSequenceNumber ( sequenceNumber ) ; return this ; }
Message withObjectMapper ( ObjectMapper objectMapper ) { this . mapper = objectMapper ; return this ; }
public String toString ( ) { try { return mapper . writeValueAsString ( this ) ;
public List < JsonFriendlyRecord > getRecords ( ) { return records ; }
public void setRecords ( List < JsonFriendlyRecord > records ) { this . records = records ; }
public String getReason ( ) { return reason ; }
public void setReason ( String reason ) { this . reason = reason ; }
public String getResponseFor ( ) { return responseFor ; }
public void setResponseFor ( String responseFor ) { this . responseFor = responseFor ; }
public synchronized void checkpoint ( ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Checkpointing " + shardInfo . getShardId ( ) + " , " + " token " + shardInfo . getConcurrencyToken ( ) + " at largest permitted value " + this . largestPermittedCheckpointValue ) ; } advancePosition ( this . largestPermittedCheckpointValue ) ; }
public synchronized void checkpoint ( String sequenceNumber ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException , IllegalArgumentException { // throws exception if sequence number shouldn't be checkpointed for this shard sequenceNumberValidator.validateSequenceNumber(sequenceNumber); if (LOG.isDebugEnabled()) { LOG.debug("Validated checkpoint sequence number " + sequenceNumber + " for " + shardInfo.getShardId() + ", token " + shardInfo.getConcurrencyToken()); } /* * If there isn't a last checkpoint value, we only care about checking the upper bound. * If there is a last checkpoint value, we want to check both the lower and upper bound. */ if ((checkpointValueComparator.compare(lastCheckpointValue, sequenceNumber) <= 0) && checkpointValueComparator.compare(sequenceNumber, largestPermittedCheckpointValue) <= 0) {
public void stop ( ) { if ( threadpool ! = null ) { threadpool . shutdown ( ) ; try { if ( threadpool . awaitTermination ( STOP_WAIT_TIME_MILLIS , TimeUnit . MILLISECONDS ) ) { LOG . info ( String . format ( " Worker %s has successfully stopped lease-tracking threads " , leaseTaker . getWorkerIdentifier ( ) ) ) ; } else { threadpool . shutdownNow ( ) ; LOG . info ( String . format ( " Worker %s stopped lease-tracking threads %dms after stop " , leaseTaker . getWorkerIdentifier ( ) , STOP_WAIT_TIME_MILLIS ) ) ; } } catch ( InterruptedException e ) { LOG . debug ( " Encountered InterruptedException when awaiting threadpool termination " ) ; } } else { LOG . debug ( " Threadpool was null, no need to shutdown/terminate threadpool. " ) ; } leaseRenewer . clearCurrentlyHeldLeases ( ) ; running = false ; }
public Map < String , ExpectedAttributeValue > getDynamoLeaseOwnerExpectation ( Lease lease ) { Map < String , ExpectedAttributeValue > result = new HashMap < String , ExpectedAttributeValue > ( ) ; ExpectedAttributeValue eav = null ; if ( lease . getLeaseOwner ( ) = = null ) { eav = new ExpectedAttributeValue ( false ) ; } else { eav = new ExpectedAttributeValue ( DynamoUtils . createAttributeValue ( lease . getLeaseOwner ( ) ) ) ; } result . put ( LEASE_OWNER_KEY , eav ) ; return result ; }
protected long getTime ( ) { return System . currentTimeMillis ( ) ; }
public static void printUsage ( PrintStream stream , String messageToPrepend ) { StringBuilder builder = new StringBuilder ( ) ; if ( messageToPrepend ! = null ) { builder . append ( messageToPrepend ) ; } builder . append ( String . format ( " java %s <properties file> " , MultiLangDaemon . class . getCanonicalName ( ) ) ) ; stream . println ( builder . toString ( ) ) ; }
public Integer call ( ) throws Exception { int exitCode = 0 ; try { worker . run ( ) ; } catch ( Throwable t ) { LOG . error ( " Caught throwable while processing data. " , t ) ; exitCode = 1 ; } return exitCode ; }
public static void main ( String [ ] args ) { if ( args . length = = 0 ) { printUsage ( System . err , " You must provide a properties file " ) ; System . exit ( 1 ) ; } MultiLangDaemonConfig config = null ; try { config = new MultiLangDaemonConfig ( args [ 0 ] ) ; } catch ( IOException e ) { printUsage ( System . err , " You must provide a properties file " ) ; System . exit ( 1 ) ; } catch ( IllegalArgumentException e ) { printUsage ( System . err , e . getMessage ( ) ) ; System . exit ( 1 ) ; } ExecutorService executorService = config . getExecutorService ( ) ; // Daemon MultiLangDaemon daemon = new MultiLangDaemon( config.getKinesisClientLibConfiguration(), config.getRecordProcessorFactory(), executorService); Future<Integer> future = executorService.submit(daemon); try { System.exit(future.get()); } catch (InterruptedException | ExecutionException e) { LOG.error("Encountered an error while running daemon", e); } System.exit(1); }
private void prepare ( String processingLanguage ) { // Ensure the JVM will refresh the cached IP values of AWS resources (e.g. service endpoints). java.security.Security.setProperty("networkaddress.cache.ttl", "60"); LOG.info("Using workerId: " + kinesisClientLibConfig.getWorkerIdentifier()); LOG.info("Using credentials with access key id: " + kinesisClientLibConfig.getKinesisCredentialsProvider().getCredentials().getAWSAccessKeyId()); StringBuilder userAgent = new StringBuilder(KinesisClientLibConfiguration.KINESIS_CLIENT_LIB_USER_AGENT); userAgent.append(" "); userAgent.append(USER_AGENT); userAgent.append("/"); userAgent.append(VERSION); if (processingLanguage != null) { userAgent.append(" "); userAgent.append(processingLanguage); } if (recordProcessorFactory.getCommandArray().length > 0) { userAgent.append(" "); userAgent.append(recordProcessorFactory.getCommandArray()[0]); } LOG.info(String.format("MultiLangDaemon is adding the following fields to the User Agent: %s", userAgent.toString())); kinesisClientLibConfig.withUserAgent(userAgent.toString()); }
private static Properties loadProperties ( ClassLoader classLoader , String propertiesFileName ) throws IOException { Properties properties = new Properties ( ) ; try ( InputStream propertiesStream = classLoader . getResourceAsStream ( propertiesFileName ) ) { properties . load ( propertiesStream ) ;
private static boolean validateProperties ( Properties properties ) { return properties ! = null & & properties . getProperty ( PROP_EXECUTABLE_NAME ) ! = null ; }
private static ExecutorService buildExecutorService ( Properties properties ) { int maxActiveThreads = getMaxActiveThreads ( properties ) ; LOG . debug ( String . format ( " Value for %s property is %d " , PROP_MAX_ACTIVE_THREADS , maxActiveThreads ) ) ; if ( maxActiveThreads < = 0 ) { LOG . info ( " Using a cached thread pool. " ) ;
public KinesisClientLibConfiguration getKinesisClientLibConfiguration ( ) { return kinesisClientLibConfig ; }
public ExecutorService getExecutorService ( ) { return executorService ; }
public MultiLangRecordProcessorFactory getRecordProcessorFactory ( ) { return recordProcessorFactory ; }
public GetRecordsResult getRecords ( int maxRecords ) { if ( ! isInitialized ) { throw new IllegalArgumentException ( " KinesisDataFetcher.getRecords called before initialization. " ) ; } GetRecordsResult response = null ; if ( nextIterator ! = null ) { try { response = kinesisProxy . get ( nextIterator , maxRecords ) ; nextIterator = response . getNextShardIterator ( ) ; } catch ( ResourceNotFoundException e ) { LOG . info ( " Caught ResourceNotFoundException when fetching records for shard " + shardId ) ; nextIterator = null ; } if ( nextIterator = = null ) { isShardEndReached = true ; } } else { isShardEndReached = true ; } return response ; }
private GetRecordsResult getRecords ( ) throws KinesisClientLibException { int maxRecords = streamConfig . getMaxRecords ( ) ; try { return dataFetcher . getRecords ( maxRecords ) ;
public < T extends Lease > void update ( T other ) { super . update ( other ) ; if ( ! ( other instanceof KinesisClientLease ) ) { throw new IllegalArgumentException ( " Must pass KinesisClientLease object to KinesisClientLease.update(Lease) " ) ; } KinesisClientLease casted = ( KinesisClientLease ) other ; setOwnerSwitchesSinceCheckpoint ( casted . ownerSwitchesSinceCheckpoint ) ; setCheckpoint ( casted . checkpoint ) ; setParentShardIds ( casted . parentShardIds ) ; }
public Map < String , AttributeValueUpdate > getDynamoTakeLeaseUpdate ( KinesisClientLease lease , String newOwner ) { Map < String , AttributeValueUpdate > result = baseSerializer . getDynamoTakeLeaseUpdate ( lease , newOwner ) ; String oldOwner = lease . getLeaseOwner ( ) ; if ( oldOwner ! = null & & ! oldOwner . equals ( newOwner ) ) { result . put ( OWNER_SWITCHES_KEY , new AttributeValueUpdate ( DynamoUtils . createAttributeValue ( 1L ) , AttributeAction . ADD ) ) ; } return result ; }
public boolean waitUntilLeaseTableExists ( long secondsBetweenPolls , long timeoutSeconds ) throws DependencyException { long sleepTimeRemaining = TimeUnit . SECONDS . toMillis ( timeoutSeconds ) ; while ( ! leaseTableExists ( ) ) { if ( sleepTimeRemaining < = 0 ) { return false ; } long timeToSleepMillis = Math . min ( TimeUnit . SECONDS . toMillis ( secondsBetweenPolls ) , sleepTimeRemaining ) ; sleepTimeRemaining - = sleep ( timeToSleepMillis ) ; } return true ; }
public boolean takeLease ( T lease , String owner ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { verifyNotNull ( lease , " lease cannot be null " ) ; verifyNotNull ( owner , " owner cannot be null " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( " Taking lease with leaseKey %s from %s to %s " , lease . getLeaseKey ( ) , lease . getLeaseOwner ( ) = = null ? " nobody " : lease . getLeaseOwner ( ) , owner ) ) ; } UpdateItemRequest request = new UpdateItemRequest ( ) ; request . setTableName ( table ) ; request . setKey ( serializer . getDynamoHashKey ( lease ) ) ; request . setExpected ( serializer . getDynamoLeaseCounterExpectation ( lease ) ) ; Map < String , AttributeValueUpdate > updates = serializer . getDynamoLeaseCounterUpdate ( lease ) ; updates . putAll ( serializer . getDynamoTakeLeaseUpdate ( lease , owner ) ) ; request . setAttributeUpdates ( updates ) ; try { dynamoDBClient . updateItem ( request ) ; } catch ( ConditionalCheckFailedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Lease renewal failed for lease with key " + lease . getLeaseKey ( ) + " because the lease counter was not " + lease . getLeaseCounter ( ) ) ; } return false ; } catch ( AmazonClientException e ) { throw convertAndRethrowExceptions ( " take " , lease . getLeaseKey ( ) , e ) ; } lease . setLeaseCounter ( lease . getLeaseCounter ( ) + 1 ) ; lease . setLeaseOwner ( owner ) ; return true ; }
public boolean evictLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { verifyNotNull ( lease , " lease cannot be null " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( " Evicting lease with leaseKey %s owned by %s " , lease . getLeaseKey ( ) , lease . getLeaseOwner ( ) ) ) ; } UpdateItemRequest request = new UpdateItemRequest ( ) ; request . setTableName ( table ) ; request . setKey ( serializer . getDynamoHashKey ( lease ) ) ; request . setExpected ( serializer . getDynamoLeaseOwnerExpectation ( lease ) ) ; Map < String , AttributeValueUpdate > updates = serializer . getDynamoLeaseCounterUpdate ( lease ) ; updates . putAll ( serializer . getDynamoEvictLeaseUpdate ( lease ) ) ; request . setAttributeUpdates ( updates ) ; try { dynamoDBClient . updateItem ( request ) ; } catch ( ConditionalCheckFailedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Lease eviction failed for lease with key " + lease . getLeaseKey ( ) + " because the lease owner was not " + lease . getLeaseOwner ( ) ) ; } return false ; } catch ( AmazonClientException e ) { throw convertAndRethrowExceptions ( " evict " , lease . getLeaseKey ( ) , e ) ; } lease . setLeaseOwner ( null ) ; lease . setLeaseCounter ( lease . getLeaseCounter ( ) + 1 ) ; return true ; }
public void deleteLease ( T lease ) throws DependencyException , InvalidStateException , ProvisionedThroughputException { verifyNotNull ( lease , " lease cannot be null " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( " Deleting lease with leaseKey %s " , lease . getLeaseKey ( ) ) ) ; } DeleteItemRequest deleteRequest = new DeleteItemRequest ( ) ; deleteRequest . setTableName ( table ) ; deleteRequest . setKey ( serializer . getDynamoHashKey ( lease ) ) ; try { dynamoDBClient . deleteItem ( deleteRequest ) ;
public static void addSuccessAndLatencyPerShard ( String shardId , String prefix , long startTimeMillis , boolean success ) { IMetricsScope scope = getMetricsScope ( ) ; String realPrefix = prefix = = null ? " " : prefix + SEP ; if ( shardId ! = null ) { scope . addDimension ( " ShardId " , shardId ) ; } scope . addData ( realPrefix + MetricsHelper . SUCCESS , success ? 1 : 0 , StandardUnit . Count ) ; scope . addData ( realPrefix + MetricsHelper . TIME , System . currentTimeMillis ( ) - startTimeMillis ,
public static void endScope ( ) { IMetricsScope scope = getMetricsScope ( ) ; if ( scope ! = null ) { referenceCount . set ( referenceCount . get ( ) - 1 ) ;
void setCheckpoint ( String shardId , ExtendedSequenceNumber checkpointValue , String concurrencyToken ) throws KinesisClientLibException ; /** * Get the current checkpoint stored for the specified shard. Useful for checking that the parent shard * has been completely processed before we start processing the child shard. * * @param shardId Current checkpoint for this shard is fetched * @return Current checkpoint for this shard, null if there is no record for this shard. * @throws KinesisClientLibException Thrown if we are unable to fetch the checkpoint */ ExtendedSequenceNumber getCheckpoint ( String shardId ) throws KinesisClientLibException ; }
ExtendedSequenceNumber getCheckpoint ( String shardId ) throws KinesisClientLibException ; }
void checkpoint ( String sequenceNumber ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException , IllegalArgumentException ; /** * This method will checkpoint the progress at the provided sequenceNumber and subSequenceNumber, the latter for * aggregated records produced with the Producer Library. This method is analogous to {@link #checkpoint()} * but provides the ability to specify the sequence and subsequence numbers at which to checkpoint. * * @param sequenceNumber A sequence number at which to checkpoint in this shard. Upon failover, the Kinesis * Client Library will start fetching records after the given sequence and subsequence numbers. * @param subSequenceNumber A subsequence number at which to checkpoint within this shard. Upon failover, the * Kinesis Client Library will start fetching records after the given sequence and subsequence numbers. * @throws ThrottlingException Can't store checkpoint. Can be caused by checkpointing too frequently. * Consider increasing the throughput/capacity of the checkpoint store or reducing checkpoint frequency. * @throws ShutdownException The record processor instance has been shutdown. Another instance may have * started processing some of these records already. * The application should abort processing via this RecordProcessor instance. * @throws InvalidStateException Can't store checkpoint. * Unable to store the checkpoint in the DynamoDB table (e.g. table doesn't exist). * @throws KinesisClientLibDependencyException Encountered an issue when storing the checkpoint. The application can * backoff and retry. * @throws IllegalArgumentException The sequence number is invalid for one of the following reasons: * 1.) It appears to be out of range, i.e. it is smaller than the last check point value, or larger than the * greatest sequence number seen by the associated record processor. * 2.) It is not a valid sequence number for a record in this shard. */ void checkpoint ( String sequenceNumber , long subSequenceNumber ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException , IllegalArgumentException ; }
void checkpoint ( String sequenceNumber , long subSequenceNumber ) throws KinesisClientLibDependencyException , InvalidStateException , ThrottlingException , ShutdownException , IllegalArgumentException ; }
void initialize ( InitializationInput initializationInput ) ; /** * Process data records. The Amazon Kinesis Client Library will invoke this method to deliver data records to the * application. * Upon fail over, the new instance will get records with sequence number > checkpoint position * for each partition key. * * @param processRecordsInput Provides the records to be processed as well as information and capabilities related * to them (eg checkpointing). */ void processRecords ( ProcessRecordsInput processRecordsInput ) ; /** * Invoked by the Amazon Kinesis Client Library to indicate it will no longer send data records to this * RecordProcessor instance. * * @param shutdownInput Provides information and capabilities (eg checkpointing) related to shutdown of this record * processor. */ void shutdown ( ShutdownInput shutdownInput ) ; }
void processRecords ( ProcessRecordsInput processRecordsInput ) ; /** * Invoked by the Amazon Kinesis Client Library to indicate it will no longer send data records to this * RecordProcessor instance. * * @param shutdownInput Provides information and capabilities (eg checkpointing) related to shutdown of this record * processor. */ void shutdown ( ShutdownInput shutdownInput ) ; }
public TaskResult call ( ) { Exception exception = null ; try { boolean blockedOnParentShard = false ; for ( String shardId : shardInfo . getParentShardIds ( ) ) { KinesisClientLease lease = leaseManager . getLease ( shardId ) ; if ( lease ! = null ) { ExtendedSequenceNumber checkpoint = lease . getCheckpoint ( ) ; if ( ( checkpoint = = null ) | | ( ! checkpoint . equals ( ExtendedSequenceNumber . SHARD_END ) ) ) { LOG . debug ( " Shard " + shardId + " is not yet done. Its current checkpoint is " + checkpoint ) ; blockedOnParentShard = true ; exception = new BlockedOnParentShardException ( " Parent shard not yet done " ) ; break ; } else { LOG . debug ( " Shard " + shardId + " has been completely processed. " ) ; } } else { LOG . info ( " No lease found for shard " + shardId + " . Not blocking on completion of this shard. " ) ; } } if ( ! blockedOnParentShard ) { LOG . info ( " No need to block on parents " + shardInfo . getParentShardIds ( ) + " of shard " + shardInfo . getShardId ( ) ) ; return new TaskResult ( null ) ; } } catch ( Exception e ) { LOG . error ( " Caught exception when checking for parent shard checkpoint " , e ) ; exception = e ; } try { Thread . sleep ( parentShardPollIntervalMillis ) ; } catch ( InterruptedException e ) { LOG . error ( " Sleep interrupted when waiting on parent shard(s) of " + shardInfo . getShardId ( ) , e ) ; } return new TaskResult ( exception ) ; }
public TaskResult call ( ) { boolean applicationException = false ; Exception exception = null ; try { LOG . debug ( " Initializing ShardId " + shardInfo . getShardId ( ) ) ; ExtendedSequenceNumber initialCheckpoint = checkpoint . getCheckpoint ( shardInfo . getShardId ( ) ) ; dataFetcher . initialize ( initialCheckpoint . getSequenceNumber ( ) ) ; recordProcessorCheckpointer . setLargestPermittedCheckpointValue ( initialCheckpoint ) ; recordProcessorCheckpointer . setInitialCheckpointValue ( initialCheckpoint ) ; try { LOG . debug ( " Calling the record processor initialize(). " ) ; final InitializationInput initializationInput = new InitializationInput ( ) . withShardId ( shardInfo . getShardId ( ) ) . withExtendedSequenceNumber ( initialCheckpoint ) ; recordProcessor . initialize ( initializationInput ) ; LOG . debug ( " Record processor initialize() completed. " ) ; } catch ( Exception e ) { applicationException = true ; throw e ; } return new TaskResult ( null ) ; } catch ( Exception e ) { if ( applicationException ) { LOG . error ( " Application initialize() threw exception: " , e ) ; } else { LOG . error ( " Caught exception: " , e ) ; } exception = e ; // backoff if we encounter an exception. try { Thread.sleep(this.backoffTimeMillis); } catch (InterruptedException ie) { LOG.debug("Interrupted sleep", ie); } } return new TaskResult(exception); }
public void init ( ServletConfig config ) throws ServletException { super . init ( config ) ; try { Connection connection = DBUtils . getConn ( ) ;
public void init ( FilterConfig config ) throws ServletException { } public void destroy ( ) { } /** * doFilter determines if user is an administrator or redirect to login page * * @param req task request * @param resp task response * @param chain filter chain * @throws ServletException * @throws IOException */ public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { boolean isAdmin = false ; //read auth token String authToken = CookieUtil.get((HttpServletRequest) req, "authToken"); //check if exists if (authToken != null && !authToken.trim().equals("")) { //decrypt auth token authToken = EncryptionUtil.decrypt(authToken); //check if valid admin auth token isAdmin = AdminDB.isAdmin(authToken); //check to see if user has timed out String timeStr = CookieUtil.get((HttpServletRequest) req, "timeout"); SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); try { if (timeStr != null && !timeStr.trim().equals("")) { Date cookieTimeout = sdf.parse(timeStr); Date currentTime = new Date(); //if current time > timeout then redirect to login page if (cookieTimeout == null || currentTime.after(cookieTimeout)) { isAdmin = false; } else { //set new timeout cookie for 15 min Calendar timeout = Calendar.getInstance(); timeout.add(Calendar.MINUTE, 15); CookieUtil.add((HttpServletResponse) resp, "timeout", sdf.format(timeout.getTime())); } } else { isAdmin = false; } } catch (Exception ex) { ex.printStackTrace(); isAdmin = false; } } //if not admin redirect to login page if (!isAdmin) { CookieUtil.deleteAll((HttpServletRequest) req, (HttpServletResponse) resp); ((HttpServletResponse) resp).sendRedirect(((HttpServletRequest) req).getContextPath() + "/login.action"); } chain.doFilter(req, resp); } }
public void destroy ( ) { } /** * doFilter determines if user is an administrator or redirect to login page * * @param req task request * @param resp task response * @param chain filter chain * @throws ServletException * @throws IOException */ public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { boolean isAdmin = false ; //read auth token String authToken = CookieUtil.get((HttpServletRequest) req, "authToken"); //check if exists if (authToken != null && !authToken.trim().equals("")) { //decrypt auth token authToken = EncryptionUtil.decrypt(authToken); //check if valid admin auth token isAdmin = AdminDB.isAdmin(authToken); //check to see if user has timed out String timeStr = CookieUtil.get((HttpServletRequest) req, "timeout"); SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); try { if (timeStr != null && !timeStr.trim().equals("")) { Date cookieTimeout = sdf.parse(timeStr); Date currentTime = new Date(); //if current time > timeout then redirect to login page if (cookieTimeout == null || currentTime.after(cookieTimeout)) { isAdmin = false; } else { //set new timeout cookie for 15 min Calendar timeout = Calendar.getInstance(); timeout.add(Calendar.MINUTE, 15); CookieUtil.add((HttpServletResponse) resp, "timeout", sdf.format(timeout.getTime())); } } else { isAdmin = false; } } catch (Exception ex) { ex.printStackTrace(); isAdmin = false; } } //if not admin redirect to login page if (!isAdmin) { CookieUtil.deleteAll((HttpServletRequest) req, (HttpServletResponse) resp); ((HttpServletResponse) resp).sendRedirect(((HttpServletRequest) req).getContextPath() + "/login.action"); } chain.doFilter(req, resp); } }
public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { boolean isAdmin = false ; //read auth token String authToken = CookieUtil.get((HttpServletRequest) req, "authToken"); //check if exists if (authToken != null && !authToken.trim().equals("")) { //decrypt auth token authToken = EncryptionUtil.decrypt(authToken); //check if valid admin auth token isAdmin = AdminDB.isAdmin(authToken); //check to see if user has timed out String timeStr = CookieUtil.get((HttpServletRequest) req, "timeout"); SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); try { if (timeStr != null && !timeStr.trim().equals("")) { Date cookieTimeout = sdf.parse(timeStr); Date currentTime = new Date(); //if current time > timeout then redirect to login page if (cookieTimeout == null || currentTime.after(cookieTimeout)) { isAdmin = false; } else { //set new timeout cookie for 15 min Calendar timeout = Calendar.getInstance(); timeout.add(Calendar.MINUTE, 15); CookieUtil.add((HttpServletResponse) resp, "timeout", sdf.format(timeout.getTime())); } } else { isAdmin = false; } } catch (Exception ex) { ex.printStackTrace(); isAdmin = false; } } //if not admin redirect to login page if (!isAdmin) { CookieUtil.deleteAll((HttpServletRequest) req, (HttpServletResponse) resp); ((HttpServletResponse) resp).sendRedirect(((HttpServletRequest) req).getContextPath() + "/login.action"); } chain.doFilter(req, resp); }
public static String getProperty ( String name ) { return prop . getString ( name ) ; }
public static String getProperty ( String name , Map < String , String > replacementMap ) { String value = prop . getString ( name ) ; //iterate through map to replace text Set<String> keySet = replacementMap.keySet(); for(String key :keySet){ //replace values in string String rVal=replacementMap.get(key); value=value.replace("${"+key+"}",rVal); } return value; }
public static Map < String , String > getMapProperties ( String name ) { String values = prop . getString ( name ) ; Map < String , String > map = new LinkedHashMap < String , String > ( ) ; for ( String set : values . split ( " ; " ) ) { String key = set . split ( " , " ) [ 0 ] ; String val = set . split ( " , " ) [ 1 ] ; map . put ( key , val ) ; } return map ; }
public String setAWSCred ( ) { awsCred = AWSCredDB . getAWSCred ( AdminUtil . getAdminId ( servletRequest ) ) ; return SUCCESS ;
public String submitAWSCred ( ) { AWSCredDB . setAWSCred ( AdminUtil . getAdminId ( servletRequest ) , awsCred ) ; return SUCCESS ;
public void validateSubmitAWSCred ( ) { if ( awsCred . getAccessKey ( ) = = null | | awsCred . getAccessKey ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " awsCred.accessKey " , " Required " ) ; } if ( awsCred . getSecretKey ( ) = = null | | awsCred . getSecretKey ( ) . trim ( ) . equals ( " " ) ) {
public AWSCred getAwsCred ( ) { return awsCred ; }
public void setAwsCred ( AWSCred awsCred ) { this . awsCred = awsCred ; }
public HttpServletRequest getServletRequest ( ) { return servletRequest ; }
public void setServletRequest ( HttpServletRequest servletRequest ) { this . servletRequest = servletRequest ; }
public String viewEC2Keys ( ) { Long adminId = AdminUtil . getAdminId ( servletRequest ) ; AWSCred awsCred = AWSCredDB . getAWSCred ( adminId ) ; //check to see if aws creds have been set if (awsCred != null) { sortedSet = EC2KeyDB.getEC2KeySet(adminId, sortedSet); } else { addActionMessage("EC2 Keys not available. Set AWS credentials <a href=\"setAWSCred.action\">here</a>"); } return SUCCESS;
public String getKeyPairJSON ( ) { Long adminId = AdminUtil . getAdminId ( servletRequest ) ; AWSCred awsCred = AWSCredDB . getAWSCred ( adminId ) ; //set AWS credentials for service BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.setEndpoint(ec2Key.getEc2Region()); DescribeKeyPairsRequest describeKeyPairsRequest = new DescribeKeyPairsRequest(); DescribeKeyPairsResult describeKeyPairsResult = service.describeKeyPairs(describeKeyPairsRequest); List<KeyPairInfo> keyPairInfoList = describeKeyPairsResult.getKeyPairs(); JSONArray json = (JSONArray) JSONSerializer.toJSON(keyPairInfoList); try { servletResponse.getOutputStream().write(json.toString().getBytes()); } catch (Exception ex) { ex.printStackTrace(); } return null; }
public String submitEC2Key ( ) { String retVal = SUCCESS ; Long adminId = AdminUtil . getAdminId ( servletRequest ) ; try { //get AWS credentials from DB AWSCred awsCred = AWSCredDB.getAWSCred(adminId); //set AWS credentials for service BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); //create service AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.setEndpoint(ec2Key.getEc2Region()); //create key pair request CreateKeyPairRequest createKeyPairRequest = new CreateKeyPairRequest(); createKeyPairRequest.withKeyName(ec2Key.getKeyNm()); //call service CreateKeyPairResult createKeyPairResult = service.createKeyPair(createKeyPairRequest); //get key pair result KeyPair keyPair = createKeyPairResult.getKeyPair(); //set private key String privateKey = keyPair.getKeyMaterial(); ec2Key.setPrivateKey(privateKey); //add to db Long keyId = EC2KeyDB.saveEC2Key(adminId, ec2Key); //store private key SSHUtil.storePrivateKey(keyId.toString(), ec2Key.getPrivateKey().trim()); } catch (AmazonServiceException ex) { addActionError(ex.getMessage()); retVal = INPUT; } return retVal;
public String importEC2Key ( ) { String retVal = SUCCESS ; Long adminId = AdminUtil . getAdminId ( servletRequest ) ; try { //get AWS credentials from DB AWSCred awsCred = AWSCredDB.getAWSCred(adminId); //set AWS credentials for service BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); //create service AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.setEndpoint(ec2Key.getEc2Region()); //describe key pair request DescribeKeyPairsRequest describeKeyPairsRequest = new DescribeKeyPairsRequest(); describeKeyPairsRequest.setKeyNames(Arrays.asList(ec2Key.getKeyNm())); //call service DescribeKeyPairsResult describeKeyPairsResult = service.describeKeyPairs(describeKeyPairsRequest); if (describeKeyPairsResult != null && describeKeyPairsResult.getKeyPairs().size() > 0) { //add to db Long keyId = EC2KeyDB.saveEC2Key(adminId, ec2Key); SSHUtil.storePrivateKey(keyId.toString(), ec2Key.getPrivateKey().trim()); } else { addActionError("Imported key does not exist on AWS"); retVal = INPUT; } } catch (AmazonServiceException ex) { addActionError(ex.getMessage()); retVal = INPUT; } return retVal;
public String deleteEC2Key ( ) { EC2KeyDB . deleteEC2Key ( ec2Key . getId ( ) ) ; SSHUtil . deletePrivateKey ( ec2Key . getId ( ) . toString ( ) ) ; return SUCCESS ;
public void validateImportEC2Key ( ) { if ( ec2Key . getEc2Region ( ) = = null | | ec2Key . getEc2Region ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " ec2Key.ec2Region " , " Required " ) ; } if ( ec2Key . getKeyNm ( ) = = null | | ec2Key . getKeyNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " ec2Key.keyNm " , " Required " ) ; } if ( ec2Key . getPrivateKey ( ) = = null | | ec2Key . getPrivateKey ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " ec2Key.privateKey " , " Required " ) ; } if ( hasErrors ( ) ) {
public void validateSubmitEC2Key ( ) { if ( ec2Key . getEc2Region ( ) = = null | | ec2Key . getEc2Region ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " ec2Key.ec2Region " , " Required " ) ; } if ( ec2Key . getKeyNm ( ) = = null | | ec2Key . getKeyNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " ec2Key.keyNm " , " Required " ) ; } if ( hasErrors ( ) ) {
public SortedSet getSortedSet ( ) { return sortedSet ; }
public void setSortedSet ( SortedSet sortedSet ) { this . sortedSet = sortedSet ; }
public Map getEc2RegionMap ( ) { return ec2RegionMap ; }
public void setEc2RegionMap ( Map < String , String > ec2RegionMap ) { this . ec2RegionMap = ec2RegionMap ; }
public EC2Key getEc2Key ( ) { return ec2Key ; }
public void setEc2Key ( EC2Key ec2Key ) { this . ec2Key = ec2Key ; }
public HttpServletResponse getServletResponse ( ) { return servletResponse ; }
public void setServletResponse ( HttpServletResponse servletResponse ) { this . servletResponse = servletResponse ; }
public String setEC2Region ( ) { Long adminId = AdminUtil . getAdminId ( servletRequest ) ; SortedSet sortedSet = EC2KeyDB . getEC2KeySet ( adminId , new SortedSet ( ) ) ; //check to see if keys have been imported if(sortedSet!=null && sortedSet.getItemList()!=null && sortedSet.getItemList().size()>0){ ec2Region= EC2RegionDB.getEC2Regions(adminId); }else{ addActionMessage("EC2 regions not available. Import EC2 Keys <a href=\"viewEC2Keys.action\">here</a>"); } return SUCCESS;
public String submitEC2Region ( ) { EC2RegionDB . setRegion ( AdminUtil . getAdminId ( servletRequest ) , ec2Region ) ; return SUCCESS ;
public void setEc2RegionMap ( Map ec2RegionMap ) { this . ec2RegionMap = ec2RegionMap ; }
public List < String > getEc2Region ( ) { return ec2Region ; }
public void setEc2Region ( List < String > ec2Region ) { this . ec2Region = ec2Region ; }
public String loginSubmit ( ) { String retVal = SUCCESS ; String authToken = AdminDB . loginAdmin ( login ) ; if ( authToken ! = null ) { CookieUtil . add ( servletResponse , " authToken " , EncryptionUtil . encrypt ( authToken ) ) ; //set timeout cookie SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); Calendar timeout = Calendar.getInstance(); timeout.add(Calendar.MINUTE, 15); CookieUtil.add(servletResponse, "timeout", sdf.format(timeout.getTime())); } else { addActionError("Invalid username and password combination"); retVal = INPUT; } if (retVal == SUCCESS && "changeme".equals(login.getPassword())) { retVal = "change_password"; } return retVal; }
public String logout ( ) { CookieUtil . deleteAll ( servletRequest , servletResponse ) ; return SUCCESS ; }
public String setPassword ( ) { return SUCCESS ; }
public String passwordSubmit ( ) { String retVal = SUCCESS ; if ( login . getPassword ( ) . equals ( login . getPasswordConfirm ( ) ) ) { login . setAuthToken ( EncryptionUtil . decrypt ( CookieUtil . get ( servletRequest , " authToken " ) ) ) ; if ( ! AdminDB . updatePassword ( login ) ) { addActionError ( " Current password is invalid " ) ; retVal = INPUT ; } } else { addActionError ( " Passwords do not match " ) ; retVal = INPUT ; } return retVal ; }
public void validateLoginSubmit ( ) { if ( login . getUsername ( ) = = null | | login . getUsername ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " login.username " , " Required " ) ; } if ( login . getPassword ( ) = = null | | login . getPassword ( ) . trim ( ) . equals ( " " ) ) {
public void validatePasswordSubmit ( ) { if ( login . getPassword ( ) = = null | | login . getPassword ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " login.password " , " Required " ) ; } if ( login . getPasswordConfirm ( ) = = null | | login . getPasswordConfirm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " login.passwordConfirm " , " Required " ) ; } if ( login . getPrevPassword ( ) = = null | | login . getPrevPassword ( ) . trim ( ) . equals ( " " ) ) {
public void setLogin ( Login login ) { this . login = login ; }
public String viewScripts ( ) { sortedSet = ScriptDB . getScriptSet ( sortedSet , AdminUtil . getAdminId ( servletRequest ) ) ; return SUCCESS ; }
public String saveScript ( ) { script . setAdminId ( AdminUtil . getAdminId ( servletRequest ) ) ; if ( script . getId ( ) ! = null ) { ScriptDB . updateScript ( script ) ; } else { ScriptDB . insertScript ( script ) ; } return SUCCESS ; }
public String deleteScript ( ) { if ( script . getId ( ) ! = null ) { ScriptDB . deleteScript ( script . getId ( ) , AdminUtil . getAdminId ( servletRequest ) ) ; } return SUCCESS ; }
public void validateSaveScript ( ) { if ( script = = null | | script . getDisplayNm ( ) = = null | | script . getDisplayNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " script.displayNm " , " Required " ) ; } if ( script = = null | | script . getScript ( ) = = null | | script . getScript ( ) . trim ( ) . equals ( " " ) | | ( new Script ( ) ) . getScript ( ) . trim ( ) . equals ( script . getScript ( ) . trim ( ) ) ) { addFieldError ( " script.script " , " Required " ) ; } if ( ! this . getFieldErrors ( ) . isEmpty ( ) ) { sortedSet = ScriptDB . getScriptSet ( sortedSet , AdminUtil . getAdminId ( servletRequest ) ) ;
public Script getScript ( ) { return script ; }
public void setScript ( Script script ) { this . script = script ; }
public String runCmd ( ) { try { //if id then write to single system output buffer if (idList != null && idList.size() > 0) { for (Long id : idList) { SchSession schSession = schSessionMap.get(id); if (keyCode != null) { if (keyMap.containsKey(keyCode)) { schSession.getCommander().write(keyMap.get(keyCode)); } } else { schSession.getCommander().print(command); } } } } catch (Exception ex) { ex.printStackTrace(); } return null; }
public String getOutputJSON ( ) { synchronized ( SessionOutputUtil . class ) { outputList = SessionOutputUtil . getOutput ( ) ; JSONArray json = ( JSONArray ) JSONSerializer . toJSON ( outputList ) ; try { servletResponse . getOutputStream ( ) . write ( json . toString ( ) . getBytes ( ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } return null ; }
public String createTerms ( ) { if ( pendingSystemStatus ! = null & & pendingSystemStatus . getId ( ) ! = null ) { //get status currentSystemStatus = SystemStatusDB.getSystemStatus(pendingSystemStatus.getId()); //if initial status run script if (currentSystemStatus != null && (SystemStatus.INITIAL_STATUS.equals(currentSystemStatus.getStatusCd()) || SystemStatus.AUTH_FAIL_STATUS.equals(currentSystemStatus.getStatusCd()) || SystemStatus.PUBLIC_KEY_FAIL_STATUS.equals(currentSystemStatus.getStatusCd())) ) { //set current session currentSystemStatus = SSHUtil.openSSHTermOnSystem(AdminUtil.getAdminId(servletRequest),passphrase, password, currentSystemStatus, schSessionMap); } if (currentSystemStatus != null && (SystemStatus.AUTH_FAIL_STATUS.equals(currentSystemStatus.getStatusCd()) || SystemStatus.PUBLIC_KEY_FAIL_STATUS.equals(currentSystemStatus.getStatusCd()))) { pendingSystemStatus = currentSystemStatus; } else { pendingSystemStatus = SystemStatusDB.getNextPendingSystem(); //if success loop through systems until finished or need password while (pendingSystemStatus != null && currentSystemStatus != null && SystemStatus.SUCCESS_STATUS.equals(currentSystemStatus.getStatusCd())) { currentSystemStatus = SSHUtil.openSSHTermOnSystem(AdminUtil.getAdminId(servletRequest),passphrase, password, pendingSystemStatus, schSessionMap); pendingSystemStatus = SystemStatusDB.getNextPendingSystem(); } } passphrase=null; } if (SystemStatusDB.getNextPendingSystem()== null) { this.passphrase=null; //run script it exists if (script != null && script.getId() != null && script.getId() > 0) { script = ScriptDB.getScript(script.getId(),AdminUtil.getAdminId(servletRequest)); for (SchSession schSession : schSessionMap.values()) { BufferedReader reader = new BufferedReader(new StringReader(script.getScript())); String line; try { while ((line = reader.readLine()) != null) { schSession.getCommander().println(line); } } catch (Exception e) { e.printStackTrace(); } } } } return SUCCESS; }
public String getNextPendingSystemForTerms ( ) { currentSystemStatus = SystemStatusDB . getSystemStatus ( pendingSystemStatus . getId ( ) ) ; currentSystemStatus . setErrorMsg ( " Auth fail " ) ; currentSystemStatus . setStatusCd ( SystemStatus . GENERIC_FAIL_STATUS ) ; SystemStatusDB . updateSystemStatus ( currentSystemStatus ) ; pendingSystemStatus = SystemStatusDB . getNextPendingSystem ( ) ; return SUCCESS ; }
public String selectSystemsForCompositeTerms ( ) { //exit any previous terms exitTerms(); if (systemSelectId != null && !systemSelectId.isEmpty()) { List<SystemStatus> systemStatusList = SystemStatusDB.setInitialSystemStatus(systemSelectId); pendingSystemStatus = SystemStatusDB.getNextPendingSystem(); //check to see if passphrase has been provided //set use provided passphrase if (pendingSystemStatus!=null) { pendingSystemStatus.setStatusCd(SystemStatus.PUBLIC_KEY_FAIL_STATUS); } } return SUCCESS; }
public String exitTerms ( ) { for ( SchSession schSession : schSessionMap . values ( ) ) { schSession . getChannel ( ) . disconnect ( ) ; schSession . getSession ( ) . disconnect ( ) ; schSession . setChannel ( null ) ; schSession . setSession ( null ) ; schSession . setInputToChannel ( null ) ; schSession . setCommander ( null ) ; schSession . setOutFromChannel ( null ) ; schSession = null ; } schSessionMap . clear ( ) ; return SUCCESS ; }
public List < SessionOutput > getOutputList ( ) { return outputList ; }
public void setOutputList ( List < SessionOutput > outputList ) { this . outputList = outputList ; }
public String getCommand ( ) { return command ; }
public void setCommand ( String command ) { this . command = command ; }
public Integer getKeyCode ( ) { return keyCode ; }
public void setKeyCode ( Integer keyCode ) { this . keyCode = keyCode ; }
public static Map < Long , SchSession > getSchSessionMap ( ) { return schSessionMap ; }
public static void setSchSessionMap ( Map < Long , SchSession > schSessionMap ) { SecureShellAction . schSessionMap = schSessionMap ; }
public List < Long > getIdList ( ) { return idList ; }
public void setIdList ( List < Long > idList ) { this . idList = idList ; }
public List < Long > getSystemSelectId ( ) { return systemSelectId ; }
public void setSystemSelectId ( List < Long > systemSelectId ) { this . systemSelectId = systemSelectId ; }
public SystemStatus getCurrentSystemStatus ( ) { return currentSystemStatus ; }
public void setCurrentSystemStatus ( SystemStatus currentSystemStatus ) { this . currentSystemStatus = currentSystemStatus ; }
public SystemStatus getPendingSystemStatus ( ) { return pendingSystemStatus ; }
public void setPendingSystemStatus ( SystemStatus pendingSystemStatus ) { this . pendingSystemStatus = pendingSystemStatus ; }
public String getPassphrase ( ) { return passphrase ; }
public void setPassphrase ( String passphrase ) { this . passphrase = passphrase ; }
public String getPassword ( ) { return password ; }
public void setPassword ( String password ) { this . password = password ; }
public String saveSystem ( ) { if ( hostSystem . getId ( ) ! = null ) { hostSystem . setAdminId ( AdminUtil . getAdminId ( servletRequest ) ) ; SystemDB . updateSystem ( hostSystem ) ; } return SUCCESS ; }
public String deleteSystem ( ) { if ( hostSystem . getId ( ) ! = null ) { SystemDB . deleteSystem ( hostSystem . getId ( ) , AdminUtil . getAdminId ( servletRequest ) ) ; } return SUCCESS ; }
public void validateSaveSystem ( ) { if ( hostSystem = = null | | hostSystem . getUser ( ) = = null | | hostSystem . getUser ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " hostSystem.user " , " Required " ) ; } if ( ! this . getFieldErrors ( ) . isEmpty ( ) ) {
public HostSystem getHostSystem ( ) { return hostSystem ; }
public void setHostSystem ( HostSystem hostSystem ) { this . hostSystem = hostSystem ; }
public String setUpload ( ) throws Exception { SystemStatusDB . setInitialSystemStatus ( idList ) ; return SUCCESS ;
public String upload ( ) { try { File destination = new File ( UPLOAD_PATH , uploadFileName ) ; FileUtils . copyFile ( upload , destination ) ; pendingSystemStatus = SystemStatusDB . getNextPendingSystem ( ) ; systemStatusList = SystemStatusDB . getAllSystemStatus ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return INPUT ; } return SUCCESS ; }
public String push ( ) { try { //get next pending system pendingSystemStatus = SystemStatusDB.getNextPendingSystem(); if (pendingSystemStatus != null) { //get session for system SchSession session = SecureShellAction.getSchSessionMap().get(pendingSystemStatus.getId()); //push upload to system currentSystemStatus = SSHUtil.pushUpload(pendingSystemStatus, session.getSession(), UPLOAD_PATH + "/" + uploadFileName, pushDir + "/" + uploadFileName); //update system status SystemStatusDB.updateSystemStatus(currentSystemStatus); pendingSystemStatus = SystemStatusDB.getNextPendingSystem(); } //if push has finished to all servers then delete uploaded file if (pendingSystemStatus == null) { File delFile = new File(UPLOAD_PATH, uploadFileName); FileUtils.deleteQuietly(delFile); } systemStatusList = SystemStatusDB.getAllSystemStatus(); } catch (Exception e) { e.printStackTrace(); } return SUCCESS; }
public void validateUpload ( ) { if ( uploadFileName = = null | | uploadFileName . trim ( ) . equals ( " " ) ) { addFieldError ( " upload " , " Required " ) ; } if ( pushDir = = null | | pushDir . trim ( ) . equals ( " " ) ) { addFieldError ( " pushPath " , " Required " ) ;
public void setUpload ( File upload ) { this . upload = upload ; }
public String getUploadContentType ( ) { return uploadContentType ; }
public void setUploadContentType ( String uploadContentType ) { this . uploadContentType = uploadContentType ; }
public String getUploadFileName ( ) { return uploadFileName ; }
public void setUploadFileName ( String uploadFileName ) { this . uploadFileName = uploadFileName ; }
public String getPushDir ( ) { return pushDir ; }
public void setPushDir ( String pushDir ) { this . pushDir = pushDir ; }
public List < SystemStatus > getSystemStatusList ( ) { return systemStatusList ; }
public void setSystemStatusList ( List < SystemStatus > systemStatusList ) { this . systemStatusList = systemStatusList ; }
public static AWSCred getAWSCred ( Long adminId ) { AWSCred awsCred = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from aws_credentials where admin_id=? " ) ; stmt . setLong ( 1 , adminId ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { awsCred = new AWSCred ( ) ; awsCred . setAccessKey ( rs . getString ( " access_key " ) ) ; awsCred . setSecretKey ( rs . getString ( " secret_key " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } //close db connection DBUtils.closeConn(con); return awsCred;
public static void setAWSCred ( Long adminId , AWSCred awsCred ) { //get db connection Connection con = DBUtils.getConn(); try { //delete PreparedStatement stmt = con.prepareStatement("delete from aws_credentials where admin_id=?"); stmt.setLong(1, adminId); stmt.execute(); //insert stmt = con.prepareStatement("insert into aws_credentials (admin_id, access_key, secret_key) values(?,?,?)"); stmt.setLong(1, adminId); stmt.setString(2, awsCred.getAccessKey()); stmt.setString(3, awsCred.getSecretKey()); stmt.execute(); DBUtils.closeStmt(stmt); } catch (Exception e) { e.printStackTrace(); } //close db connection DBUtils.closeConn(con);
public static Login getAdminLogin ( String authToken ) { Login login = null ; if ( authToken ! = null & & ! authToken . trim ( ) . equals ( " " ) ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from admin where auth_token=? " ) ; stmt . setString ( 1 , authToken ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { login = new Login ( ) ; login . setId ( rs . getLong ( " id " ) ) ; login . setAuthToken ( rs . getString ( " auth_token " ) ) ; login . setUsername ( rs . getString ( " username " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; } return login ; }
public static String loginAdmin ( Login login ) { String authToken = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from admin where username=? and password=? " ) ; stmt . setString ( 1 , login . getUsername ( ) ) ; stmt . setString ( 2 , EncryptionUtil . hash ( login . getPassword ( ) ) ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { login . setId ( rs . getLong ( " id " ) ) ; authToken = UUID . randomUUID ( ) . toString ( ) ; login . setAuthToken ( authToken ) ; //set auth token updateAdmin(con, login); } DBUtils.closeRs(rs); DBUtils.closeStmt(stmt); } catch (Exception e) { e.printStackTrace(); } DBUtils.closeConn(con); return authToken;
public static boolean isAdmin ( String authToken ) { boolean isAdmin = false ; Connection con = null ; if ( authToken ! = null & & ! authToken . trim ( ) . equals ( " " ) ) { try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from admin where auth_token=? " ) ; stmt . setString ( 1 , authToken ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { isAdmin = true ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } DBUtils . closeConn ( con ) ; return isAdmin ;
private static void updateAdmin ( Connection con , Login login ) { try { PreparedStatement stmt = con . prepareStatement ( " update admin set username=?, password=?, auth_token=? where id=? " ) ;
public static boolean updatePassword ( Login login ) { boolean success = false ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from admin where auth_token like ? and password like ? " ) ; stmt . setString ( 1 , login . getAuthToken ( ) ) ; stmt . setString ( 2 , EncryptionUtil . hash ( login . getPrevPassword ( ) ) ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { stmt = con . prepareStatement ( " update admin set password=? where auth_token like ? " ) ; stmt . setString ( 1 , EncryptionUtil . hash ( login . getPassword ( ) ) ) ; stmt . setString ( 2 , login . getAuthToken ( ) ) ; stmt . execute ( ) ; success = true ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return success ; }
public static SortedSet getEC2KeySet ( Long adminId , SortedSet sortedSet ) { List < EC2Key > ec2KeyList = new ArrayList < EC2Key > ( ) ; String orderBy = " " ; if ( sortedSet . getOrderByField ( ) ! = null & & ! sortedSet . getOrderByField ( ) . trim ( ) . equals ( " " ) ) { orderBy = " order by " + sortedSet . getOrderByField ( ) + " " + sortedSet . getOrderByDirection ( ) ; } Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from ec2_keys where admin_id=? " + orderBy ) ; stmt . setLong ( 1 , adminId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { EC2Key ec2Key = new EC2Key ( ) ; ec2Key . setId ( rs . getLong ( " id " ) ) ; ec2Key . setAdminId ( rs . getLong ( " admin_id " ) ) ; ec2Key . setKeyNm ( rs . getString ( " key_nm " ) ) ; ec2Key . setEc2Region ( rs . getString ( " ec2_region " ) ) ; ec2KeyList . add ( ec2Key ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; sortedSet . setItemList ( ec2KeyList ) ; return sortedSet ;
public static EC2Key getEC2KeyByKeyNm ( Long adminId , String keyNm , String ec2Region ) { EC2Key ec2Key = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from ec2_keys where admin_id=? and key_nm like ? and ec2_region like ? " ) ; stmt . setLong ( 1 , adminId ) ; stmt . setString ( 2 , keyNm ) ; stmt . setString ( 3 , ec2Region ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { ec2Key = new EC2Key ( ) ; ec2Key . setId ( rs . getLong ( " id " ) ) ; ec2Key . setAdminId ( rs . getLong ( " admin_id " ) ) ; ec2Key . setKeyNm ( rs . getString ( " key_nm " ) ) ; ec2Key . setEc2Region ( rs . getString ( " ec2_region " ) ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return ec2Key ;
public static List < EC2Key > getEC2KeyByRegion ( Long adminId , String ec2Region ) { List < EC2Key > ec2KeyList = new ArrayList < EC2Key > ( ) ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from ec2_keys where admin_id=? and ec2_region like ? " ) ; stmt . setLong ( 1 , adminId ) ; stmt . setString ( 2 , ec2Region ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { EC2Key ec2Key = new EC2Key ( ) ; ec2Key . setId ( rs . getLong ( " id " ) ) ; ec2Key . setAdminId ( rs . getLong ( " admin_id " ) ) ; ec2Key . setKeyNm ( rs . getString ( " key_nm " ) ) ; ec2Key . setEc2Region ( rs . getString ( " ec2_region " ) ) ; ec2KeyList . add ( ec2Key ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return ec2KeyList ;
public static Long insertEC2Key ( Long adminId , EC2Key ec2Key ) { Connection con = null ; Long ec2KeyId = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " insert into ec2_keys (admin_id, key_nm, ec2_region) values (?,?,?) " , Statement . RETURN_GENERATED_KEYS ) ; stmt . setLong ( 1 , adminId ) ; stmt . setString ( 2 , ec2Key . getKeyNm ( ) ) ; stmt . setString ( 3 , ec2Key . getEc2Region ( ) ) ; stmt . execute ( ) ; ResultSet rs = stmt . getGeneratedKeys ( ) ; if ( rs ! = null & & rs . next ( ) ) { ec2KeyId = rs . getLong ( 1 ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return ec2KeyId ;
public static Long saveEC2Key ( Long adminId , EC2Key ec2Key ) { Long ec2KeyId = null ; //get id for key if exists EC2Key ec2KeyTmp = getEC2KeyByKeyNm(adminId,ec2Key.getKeyNm(), ec2Key.getEc2Region()); if(ec2KeyTmp!=null){ ec2KeyId=ec2KeyTmp.getId(); //else insert if it doesn't exist }else{ ec2KeyId=insertEC2Key(adminId,ec2Key); } ec2KeyTmp=null; return ec2KeyId;
public static void deleteEC2Key ( Long identityId ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " delete from ec2_keys where id=? " ) ; stmt . setLong ( 1 , identityId ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static List < String > getEC2Regions ( Long adminId ) { List < String > ec2RegionList = new ArrayList < String > ( ) ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from ec2_region where admin_id=? " ) ; stmt . setLong ( 1 , adminId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { ec2RegionList . add ( rs . getString ( " region " ) ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return ec2RegionList ;
public static void setRegion ( Long adminId , List < String > ec2RegionList ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; //delete region PreparedStatement stmt = con.prepareStatement("delete from ec2_region where admin_id=?"); stmt.setLong(1, adminId); stmt.execute(); //insert new region for (String ec2Region : ec2RegionList) { stmt = con.prepareStatement("insert into ec2_region (admin_id, region) values (?,?)"); stmt.setLong(1, adminId); stmt.setString(2, ec2Region); stmt.execute(); DBUtils.closeStmt(stmt); } } catch (Exception e) { e.printStackTrace(); } DBUtils.closeConn(con);
public static SortedSet getScriptSet ( SortedSet sortedSet , Long adminId ) { ArrayList < Script > scriptList = new ArrayList < Script > ( ) ; String orderBy = " " ; if ( sortedSet . getOrderByField ( ) ! = null & & ! sortedSet . getOrderByField ( ) . trim ( ) . equals ( " " ) ) { orderBy = " order by " + sortedSet . getOrderByField ( ) + " " + sortedSet . getOrderByDirection ( ) ; } String sql = " select * from scripts where admin_id =? " + orderBy ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( sql ) ; stmt . setLong ( 1 , adminId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { Script script = new Script ( ) ; script . setId ( rs . getLong ( " id " ) ) ; script . setDisplayNm ( rs . getString ( " display_nm " ) ) ; script . setScript ( rs . getString ( " script " ) ) ; script . setAdminId ( rs . getLong ( " admin_id " ) ) ; scriptList . add ( script ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; sortedSet . setItemList ( scriptList ) ; return sortedSet ; }
public static Script getScript ( Long scriptId , Long adminId ) { Script script = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; script = getScript ( con , scriptId , adminId ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return script ; }
public static Script getScript ( Connection con , Long scriptId , Long adminId ) { Script script = null ; try { PreparedStatement stmt = con . prepareStatement ( " select * from scripts where id=? and admin_id=? " ) ; stmt . setLong ( 1 , scriptId ) ; stmt . setLong ( 2 , adminId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { script = new Script ( ) ; script . setId ( rs . getLong ( " id " ) ) ; script . setDisplayNm ( rs . getString ( " display_nm " ) ) ; script . setScript ( rs . getString ( " script " ) ) ; script . setAdminId ( rs . getLong ( " admin_id " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return script ; }
public static void insertScript ( Script script ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " insert into scripts (display_nm, script, admin_id) values (?,?,?) " ) ; stmt . setString ( 1 , script . getDisplayNm ( ) ) ; stmt . setString ( 2 , script . getScript ( ) ) ; stmt . setLong ( 3 , script . getAdminId ( ) ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void updateScript ( Script script ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " update scripts set display_nm=?, script=? where id=? and admin_id=? " ) ; stmt . setString ( 1 , script . getDisplayNm ( ) ) ; stmt . setString ( 2 , script . getScript ( ) ) ; stmt . setLong ( 3 , script . getId ( ) ) ; stmt . setLong ( 4 , script . getAdminId ( ) ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void deleteScript ( Long scriptId , Long adminId ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " delete from scripts where id=? and admin_id=? " ) ; stmt . setLong ( 1 , scriptId ) ; stmt . setLong ( 2 , adminId ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static SortedSet getSystemSet ( SortedSet sortedSet , Long adminId ) { List < HostSystem > hostSystemList = new ArrayList < HostSystem > ( ) ; String orderBy = " " ; if ( sortedSet . getOrderByField ( ) ! = null & & ! sortedSet . getOrderByField ( ) . trim ( ) . equals ( " " ) ) { orderBy = " order by " + sortedSet . getOrderByField ( ) + " " + sortedSet . getOrderByDirection ( ) ; } String sql = " select s.* from system s, ec2_region r where s.region=r.region and s.admin_id= ? " + orderBy ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( sql ) ; stmt . setLong ( 1 , adminId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { HostSystem hostSystem = new HostSystem ( ) ; hostSystem . setId ( rs . getLong ( " id " ) ) ; hostSystem . setDisplayNm ( rs . getString ( " display_nm " ) ) ; hostSystem . setInstanceId ( rs . getString ( " instance_id " ) ) ; hostSystem . setUser ( rs . getString ( " user " ) ) ; hostSystem . setHost ( rs . getString ( " host " ) ) ; hostSystem . setPort ( rs . getInt ( " port " ) ) ; hostSystem . setKeyNm ( rs . getString ( " key_nm " ) ) ; hostSystem . setEc2Region ( rs . getString ( " region " ) ) ; hostSystem . setState ( rs . getString ( " state " ) ) ; hostSystem . setAdminId ( rs . getLong ( " admin_id " ) ) ; hostSystemList . add ( hostSystem ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; sortedSet . setItemList ( hostSystemList ) ; return sortedSet ;
public static HostSystem getSystem ( Long id ) { HostSystem hostSystem = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; getSystem ( con , id ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return hostSystem ; }
public static HostSystem getSystem ( Connection con , Long id ) { HostSystem hostSystem = null ; try { PreparedStatement stmt = con . prepareStatement ( " select * from system where id=? " ) ; stmt . setLong ( 1 , id ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { hostSystem = new HostSystem ( ) ; hostSystem . setId ( rs . getLong ( " id " ) ) ; hostSystem . setDisplayNm ( rs . getString ( " display_nm " ) ) ; hostSystem . setInstanceId ( rs . getString ( " instance_id " ) ) ; hostSystem . setUser ( rs . getString ( " user " ) ) ; hostSystem . setHost ( rs . getString ( " host " ) ) ; hostSystem . setPort ( rs . getInt ( " port " ) ) ; hostSystem . setKeyNm ( rs . getString ( " key_nm " ) ) ; hostSystem . setEc2Region ( rs . getString ( " region " ) ) ; hostSystem . setState ( rs . getString ( " state " ) ) ; hostSystem . setAdminId ( rs . getLong ( " admin_id " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return hostSystem ; }
public static HostSystem getSystem ( String instanceId , Long adminId ) { HostSystem hostSystem = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from system where instance_id=? and admin_id =? " ) ; stmt . setString ( 1 , instanceId ) ; stmt . setLong ( 2 , adminId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { hostSystem = new HostSystem ( ) ; hostSystem . setId ( rs . getLong ( " id " ) ) ; hostSystem . setDisplayNm ( rs . getString ( " display_nm " ) ) ; hostSystem . setInstanceId ( rs . getString ( " instance_id " ) ) ; hostSystem . setUser ( rs . getString ( " user " ) ) ; hostSystem . setHost ( rs . getString ( " host " ) ) ; hostSystem . setPort ( rs . getInt ( " port " ) ) ; hostSystem . setKeyNm ( rs . getString ( " key_nm " ) ) ; hostSystem . setEc2Region ( rs . getString ( " region " ) ) ; hostSystem . setState ( rs . getString ( " state " ) ) ; hostSystem . setAdminId ( rs . getLong ( " admin_id " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return hostSystem ; }
public static void insertSystem ( Connection con , HostSystem hostSystem ) { try {
public static void updateSystem ( HostSystem hostSystem ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " update system set display_nm=?, user=?, host=?, port=?, instance_id=?, key_nm=?, region=?, state=? where id=? and admin_id=? " ) ; stmt . setString ( 1 , hostSystem . getDisplayNm ( ) ) ; stmt . setString ( 2 , hostSystem . getUser ( ) ) ; stmt . setString ( 3 , hostSystem . getHost ( ) ) ; stmt . setInt ( 4 , hostSystem . getPort ( ) ) ; stmt . setString ( 5 , hostSystem . getInstanceId ( ) ) ; stmt . setString ( 6 , hostSystem . getKeyNm ( ) ) ; stmt . setString ( 7 , hostSystem . getEc2Region ( ) ) ; stmt . setString ( 8 , hostSystem . getState ( ) ) ; stmt . setLong ( 9 , hostSystem . getId ( ) ) ; stmt . setLong ( 10 , hostSystem . getAdminId ( ) ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void deleteSystem ( Long hostSystemId , Long adminId ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " delete from system where id=? and admin_id=? " ) ; stmt . setLong ( 1 , hostSystemId ) ; stmt . setLong ( 2 , adminId ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void setSystems ( List < HostSystem > hostSystemList , String ec2Region , Long adminId ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; //delete all systems for region PreparedStatement stmt = con.prepareStatement("delete from system where region like ? and admin_id=?"); stmt.setString(1, ec2Region); stmt.setLong(2, adminId); stmt.execute(); DBUtils.closeStmt(stmt); //insert new host systems for(HostSystem hostSystem:hostSystemList){ insertSystem(con, hostSystem); } } catch (Exception e) { e.printStackTrace(); } DBUtils.closeConn(con);
public static List < SystemStatus > setInitialSystemStatus ( List < Long > systemSelectIds ) { Connection con = null ; List < SystemStatus > systemStatusList = new ArrayList < SystemStatus > ( ) ; try { con = DBUtils . getConn ( ) ; //deletes all old systems deleteAllSystemStatus(con); for (Long hostSystemId : systemSelectIds) { HostSystem hostSystem= SystemDB.getSystem(con, hostSystemId); SystemStatus systemStatus = new SystemStatus(); systemStatus.setId(hostSystem.getId()); systemStatus.setStatusCd(SystemStatus.INITIAL_STATUS); //insert new status insertSystemStatus(con, systemStatus); //get update status list systemStatusList = getAllSystemStatus(con); } } catch (Exception e) { e.printStackTrace(); } DBUtils.closeConn(con); return systemStatusList; }
private static void deleteAllSystemStatus ( Connection con ) { try {
private static void insertSystemStatus ( Connection con , SystemStatus systemStatus ) { try {
public static void updateSystemStatus ( SystemStatus systemStatus ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; updateSystemStatus ( con , systemStatus ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void updateSystemStatus ( Connection con , SystemStatus systemStatus ) { try {
public static List < SystemStatus > getAllSystemStatus ( ) { List < SystemStatus > systemStatusList = new ArrayList < SystemStatus > ( ) ; Connection con = null ; try { con = DBUtils . getConn ( ) ; systemStatusList = getAllSystemStatus ( con ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return systemStatusList ;
private static List < SystemStatus > getAllSystemStatus ( Connection con ) { List < SystemStatus > systemStatusList = new ArrayList < SystemStatus > ( ) ; try { PreparedStatement stmt = con . prepareStatement ( " select * from status " ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { SystemStatus systemStatus = new SystemStatus ( ) ; systemStatus . setId ( rs . getLong ( " id " ) ) ; systemStatus . setStatusCd ( rs . getString ( " status_cd " ) ) ; systemStatus . setHostSystem ( SystemDB . getSystem ( con , systemStatus . getId ( ) ) ) ; systemStatusList . add ( systemStatus ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return systemStatusList ;
public static SystemStatus getSystemStatus ( Long systemId ) { Connection con = null ; SystemStatus systemStatus = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from status where id=? " ) ; stmt . setLong ( 1 , systemId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { systemStatus = new SystemStatus ( ) ; systemStatus . setId ( rs . getLong ( " id " ) ) ; systemStatus . setStatusCd ( rs . getString ( " status_cd " ) ) ; systemStatus . setHostSystem ( SystemDB . getSystem ( con , systemStatus . getId ( ) ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return systemStatus ;
public static SystemStatus getNextPendingSystem ( ) { SystemStatus systemStatus = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from status where status_cd like ? or status_cd like ? or status_cd like ? " ) ; stmt . setString ( 1 , SystemStatus . INITIAL_STATUS ) ; stmt . setString ( 2 , SystemStatus . AUTH_FAIL_STATUS ) ; stmt . setString ( 3 , SystemStatus . PUBLIC_KEY_FAIL_STATUS ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { systemStatus = new SystemStatus ( ) ; systemStatus . setId ( rs . getLong ( " id " ) ) ; systemStatus . setStatusCd ( rs . getString ( " status_cd " ) ) ; systemStatus . setHostSystem ( SystemDB . getSystem ( con , systemStatus . getId ( ) ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return systemStatus ;
public String getAccessKey ( ) { return accessKey ; }
public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; }
public String getSecretKey ( ) { return secretKey ; }
public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; }
public String getEndPoint ( ) { return endPoint ; }
public void setEndPoint ( String endPoint ) { this . endPoint = endPoint ; }
public String getKeyName ( ) { return keyName ; }
public void setKeyName ( String keyName ) { this . keyName = keyName ; }
public Long getAdminId ( ) { return adminId ; }
public void setAdminId ( Long adminId ) { this . adminId = adminId ; }
public void setKeyNm ( String keyNm ) { this . keyNm = keyNm ; }
public String getPrivateKey ( ) { return privateKey ; }
public void setPrivateKey ( String privateKey ) { this . privateKey = privateKey ; }
public String getEc2Region ( ) { return ec2Region ; }
public void setEc2Region ( String ec2Region ) { this . ec2Region = ec2Region ; }
public String getDisplayNm ( ) { return displayNm ; }
public List < String > getPublicKeyList ( ) { return publicKeyList ; }
public void setPublicKeyList ( List < String > publicKeyList ) { this . publicKeyList = publicKeyList ; }
public void setDisplayNm ( String displayNm ) { this . displayNm = displayNm ; }
public void setUser ( String user ) { this . user = user ; }
public void setHost ( String host ) { this . host = host ; }
public String getDisplayLabel ( ) { return getDisplayNm ( ) + " - ( " + getHost ( ) + " ) " ; }
public void setDisplayLabel ( String displayLabel ) { this . displayLabel = displayLabel ; }
public String getAuthorizedKeys ( ) { return authorizedKeys ; }
public void setAuthorizedKeys ( String authorizedKeys ) { this . authorizedKeys = authorizedKeys ; }
public void setPort ( Integer port ) { this . port = port ; }
public boolean getChecked ( ) { return checked ; }
public void setChecked ( boolean checked ) { this . checked = checked ; }
public String getInstanceId ( ) { return instanceId ; }
public void setInstanceId ( String instanceId ) { this . instanceId = instanceId ; }
public void setState ( String state ) { this . state = state ; }
public String getUsername ( ) { return username ; }
public String getAuthToken ( ) { return authToken ; }
public void setAuthToken ( String authToken ) { this . authToken = authToken ; }
public String getPasswordConfirm ( ) { return passwordConfirm ; }
public void setPasswordConfirm ( String passwordConfirm ) { this . passwordConfirm = passwordConfirm ; }
public String getPrevPassword ( ) { return prevPassword ; }
public void setPrevPassword ( String prevPassword ) { this . prevPassword = prevPassword ; }
public Session getSession ( ) { return session ; }
public void setSession ( Session session ) { this . session = session ; }
public Channel getChannel ( ) { return channel ; }
public void setChannel ( Channel channel ) { this . channel = channel ; }
public PrintStream getCommander ( ) { return commander ; }
public void setCommander ( PrintStream commander ) { this . commander = commander ; }
public InputStream getOutFromChannel ( ) { return outFromChannel ; }
public void setOutFromChannel ( InputStream outFromChannel ) { this . outFromChannel = outFromChannel ; }
public OutputStream getInputToChannel ( ) { return inputToChannel ; }
public void setInputToChannel ( OutputStream inputToChannel ) { this . inputToChannel = inputToChannel ; }
public String getScript ( ) { return script ; }
public void setScript ( String script ) { this . script = script ; }
public Long getSessionId ( ) { return sessionId ; }
public void setSessionId ( Long sessionId ) { this . sessionId = sessionId ; }
public String getOutput ( ) { return output ; }
public void setOutput ( String output ) { this . output = output ; }
public List < Character > getOutputChars ( ) { return outputChars ; }
public void setOutputChars ( List < Character > outputChars ) { this . outputChars = outputChars ; }
public String getOrderByField ( ) { return orderByField ; }
public void setOrderByField ( String orderByField ) { this . orderByField = orderByField ; }
public String getOrderByDirection ( ) { return orderByDirection ; }
public void setOrderByDirection ( String orderByDirection ) { this . orderByDirection = orderByDirection ; }
public List getItemList ( ) { return itemList ; }
public void setItemList ( List itemList ) { this . itemList = itemList ; }
public String getStatusCd ( ) { return statusCd ; }
public void setStatusCd ( String statusCd ) { this . statusCd = statusCd ; }
public String getErrorMsg ( ) { return errorMsg ; }
public void setErrorMsg ( String errorMsg ) { this . errorMsg = errorMsg ; }
public void run ( ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( outFromChannel ) ) ; try {
public static Long getAdminId ( HttpServletRequest servletRequest ) { Long adminId = null ; String authToken = EncryptionUtil . decrypt ( CookieUtil . get ( servletRequest , " authToken " ) ) ; Login login = AdminDB . getAdminLogin ( authToken ) ; if ( login ! = null ) { adminId = login . getId ( ) ; } return adminId ; }
public static String get ( HttpServletRequest request , String cookieNm ) { String value = null ; if ( cookieNm ! = null & & request . getCookies ( ) ! = null ) { for ( Cookie cookie : request . getCookies ( ) ) { if ( cookie . getName ( ) . equals ( cookieNm ) ) { value = cookie . getValue ( ) ; } } } return value ; }
public static void add ( HttpServletResponse response , String cookieNm , String cookieVal ) { Cookie cookie = new Cookie ( cookieNm , cookieVal ) ; cookie . setPath ( " / " ) ; cookie . setMaxAge ( MAX_AGE ) ; response . addCookie ( cookie ) ;
public static void deleteAll ( HttpServletRequest request , HttpServletResponse response ) { if ( request . getCookies ( ) ! = null ) { for ( Cookie cookie : request . getCookies ( ) ) {
public static void delete ( HttpServletRequest request , HttpServletResponse response , String cookieNm ) { if ( cookieNm ! = null & & request . getCookies ( ) ! = null ) { for ( Cookie cookie : request . getCookies ( ) ) {
public String getValue ( ) { return name ( ) ; }
public static Connection getConn ( ) { Connection con = null ; try { SQLiteConfig config = new SQLiteConfig ( ) ; config . enforceForeignKeys ( true ) ; Class . forName ( " org.sqlite.JDBC " ) ; // create a database connection con = DriverManager.getConnection("jdbc:sqlite:" + DB_PATH + "/ec2box.db", config.toProperties()); } catch (Exception ex) { ex.printStackTrace(); } return con;
public static void closeConn ( Connection con ) { try { if ( con ! = null ) {
public static void closeStmt ( Statement stmt ) { try { if ( stmt ! = null ) {
public static void closeRs ( ResultSet rs ) { try { if ( rs ! = null ) {
public static String hash ( String str ) { String hash = null ; try { MessageDigest md = MessageDigest . getInstance ( " SHA-256 " ) ; md . update ( str . getBytes ( " UTF-8 " ) ) ; hash = ( new BASE64Encoder ( ) ) . encode ( md . digest ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return hash ; }
public static String encrypt ( String str ) { String retVal = null ; if ( str ! = null & & str . length ( ) > 0 ) { try { Cipher c = Cipher . getInstance ( " AES " ) ; c . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( key , " AES " ) ) ; byte [ ] encVal = c . doFinal ( str . getBytes ( ) ) ; retVal = new BASE64Encoder ( ) . encode ( encVal ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } return retVal ; }
public static String decrypt ( String str ) { String retVal = null ; if ( str ! = null & & str . length ( ) > 0 ) { try { Cipher c = Cipher . getInstance ( " AES " ) ; c . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( key , " AES " ) ) ; byte [ ] decodedVal = new BASE64Decoder ( ) . decodeBuffer ( str ) ; retVal = new String ( c . doFinal ( decodedVal ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } return retVal ; }
public static SystemStatus pushUpload ( SystemStatus hostSystemStatus , Session session , String source , String destination ) { hostSystemStatus . setStatusCd ( SystemStatus . SUCCESS_STATUS ) ; Channel channel = null ; ChannelSftp c = null ; try { channel = session . openChannel ( " sftp " ) ; channel . setInputStream ( System . in ) ; channel . setOutputStream ( System . out ) ; channel . connect ( CHANNEL_TIMEOUT ) ; c = ( ChannelSftp ) channel ; destination = destination . replaceAll ( " ~ \\ /|~ " , " " ) ; //get file input stream FileInputStream file = new FileInputStream(source); c.put(file, destination); } catch (Exception e) { hostSystemStatus.setErrorMsg(e.getMessage()); hostSystemStatus.setStatusCd(SystemStatus.GENERIC_FAIL_STATUS); } //exit if (c != null) { c.exit(); } //disconnect if (channel != null) { channel.disconnect(); } return hostSystemStatus;
public static void storePrivateKey ( String keyName , String keyValue ) { try {
public static void deletePrivateKey ( String keyName ) { try { File keyFile = new File ( KEY_PATH + " / " + keyName + " .pem " ) ;
public synchronized static void addOutput ( SessionOutput sessionOutput ) { if ( sessionOutput ! = null ) { sessionOutputMap . put ( sessionOutput . getSessionId ( ) , sessionOutput ) ;
public synchronized static void removeOutput ( SessionOutput sessionOutput ) { if ( sessionOutput ! = null ) { sessionOutputMap . remove ( sessionOutput . getSessionId ( ) ) ;
public synchronized static void addCharToOutput ( SessionOutput sessionOutput , char c ) { if ( sessionOutput ! = null ) { sessionOutput . getOutputChars ( ) . add ( c ) ;
public synchronized static List < SessionOutput > getOutput ( ) { List < SessionOutput > outputList = new ArrayList < SessionOutput > ( ) ; for ( Long outputId : sessionOutputMap . keySet ( ) ) { SessionOutput sessionOutput = sessionOutputMap . get ( outputId ) ; //get output chars and set to output StringBuilder output = new StringBuilder(sessionOutput.getOutputChars().size()); for (Character ch : sessionOutput.getOutputChars()) { output.append(ch); } //sessionOutput.setOutput(output.toString().replaceAll("\\[.*?m|\\[.*?m","")); sessionOutput.setOutput(output.toString()); sessionOutput.setOutputChars(new ArrayList<Character>()); outputList.add(sessionOutput); //put back with new char array sessionOutputMap.put(sessionOutput.getSessionId(), sessionOutput); } return outputList; }
public String selectSystemsForCompositeTerms ( ) { //exit any previous terms exitTerms(); if (systemSelectId != null && !systemSelectId.isEmpty()) { List<SystemStatus> systemStatusList = SystemStatusDB.setInitialSystemStatus(systemSelectId); pendingSystemStatus = SystemStatusDB.getNextPendingSystem(); } return SUCCESS; }
public String setAWSCred ( ) { awsCred = AWSCredDB . getAWSCred ( AdminUtil . getAdminId ( servletRequest ) ) ; return SUCCESS ;
public String submitAWSCred ( ) { AWSCredDB . setAWSCred ( AdminUtil . getAdminId ( servletRequest ) , awsCred ) ; return SUCCESS ;
public void validateSubmitAWSCred ( ) { if ( awsCred . getAccessKey ( ) = = null | | awsCred . getAccessKey ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " awsCred.accessKey " , " Required " ) ; } if ( awsCred . getSecretKey ( ) = = null | | awsCred . getSecretKey ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " awsCred.secretKey " , " Required " ) ; } if ( ! this . hasErrors ( ) ) { try {
public String getOutputJSON ( ) { outputList = SessionOutputUtil . getOutput ( ) ; JSONArray json = ( JSONArray ) JSONSerializer . toJSON ( outputList ) ; try { servletResponse . getOutputStream ( ) . write ( json . toString ( ) . getBytes ( ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return null ; }
public static void addOutput ( SessionOutput sessionOutput ) { if ( sessionOutput ! = null ) { synchronized ( lock ) {
public static void removeOutput ( SessionOutput sessionOutput ) { if ( sessionOutput ! = null ) { synchronized ( lock ) {
public static void addCharToOutput ( SessionOutput sessionOutput , char c ) { if ( sessionOutput ! = null ) { sessionOutput . getOutputChars ( ) . add ( c ) ;
public static List < SessionOutput > getOutput ( ) { List < SessionOutput > outputList = new ArrayList < SessionOutput > ( ) ; synchronized ( lock ) { for ( Long outputId : sessionOutputMap . keySet ( ) ) { SessionOutput sessionOutput = sessionOutputMap . get ( outputId ) ; //get output chars and set to output StringBuilder output = new StringBuilder(sessionOutput.getOutputChars().size()); for (Character ch : sessionOutput.getOutputChars()) { output.append(ch); } //sessionOutput.setOutput(output.toString().replaceAll("\\[.*?m|\\[.*?m","")); sessionOutput.setOutput(output.toString()); sessionOutput.setOutputChars(new ArrayList<Character>()); outputList.add(sessionOutput); //put back with new char array sessionOutputMap.put(sessionOutput.getSessionId(), sessionOutput); } } return outputList; }
public static List < String > getEC2Regions ( Long adminId ) { List < String > ec2RegionList = new ArrayList < String > ( ) ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select distinct ec2_region from ec2_keys where admin_id=? " ) ; stmt . setLong ( 1 , adminId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { ec2RegionList . add ( rs . getString ( " ec2_region " ) ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return ec2RegionList ;
public static SortedSet getSystemSet ( SortedSet sortedSet , Long adminId ) { List < HostSystem > hostSystemList = new ArrayList < HostSystem > ( ) ; String orderBy = " " ; if ( sortedSet . getOrderByField ( ) ! = null & & ! sortedSet . getOrderByField ( ) . trim ( ) . equals ( " " ) ) { orderBy = " order by " + sortedSet . getOrderByField ( ) + " " + sortedSet . getOrderByDirection ( ) ; } String sql = " select * from system where admin_id= ? " + orderBy ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( sql ) ; stmt . setLong ( 1 , adminId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { HostSystem hostSystem = new HostSystem ( ) ; hostSystem . setId ( rs . getLong ( " id " ) ) ; hostSystem . setDisplayNm ( rs . getString ( " display_nm " ) ) ; hostSystem . setInstanceId ( rs . getString ( " instance_id " ) ) ; hostSystem . setUser ( rs . getString ( " user " ) ) ; hostSystem . setHost ( rs . getString ( " host " ) ) ; hostSystem . setPort ( rs . getInt ( " port " ) ) ; hostSystem . setKeyNm ( rs . getString ( " key_nm " ) ) ; hostSystem . setEc2Region ( rs . getString ( " region " ) ) ; hostSystem . setState ( rs . getString ( " state " ) ) ; hostSystem . setAdminId ( rs . getLong ( " admin_id " ) ) ; hostSystemList . add ( hostSystem ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; sortedSet . setItemList ( hostSystemList ) ; return sortedSet ;
public static HostSystem getSystem ( String instanceId , Long adminId ) { HostSystem hostSystem = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from system where instance_id like ? and admin_id =? " ) ; stmt . setString ( 1 , instanceId ) ; stmt . setLong ( 2 , adminId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { hostSystem = new HostSystem ( ) ; hostSystem . setId ( rs . getLong ( " id " ) ) ; hostSystem . setDisplayNm ( rs . getString ( " display_nm " ) ) ; hostSystem . setInstanceId ( rs . getString ( " instance_id " ) ) ; hostSystem . setUser ( rs . getString ( " user " ) ) ; hostSystem . setHost ( rs . getString ( " host " ) ) ; hostSystem . setPort ( rs . getInt ( " port " ) ) ; hostSystem . setKeyNm ( rs . getString ( " key_nm " ) ) ; hostSystem . setEc2Region ( rs . getString ( " region " ) ) ; hostSystem . setState ( rs . getString ( " state " ) ) ; hostSystem . setAdminId ( rs . getLong ( " admin_id " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return hostSystem ; }
public static void setSystems ( List < HostSystem > hostSystemList , String ec2Region , Long adminId ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; //delete all systems for region PreparedStatement stmt = con.prepareStatement("delete from system where region like ? and admin_id=?"); stmt.setString(1, ec2Region); stmt.setLong(2, adminId); stmt.execute(); DBUtils.closeStmt(stmt); //insert new host systems for(HostSystem hostSystem:hostSystemList){ insertSystem(con, hostSystem); } } catch (Exception e) { e.printStackTrace(); } DBUtils.closeConn(con);
public static Connection getConn ( ) { Connection con = null ; try { Class . forName ( " org.h2.Driver " ) ; // create a database connection String user="ec2box"; String password="filepwd 0WJLnwhpA47EepT1A4drVnDn3vYRvJhpZi0sVdvN9SmlbKw"; con = DriverManager.getConnection("jdbc:h2:" + DB_PATH + "/ec2box;CIPHER=AES",user,password); } catch (Exception ex) { ex.printStackTrace(); } return con;
public static void addOutput ( SessionOutput sessionOutput ) { if ( sessionOutput ! = null ) { synchronized ( sessionOutputMap ) {
public static void removeOutput ( SessionOutput sessionOutput ) { if ( sessionOutput ! = null ) { synchronized ( sessionOutputMap ) {
public static List < SessionOutput > getOutput ( ) { List < SessionOutput > outputList = new ArrayList < SessionOutput > ( ) ; synchronized ( sessionOutputMap ) { for ( Long outputId : sessionOutputMap . keySet ( ) ) { SessionOutput sessionOutput = sessionOutputMap . get ( outputId ) ; //get output chars and set to output StringBuilder output = new StringBuilder(sessionOutput.getOutputChars().size()); for (Character ch : sessionOutput.getOutputChars()) { output.append(ch); } //sessionOutput.setOutput(output.toString().replaceAll("\\[.*?m|\\[.*?m","")); sessionOutput.setOutput(output.toString()); sessionOutput.setOutputChars(new ArrayList<Character>()); outputList.add(sessionOutput); //put back with new char array sessionOutputMap.put(sessionOutput.getSessionId(), sessionOutput); } } return outputList; }
public void init ( FilterConfig config ) throws ServletException { } public void destroy ( ) { } /** * doFilter determines if user is an administrator or redirect to login page * * @param req task request * @param resp task response * @param chain filter chain * @throws ServletException * @throws IOException */ public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { HttpServletRequest servletRequest = ( HttpServletRequest ) req ; HttpServletResponse servletResponse = ( HttpServletResponse ) resp ; boolean isAdmin = false ; //read auth token String authToken = AuthUtil.getAuthToken(servletRequest.getSession()); //check if exists if (authToken != null && !authToken.trim().equals("")) { String userType = AuthDB.isAuthorized(authToken); if (userType != null) { String uri = servletRequest.getRequestURI(); if (Auth.MANAGER.equals(userType)) { isAdmin = true; } else if (uri.matches("^\\/admin\\/.*") && Auth.ADMINISTRATOR.equals(userType)) { isAdmin = true; } servletRequest.getSession().setAttribute("userType", userType); //check to see if user has timed out String timeStr = AuthUtil.getTimeout(servletRequest.getSession()); try { if (timeStr != null && !timeStr.trim().equals("")) { SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); Date cookieTimeout = sdf.parse(timeStr); Date currentTime = new Date(); //if current time > timeout then redirect to login page if (cookieTimeout == null || currentTime.after(cookieTimeout)) { isAdmin = false; } else { AuthUtil.setTimeout(servletRequest.getSession()); } } else { isAdmin = false; } } catch (Exception ex) { ex.printStackTrace(); isAdmin = false; } } } //if not admin redirect to login page if (!isAdmin) { AuthUtil.deleteAllSession(servletRequest.getSession()); servletResponse.sendRedirect((servletRequest.getContextPath() + "/login.action")); } else { chain.doFilter(req, resp); } } }
public void destroy ( ) { } /** * doFilter determines if user is an administrator or redirect to login page * * @param req task request * @param resp task response * @param chain filter chain * @throws ServletException * @throws IOException */ public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { HttpServletRequest servletRequest = ( HttpServletRequest ) req ; HttpServletResponse servletResponse = ( HttpServletResponse ) resp ; boolean isAdmin = false ; //read auth token String authToken = AuthUtil.getAuthToken(servletRequest.getSession()); //check if exists if (authToken != null && !authToken.trim().equals("")) { String userType = AuthDB.isAuthorized(authToken); if (userType != null) { String uri = servletRequest.getRequestURI(); if (Auth.MANAGER.equals(userType)) { isAdmin = true; } else if (uri.matches("^\\/admin\\/.*") && Auth.ADMINISTRATOR.equals(userType)) { isAdmin = true; } servletRequest.getSession().setAttribute("userType", userType); //check to see if user has timed out String timeStr = AuthUtil.getTimeout(servletRequest.getSession()); try { if (timeStr != null && !timeStr.trim().equals("")) { SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); Date cookieTimeout = sdf.parse(timeStr); Date currentTime = new Date(); //if current time > timeout then redirect to login page if (cookieTimeout == null || currentTime.after(cookieTimeout)) { isAdmin = false; } else { AuthUtil.setTimeout(servletRequest.getSession()); } } else { isAdmin = false; } } catch (Exception ex) { ex.printStackTrace(); isAdmin = false; } } } //if not admin redirect to login page if (!isAdmin) { AuthUtil.deleteAllSession(servletRequest.getSession()); servletResponse.sendRedirect((servletRequest.getContextPath() + "/login.action")); } else { chain.doFilter(req, resp); } } }
public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { HttpServletRequest servletRequest = ( HttpServletRequest ) req ; HttpServletResponse servletResponse = ( HttpServletResponse ) resp ; boolean isAdmin = false ; //read auth token String authToken = AuthUtil.getAuthToken(servletRequest.getSession()); //check if exists if (authToken != null && !authToken.trim().equals("")) { String userType = AuthDB.isAuthorized(authToken); if (userType != null) { String uri = servletRequest.getRequestURI(); if (Auth.MANAGER.equals(userType)) { isAdmin = true; } else if (uri.matches("^\\/admin\\/.*") && Auth.ADMINISTRATOR.equals(userType)) { isAdmin = true; } servletRequest.getSession().setAttribute("userType", userType); //check to see if user has timed out String timeStr = AuthUtil.getTimeout(servletRequest.getSession()); try { if (timeStr != null && !timeStr.trim().equals("")) { SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); Date cookieTimeout = sdf.parse(timeStr); Date currentTime = new Date(); //if current time > timeout then redirect to login page if (cookieTimeout == null || currentTime.after(cookieTimeout)) { isAdmin = false; } else { AuthUtil.setTimeout(servletRequest.getSession()); } } else { isAdmin = false; } } catch (Exception ex) { ex.printStackTrace(); isAdmin = false; } } } //if not admin redirect to login page if (!isAdmin) { AuthUtil.deleteAllSession(servletRequest.getSession());
public static void setSessionId ( HttpSession session , Long sessionId ) { if ( sessionId ! = null ) { session . setAttribute ( " sessionId " , EncryptionUtil . encrypt ( sessionId . toString ( ) ) ) ;
public static Long getSessionId ( HttpSession session ) { Long sessionId = null ; String sessionIdStr = EncryptionUtil . decrypt ( ( String ) session . getAttribute ( " sessionId " ) ) ; if ( sessionIdStr ! = null & & ! sessionIdStr . trim ( ) . equals ( " " ) ) { sessionId = Long . parseLong ( sessionIdStr ) ; } return sessionId ; }
public static Long getUserId ( HttpSession session ) { Long userId = null ; String userIdStr = EncryptionUtil . decrypt ( ( String ) session . getAttribute ( " userId " ) ) ; if ( userIdStr ! = null & & ! userIdStr . trim ( ) . equals ( " " ) ) { userId = Long . parseLong ( userIdStr ) ; } return userId ; }
public static String getAuthToken ( HttpSession session ) { String authToken = ( String ) session . getAttribute ( " authToken " ) ; authToken = EncryptionUtil . decrypt ( authToken ) ; return authToken ; }
public static String getTimeout ( HttpSession session ) { String timeout = ( String ) session . getAttribute ( " timeout " ) ; return timeout ; }
public static void setUserId ( HttpSession session , Long userId ) { if ( userId ! = null ) { session . setAttribute ( " userId " , EncryptionUtil . encrypt ( userId . toString ( ) ) ) ;
public static void setAuthToken ( HttpSession session , String authToken ) { if ( authToken ! = null & & ! authToken . trim ( ) . equals ( " " ) ) { session . setAttribute ( " authToken " , EncryptionUtil . encrypt ( authToken ) ) ;
public static void setTimeout ( HttpSession session ) { //set session timeout SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); Calendar timeout = Calendar.getInstance(); timeout.add(Calendar.MINUTE, 15); session.setAttribute("timeout", sdf.format(timeout.getTime())); }
public static void deleteAllSession ( HttpSession session ) { session . setAttribute ( " timeout " , null ) ; session . setAttribute ( " authToken " , null ) ; session . setAttribute ( " userId " , null ) ; session . setAttribute ( " sessionId " , null ) ; session . invalidate ( ) ; }
public String setAWSCred ( ) { awsCred = AWSCredDB . getAWSCred ( ) ; return SUCCESS ;
public String submitAWSCred ( ) { AWSCredDB . setAWSCred ( awsCred ) ; return SUCCESS ;
public Map < String , Object > getSession ( ) { return session ; }
public void setSession ( Map < String , Object > session ) { this . session = session ; }
public String viewEC2Keys ( ) { AWSCred awsCred = AWSCredDB . getAWSCred ( ) ; //check to see if aws creds have been set if (awsCred != null) { sortedSet = EC2KeyDB.getEC2KeySet(sortedSet); } else { addActionMessage("EC2 Keys not available. Set AWS credentials <a href=\"setAWSCred.action\">here</a>"); } return SUCCESS;
public String getKeyPairJSON ( ) { AWSCred awsCred = AWSCredDB . getAWSCred ( ) ; //set AWS credentials for service BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.setEndpoint(ec2Key.getEc2Region()); DescribeKeyPairsRequest describeKeyPairsRequest = new DescribeKeyPairsRequest(); DescribeKeyPairsResult describeKeyPairsResult = service.describeKeyPairs(describeKeyPairsRequest); List<KeyPairInfo> keyPairInfoList = describeKeyPairsResult.getKeyPairs(); String json = new Gson().toJson(keyPairInfoList); try { servletResponse.getOutputStream().write(json.getBytes()); } catch (Exception ex) { ex.printStackTrace(); } return null; }
public String submitEC2Key ( ) { String retVal = SUCCESS ; try { //get AWS credentials from DB AWSCred awsCred = AWSCredDB.getAWSCred(); //set AWS credentials for service BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); //create service AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.setEndpoint(ec2Key.getEc2Region()); //create key pair request CreateKeyPairRequest createKeyPairRequest = new CreateKeyPairRequest(); createKeyPairRequest.withKeyName(ec2Key.getKeyNm()); //call service CreateKeyPairResult createKeyPairResult = service.createKeyPair(createKeyPairRequest); //get key pair result KeyPair keyPair = createKeyPairResult.getKeyPair(); //set private key String privateKey = keyPair.getKeyMaterial(); ec2Key.setPrivateKey(privateKey); //add to db Long keyId = EC2KeyDB.saveEC2Key(ec2Key); //store private key SSHUtil.storePrivateKey(keyId.toString(), ec2Key.getPrivateKey().trim()); } catch (AmazonServiceException ex) { addActionError(ex.getMessage()); retVal = INPUT; } return retVal;
public String importEC2Key ( ) { String retVal = SUCCESS ; try { //get AWS credentials from DB AWSCred awsCred = AWSCredDB.getAWSCred(); //set AWS credentials for service BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); //create service AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.setEndpoint(ec2Key.getEc2Region()); //describe key pair request DescribeKeyPairsRequest describeKeyPairsRequest = new DescribeKeyPairsRequest(); describeKeyPairsRequest.setKeyNames(Arrays.asList(ec2Key.getKeyNm())); //call service DescribeKeyPairsResult describeKeyPairsResult = service.describeKeyPairs(describeKeyPairsRequest); if (describeKeyPairsResult != null && describeKeyPairsResult.getKeyPairs().size() > 0) { //add to db Long keyId = EC2KeyDB.saveEC2Key(ec2Key); SSHUtil.storePrivateKey(keyId.toString(), ec2Key.getPrivateKey().trim()); } else { addActionError("Imported key does not exist on AWS"); retVal = INPUT; } } catch (AmazonServiceException ex) { addActionError(ex.getMessage()); retVal = INPUT; } return retVal;
public String loginSubmit ( ) { String retVal = SUCCESS ; String authToken = AuthDB . loginAdmin ( auth ) ; if ( authToken ! = null ) { AuthUtil . setAuthToken ( servletRequest . getSession ( ) , authToken ) ; AuthUtil . setUserId ( servletRequest . getSession ( ) , AuthDB . getUserIdByAuthToken ( authToken ) ) ; AuthUtil . setTimeout ( servletRequest . getSession ( ) ) ; } else { addActionError ( " Invalid username and password combination " ) ; retVal = INPUT ; } if ( retVal = = SUCCESS & & " changeme " . equals ( auth . getPassword ( ) ) ) { retVal = " change_password " ; } return retVal ; }
public String logout ( ) { AuthUtil . deleteAllSession ( servletRequest . getSession ( ) ) ; return SUCCESS ; }
public String passwordSubmit ( ) { String retVal = SUCCESS ; if ( auth . getPassword ( ) . equals ( auth . getPasswordConfirm ( ) ) ) { auth . setAuthToken ( AuthUtil . getAuthToken ( servletRequest . getSession ( ) ) ) ; if ( ! AuthDB . updatePassword ( auth ) ) { addActionError ( " Current password is invalid " ) ; retVal = INPUT ; } } else { addActionError ( " Passwords do not match " ) ; retVal = INPUT ; } return retVal ; }
public void validateLoginSubmit ( ) { if ( auth . getUsername ( ) = = null | | auth . getUsername ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " auth.username " , " Required " ) ; } if ( auth . getPassword ( ) = = null | | auth . getPassword ( ) . trim ( ) . equals ( " " ) ) {
public void validatePasswordSubmit ( ) { if ( auth . getPassword ( ) = = null | | auth . getPassword ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " auth.password " , " Required " ) ; } if ( auth . getPasswordConfirm ( ) = = null | | auth . getPasswordConfirm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " auth.passwordConfirm " , " Required " ) ; } if ( auth . getPrevPassword ( ) = = null | | auth . getPrevPassword ( ) . trim ( ) . equals ( " " ) ) {
public void setAuth ( Auth auth ) { this . auth = auth ; }
public String viewScripts ( ) { sortedSet = ScriptDB . getScriptSet ( sortedSet , AuthUtil . getUserId ( servletRequest . getSession ( ) ) ) ; return SUCCESS ; }
public String saveScript ( ) { script . setUserId ( AuthUtil . getUserId ( servletRequest . getSession ( ) ) ) ; if ( script . getId ( ) ! = null ) { ScriptDB . updateScript ( script ) ; } else { ScriptDB . insertScript ( script ) ; } return SUCCESS ; }
public String deleteScript ( ) { if ( script . getId ( ) ! = null ) { ScriptDB . deleteScript ( script . getId ( ) , AuthUtil . getUserId ( servletRequest . getSession ( ) ) ) ; } return SUCCESS ; }
public void validateSaveScript ( ) { if ( script = = null | | script . getDisplayNm ( ) = = null | | script . getDisplayNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " script.displayNm " , " Required " ) ; } if ( script = = null | | script . getScript ( ) = = null | | script . getScript ( ) . trim ( ) . equals ( " " ) | | ( new Script ( ) ) . getScript ( ) . trim ( ) . equals ( script . getScript ( ) . trim ( ) ) ) { addFieldError ( " script.script " , " Required " ) ; } if ( ! this . getFieldErrors ( ) . isEmpty ( ) ) { sortedSet = ScriptDB . getScriptSet ( sortedSet , AuthUtil . getUserId ( servletRequest . getSession ( ) ) ) ;
public String runCmd ( ) { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; if ( userId ! = null ) { try { //if id then write to single system output buffer if (idList != null && idList.size() > 0) { for (Long id : idList) { //get servletRequest.getSession() for user UserSchSessions userSchSessions = userSchSessionMap.get(userId); if (userSchSessions != null) { SchSession schSession = userSchSessions.getSchSessionMap().get(id); if (keyCode != null) { if (keyMap.containsKey(keyCode)) { schSession.getCommander().write(keyMap.get(keyCode)); } } else { schSession.getCommander().print(command); } } } } } catch (Exception ex) { ex.printStackTrace(); } } return null; }
public String getOutputJSON ( ) { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; if ( userId ! = null ) { try { List < SessionOutput > outputList = SessionOutputUtil . getOutput ( userId ) ; String json = new Gson ( ) . toJson ( outputList ) ; servletResponse . getOutputStream ( ) . write ( json . getBytes ( ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } return null ; }
public String getNextPendingSystemForTerms ( ) { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; currentSystemStatus = SystemStatusDB . getSystemStatus ( pendingSystemStatus . getId ( ) , userId ) ; currentSystemStatus . setErrorMsg ( " Auth fail " ) ; currentSystemStatus . setStatusCd ( HostSystem . GENERIC_FAIL_STATUS ) ; SystemStatusDB . updateSystemStatus ( currentSystemStatus , userId ) ; pendingSystemStatus = SystemStatusDB . getNextPendingSystem ( userId ) ; return SUCCESS ; }
public String selectSystemsForCompositeTerms ( ) { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; //exit any previous terms exitTerms(); if (systemSelectId != null && !systemSelectId.isEmpty()) { SystemStatusDB.setInitialSystemStatus(systemSelectId, userId); pendingSystemStatus = SystemStatusDB.getNextPendingSystem(userId); AuthUtil.setSessionId(servletRequest.getSession(), SessionAuditDB.createSessionLog(userId)); } return SUCCESS; }
public String exitTerms ( ) { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; //check user map if (userSchSessionMap != null && !userSchSessionMap.isEmpty()) { //get user servletRequest.getSession()s for (Long userKey : userSchSessionMap.keySet()) { UserSchSessions userSchSessions = userSchSessionMap.get(userKey); //get current time and subtract number of hours set to determine expire time Calendar expireTime = Calendar.getInstance(); expireTime.add(Calendar.HOUR, (-1 * Integer.parseInt(AppConfigLkup.getProperty("timeoutSshAfter"))));//subtract hours to get expire time //if current user or session has timed out remove ssh session if (userId.equals(userKey) || userSchSessions.getStartTime().before(expireTime.getTime())) { Map<Long, SchSession> schSessionMap = userSchSessionMap.get(userKey).getSchSessionMap(); for (Long sessionKey : schSessionMap.keySet()) { SchSession schSession = schSessionMap.get(sessionKey); //disconnect ssh session schSession.getChannel().disconnect(); schSession.getSession().disconnect(); schSession.setChannel(null); schSession.setSession(null); schSession.setInputToChannel(null); schSession.setCommander(null); schSession.setOutFromChannel(null); schSession = null; //remove from map schSessionMap.remove(sessionKey); } //clear and remove session map for user schSessionMap.clear(); userSchSessionMap.remove(userKey); SessionOutputUtil.removeUserSession(userKey); } } } return SUCCESS; }
public HostSystem getCurrentSystemStatus ( ) { return currentSystemStatus ; }
public void setCurrentSystemStatus ( HostSystem currentSystemStatus ) { this . currentSystemStatus = currentSystemStatus ; }
public HostSystem getPendingSystemStatus ( ) { return pendingSystemStatus ; }
public void setPendingSystemStatus ( HostSystem pendingSystemStatus ) { this . pendingSystemStatus = pendingSystemStatus ; }
public static Map < Long , UserSchSessions > getUserSchSessionMap ( ) { return userSchSessionMap ; }
public static void setUserSchSessionMap ( Map < Long , UserSchSessions > userSchSessionMap ) { SecureShellAction . userSchSessionMap = userSchSessionMap ; }
public List < HostSystem > getSystemList ( ) { return systemList ; }
public void setSystemList ( List < HostSystem > systemList ) { this . systemList = systemList ; }
public String viewSessions ( ) { if ( sortedSet . getOrderByField ( ) = = null | | sortedSet . getOrderByField ( ) . trim ( ) . equals ( " " ) ) { sortedSet . setOrderByField ( SessionAuditDB . SORT_BY_SESSION_TM ) ; sortedSet . setOrderByDirection ( " desc " ) ; } sortedSet = SessionAuditDB . getSessions ( sortedSet ) ; return SUCCESS ;
public String getTermsForSession ( ) { sessionAudit = SessionAuditDB . getSessionsTerminals ( sessionId ) ; return SUCCESS ;
public String getJSONTermOutputForSession ( ) { String json = new Gson ( ) . toJson ( SessionAuditDB . getTerminalLogsForSession ( sessionId , hostSystemId ) ) ; try { servletResponse . getOutputStream ( ) . write ( json . getBytes ( ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return null ;
public SessionAudit getSessionAudit ( ) { return sessionAudit ; }
public void setSessionAudit ( SessionAudit sessionAudit ) { this . sessionAudit = sessionAudit ; }
public Long getHostSystemId ( ) { return hostSystemId ; }
public void setHostSystemId ( Long hostSystemId ) { this . hostSystemId = hostSystemId ; }
public String saveSystem ( ) { if ( hostSystem . getId ( ) ! = null ) { SystemDB . updateSystem ( hostSystem ) ; } return SUCCESS ; }
public List < String > getInstanceIdList ( ) { return instanceIdList ; }
public void setInstanceIdList ( List < String > instanceIdList ) { this . instanceIdList = instanceIdList ; }
public String setUpload ( ) throws Exception { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; SystemStatusDB . setInitialSystemStatus ( idList , userId ) ; return SUCCESS ;
public String upload ( ) { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; try { File destination = new File ( UPLOAD_PATH , uploadFileName ) ; FileUtils . copyFile ( upload , destination ) ; pendingSystemStatus = SystemStatusDB . getNextPendingSystem ( userId ) ; systemStatusList = SystemStatusDB . getAllSystemStatus ( userId ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return INPUT ; } return SUCCESS ; }
public String push ( ) { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; try { //get next pending system pendingSystemStatus = SystemStatusDB.getNextPendingSystem(userId); if (pendingSystemStatus != null) { //get session for system SchSession session = SecureShellAction.getUserSchSessionMap().get(userId).getSchSessionMap().get(pendingSystemStatus.getId()); //push upload to system currentSystemStatus = SSHUtil.pushUpload(pendingSystemStatus, session.getSession(), UPLOAD_PATH + "/" + uploadFileName, pushDir + "/" + uploadFileName); //update system status SystemStatusDB.updateSystemStatus(currentSystemStatus,userId); pendingSystemStatus = SystemStatusDB.getNextPendingSystem(userId); } //if push has finished to all servers then delete uploaded file if (pendingSystemStatus == null) { File delFile = new File(UPLOAD_PATH, uploadFileName); FileUtils.deleteQuietly(delFile); } systemStatusList = SystemStatusDB.getAllSystemStatus(userId); } catch (Exception e) { e.printStackTrace(); } return SUCCESS; }
public List < HostSystem > getSystemStatusList ( ) { return systemStatusList ; }
public void setSystemStatusList ( List < HostSystem > systemStatusList ) { this . systemStatusList = systemStatusList ; }
public String viewUsers ( ) { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; sortedSet = UserDB . getUserSet ( sortedSet ) ; return SUCCESS ; }
public String saveUser ( ) { if ( user . getId ( ) ! = null ) { if ( user . getPassword ( ) = = null | | user . getPassword ( ) . trim ( ) . equals ( " " ) ) { User tmpUser = UserDB . getUser ( getUser ( ) . getId ( ) ) ; user . setPassword ( tmpUser . getPassword ( ) ) ; } UserDB . updateUser ( user ) ; } else { UserDB . insertUser ( user ) ; } return SUCCESS ; }
public String deleteUser ( ) { if ( user . getId ( ) ! = null ) { UserDB . disableUser ( user . getId ( ) ) ; } return SUCCESS ; }
public void validateSaveUser ( ) { if ( user = = null | | user . getUsername ( ) = = null | | user . getUsername ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " user.username " , " Required " ) ; } if ( user = = null | | user . getLastNm ( ) = = null | | user . getLastNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " user.lastNm " , " Required " ) ; } if ( user = = null | | user . getFirstNm ( ) = = null | | user . getFirstNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " user.firstNm " , " Required " ) ; } if ( user ! = null & & user . getPassword ( ) ! = null & & ! user . getPassword ( ) . trim ( ) . equals ( " " ) & & ! user . getPassword ( ) . equals ( user . getPasswordConfirm ( ) ) ) { addActionError ( " Passwords do not match " ) ; } if ( user ! = null & & user . getId ( ) = = null & & ( user . getPassword ( ) = = null | | user . getPassword ( ) . trim ( ) . equals ( " " ) ) ) { addActionError ( " Password is required " ) ; } if ( user ! = null & & ! UserDB . isUnique ( user . getId ( ) , user . getUsername ( ) ) ) { addActionError ( " Username has been taken " ) ; } if ( ! this . getFieldErrors ( ) . isEmpty ( ) | | ! this . getActionErrors ( ) . isEmpty ( ) ) { sortedSet = UserDB . getUserSet ( sortedSet ) ;
public void setUser ( User user ) { this . user = user ; }
public static AWSCred getAWSCred ( ) { AWSCred awsCred = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from aws_credentials " ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { awsCred = new AWSCred ( ) ; awsCred . setAccessKey ( rs . getString ( " access_key " ) ) ; awsCred . setSecretKey ( rs . getString ( " secret_key " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } //close db connection DBUtils.closeConn(con); return awsCred;
public static void setAWSCred ( AWSCred awsCred ) { //get db connection Connection con = DBUtils.getConn(); try { //delete PreparedStatement stmt = con.prepareStatement("delete from aws_credentials"); stmt.execute(); //insert stmt = con.prepareStatement("insert into aws_credentials (access_key, secret_key) values(?,?)"); stmt.setString(1, awsCred.getAccessKey()); stmt.setString(2, awsCred.getSecretKey()); stmt.execute(); DBUtils.closeStmt(stmt); } catch (Exception e) { e.printStackTrace(); } //close db connection DBUtils.closeConn(con);
public static Auth getAdminLogin ( String authToken ) { Auth auth = null ; if ( authToken ! = null & & ! authToken . trim ( ) . equals ( " " ) ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from users where auth_token=? " ) ; stmt . setString ( 1 , authToken ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { auth = new Auth ( ) ; auth . setId ( rs . getLong ( " id " ) ) ; auth . setAuthToken ( rs . getString ( " auth_token " ) ) ; auth . setUsername ( rs . getString ( " username " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; } return auth ; }
public static String loginAdmin ( Auth auth ) { String authToken = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from users where username=? and password=? " ) ; stmt . setString ( 1 , auth . getUsername ( ) ) ; stmt . setString ( 2 , EncryptionUtil . hash ( auth . getPassword ( ) ) ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { auth . setId ( rs . getLong ( " id " ) ) ; authToken = UUID . randomUUID ( ) . toString ( ) ; auth . setAuthToken ( authToken ) ; //set auth token updateAdmin(con, auth); } DBUtils.closeRs(rs); DBUtils.closeStmt(stmt); } catch (Exception e) { e.printStackTrace(); } DBUtils.closeConn(con); return authToken;
public static boolean isAdmin ( String authToken ) { boolean isAdmin = false ; Connection con = null ; if ( authToken ! = null & & ! authToken . trim ( ) . equals ( " " ) ) { try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from users where auth_token=? " ) ; stmt . setString ( 1 , authToken ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { isAdmin = true ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } DBUtils . closeConn ( con ) ; return isAdmin ;
private static void updateAdmin ( Connection con , Auth auth ) { try { PreparedStatement stmt = con . prepareStatement ( " update users set username=?, password=?, auth_token=? where id=? " ) ;
public static boolean updatePassword ( Auth auth ) { boolean success = false ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from users where auth_token like ? and password like ? " ) ; stmt . setString ( 1 , auth . getAuthToken ( ) ) ; stmt . setString ( 2 , EncryptionUtil . hash ( auth . getPrevPassword ( ) ) ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { stmt = con . prepareStatement ( " update users set password=? where auth_token like ? " ) ; stmt . setString ( 1 , EncryptionUtil . hash ( auth . getPassword ( ) ) ) ; stmt . setString ( 2 , auth . getAuthToken ( ) ) ; stmt . execute ( ) ; success = true ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return success ; }
public static Long getUserIdByAuthToken ( Connection con , String authToken ) { Long userId = null ; try { PreparedStatement stmt = con . prepareStatement ( " select * from users where auth_token like ? " ) ; stmt . setString ( 1 , authToken ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { userId = rs . getLong ( " id " ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return userId ;
public static Long getUserIdByAuthToken ( String authToken ) { Long userId = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; userId = getUserIdByAuthToken ( con , authToken ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return userId ;
public static String isAuthorized ( String authToken ) { String authorized = null ; Connection con = null ; if ( authToken ! = null & & ! authToken . trim ( ) . equals ( " " ) ) { try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from users where auth_token=? " ) ; stmt . setString ( 1 , authToken ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { authorized = rs . getString ( " user_type " ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } DBUtils . closeConn ( con ) ; return authorized ;
public static SortedSet getEC2KeySet ( SortedSet sortedSet ) { List < EC2Key > ec2KeyList = new ArrayList < EC2Key > ( ) ; String orderBy = " " ; if ( sortedSet . getOrderByField ( ) ! = null & & ! sortedSet . getOrderByField ( ) . trim ( ) . equals ( " " ) ) { orderBy = " order by " + sortedSet . getOrderByField ( ) + " " + sortedSet . getOrderByDirection ( ) ; } Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from ec2_keys " + orderBy ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { EC2Key ec2Key = new EC2Key ( ) ; ec2Key . setId ( rs . getLong ( " id " ) ) ; ec2Key . setKeyNm ( rs . getString ( " key_nm " ) ) ; ec2Key . setEc2Region ( rs . getString ( " ec2_region " ) ) ; ec2KeyList . add ( ec2Key ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; sortedSet . setItemList ( ec2KeyList ) ; return sortedSet ;
public static EC2Key getEC2KeyByKeyNm ( String keyNm , String ec2Region ) { EC2Key ec2Key = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from ec2_keys where key_nm like ? and ec2_region like ? " ) ; stmt . setString ( 1 , keyNm ) ; stmt . setString ( 2 , ec2Region ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { ec2Key = new EC2Key ( ) ; ec2Key . setId ( rs . getLong ( " id " ) ) ; ec2Key . setKeyNm ( rs . getString ( " key_nm " ) ) ; ec2Key . setEc2Region ( rs . getString ( " ec2_region " ) ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return ec2Key ;
public static List < EC2Key > getEC2KeyByRegion ( String ec2Region ) { List < EC2Key > ec2KeyList = new ArrayList < EC2Key > ( ) ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from ec2_keys where ec2_region like ? " ) ; stmt . setString ( 1 , ec2Region ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { EC2Key ec2Key = new EC2Key ( ) ; ec2Key . setId ( rs . getLong ( " id " ) ) ; ec2Key . setKeyNm ( rs . getString ( " key_nm " ) ) ; ec2Key . setEc2Region ( rs . getString ( " ec2_region " ) ) ; ec2KeyList . add ( ec2Key ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return ec2KeyList ;
public static Long insertEC2Key ( EC2Key ec2Key ) { Connection con = null ; Long ec2KeyId = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " insert into ec2_keys (key_nm, ec2_region) values (?,?) " , Statement . RETURN_GENERATED_KEYS ) ; stmt . setString ( 1 , ec2Key . getKeyNm ( ) ) ; stmt . setString ( 2 , ec2Key . getEc2Region ( ) ) ; stmt . execute ( ) ; ResultSet rs = stmt . getGeneratedKeys ( ) ; if ( rs ! = null & & rs . next ( ) ) { ec2KeyId = rs . getLong ( 1 ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return ec2KeyId ;
public static Long saveEC2Key ( EC2Key ec2Key ) { Long ec2KeyId = null ; //get id for key if exists EC2Key ec2KeyTmp = getEC2KeyByKeyNm(ec2Key.getKeyNm(), ec2Key.getEc2Region()); if(ec2KeyTmp!=null){ ec2KeyId=ec2KeyTmp.getId(); //else insert if it doesn't exist }else{ ec2KeyId=insertEC2Key(ec2Key); } ec2KeyTmp=null; return ec2KeyId;
public static List < String > getEC2Regions ( ) { List < String > ec2RegionList = new ArrayList < String > ( ) ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select distinct ec2_region from ec2_keys " ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { ec2RegionList . add ( rs . getString ( " ec2_region " ) ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return ec2RegionList ;
public static SortedSet getScriptSet ( SortedSet sortedSet , Long userId ) { ArrayList < Script > scriptList = new ArrayList < Script > ( ) ; String orderBy = " " ; if ( sortedSet . getOrderByField ( ) ! = null & & ! sortedSet . getOrderByField ( ) . trim ( ) . equals ( " " ) ) { orderBy = " order by " + sortedSet . getOrderByField ( ) + " " + sortedSet . getOrderByDirection ( ) ; } String sql = " select * from scripts where user_id =? " + orderBy ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( sql ) ; stmt . setLong ( 1 , userId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { Script script = new Script ( ) ; script . setId ( rs . getLong ( " id " ) ) ; script . setDisplayNm ( rs . getString ( " display_nm " ) ) ; script . setScript ( rs . getString ( " script " ) ) ; script . setUserId ( rs . getLong ( " user_id " ) ) ; scriptList . add ( script ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; sortedSet . setItemList ( scriptList ) ; return sortedSet ; }
public static Script getScript ( Long scriptId , Long userId ) { Script script = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; script = getScript ( con , scriptId , userId ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return script ; }
public static Script getScript ( Connection con , Long scriptId , Long userId ) { Script script = null ; try { PreparedStatement stmt = con . prepareStatement ( " select * from scripts where id=? and user_id=? " ) ; stmt . setLong ( 1 , scriptId ) ; stmt . setLong ( 2 , userId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { script = new Script ( ) ; script . setId ( rs . getLong ( " id " ) ) ; script . setDisplayNm ( rs . getString ( " display_nm " ) ) ; script . setScript ( rs . getString ( " script " ) ) ; script . setUserId ( rs . getLong ( " user_id " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return script ; }
public static void insertScript ( Script script ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " insert into scripts (display_nm, script, user_id) values (?,?,?) " ) ; stmt . setString ( 1 , script . getDisplayNm ( ) ) ; stmt . setString ( 2 , script . getScript ( ) ) ; stmt . setLong ( 3 , script . getUserId ( ) ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void updateScript ( Script script ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " update scripts set display_nm=?, script=? where id=? and user_id=? " ) ; stmt . setString ( 1 , script . getDisplayNm ( ) ) ; stmt . setString ( 2 , script . getScript ( ) ) ; stmt . setLong ( 3 , script . getId ( ) ) ; stmt . setLong ( 4 , script . getUserId ( ) ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void deleteScript ( Long scriptId , Long userId ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " delete from scripts where id=? and user_id=? " ) ; stmt . setLong ( 1 , scriptId ) ; stmt . setLong ( 2 , userId ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void deleteAuditHistory ( Connection con ) { try {
public static SortedSet getSessions ( SortedSet sortedSet ) { //get db connection Connection con = null; List<SessionAudit> outputList = new LinkedList<SessionAudit>(); String orderBy = ""; if (sortedSet.getOrderByField() != null && !sortedSet.getOrderByField().trim().equals("")) { orderBy = " order by " + sortedSet.getOrderByField() + " " + sortedSet.getOrderByDirection(); } String sql = "select * from session_log, users where users.id= session_log.user_id " + orderBy; try { con = DBUtils.getConn(); deleteAuditHistory(con); PreparedStatement stmt = con.prepareStatement(sql); ResultSet rs = stmt.executeQuery(); while (rs.next()) { SessionAudit sessionAudit = new SessionAudit(); sessionAudit.setId(rs.getLong("session_log.id")); sessionAudit.setSessionTm(rs.getTimestamp("session_tm")); sessionAudit.setUser(UserDB.getUser(con, rs.getLong("user_id"))); outputList.add(sessionAudit); } DBUtils.closeStmt(stmt); } catch (Exception e) { e.printStackTrace(); } //close db connection DBUtils.closeConn(con); sortedSet.setItemList(outputList); return sortedSet;
public static Long createSessionLog ( Long userId ) { //get db connection Connection con = DBUtils.getConn(); Long sessionId = null; try { sessionId = createSessionLog(con, userId); } catch (Exception e) { e.printStackTrace(); } //close db connection DBUtils.closeConn(con); return sessionId; }
public static Long createSessionLog ( Connection con , Long userId ) { Long sessionId = null ; try { //insert PreparedStatement stmt = con.prepareStatement("insert into session_log (user_id) values(?)", Statement.RETURN_GENERATED_KEYS); stmt.setLong(1, userId); stmt.execute(); ResultSet rs = stmt.getGeneratedKeys(); if (rs != null && rs.next()) { sessionId = rs.getLong(1); } DBUtils.closeStmt(stmt); } catch (Exception e) { e.printStackTrace(); } return sessionId;
public static void insertTerminalLog ( SessionOutput sessionOutput ) { //get db connection Connection con = DBUtils.getConn(); try { insertTerminalLog(con, sessionOutput); } catch (Exception e) { e.printStackTrace(); } //close db connection DBUtils.closeConn(con); }
public static void insertTerminalLog ( Connection con , SessionOutput sessionOutput ) { try {
public static List < SessionOutput > getTerminalLogsForSession ( Long sessionId , Long hostSystemId ) { //get db connection Connection con = DBUtils.getConn(); List<SessionOutput> outputList = null; try { outputList = getTerminalLogsForSession(con, sessionId, hostSystemId); } catch (Exception e) { e.printStackTrace(); } //close db connection DBUtils.closeConn(con); return outputList; }
public static List < SessionOutput > getTerminalLogsForSession ( Connection con , Long sessionId , Long hostSystemId ) { List < SessionOutput > outputList = new LinkedList < SessionOutput > ( ) ; try { PreparedStatement stmt = con . prepareStatement ( " select * from terminal_log where system_id=? and session_id=? order by log_tm asc " ) ; stmt . setLong ( 1 , hostSystemId ) ; stmt . setLong ( 2 , sessionId ) ; ResultSet rs = stmt . executeQuery ( ) ; String output = " " ; while ( rs . next ( ) ) { output = output + rs . getString ( " output " ) ; } output = output . replaceAll ( " ( \\ u0007| \ u001B \\ [K) " , " " ) ; while ( output . contains ( " \ b " ) ) { output = output . replaceFirst ( " . \ b " , " " ) ; } DBUtils . closeRs ( rs ) ; SessionOutput sessionOutput = new SessionOutput ( ) ; sessionOutput . setHostSystemId ( hostSystemId ) ; sessionOutput . setSessionId ( sessionId ) ; sessionOutput . setOutput ( output ) ; outputList . add ( sessionOutput ) ; DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return outputList ;
public static List < HostSystem > getHostSystemsForSession ( Connection con , Long sessionId ) { List < HostSystem > hostSystemList = new ArrayList < HostSystem > ( ) ; try { PreparedStatement stmt = con . prepareStatement ( " select distinct system_id from terminal_log where session_id=? " ) ; stmt . setLong ( 1 , sessionId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { HostSystem hostSystem = SystemDB . getSystem ( con , rs . getLong ( " system_id " ) ) ; hostSystemList . add ( hostSystem ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return hostSystemList ;
public static SessionAudit getSessionsTerminals ( Long sessionId ) { //get db connection Connection con = null; SessionAudit sessionAudit = new SessionAudit(); String sql = "select * from session_log, users where users.id= session_log.user_id and session_log.id = ? "; try { con = DBUtils.getConn(); PreparedStatement stmt = con.prepareStatement(sql); stmt.setLong(1, sessionId); ResultSet rs = stmt.executeQuery(); while (rs.next()) { sessionAudit.setId(rs.getLong("session_log.id")); sessionAudit.setSessionTm(rs.getTimestamp("session_tm")); sessionAudit.setUser(UserDB.getUser(con, rs.getLong("user_id"))); sessionAudit.setHostSystemList(getHostSystemsForSession(con, sessionId)); } DBUtils.closeStmt(stmt); } catch (Exception e) { e.printStackTrace(); } //close db connection DBUtils.closeConn(con); return sessionAudit;
public static SortedSet getSystemSet ( SortedSet sortedSet , List < String > instanceIdList ) { List < HostSystem > hostSystemList = new ArrayList < HostSystem > ( ) ; if ( ! instanceIdList . isEmpty ( ) ) { String orderBy = " " ; if ( sortedSet . getOrderByField ( ) ! = null & & ! sortedSet . getOrderByField ( ) . trim ( ) . equals ( " " ) ) { orderBy = " order by " + sortedSet . getOrderByField ( ) + " " + sortedSet . getOrderByDirection ( ) ; } String sql = " select * from system where instance_id in ( " ; for ( int i = 0 ; i < instanceIdList . size ( ) ; i + + ) { if ( i = = instanceIdList . size ( ) - 1 ) sql = sql + " ' " + instanceIdList . get ( i ) + " ') " ; else sql = sql + " ' " + instanceIdList . get ( i ) + " ', " ; } sql = sql + orderBy ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( sql ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { HostSystem hostSystem = new HostSystem ( ) ; hostSystem . setId ( rs . getLong ( " id " ) ) ; hostSystem . setDisplayNm ( rs . getString ( " display_nm " ) ) ; hostSystem . setInstanceId ( rs . getString ( " instance_id " ) ) ; hostSystem . setUser ( rs . getString ( " user " ) ) ; hostSystem . setHost ( rs . getString ( " host " ) ) ; hostSystem . setPort ( rs . getInt ( " port " ) ) ; hostSystem . setKeyNm ( rs . getString ( " key_nm " ) ) ; hostSystem . setEc2Region ( rs . getString ( " region " ) ) ; hostSystem . setState ( rs . getString ( " state " ) ) ; hostSystemList . add ( hostSystem ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; sortedSet . setItemList ( hostSystemList ) ; } return sortedSet ;
public static HostSystem getSystem ( Long id ) { HostSystem hostSystem = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; getSystem ( con , id ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return hostSystem ; }
public static HostSystem getSystem ( Connection con , Long id ) { HostSystem hostSystem = null ; try { PreparedStatement stmt = con . prepareStatement ( " select * from system where id=? " ) ; stmt . setLong ( 1 , id ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { hostSystem = new HostSystem ( ) ; hostSystem . setId ( rs . getLong ( " id " ) ) ; hostSystem . setDisplayNm ( rs . getString ( " display_nm " ) ) ; hostSystem . setInstanceId ( rs . getString ( " instance_id " ) ) ; hostSystem . setUser ( rs . getString ( " user " ) ) ; hostSystem . setHost ( rs . getString ( " host " ) ) ; hostSystem . setPort ( rs . getInt ( " port " ) ) ; hostSystem . setKeyNm ( rs . getString ( " key_nm " ) ) ; hostSystem . setEc2Region ( rs . getString ( " region " ) ) ; hostSystem . setState ( rs . getString ( " state " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return hostSystem ; }
public static HostSystem getSystem ( String instanceId ) { HostSystem hostSystem = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; hostSystem = getSystem ( con , instanceId ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return hostSystem ; }
public static HostSystem getSystem ( Connection con , String instanceId ) { HostSystem hostSystem = null ; try { PreparedStatement stmt = con . prepareStatement ( " select * from system where instance_id like ? " ) ; stmt . setString ( 1 , instanceId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { hostSystem = new HostSystem ( ) ; hostSystem . setId ( rs . getLong ( " id " ) ) ; hostSystem . setDisplayNm ( rs . getString ( " display_nm " ) ) ; hostSystem . setInstanceId ( rs . getString ( " instance_id " ) ) ; hostSystem . setUser ( rs . getString ( " user " ) ) ; hostSystem . setHost ( rs . getString ( " host " ) ) ; hostSystem . setPort ( rs . getInt ( " port " ) ) ; hostSystem . setKeyNm ( rs . getString ( " key_nm " ) ) ; hostSystem . setEc2Region ( rs . getString ( " region " ) ) ; hostSystem . setState ( rs . getString ( " state " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return hostSystem ; }
public static void insertSystem ( Connection con , HostSystem hostSystem ) { try {
public static void updateSystem ( HostSystem hostSystem ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; updateSystem ( con , hostSystem ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void updateSystem ( Connection con , HostSystem hostSystem ) { try {
public static void setSystems ( List < HostSystem > hostSystemList ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; //insert new host systems for (HostSystem hostSystem : hostSystemList) { HostSystem hostSystemTmp = getSystem(con, hostSystem.getInstanceId()); if (hostSystemTmp == null) { insertSystem(con, hostSystem); } else { hostSystem.setId(hostSystemTmp.getId()); hostSystem.setUser(hostSystemTmp.getUser()); updateSystem(con, hostSystem); } } } catch (Exception e) { e.printStackTrace(); } DBUtils.closeConn(con);
public static void setInitialSystemStatus ( List < Long > systemSelectIds , Long userId ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; //deletes all old systems deleteAllSystemStatus(con, userId); for (Long hostSystemId : systemSelectIds) { HostSystem hostSystem= new HostSystem(); hostSystem.setId(hostSystemId); hostSystem.setStatusCd(HostSystem.INITIAL_STATUS); //insert new status insertSystemStatus(con, hostSystem, userId); } } catch (Exception e) { e.printStackTrace(); } DBUtils.closeConn(con); }
private static void deleteAllSystemStatus ( Connection con , Long userId ) { try {
private static void insertSystemStatus ( Connection con , HostSystem hostSystem , Long userId ) { try {
public static void updateSystemStatus ( HostSystem hostSystem , Long userId ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; updateSystemStatus ( con , hostSystem , userId ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void updateSystemStatus ( Connection con , HostSystem hostSystem , Long userId ) { try {
public static List < HostSystem > getAllSystemStatus ( Long userId ) { List < HostSystem > hostSystemList = new ArrayList < HostSystem > ( ) ; Connection con = null ; try { con = DBUtils . getConn ( ) ; hostSystemList = getAllSystemStatus ( con , userId ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return hostSystemList ;
private static List < HostSystem > getAllSystemStatus ( Connection con , Long userId ) { List < HostSystem > hostSystemList = new ArrayList < HostSystem > ( ) ; try { PreparedStatement stmt = con . prepareStatement ( " select * from status where user_id=? order by id asc " ) ; stmt . setLong ( 1 , userId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { HostSystem hostSystem = SystemDB . getSystem ( con , rs . getLong ( " id " ) ) ; hostSystem . setStatusCd ( rs . getString ( " status_cd " ) ) ; hostSystemList . add ( hostSystem ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return hostSystemList ;
public static HostSystem getSystemStatus ( Long systemId , Long userId ) { Connection con = null ; HostSystem hostSystem = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from status where id=? and user_id=? " ) ; stmt . setLong ( 1 , systemId ) ; stmt . setLong ( 2 , userId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { hostSystem = SystemDB . getSystem ( con , rs . getLong ( " id " ) ) ; hostSystem . setStatusCd ( rs . getString ( " status_cd " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return hostSystem ;
public static HostSystem getNextPendingSystem ( Long userId ) { HostSystem hostSystem = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from status where (status_cd like ? or status_cd like ? or status_cd like ?) and user_id=? order by id asc " ) ; stmt . setString ( 1 , HostSystem . INITIAL_STATUS ) ; stmt . setString ( 2 , HostSystem . AUTH_FAIL_STATUS ) ; stmt . setString ( 3 , HostSystem . PUBLIC_KEY_FAIL_STATUS ) ; stmt . setLong ( 4 , userId ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { hostSystem = SystemDB . getSystem ( con , rs . getLong ( " id " ) ) ; hostSystem . setStatusCd ( rs . getString ( " status_cd " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return hostSystem ;
public static SortedSet getUserSet ( SortedSet sortedSet ) { ArrayList < User > userList = new ArrayList < User > ( ) ; String orderBy = " " ; if ( sortedSet . getOrderByField ( ) ! = null & & ! sortedSet . getOrderByField ( ) . trim ( ) . equals ( " " ) ) { orderBy = " order by " + sortedSet . getOrderByField ( ) + " " + sortedSet . getOrderByDirection ( ) ; } String sql = " select * from users where enabled=true and user_type like ? " + orderBy ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( sql ) ; stmt . setString ( 1 , User . ADMINISTRATOR ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { User user = new User ( ) ; user . setId ( rs . getLong ( " id " ) ) ; user . setFirstNm ( rs . getString ( " first_nm " ) ) ; user . setLastNm ( rs . getString ( " last_nm " ) ) ; user . setEmail ( rs . getString ( " email " ) ) ; user . setUsername ( rs . getString ( " username " ) ) ; user . setPassword ( rs . getString ( " password " ) ) ; user . setUserType ( rs . getString ( " user_type " ) ) ; userList . add ( user ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; sortedSet . setItemList ( userList ) ; return sortedSet ; }
public static User getUser ( Long userId ) { User user = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; user = getUser ( con , userId ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return user ; }
public static User getUser ( Connection con , Long userId ) { User user = null ; try { PreparedStatement stmt = con . prepareStatement ( " select * from users where id=? " ) ; stmt . setLong ( 1 , userId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { user = new User ( ) ; user . setId ( rs . getLong ( " id " ) ) ; user . setFirstNm ( rs . getString ( " first_nm " ) ) ; user . setLastNm ( rs . getString ( " last_nm " ) ) ; user . setEmail ( rs . getString ( " email " ) ) ; user . setUsername ( rs . getString ( " username " ) ) ; user . setPassword ( rs . getString ( " password " ) ) ; user . setUserType ( rs . getString ( " user_type " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return user ; }
public static void insertUser ( User user ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " insert into users (first_nm, last_nm, email, username, user_type, password) values (?,?,?,?,?,?) " ) ; stmt . setString ( 1 , user . getFirstNm ( ) ) ; stmt . setString ( 2 , user . getLastNm ( ) ) ; stmt . setString ( 3 , user . getEmail ( ) ) ; stmt . setString ( 4 , user . getUsername ( ) ) ; stmt . setString ( 5 , user . getUserType ( ) ) ; stmt . setString ( 6 , EncryptionUtil . hash ( user . getPassword ( ) ) ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void updateUser ( User user ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " update users set first_nm=?, last_nm=?, email=?, username=?, user_type=?, password=? where id=? " ) ; stmt . setString ( 1 , user . getFirstNm ( ) ) ; stmt . setString ( 2 , user . getLastNm ( ) ) ; stmt . setString ( 3 , user . getEmail ( ) ) ; stmt . setString ( 4 , user . getUsername ( ) ) ; stmt . setString ( 5 , user . getUserType ( ) ) ; stmt . setString ( 6 , EncryptionUtil . hash ( user . getPassword ( ) ) ) ; stmt . setLong ( 7 , user . getId ( ) ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void disableUser ( Long userId ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " update users set enabled=false where id=? " ) ; stmt . setLong ( 1 , userId ) ; stmt . execute ( ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static boolean isUnique ( Long userId , String username ) { boolean isUnique = true ; if ( userId = = null ) { userId = - 99L ; } Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from users where enabled=true and lower(username) like lower(?) and id != ? " ) ; stmt . setString ( 1 , username ) ; stmt . setLong ( 2 , userId ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { isUnique = false ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return isUnique ;
public String getUserType ( ) { return userType ; }
public void setUserType ( String userType ) { this . userType = userType ; }
public void setUserId ( Long userId ) { this . userId = userId ; }
public Date getSessionTm ( ) { return sessionTm ; }
public void setSessionTm ( Date sessionTm ) { this . sessionTm = sessionTm ; }
public List < HostSystem > getHostSystemList ( ) { return hostSystemList ; }
public void setHostSystemList ( List < HostSystem > hostSystemList ) { this . hostSystemList = hostSystemList ; }
public Long getUserId ( ) { return userId ; }
public String getFirstNm ( ) { return firstNm ; }
public void setFirstNm ( String firstNm ) { this . firstNm = firstNm ; }
public String getLastNm ( ) { return lastNm ; }
public void setLastNm ( String lastNm ) { this . lastNm = lastNm ; }
public Map < Long , SchSession > getSchSessionMap ( ) { return schSessionMap ; }
public void setSchSessionMap ( Map < Long , SchSession > schSessionMap ) { this . schSessionMap = schSessionMap ; }
public Date getStartTime ( ) { return startTime ; }
public void setStartTime ( Date startTime ) { this . startTime = startTime ; }
public Map < Long , SessionOutput > getSessionOutputMap ( ) { return sessionOutputMap ; }
public void setSessionOutputMap ( Map < Long , SessionOutput > sessionOutputMap ) { this . sessionOutputMap = sessionOutputMap ; }
public void run ( ) { SessionAuditDB . insertTerminalLog ( sessionOutput ) ;
public static HostSystem pushUpload ( HostSystem hostSystem , Session session , String source , String destination ) { hostSystem . setStatusCd ( HostSystem . SUCCESS_STATUS ) ; Channel channel = null ; ChannelSftp c = null ; try { channel = session . openChannel ( " sftp " ) ; channel . setInputStream ( System . in ) ; channel . setOutputStream ( System . out ) ; channel . connect ( CHANNEL_TIMEOUT ) ; c = ( ChannelSftp ) channel ; destination = destination . replaceAll ( " ~ \\ /|~ " , " " ) ; //get file input stream FileInputStream file = new FileInputStream(source); c.put(file, destination); } catch (Exception e) { hostSystem.setErrorMsg(e.getMessage()); hostSystem.setStatusCd(HostSystem.GENERIC_FAIL_STATUS); } //exit if (c != null) { c.exit(); } //disconnect if (channel != null) { channel.disconnect(); } return hostSystem;
public static void removeUserSession ( Long userId ) { userSessionsOutputMap . remove ( userId ) ;
public static void removeOutput ( Long userId , Long hostSystemId ) { UserSessionsOutput userSessionsOutput = userSessionsOutputMap . get ( userId ) ; if ( userSessionsOutput ! = null ) { userSessionsOutput . getSessionOutputMap ( ) . remove ( hostSystemId ) ;
public static void addOutput ( Long userId , SessionOutput sessionOutput ) { UserSessionsOutput userSessionsOutput = userSessionsOutputMap . get ( userId ) ; if ( userSessionsOutput = = null ) { userSessionsOutputMap . put ( userId , new UserSessionsOutput ( ) ) ; userSessionsOutput = userSessionsOutputMap . get ( userId ) ; } userSessionsOutput . getSessionOutputMap ( ) . put ( sessionOutput . getHostSystemId ( ) , sessionOutput ) ;
public static void addCharToOutput ( Long userId , Long hostSystemId , char c ) { UserSessionsOutput userSessionsOutput = userSessionsOutputMap . get ( userId ) ; if ( userSessionsOutput ! = null ) { SessionOutput sessionOutput = userSessionsOutput . getSessionOutputMap ( ) . get ( hostSystemId ) ;
public static List < SessionOutput > getOutput ( Long userId ) { List < SessionOutput > outputList = new ArrayList < SessionOutput > ( ) ; UserSessionsOutput userSessionsOutput = userSessionsOutputMap . get ( userId ) ; if ( userSessionsOutput ! = null ) { for ( Long key : userSessionsOutput . getSessionOutputMap ( ) . keySet ( ) ) { //get output chars and set to output try { SessionOutput sessionOutput = (SessionOutput) BeanUtils.cloneBean(userSessionsOutput.getSessionOutputMap().get(key)); outputList.add(sessionOutput); ExecutorService executor = Executors.newCachedThreadPool(); executor.execute(new TerminalLogTask(sessionOutput)); userSessionsOutput.getSessionOutputMap().get(key).setOutput(""); } catch (Exception ex) { ex.printStackTrace(); } } } return outputList; }
public String runCmd ( ) { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; if ( userId ! = null ) { try { //if id then write to single system output buffer if (idList != null && idList.size() > 0) { for (Long id : idList) { //get servletRequest.getSession() for user UserSchSessions userSchSessions = userSchSessionMap.get(userId); if (userSchSessions != null) { SchSession schSession = userSchSessions.getSchSessionMap().get(id); if (keyCode != null) { if (keyMap.containsKey(keyCode)) { schSession.getCommander().write(keyMap.get(keyCode)); } } else { schSession.getCommander().print(command); } } } } } catch (Exception ex) { ex.printStackTrace(); } }else{ AuthUtil.deleteAllSession(servletRequest.getSession()); } return null; }
public String getOutputJSON ( ) { Connection con = DBUtils . getConn ( ) ; //this checks to see if session is valid Long userId = AuthDB.getUserIdByAuthToken(con, AuthUtil.getAuthToken(servletRequest.getSession())); if (userId != null) { //update timeout AuthUtil.setTimeout(servletRequest.getSession()); List<SessionOutput> outputList = SessionOutputUtil.getOutput(con, userId); String json = new Gson().toJson(outputList); try { servletResponse.getOutputStream().write(json.getBytes()); } catch (Exception ex) { ex.printStackTrace(); } }else{ AuthUtil.deleteAllSession(servletRequest.getSession()); } DBUtils.closeConn(con); return null; }
public void run ( ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( outFromChannel ) ) ; try { int value = 0 ;
public static void removeUserSession ( Long userId ) { UserSessionsOutput userSessionsOutput = userSessionsOutputMap . get ( userId ) ; if ( userSessionsOutput ! = null ) { userSessionsOutput . getSessionOutputMap ( ) . clear ( ) ; } userSessionsOutputMap . remove ( userId ) ;
public static List < SessionOutput > getOutput ( Connection con , Long userId ) { List < SessionOutput > outputList = new ArrayList < SessionOutput > ( ) ; UserSessionsOutput userSessionsOutput = userSessionsOutputMap . get ( userId ) ; if ( userSessionsOutput ! = null ) { for ( Long key : userSessionsOutput . getSessionOutputMap ( ) . keySet ( ) ) { //get output chars and set to output try { SessionOutput sessionOutput = (SessionOutput) BeanUtils.cloneBean(userSessionsOutput.getSessionOutputMap().get(key)); outputList.add(sessionOutput); SessionAuditDB.insertTerminalLog(con, sessionOutput); userSessionsOutput.getSessionOutputMap().get(key).setOutput(""); } catch (Exception ex) { ex.printStackTrace(); } } } return outputList; }
public static Auth getAdminLogin ( String authToken ) { Auth auth = null ; if ( authToken ! = null & & ! authToken . trim ( ) . equals ( " " ) ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from users where enabled=true and auth_token=? " ) ; stmt . setString ( 1 , authToken ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { auth = new Auth ( ) ; auth . setId ( rs . getLong ( " id " ) ) ; auth . setAuthToken ( rs . getString ( " auth_token " ) ) ; auth . setUsername ( rs . getString ( " username " ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; } return auth ; }
public static String loginAdmin ( Auth auth ) { String authToken = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from users where enabled=true and username=? and password=? " ) ; stmt . setString ( 1 , auth . getUsername ( ) ) ; stmt . setString ( 2 , EncryptionUtil . hash ( auth . getPassword ( ) ) ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { auth . setId ( rs . getLong ( " id " ) ) ; authToken = UUID . randomUUID ( ) . toString ( ) ; auth . setAuthToken ( authToken ) ; //set auth token updateAdmin(con, auth); } DBUtils.closeRs(rs); DBUtils.closeStmt(stmt); } catch (Exception e) { e.printStackTrace(); } DBUtils.closeConn(con); return authToken;
public static boolean isAdmin ( String authToken ) { boolean isAdmin = false ; Connection con = null ; if ( authToken ! = null & & ! authToken . trim ( ) . equals ( " " ) ) { try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from users where enabled=true and auth_token=? " ) ; stmt . setString ( 1 , authToken ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { isAdmin = true ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } DBUtils . closeConn ( con ) ; return isAdmin ;
public static Long getUserIdByAuthToken ( Connection con , String authToken ) { Long userId = null ; try { PreparedStatement stmt = con . prepareStatement ( " select * from users where enabled=true and auth_token like ? " ) ; stmt . setString ( 1 , authToken ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { userId = rs . getLong ( " id " ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return userId ;
public static String isAuthorized ( String authToken ) { String authorized = null ; Connection con = null ; if ( authToken ! = null & & ! authToken . trim ( ) . equals ( " " ) ) { try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from users where enabled=true and auth_token=? " ) ; stmt . setString ( 1 , authToken ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { authorized = rs . getString ( " user_type " ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } DBUtils . closeConn ( con ) ; return authorized ;
public void init ( FilterConfig config ) throws ServletException { } public void destroy ( ) { } /** * doFilter determines if user is an administrator or redirect to login page * * @param req task request * @param resp task response * @param chain filter chain * @throws ServletException * @throws IOException */ public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { HttpServletRequest servletRequest = ( HttpServletRequest ) req ; HttpServletResponse servletResponse = ( HttpServletResponse ) resp ; boolean isAdmin = false ; //read auth token String authToken = AuthUtil.getAuthToken(servletRequest.getSession()); //check if exists if (authToken != null && !authToken.trim().equals("")) { String userType = AuthDB.isAuthorized(authToken); if (userType != null) { String uri = servletRequest.getRequestURI(); if (Auth.MANAGER.equals(userType)) { isAdmin = true; } else if (uri.matches(".*\\/admin\\/.*") && Auth.ADMINISTRATOR.equals(userType)) { isAdmin = true; } AuthUtil.setUserType(servletRequest.getSession(), userType); //check to see if user has timed out String timeStr = AuthUtil.getTimeout(servletRequest.getSession()); try { if (timeStr != null && !timeStr.trim().equals("")) { SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); Date cookieTimeout = sdf.parse(timeStr); Date currentTime = new Date(); //if current time > timeout then redirect to login page if (cookieTimeout == null || currentTime.after(cookieTimeout)) { isAdmin = false; } else { AuthUtil.setTimeout(servletRequest.getSession()); } } else { isAdmin = false; } } catch (Exception ex) { ex.printStackTrace(); isAdmin = false; } } } //if not admin redirect to login page if (!isAdmin) { AuthUtil.deleteAllSession(servletRequest.getSession()); servletResponse.sendRedirect((servletRequest.getContextPath() + "/login.action")); } else { chain.doFilter(req, resp); } } }
public void destroy ( ) { } /** * doFilter determines if user is an administrator or redirect to login page * * @param req task request * @param resp task response * @param chain filter chain * @throws ServletException * @throws IOException */ public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { HttpServletRequest servletRequest = ( HttpServletRequest ) req ; HttpServletResponse servletResponse = ( HttpServletResponse ) resp ; boolean isAdmin = false ; //read auth token String authToken = AuthUtil.getAuthToken(servletRequest.getSession()); //check if exists if (authToken != null && !authToken.trim().equals("")) { String userType = AuthDB.isAuthorized(authToken); if (userType != null) { String uri = servletRequest.getRequestURI(); if (Auth.MANAGER.equals(userType)) { isAdmin = true; } else if (uri.matches(".*\\/admin\\/.*") && Auth.ADMINISTRATOR.equals(userType)) { isAdmin = true; } AuthUtil.setUserType(servletRequest.getSession(), userType); //check to see if user has timed out String timeStr = AuthUtil.getTimeout(servletRequest.getSession()); try { if (timeStr != null && !timeStr.trim().equals("")) { SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); Date cookieTimeout = sdf.parse(timeStr); Date currentTime = new Date(); //if current time > timeout then redirect to login page if (cookieTimeout == null || currentTime.after(cookieTimeout)) { isAdmin = false; } else { AuthUtil.setTimeout(servletRequest.getSession()); } } else { isAdmin = false; } } catch (Exception ex) { ex.printStackTrace(); isAdmin = false; } } } //if not admin redirect to login page if (!isAdmin) { AuthUtil.deleteAllSession(servletRequest.getSession()); servletResponse.sendRedirect((servletRequest.getContextPath() + "/login.action")); } else { chain.doFilter(req, resp); } } }
public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { HttpServletRequest servletRequest = ( HttpServletRequest ) req ; HttpServletResponse servletResponse = ( HttpServletResponse ) resp ; boolean isAdmin = false ; //read auth token String authToken = AuthUtil.getAuthToken(servletRequest.getSession()); //check if exists if (authToken != null && !authToken.trim().equals("")) { String userType = AuthDB.isAuthorized(authToken); if (userType != null) { String uri = servletRequest.getRequestURI(); if (Auth.MANAGER.equals(userType)) { isAdmin = true; } else if (uri.matches(".*\\/admin\\/.*") && Auth.ADMINISTRATOR.equals(userType)) { isAdmin = true; } AuthUtil.setUserType(servletRequest.getSession(), userType); //check to see if user has timed out String timeStr = AuthUtil.getTimeout(servletRequest.getSession()); try { if (timeStr != null && !timeStr.trim().equals("")) { SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); Date cookieTimeout = sdf.parse(timeStr); Date currentTime = new Date(); //if current time > timeout then redirect to login page if (cookieTimeout == null || currentTime.after(cookieTimeout)) { isAdmin = false; } else { AuthUtil.setTimeout(servletRequest.getSession()); } } else { isAdmin = false; } } catch (Exception ex) { ex.printStackTrace(); isAdmin = false; } } } //if not admin redirect to login page if (!isAdmin) { AuthUtil.deleteAllSession(servletRequest.getSession());
public static void setUserType ( HttpSession session , String userType ) { if ( userType ! = null ) { session . setAttribute ( " userType " , userType ) ;
public static String getUserType ( HttpSession session ) { String userType = ( String ) session . getAttribute ( " userType " ) ; return userType ; }
public String submitEC2Key ( ) { String retVal = SUCCESS ; try { //get AWS credentials from DB AWSCred awsCred = AWSCredDB.getAWSCred(); //set AWS credentials for service BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); //create service AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.setEndpoint(ec2Key.getEc2Region()); //create key pair request CreateKeyPairRequest createKeyPairRequest = new CreateKeyPairRequest(); createKeyPairRequest.withKeyName(ec2Key.getKeyNm()); //call service CreateKeyPairResult createKeyPairResult = service.createKeyPair(createKeyPairRequest); //get key pair result KeyPair keyPair = createKeyPairResult.getKeyPair(); //set private key String privateKey = keyPair.getKeyMaterial(); ec2Key.setPrivateKey(privateKey); //add to db EC2KeyDB.saveEC2Key(ec2Key); } catch (AmazonServiceException ex) { addActionError(ex.getMessage()); retVal = INPUT; } return retVal;
public String importEC2Key ( ) { String retVal = SUCCESS ; try { //get AWS credentials from DB AWSCred awsCred = AWSCredDB.getAWSCred(); //set AWS credentials for service BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); //create service AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.setEndpoint(ec2Key.getEc2Region()); //describe key pair request DescribeKeyPairsRequest describeKeyPairsRequest = new DescribeKeyPairsRequest(); describeKeyPairsRequest.setKeyNames(Arrays.asList(ec2Key.getKeyNm())); //call service DescribeKeyPairsResult describeKeyPairsResult = service.describeKeyPairs(describeKeyPairsRequest); if (describeKeyPairsResult != null && describeKeyPairsResult.getKeyPairs().size() > 0) { //add to db EC2KeyDB.saveEC2Key(ec2Key); } else { addActionError("Imported key does not exist on AWS"); retVal = INPUT; } } catch (AmazonServiceException ex) { addActionError(ex.getMessage()); retVal = INPUT; } return retVal;
public String deleteEC2Key ( ) { EC2KeyDB . deleteEC2Key ( ec2Key . getId ( ) ) ; return SUCCESS ;
public String push ( ) { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; try { //get next pending system pendingSystemStatus = SystemStatusDB.getNextPendingSystem(userId); if (pendingSystemStatus != null) { //get session for system SchSession session = SecureShellAction.getUserSchSessionMap().get(userId).getSchSessionMap().get(pendingSystemStatus.getId()); //push upload to system currentSystemStatus = SSHUtil.pushUpload(pendingSystemStatus, session.getSession(), UPLOAD_PATH + "/" + uploadFileName, pushDir + "/" + uploadFileName); //update system status SystemStatusDB.updateSystemStatus(currentSystemStatus,userId); pendingSystemStatus = SystemStatusDB.getNextPendingSystem(userId); } //if push has finished to all servers then delete uploaded file if (pendingSystemStatus == null) { File delFile = new File(UPLOAD_PATH, uploadFileName); FileUtils.deleteQuietly(delFile); //delete all expired files in upload path File delDir = new File(UPLOAD_PATH); if (delDir.isDirectory()) { //set expire time to delete all files older than 48 hrs Calendar expireTime = Calendar.getInstance(); expireTime.add(Calendar.HOUR, - 48); Iterator<File> filesToDelete = FileUtils.iterateFiles(delDir, new AgeFileFilter(expireTime.getTime()), TrueFileFilter.TRUE); while(filesToDelete.hasNext()) { delFile=filesToDelete.next(); delFile.delete(); } } } systemStatusList = SystemStatusDB.getAllSystemStatus(userId); } catch (Exception e) { e.printStackTrace(); } return SUCCESS; }
public static EC2Key getEC2KeyByKeyNm ( String keyNm , String ec2Region ) { EC2Key ec2Key = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from ec2_keys where key_nm like ? and ec2_region like ? " ) ; stmt . setString ( 1 , keyNm ) ; stmt . setString ( 2 , ec2Region ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { ec2Key = new EC2Key ( ) ; ec2Key . setId ( rs . getLong ( " id " ) ) ; ec2Key . setKeyNm ( rs . getString ( " key_nm " ) ) ; ec2Key . setEc2Region ( rs . getString ( " ec2_region " ) ) ; ec2Key . setPrivateKey ( EncryptionUtil . decrypt ( rs . getString ( " private_key " ) ) ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return ec2Key ;
public static Long insertEC2Key ( EC2Key ec2Key ) { Connection con = null ; Long ec2KeyId = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " insert into ec2_keys (key_nm, ec2_region, private_key) values (?,?,?) " , Statement . RETURN_GENERATED_KEYS ) ; stmt . setString ( 1 , ec2Key . getKeyNm ( ) ) ; stmt . setString ( 2 , ec2Key . getEc2Region ( ) ) ; stmt . setString ( 3 , EncryptionUtil . encrypt ( ec2Key . getPrivateKey ( ) . trim ( ) ) ) ; stmt . execute ( ) ; ResultSet rs = stmt . getGeneratedKeys ( ) ; if ( rs ! = null & & rs . next ( ) ) { ec2KeyId = rs . getLong ( 1 ) ; } DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return ec2KeyId ;
public static String hash ( String str ) { String hash = null ; try { MessageDigest md = MessageDigest . getInstance ( " SHA-256 " ) ; md . update ( str . getBytes ( " UTF-8 " ) ) ; hash = new String ( Base64 . encodeBase64 ( md . digest ( ) ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return hash ; }
public static String encrypt ( String str ) { String retVal = null ; if ( str ! = null & & str . length ( ) > 0 ) { try { Cipher c = Cipher . getInstance ( " AES " ) ; c . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( key , " AES " ) ) ; byte [ ] encVal = c . doFinal ( str . getBytes ( ) ) ; retVal = new String ( Base64 . encodeBase64 ( encVal ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } return retVal ; }
public static String decrypt ( String str ) { String retVal = null ; if ( str ! = null & & str . length ( ) > 0 ) { try { Cipher c = Cipher . getInstance ( " AES " ) ; c . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( key , " AES " ) ) ; byte [ ] decodedVal = Base64 . decodeBase64 ( str . getBytes ( ) ) ; retVal = new String ( c . doFinal ( decodedVal ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } return retVal ; }
public static Connection getConn ( ) { Connection con = null ; try { con = DSPool . getDataSource ( ) . getConnection ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return con ;
public static org . apache . commons . dbcp . PoolingDataSource getDataSource ( ) { if ( dsPool = = null ) { dsPool = registerDataSource ( ) ; } return dsPool ;
private static PoolingDataSource registerDataSource ( ) { // create a database connection String user="ec2box"; String password="filepwd 0WJLnwhpA47EepT1A4drVnDn3vYRvJhpZi0sVdvN9SmlbKw"; String connectionURI = "jdbc:h2:" + DB_PATH + "/ec2box;CIPHER=AES"; String validationQuery = "select 1"; try { Class.forName("org.h2.Driver"); } catch (ClassNotFoundException ex) { ex.printStackTrace(); } GenericObjectPool connectionPool = new GenericObjectPool(null); connectionPool.setMaxActive(25); connectionPool.setTestOnBorrow(true); connectionPool.setMinIdle(2); connectionPool.setMaxWait(15000); connectionPool.setWhenExhaustedAction(GenericObjectPool.WHEN_EXHAUSTED_BLOCK); ConnectionFactory connectionFactory = new DriverManagerConnectionFactory(connectionURI, user, password); new PoolableConnectionFactory(connectionFactory, connectionPool, null, validationQuery, false, true); return new PoolingDataSource(connectionPool);
public void init ( ServletConfig config ) throws ServletException { super . init ( config ) ; try { Connection connection = DBUtils . getConn ( ) ;
public String viewAWSCred ( ) { sortedSet = AWSCredDB . getAWSCredSet ( sortedSet ) ; return SUCCESS ;
public String saveAWSCred ( ) { AWSCredDB . saveAWSCred ( awsCred ) ; return SUCCESS ;
public String deleteAWSCred ( ) { AWSCredDB . deleteAWSCred ( awsCred . getId ( ) ) ; return SUCCESS ;
public void validateSaveAWSCred ( ) { if ( awsCred . getAccessKey ( ) = = null | | awsCred . getAccessKey ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " awsCred.accessKey " , " Required " ) ; } if ( awsCred . getSecretKey ( ) = = null | | awsCred . getSecretKey ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " awsCred.secretKey " , " Required " ) ; } if ( ! this . hasErrors ( ) ) { try { //check if credential are valid BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.describeKeyPairs(); } catch (Exception ex) { addActionError("Invalid Credentials"); } } if(this.hasActionErrors() || this.hasErrors()){ sortedSet = AWSCredDB.getAWSCredSet(sortedSet);
public String viewEC2Keys ( ) { sortedSet = EC2KeyDB . getEC2KeySet ( sortedSet ) ; return SUCCESS ;
public String getKeyPairJSON ( ) { AWSCred awsCred = AWSCredDB . getAWSCred ( ec2Key . getAwsCredId ( ) ) ; //set AWS credentials for service BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.setEndpoint(ec2Key.getEc2Region()); DescribeKeyPairsRequest describeKeyPairsRequest = new DescribeKeyPairsRequest(); DescribeKeyPairsResult describeKeyPairsResult = service.describeKeyPairs(describeKeyPairsRequest); List<KeyPairInfo> keyPairInfoList = describeKeyPairsResult.getKeyPairs(); String json = new Gson().toJson(keyPairInfoList); try { servletResponse.getOutputStream().write(json.getBytes()); } catch (Exception ex) { ex.printStackTrace(); } return null; }
public String submitEC2Key ( ) { String retVal = SUCCESS ; try { //get AWS credentials from DB AWSCred awsCred = AWSCredDB.getAWSCred(ec2Key.getAwsCredId()); //set AWS credentials for service BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); //create service AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.setEndpoint(ec2Key.getEc2Region()); //create key pair request CreateKeyPairRequest createKeyPairRequest = new CreateKeyPairRequest(); createKeyPairRequest.withKeyName(ec2Key.getKeyNm()); //call service CreateKeyPairResult createKeyPairResult = service.createKeyPair(createKeyPairRequest); //get key pair result KeyPair keyPair = createKeyPairResult.getKeyPair(); //set private key String privateKey = keyPair.getKeyMaterial(); ec2Key.setPrivateKey(privateKey); //add to db EC2KeyDB.saveEC2Key(ec2Key); } catch (AmazonServiceException ex) { addActionError(ex.getMessage()); retVal = INPUT; } return retVal;
public String importEC2Key ( ) { String retVal = SUCCESS ; try { //get AWS credentials from DB AWSCred awsCred = AWSCredDB.getAWSCred(ec2Key.getAwsCredId()); //set AWS credentials for service BasicAWSCredentials awsCredentials = new BasicAWSCredentials(awsCred.getAccessKey(), awsCred.getSecretKey()); //create service AmazonEC2 service = new AmazonEC2Client(awsCredentials); service.setEndpoint(ec2Key.getEc2Region()); //describe key pair request DescribeKeyPairsRequest describeKeyPairsRequest = new DescribeKeyPairsRequest(); describeKeyPairsRequest.setKeyNames(Arrays.asList(ec2Key.getKeyNm())); //call service DescribeKeyPairsResult describeKeyPairsResult = service.describeKeyPairs(describeKeyPairsRequest); if (describeKeyPairsResult != null && describeKeyPairsResult.getKeyPairs().size() > 0) { //add to db EC2KeyDB.saveEC2Key(ec2Key); } else { addActionError("Imported key does not exist on AWS"); retVal = INPUT; } } catch (AmazonServiceException ex) { addActionError(ex.getMessage()); retVal = INPUT; } return retVal;
public void validateImportEC2Key ( ) { if ( ec2Key . getAwsCredId ( ) = = null ) { addFieldError ( " ec2Key.awsCredId " , " Required " ) ; } if ( ec2Key . getEc2Region ( ) = = null | | ec2Key . getEc2Region ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " ec2Key.ec2Region " , " Required " ) ; } if ( ec2Key . getKeyNm ( ) = = null | | ec2Key . getKeyNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " ec2Key.keyNm " , " Required " ) ; } if ( ec2Key . getPrivateKey ( ) = = null | | ec2Key . getPrivateKey ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " ec2Key.privateKey " , " Required " ) ; } if ( hasErrors ( ) ) {
public void validateSubmitEC2Key ( ) { if ( ec2Key . getEc2Region ( ) = = null | | ec2Key . getEc2Region ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " ec2Key.ec2Region " , " Required " ) ; } if ( ec2Key . getKeyNm ( ) = = null | | ec2Key . getKeyNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " ec2Key.keyNm " , " Required " ) ; } if ( hasErrors ( ) ) {
public List < AWSCred > getAwsCredList ( ) { return awsCredList ; }
public void setAwsCredList ( List < AWSCred > awsCredList ) { this . awsCredList = awsCredList ; }
public String exitTerms ( ) { return SUCCESS ; }
public String saveSystem ( ) { if ( hostSystem . getId ( ) ! = null & & hostSystem . getPort ( ) ! = null & & hostSystem . getUser ( ) ! = null & & ! hostSystem . getUser ( ) . trim ( ) . equals ( " " ) ) { SystemDB . updateSystem ( hostSystem ) ; } return SUCCESS ; }
public String push ( ) { Long userId = AuthUtil . getUserId ( servletRequest . getSession ( ) ) ; Long sessionId = AuthUtil . getSessionId ( servletRequest . getSession ( ) ) ; try { //get next pending system pendingSystemStatus = SystemStatusDB.getNextPendingSystem(userId); if (pendingSystemStatus != null) { //get session for system SchSession session = SecureShellAction.getUserSchSessionMap().get(sessionId).getSchSessionMap().get(pendingSystemStatus.getId()); //push upload to system currentSystemStatus = SSHUtil.pushUpload(pendingSystemStatus, session.getSession(), UPLOAD_PATH + "/" + uploadFileName, pushDir + "/" + uploadFileName); //update system status SystemStatusDB.updateSystemStatus(currentSystemStatus,userId); pendingSystemStatus = SystemStatusDB.getNextPendingSystem(userId); } //if push has finished to all servers then delete uploaded file if (pendingSystemStatus == null) { File delFile = new File(UPLOAD_PATH, uploadFileName); FileUtils.deleteQuietly(delFile); //delete all expired files in upload path File delDir = new File(UPLOAD_PATH); if (delDir.isDirectory()) { //set expire time to delete all files older than 48 hrs Calendar expireTime = Calendar.getInstance(); expireTime.add(Calendar.HOUR, - 48); Iterator<File> filesToDelete = FileUtils.iterateFiles(delDir, new AgeFileFilter(expireTime.getTime()), TrueFileFilter.TRUE); while(filesToDelete.hasNext()) { delFile=filesToDelete.next(); delFile.delete(); } } } systemStatusList = SystemStatusDB.getAllSystemStatus(userId); } catch (Exception e) { e.printStackTrace(); } return SUCCESS; }
public void init ( FilterConfig config ) throws ServletException { } public void destroy ( ) { } /** * doFilter determines if user is an administrator or redirect to login page * * @param req servlet request * @param resp servlet response * @param chain filter chain * @throws ServletException * @throws IOException */ public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { boolean isAdmin = false ; //read auth token String authToken = CookieUtil.get((HttpServletRequest) req, "authToken"); //check if exists if (authToken != null && !authToken.trim().equals("")) { //decrypt auth token authToken = EncryptionUtil.decrypt(authToken); //check if valid admin auth token isAdmin = AdminDB.isAdmin(authToken); //check to see if user has timed out String timeStr = CookieUtil.get((HttpServletRequest) req, "timeout"); SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); try { if (timeStr != null && !timeStr.trim().equals("")) { Date cookieTimeout = sdf.parse(timeStr); Date currentTime = new Date(); //if current time > timeout then redirect to login page if (cookieTimeout == null || currentTime.after(cookieTimeout)) { isAdmin = false; } else { //set new timeout cookie for 15 min Calendar timeout = Calendar.getInstance(); timeout.add(Calendar.MINUTE, 15); CookieUtil.add((HttpServletResponse) resp, "timeout", sdf.format(timeout.getTime())); } } else { isAdmin = false; } } catch (Exception ex) { ex.printStackTrace(); isAdmin = false; } } //if not admin redirect to login page if (!isAdmin) { CookieUtil.deleteAll((HttpServletRequest) req, (HttpServletResponse) resp); ((HttpServletResponse) resp).sendRedirect(((HttpServletRequest) req).getContextPath() + "/login.action"); } chain.doFilter(req, resp); } }
public void destroy ( ) { } /** * doFilter determines if user is an administrator or redirect to login page * * @param req servlet request * @param resp servlet response * @param chain filter chain * @throws ServletException * @throws IOException */ public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { boolean isAdmin = false ; //read auth token String authToken = CookieUtil.get((HttpServletRequest) req, "authToken"); //check if exists if (authToken != null && !authToken.trim().equals("")) { //decrypt auth token authToken = EncryptionUtil.decrypt(authToken); //check if valid admin auth token isAdmin = AdminDB.isAdmin(authToken); //check to see if user has timed out String timeStr = CookieUtil.get((HttpServletRequest) req, "timeout"); SimpleDateFormat sdf = new SimpleDateFormat("MMddyyyyHHmmss"); try { if (timeStr != null && !timeStr.trim().equals("")) { Date cookieTimeout = sdf.parse(timeStr); Date currentTime = new Date(); //if current time > timeout then redirect to login page if (cookieTimeout == null || currentTime.after(cookieTimeout)) { isAdmin = false; } else { //set new timeout cookie for 15 min Calendar timeout = Calendar.getInstance(); timeout.add(Calendar.MINUTE, 15); CookieUtil.add((HttpServletResponse) resp, "timeout", sdf.format(timeout.getTime())); } } else { isAdmin = false; } } catch (Exception ex) { ex.printStackTrace(); isAdmin = false; } } //if not admin redirect to login page if (!isAdmin) { CookieUtil.deleteAll((HttpServletRequest) req, (HttpServletResponse) resp); ((HttpServletResponse) resp).sendRedirect(((HttpServletRequest) req).getContextPath() + "/login.action"); } chain.doFilter(req, resp); } }
public String genAuthKeyForSystem ( ) { if ( pendingSystemStatus ! = null & & pendingSystemStatus . getId ( ) ! = null ) { //get key gen status and a currentSystemStatus = GenerateAuthKeysDB.getSystemKeyGen(pendingSystemStatus.getId()); //try and sftp key to remote server currentSystemStatus = SSHUtil.authAndAddPubKey(currentSystemStatus, password, PrivateKeyDB.getPassphrase()); GenerateAuthKeysDB.updateSystemKeyGen(currentSystemStatus); if (SystemKeyGenStatus.AUTH_FAIL_STATUS.equals(currentSystemStatus.getStatusCd())) { pendingSystemStatus = currentSystemStatus; } else { pendingSystemStatus = GenerateAuthKeysDB.getNextPendingSystem(); } } else { currentSystemStatus = null; pendingSystemStatus = null; } systemStatusList = GenerateAuthKeysDB.getAllSystemKeyGen(); return SUCCESS; }
public String getNextPendingSystem ( ) { currentSystemStatus = GenerateAuthKeysDB . getSystemKeyGen ( pendingSystemStatus . getId ( ) ) ; currentSystemStatus . setErrorMsg ( " Auth fail " ) ; currentSystemStatus . setStatusCd ( SystemKeyGenStatus . GENERIC_FAIL_STATUS ) ; GenerateAuthKeysDB . updateSystemKeyGen ( currentSystemStatus ) ; pendingSystemStatus = GenerateAuthKeysDB . getNextPendingSystem ( ) ; systemStatusList = GenerateAuthKeysDB . getAllSystemKeyGen ( ) ; return SUCCESS ; }
public String selectSystemsForAuthKeys ( ) { if ( systemSelectId ! = null & & ! systemSelectId . isEmpty ( ) ) { systemStatusList = GenerateAuthKeysDB . setInitialSystemKeyGen ( GenerateAuthKeysDB . findAuthKeysForSystems ( systemSelectId ) ) ; //set first system to set auth keys pendingSystemStatus = GenerateAuthKeysDB.getNextPendingSystem(); } return SUCCESS; }
public String selectUsersForAuthKeys ( ) { if ( userSelectId ! = null & & ! userSelectId . isEmpty ( ) ) { systemStatusList = GenerateAuthKeysDB . setInitialSystemKeyGen ( GenerateAuthKeysDB . findAuthKeysForUsers ( userSelectId ) ) ; //set first system to set auth keys pendingSystemStatus = GenerateAuthKeysDB.getNextPendingSystem(); } return SUCCESS; }
public List < Long > getUserSelectId ( ) { return userSelectId ; }
public void setUserSelectId ( List < Long > userSelectId ) { this . userSelectId = userSelectId ; }
public List < SystemKeyGenStatus > getSystemStatusList ( ) { return systemStatusList ; }
public void setSystemStatusList ( List < SystemKeyGenStatus > systemStatusList ) { this . systemStatusList = systemStatusList ; }
public SystemKeyGenStatus getPendingSystemStatus ( ) { return pendingSystemStatus ; }
public void setPendingSystemStatus ( SystemKeyGenStatus pendingSystemStatus ) { this . pendingSystemStatus = pendingSystemStatus ; }
public SystemKeyGenStatus getCurrentSystemStatus ( ) { return currentSystemStatus ; }
public void setCurrentSystemStatus ( SystemKeyGenStatus currentSystemStatus ) { this . currentSystemStatus = currentSystemStatus ; }
public void validateLoginSubmit ( ) { if ( login . getUsername ( ) = = null | | login . getUsername ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " login.username " , " Username is required " ) ; } if ( login . getPassword ( ) = = null | | login . getPassword ( ) . trim ( ) . equals ( " " ) ) {
public void validatePasswordSubmit ( ) { if ( login . getPassword ( ) = = null | | login . getPassword ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " login.password " , " New password is required " ) ; } if ( login . getPasswordConfirm ( ) = = null | | login . getPasswordConfirm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " login.passwordConfirm " , " New password confirmation is required " ) ; } if ( login . getPrevPassword ( ) = = null | | login . getPrevPassword ( ) . trim ( ) . equals ( " " ) ) {
public String viewSystems ( ) { sortedSet = ProfileDB . getProfileSet ( sortedSet ) ; return SUCCESS ; }
public String saveProfile ( ) { if ( profile . getId ( ) ! = null ) { ProfileDB . updateProfile ( profile ) ; } else { ProfileDB . insertProfile ( profile ) ; } return SUCCESS ; }
public String deleteProfile ( ) { if ( profile . getId ( ) ! = null ) { ProfileDB . deleteProfile ( profile . getId ( ) ) ; } return SUCCESS ; }
public void validateSaveProfile ( ) { if ( profile = = null | | profile . getNm ( ) = = null | | profile . getNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " profile.nm " , " Profile Name is required " ) ; } if ( ! this . getFieldErrors ( ) . isEmpty ( ) ) { sortedSet = ProfileDB . getProfileSet ( sortedSet ) ;
public Profile getProfile ( ) { return profile ; }
public void setProfile ( Profile profile ) { this . profile = profile ; }
public String viewProfileSystems ( ) { if ( profile ! = null & & profile . getId ( ) ! = null ) { profile = ProfileDB . getProfile ( profile . getId ( ) ) ; sortedSet = SystemDB . getSystemSet ( sortedSet ) ; } return SUCCESS ; }
public String assignSystemsToProfile ( ) { ProfileSystemsDB . deleteAllSystemsFromProfile ( profile . getId ( ) ) ; for ( Long hostSystemId : systemSelectId ) { ProfileSystemsDB . addSystemToProfile ( profile . getId ( ) , hostSystemId ) ; } return SUCCESS ; }
public String viewSystems ( ) { sortedSet = SystemDB . getSystemSet ( sortedSet ) ; return SUCCESS ; }
public String saveSystem ( ) { if ( hostSystem . getId ( ) ! = null ) { SystemDB . updateSystem ( hostSystem ) ; } else { SystemDB . insertSystem ( hostSystem ) ; } return SUCCESS ; }
public String deleteSystem ( ) { if ( hostSystem . getId ( ) ! = null ) { SystemDB . deleteSystem ( hostSystem . getId ( ) ) ; } return SUCCESS ; }
public void validateSaveSystem ( ) { if ( hostSystem = = null | | hostSystem . getDisplayNm ( ) = = null | | hostSystem . getDisplayNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " hostSystem.displayNm " , " Display Name is required " ) ; } if ( hostSystem = = null | | hostSystem . getUser ( ) = = null | | hostSystem . getUser ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " hostSystem.user " , " User is required " ) ; } if ( hostSystem = = null | | hostSystem . getHost ( ) = = null | | hostSystem . getHost ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " hostSystem.host " , " Host is required " ) ; } if ( hostSystem = = null | | hostSystem . getPort ( ) = = null ) { addFieldError ( " hostSystem.port " , " Port is required " ) ; } else if ( ! ( hostSystem . getPort ( ) > 0 ) ) { addFieldError ( " hostSystem.port " , " Port is invalid " ) ; } if ( hostSystem = = null | | hostSystem . getAuthorizedKeys ( ) = = null | | hostSystem . getAuthorizedKeys ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " hostSystem.authorizedKeys " , " Authorized Keys is required " ) ; } if ( ! this . getFieldErrors ( ) . isEmpty ( ) ) {
public String viewUserProfiles ( ) { if ( user ! = null & & user . getId ( ) ! = null ) { user = UserDB . getUser ( user . getId ( ) ) ; profileList = ProfileDB . getAllProfiles ( ) ; } return SUCCESS ; }
public String addProfileToUser ( ) { if ( profileId ! = null ) { UserProfileDB . addProfileToUser ( profileId , user . getId ( ) ) ; } return SUCCESS ; }
public String deleteProfileFromUser ( ) { UserProfileDB . deleteProfileFromUser ( profileId , user . getId ( ) ) ; return SUCCESS ; }
public List < Profile > getProfileList ( ) { return profileList ; }
public void setProfileList ( List < Profile > profileList ) { this . profileList = profileList ; }
public Long getProfileId ( ) { return profileId ; }
public void setProfileId ( Long profileId ) { this . profileId = profileId ; }
public String viewSystems ( ) { sortedSet = UserDB . getUserSet ( sortedSet ) ; return SUCCESS ; }
public String saveUser ( ) { if ( user . getId ( ) ! = null ) { UserDB . updateUser ( user ) ; } else { UserDB . insertUser ( user ) ; } return SUCCESS ; }
public String deleteUser ( ) { if ( user . getId ( ) ! = null ) { UserDB . deleteUser ( user . getId ( ) ) ; } return SUCCESS ; }
public void validateSaveUser ( ) { if ( user = = null | | user . getLastNm ( ) = = null | | user . getLastNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " user.lastNm " , " Last Name is required " ) ; } if ( user = = null | | user . getFirstNm ( ) = = null | | user . getFirstNm ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " user.firstNm " , " First Name is required " ) ; } if ( user = = null | | user . getPublicKey ( ) = = null | | user . getPublicKey ( ) . trim ( ) . equals ( " " ) ) { addFieldError ( " user.publicKey " , " Public Key is required " ) ; } if ( ! this . getFieldErrors ( ) . isEmpty ( ) ) { sortedSet = UserDB . getUserSet ( sortedSet ) ;
public static boolean updatePassword ( Login login ) { boolean success = false ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from admin where auth_token like ? and password like ? " ) ; stmt . setString ( 1 , login . getAuthToken ( ) ) ; stmt . setString ( 2 , EncryptionUtil . hash ( login . getPrevPassword ( ) ) ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { stmt = con . prepareStatement ( " update admin set password=? where auth_token like ? " ) ; stmt . setString ( 1 , EncryptionUtil . hash ( login . getPassword ( ) ) ) ; stmt . setString ( 2 , login . getAuthToken ( ) ) ; stmt . execute ( ) ; success = true ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return success ; }
public static List < HostSystem > findAuthKeysForUsers ( List < Long > userIdList ) { Connection con = null ; List < HostSystem > hostSystemListReturn = new ArrayList < HostSystem > ( ) ; try { con = DBUtils . getConn ( ) ; List < Long > profileIdList = new ArrayList < Long > ( ) ; for ( Long userId : userIdList ) { //get user User user = UserDB.getUser(con, userId); //get profiles for user for (Profile profile : user.getProfileList()) { //add profiles to list if not already defined if (!profileIdList.contains(profile.getId())) { profileIdList.add(profile.getId()); } } } //get host systems based on profile hostSystemListReturn = findAuthKeysForProfile(con, profileIdList); } catch (Exception e) { e.printStackTrace(); } DBUtils.closeConn(con); return hostSystemListReturn;
public static List < HostSystem > findAuthKeysForSystems ( List < Long > systemIdList ) { Connection con = null ; List < HostSystem > hostSystemListReturn = new ArrayList < HostSystem > ( ) ; try { con = DBUtils . getConn ( ) ; for ( Long systemId : systemIdList ) { HostSystem hostSystem = findAuthKeysForSystem ( con , systemId ) ; hostSystemListReturn . add ( hostSystem ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return hostSystemListReturn ;
public static HostSystem findAuthKeysForSystem ( Long systemId ) { HostSystem hostSystem = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; hostSystem = findAuthKeysForSystem ( con , systemId ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return hostSystem ;
private static HostSystem findAuthKeysForSystem ( Connection con , Long systemId ) { HostSystem hostSystem = null ; try { //get host system hostSystem = SystemDB.getSystem(con, systemId); //get profiles associated with host system List<Profile> profileList = ProfileSystemsDB.getProfilesBySystem(con, systemId); Map<Long, User> userMap = new HashMap<Long, User>(); for (Profile profile : profileList) { //get users associated with profile List<User> userList = UserProfileDB.getUsersByProfile(con, profile.getId()); for (User user : userList) { if (!userMap.containsKey(user.getId())) { userMap.put(user.getId(), user); } } } List<User> userList = new ArrayList<User>(userMap.values()); //get public keys from user list hostSystem.setPublicKeyList(getPublicKeysFromUserList(userList)); } catch (Exception e) { e.printStackTrace(); } return hostSystem;
private static List < HostSystem > findAuthKeysForProfile ( Connection con , List < Long > profileIdList ) { Map < Long , HostSystem > hostSystemMap = new HashMap < Long , HostSystem > ( ) ; try { for ( Long profileId : profileIdList ) { //get host systems assigned to profile List<HostSystem> hostSystemList = ProfileSystemsDB.getSystemsByProfile(con, profileId); for (HostSystem hostSystem : hostSystemList) { if (!hostSystemMap.containsKey(hostSystem.getId())) { //get users associated with profile hostSystem = findAuthKeysForSystem(con, hostSystem.getId()); hostSystemMap.put(hostSystem.getId(), hostSystem); } } } } catch (Exception e) { e.printStackTrace(); } List<HostSystem> hostSystemList = new ArrayList<HostSystem>(hostSystemMap.values()); return hostSystemList;
private static List < String > getPublicKeysFromUserList ( List < User > userList ) { List < String > publicKeyList = new ArrayList < String > ( ) ; //add keybox public key if (SSHUtil.getPublicKey() != null) { publicKeyList.add(SSHUtil.getPublicKey().replace("\n", "").trim()); } //add user's public key for (User user : userList) { if (user.getPublicKey() != null) { publicKeyList.add(user.getPublicKey().replace("\n", "").trim()); } } return publicKeyList; }
public static List < SystemKeyGenStatus > setInitialSystemKeyGen ( List < HostSystem > hostSystemList ) { Connection con = null ; List < SystemKeyGenStatus > systemKeyGenStatusList = new ArrayList < SystemKeyGenStatus > ( ) ; try { con = DBUtils . getConn ( ) ; //deletes all old systems deleteAllSystemKeyGen(con); for (HostSystem hostSystem : hostSystemList) { //create auth keys file String authKeyVal = ""; for (String pubKey : hostSystem.getPublicKeyList()) { authKeyVal = authKeyVal + pubKey + "\n"; } SystemKeyGenStatus systemKeyGenStatus = new SystemKeyGenStatus(); systemKeyGenStatus.setId(hostSystem.getId()); systemKeyGenStatus.setAuthKeyVal(authKeyVal); systemKeyGenStatus.setStatusCd("I"); //insert new status insertSystemKeyGen(con, systemKeyGenStatus); //get update status list systemKeyGenStatusList = getAllSystemKeyGen(con); } } catch (Exception e) { e.printStackTrace(); } DBUtils.closeConn(con); return systemKeyGenStatusList; }
private static void deleteAllSystemKeyGen ( Connection con ) { try {
private static void insertSystemKeyGen ( Connection con , SystemKeyGenStatus systemKeyGenStatus ) { try {
public static void updateSystemKeyGen ( SystemKeyGenStatus systemKeyGenStatus ) { Connection con = null ; try { con = DBUtils . getConn ( ) ; updateSystemKeyGen ( con , systemKeyGenStatus ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ;
public static void updateSystemKeyGen ( Connection con , SystemKeyGenStatus systemKeyGenStatus ) { try {
public static List < SystemKeyGenStatus > getAllSystemKeyGen ( ) { List < SystemKeyGenStatus > systemKeyGenStatusList = new ArrayList < SystemKeyGenStatus > ( ) ; Connection con = null ; try { con = DBUtils . getConn ( ) ; systemKeyGenStatusList = getAllSystemKeyGen ( con ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return systemKeyGenStatusList ;
private static List < SystemKeyGenStatus > getAllSystemKeyGen ( Connection con ) { List < SystemKeyGenStatus > systemKeyGenStatusList = new ArrayList < SystemKeyGenStatus > ( ) ; try { PreparedStatement stmt = con . prepareStatement ( " select * from system_key_gen " ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { SystemKeyGenStatus systemKeyGenStatus = new SystemKeyGenStatus ( ) ; systemKeyGenStatus . setId ( rs . getLong ( " id " ) ) ; systemKeyGenStatus . setAuthKeyVal ( rs . getString ( " auth_keys_val " ) ) ; systemKeyGenStatus . setStatusCd ( rs . getString ( " status_cd " ) ) ; systemKeyGenStatus . setHostSystem ( SystemDB . getSystem ( con , systemKeyGenStatus . getId ( ) ) ) ; systemKeyGenStatusList . add ( systemKeyGenStatus ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return systemKeyGenStatusList ;
public static SystemKeyGenStatus getSystemKeyGen ( Long systemId ) { Connection con = null ; SystemKeyGenStatus systemKeyGenStatus = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from system_key_gen where id=? " ) ; stmt . setLong ( 1 , systemId ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { systemKeyGenStatus = new SystemKeyGenStatus ( ) ; systemKeyGenStatus . setId ( rs . getLong ( " id " ) ) ; systemKeyGenStatus . setAuthKeyVal ( rs . getString ( " auth_keys_val " ) ) ; systemKeyGenStatus . setStatusCd ( rs . getString ( " status_cd " ) ) ; systemKeyGenStatus . setHostSystem ( SystemDB . getSystem ( con , systemKeyGenStatus . getId ( ) ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return systemKeyGenStatus ;
public static SystemKeyGenStatus getNextPendingSystem ( ) { SystemKeyGenStatus systemKeyGenStatus = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from system_key_gen where status_cd like 'A' or status_cd like 'I' " ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { systemKeyGenStatus = new SystemKeyGenStatus ( ) ; systemKeyGenStatus . setId ( rs . getLong ( " id " ) ) ; systemKeyGenStatus . setAuthKeyVal ( rs . getString ( " auth_keys_val " ) ) ; systemKeyGenStatus . setStatusCd ( rs . getString ( " status_cd " ) ) ; systemKeyGenStatus . setHostSystem ( SystemDB . getSystem ( con , systemKeyGenStatus . getId ( ) ) ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return systemKeyGenStatus ;
public static String getPassphrase ( ) { String passphrase = null ; Connection con = null ; try { con = DBUtils . getConn ( ) ; PreparedStatement stmt = con . prepareStatement ( " select * from private_key " ) ; ResultSet rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { passphrase = rs . getString ( " passphrase " ) ; } DBUtils . closeRs ( rs ) ; DBUtils . closeStmt ( stmt ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } DBUtils . closeConn ( con ) ; return passphrase ; }
public static SortedSet getProfileSet ( SortedSet sortedSet ) { ArrayList < Profile > profileList = new ArrayList < Profile > ( ) ; String orderBy = " " ; if ( sortedSet . getOrderByField ( ) ! = null & & ! sortedSet . getOrderByField ( ) . trim ( ) . equals ( " " ) ) { orderBy = " order by " + sortedSet . getOrderByField ( ) + " " + sortedSet . getOrderByDirection ( ) ; } String sql = " select * from profiles " + orderBy ; Connection con = null ; try { con = DBU